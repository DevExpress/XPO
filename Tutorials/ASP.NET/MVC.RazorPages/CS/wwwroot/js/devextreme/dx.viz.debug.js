/*!
 * DevExtreme (dx.viz.debug.js)
 * Version: 20.1.4
 * Build date: Tue Jun 02 2020
 *
 * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
! function(modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
            return installedModules[moduleId].exports
        }
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.l = true;
        return module.exports
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
        if (!__webpack_require__.o(exports, name)) {
            Object.defineProperty(exports, name, {
                configurable: false,
                enumerable: true,
                get: getter
            })
        }
    };
    __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function() {
            return module.default
        } : function() {
            return module
        };
        __webpack_require__.d(getter, "a", getter);
        return getter
    };
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property)
    };
    __webpack_require__.p = "";
    return __webpack_require__(__webpack_require__.s = 915)
}([
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/utils/extend.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var isPlainObject = __webpack_require__( /*! ./type */ 1).isPlainObject;
        var extendFromObject = function(target, source, overrideExistingValues) {
            target = target || {};
            for (var prop in source) {
                if (Object.prototype.hasOwnProperty.call(source, prop)) {
                    var value = source[prop];
                    if (!(prop in target) || overrideExistingValues) {
                        target[prop] = value
                    }
                }
            }
            return target
        };
        var extend = function extend(target) {
            target = target || {};
            var i = 1;
            var deep = false;
            if ("boolean" === typeof target) {
                deep = target;
                target = arguments[1] || {};
                i++
            }
            for (; i < arguments.length; i++) {
                var source = arguments[i];
                if (null == source) {
                    continue
                }
                for (var key in source) {
                    var targetValue = target[key];
                    var sourceValue = source[key];
                    var sourceValueIsArray = false;
                    var clone = void 0;
                    if ("__proto__" === key || target === sourceValue) {
                        continue
                    }
                    if (deep && sourceValue && (isPlainObject(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
                        if (sourceValueIsArray) {
                            clone = targetValue && Array.isArray(targetValue) ? targetValue : []
                        } else {
                            clone = targetValue && isPlainObject(targetValue) ? targetValue : {}
                        }
                        target[key] = extend(deep, clone, sourceValue)
                    } else {
                        if (void 0 !== sourceValue) {
                            target[key] = sourceValue
                        }
                    }
                }
            }
            return target
        };
        exports.extend = extend;
        exports.extendFromObject = extendFromObject
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/core/utils/type.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var types = {
            "[object Array]": "array",
            "[object Date]": "date",
            "[object Object]": "object",
            "[object String]": "string",
            "[object Null]": "null"
        };
        var type = function(object) {
            var typeOfObject = Object.prototype.toString.call(object);
            return "object" === _typeof(object) ? types[typeOfObject] || "object" : _typeof(object)
        };
        var isBoolean = function(object) {
            return "boolean" === typeof object
        };
        var isExponential = function(value) {
            return isNumeric(value) && value.toString().indexOf("e") !== -1
        };
        var isDate = function(object) {
            return "date" === type(object)
        };
        var isDefined = function(object) {
            return null !== object && void 0 !== object
        };
        var isFunction = function(object) {
            return "function" === typeof object
        };
        var isString = function(object) {
            return "string" === typeof object
        };
        var isNumeric = function(object) {
            return "number" === typeof object && isFinite(object) || !isNaN(object - parseFloat(object))
        };
        var isObject = function(object) {
            return "object" === type(object)
        };
        var isEmptyObject = function(object) {
            var property;
            for (property in object) {
                return false
            }
            return true
        };
        var isPlainObject = function(object) {
            if (!object || "[object Object]" !== Object.prototype.toString.call(object)) {
                return false
            }
            var proto = Object.getPrototypeOf(object);
            var ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return "function" === typeof ctor && Object.toString.call(ctor) === Object.toString.call(Object)
        };
        var isPrimitive = function(value) {
            return ["object", "array", "function"].indexOf(type(value)) === -1
        };
        var isWindow = function(object) {
            return null != object && object === object.window
        };
        var isRenderer = function(object) {
            return !!(object.jquery || object.dxRenderer)
        };
        var isPromise = function(object) {
            return object && isFunction(object.then)
        };
        var isDeferred = function(object) {
            return object && isFunction(object.done) && isFunction(object.fail)
        };
        exports.isBoolean = isBoolean;
        exports.isExponential = isExponential;
        exports.isDate = isDate;
        exports.isDefined = isDefined;
        exports.isFunction = isFunction;
        exports.isString = isString;
        exports.isNumeric = isNumeric;
        exports.isObject = isObject;
        exports.isEmptyObject = isEmptyObject;
        exports.isPlainObject = isPlainObject;
        exports.isPrimitive = isPrimitive;
        exports.isWindow = isWindow;
        exports.isRenderer = isRenderer;
        exports.isPromise = isPromise;
        exports.isDeferred = isDeferred;
        exports.type = type
    },
    /*!***********************************************!*\
      !*** ./artifacts/transpiled/core/renderer.js ***!
      \***********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var rendererBase = __webpack_require__( /*! ./renderer_base */ 268);
        module.exports = rendererBase.get()
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/utils/common.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _config = __webpack_require__( /*! ../config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _guid = __webpack_require__( /*! ../guid */ 36);
        var _guid2 = _interopRequireDefault(_guid);
        var _deferred = __webpack_require__( /*! ../utils/deferred */ 6);
        var _data = __webpack_require__( /*! ./data */ 20);
        var _iterator = __webpack_require__( /*! ./iterator */ 4);
        var _type = __webpack_require__( /*! ./type */ 1);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var ensureDefined = function(value, defaultValue) {
            return (0, _type.isDefined)(value) ? value : defaultValue
        };
        var executeAsync = function(action, context) {
            var deferred = new _deferred.Deferred;
            var normalizedContext = context || this;
            var task = {
                promise: deferred.promise(),
                abort: function() {
                    clearTimeout(timerId);
                    deferred.rejectWith(normalizedContext)
                }
            };
            var callback = function() {
                var result = action.call(normalizedContext);
                if (result && result.done && (0, _type.isFunction)(result.done)) {
                    result.done(function() {
                        deferred.resolveWith(normalizedContext)
                    })
                } else {
                    deferred.resolveWith(normalizedContext)
                }
            };
            var timerId = (arguments[2] || setTimeout)(callback, "number" === typeof context ? context : 0);
            return task
        };
        var delayedFuncs = [];
        var delayedNames = [];
        var delayedDeferreds = [];
        var executingName;
        var deferExecute = function(name, func, deferred) {
            if (executingName && executingName !== name) {
                delayedFuncs.push(func);
                delayedNames.push(name);
                deferred = deferred || new _deferred.Deferred;
                delayedDeferreds.push(deferred);
                return deferred
            } else {
                var oldExecutingName = executingName;
                var currentDelayedCount = delayedDeferreds.length;
                executingName = name;
                var result = func();
                if (!result) {
                    if (delayedDeferreds.length > currentDelayedCount) {
                        result = _deferred.when.apply(this, delayedDeferreds.slice(currentDelayedCount))
                    } else {
                        if (deferred) {
                            deferred.resolve()
                        }
                    }
                }
                executingName = oldExecutingName;
                if (deferred && result && result.done) {
                    result.done(deferred.resolve).fail(deferred.reject)
                }
                if (!executingName && delayedFuncs.length) {
                    ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift())
                }
                return result || (0, _deferred.when)()
            }
        };
        var deferRender = function(func, deferred) {
            return deferExecute("render", func, deferred)
        };
        var deferUpdate = function(func, deferred) {
            return deferExecute("update", func, deferred)
        };
        var deferRenderer = function(func) {
            return function() {
                var that = this;
                return deferExecute("render", function() {
                    return func.call(that)
                })
            }
        };
        var deferUpdater = function(func) {
            return function() {
                var that = this;
                return deferExecute("update", function() {
                    return func.call(that)
                })
            }
        };
        var findBestMatches = function(targetFilter, items, mapFn) {
            var bestMatches = [];
            var maxMatchCount = 0;
            (0, _iterator.each)(items, function(index, itemSrc) {
                var matchCount = 0;
                var item = mapFn ? mapFn(itemSrc) : itemSrc;
                (0, _iterator.each)(targetFilter, function(paramName, targetValue) {
                    var value = item[paramName];
                    if (void 0 === value) {
                        return
                    }
                    if (match(value, targetValue)) {
                        matchCount++;
                        return
                    }
                    matchCount = -1;
                    return false
                });
                if (matchCount < maxMatchCount) {
                    return
                }
                if (matchCount > maxMatchCount) {
                    bestMatches.length = 0;
                    maxMatchCount = matchCount
                }
                bestMatches.push(itemSrc)
            });
            return bestMatches
        };
        var match = function(value, targetValue) {
            if (Array.isArray(value) && Array.isArray(targetValue)) {
                var mismatch = false;
                (0, _iterator.each)(value, function(index, valueItem) {
                    if (valueItem !== targetValue[index]) {
                        mismatch = true;
                        return false
                    }
                });
                if (mismatch) {
                    return false
                }
                return true
            }
            if (value === targetValue) {
                return true
            }
            return false
        };
        var splitPair = function(raw) {
            switch (_typeof(raw)) {
                case "string":
                    return raw.split(/\s+/, 2);
                case "object":
                    return [raw.x || raw.h, raw.y || raw.v];
                case "number":
                    return [raw];
                default:
                    return raw
            }
        };
        var normalizeKey = function(id) {
            var key = (0, _type.isString)(id) ? id : id.toString();
            var arr = key.match(/[^a-zA-Z0-9_]/g);
            arr && (0, _iterator.each)(arr, function(_, sign) {
                key = key.replace(sign, "__" + sign.charCodeAt() + "__")
            });
            return key
        };
        var denormalizeKey = function(key) {
            var arr = key.match(/__\d+__/g);
            arr && arr.forEach(function(char) {
                var charCode = parseInt(char.replace("__", ""));
                key = key.replace(char, String.fromCharCode(charCode))
            });
            return key
        };
        var pairToObject = function(raw, preventRound) {
            var pair = splitPair(raw);
            var h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
            var v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
            if (!isFinite(h)) {
                h = 0
            }
            if (!isFinite(v)) {
                v = h
            }
            return {
                h: h,
                v: v
            }
        };
        var getKeyHash = function(key) {
            if (key instanceof _guid2.default) {
                return key.toString()
            } else {
                if ((0, _type.isObject)(key) || Array.isArray(key)) {
                    try {
                        var keyHash = JSON.stringify(key);
                        return "{}" === keyHash ? key : keyHash
                    } catch (e) {
                        return key
                    }
                }
            }
            return key
        };
        var escapeRegExp = function(string) {
            return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, "\\$&")
        };
        var applyServerDecimalSeparator = function(value) {
            var separator = (0, _config2.default)().serverDecimalSeparator;
            if ((0, _type.isDefined)(value)) {
                value = value.toString().replace(".", separator)
            }
            return value
        };
        var noop = function() {};
        var asyncNoop = function() {
            return (new _deferred.Deferred).resolve().promise()
        };
        var grep = function(elements, checkFunction, invert) {
            var result = [];
            var check;
            var expectedCheck = !invert;
            for (var i = 0; i < elements.length; i++) {
                check = !!checkFunction(elements[i], i);
                if (check === expectedCheck) {
                    result.push(elements[i])
                }
            }
            return result
        };
        var arraysEqualByValue = function(array1, array2, depth) {
            if (array1.length !== array2.length) {
                return false
            }
            for (var i = 0; i < array1.length; i++) {
                if (!equalByValue(array1[i], array2[i], depth + 1)) {
                    return false
                }
            }
            return true
        };
        var objectsEqualByValue = function(object1, object2, depth, strict) {
            for (var propertyName in object1) {
                if (Object.prototype.hasOwnProperty.call(object1, propertyName) && !equalByValue(object1[propertyName], object2[propertyName], depth + 1, strict)) {
                    return false
                }
            }
            for (var _propertyName in object2) {
                if (!(_propertyName in object1)) {
                    return false
                }
            }
            return true
        };
        var maxEqualityDepth = 3;
        var equalByValue = function(object1, object2) {
            var depth = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            var strict = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;
            object1 = (0, _data.toComparable)(object1, true);
            object2 = (0, _data.toComparable)(object2, true);
            var comparisonResult = strict ? object1 === object2 : object1 == object2;
            if (comparisonResult || depth >= maxEqualityDepth) {
                return true
            }
            if ((0, _type.isObject)(object1) && (0, _type.isObject)(object2)) {
                return objectsEqualByValue(object1, object2, depth, strict)
            } else {
                if (Array.isArray(object1) && Array.isArray(object2)) {
                    return arraysEqualByValue(object1, object2, depth)
                }
            }
            return false
        };
        exports.ensureDefined = ensureDefined;
        exports.executeAsync = executeAsync;
        exports.deferRender = deferRender;
        exports.deferRenderer = deferRenderer;
        exports.deferUpdate = deferUpdate;
        exports.deferUpdater = deferUpdater;
        exports.pairToObject = pairToObject;
        exports.splitPair = splitPair;
        exports.findBestMatches = findBestMatches;
        exports.normalizeKey = normalizeKey;
        exports.denormalizeKey = denormalizeKey;
        exports.getKeyHash = getKeyHash;
        exports.escapeRegExp = escapeRegExp;
        exports.applyServerDecimalSeparator = applyServerDecimalSeparator;
        exports.noop = noop;
        exports.asyncNoop = asyncNoop;
        exports.grep = grep;
        exports.equalByValue = equalByValue
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/core/utils/iterator.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var map = function(values, callback) {
            if (Array.isArray(values)) {
                return values.map(callback)
            }
            var result = [];
            for (var key in values) {
                result.push(callback(values[key], key))
            }
            return result
        };
        var each = function(values, callback) {
            if (!values) {
                return
            }
            if ("length" in values) {
                for (var i = 0; i < values.length; i++) {
                    if (false === callback.call(values[i], i, values[i])) {
                        break
                    }
                }
            } else {
                for (var key in values) {
                    if (false === callback.call(values[key], key, values[key])) {
                        break
                    }
                }
            }
            return values
        };
        var reverseEach = function(array, callback) {
            if (!array || !("length" in array) || 0 === array.length) {
                return
            }
            for (var i = array.length - 1; i >= 0; i--) {
                if (false === callback.call(array[i], i, array[i])) {
                    break
                }
            }
        };
        exports.map = map;
        exports.each = each;
        exports.reverseEach = reverseEach
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/events/core/events_engine.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _event_registrator_callbacks = __webpack_require__( /*! ./event_registrator_callbacks */ 130);
        var _event_registrator_callbacks2 = _interopRequireDefault(_event_registrator_callbacks);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _window = __webpack_require__( /*! ../../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _dependency_injector = __webpack_require__( /*! ../../core/utils/dependency_injector */ 56);
        var _dependency_injector2 = _interopRequireDefault(_dependency_injector);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _type2 = _interopRequireDefault(_type);
        var _callbacks = __webpack_require__( /*! ../../core/utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);
        var _errors = __webpack_require__( /*! ../../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _weak_map = __webpack_require__( /*! ../../core/polyfills/weak_map */ 184);
        var _weak_map2 = _interopRequireDefault(_weak_map);
        var _hook_touch_props = __webpack_require__( /*! ../../events/core/hook_touch_props */ 269);
        var _hook_touch_props2 = _interopRequireDefault(_hook_touch_props);
        var _call_once = __webpack_require__( /*! ../../core/utils/call_once */ 80);
        var _call_once2 = _interopRequireDefault(_call_once);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var window = _window2.default.getWindow();
        var isWindow = _type2.default.isWindow;
        var isFunction = _type2.default.isFunction;
        var isString = _type2.default.isString;
        var EMPTY_EVENT_NAME = "dxEmptyEventType";
        var NATIVE_EVENTS_TO_SUBSCRIBE = {
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        };
        var NATIVE_EVENTS_TO_TRIGGER = {
            focusin: "focus",
            focusout: "blur"
        };
        var NO_BUBBLE_EVENTS = ["blur", "focus", "load"];
        var forcePassiveFalseEventNames = ["touchmove", "wheel", "mousewheel", "touchstart"];

        function matchesSafe(target, selector) {
            return !isWindow(target) && "#document" !== target.nodeName && _dom_adapter2.default.elementMatches(target, selector)
        }
        var elementDataMap = new _weak_map2.default;
        var guid = 0;
        var skipEvent;
        var special = function() {
            var specialData = {};
            _event_registrator_callbacks2.default.add(function(eventName, eventObject) {
                specialData[eventName] = eventObject
            });
            return {
                getField: function(eventName, field) {
                    return specialData[eventName] && specialData[eventName][field]
                },
                callMethod: function(eventName, methodName, context, args) {
                    return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context, args)
                }
            }
        }();
        var eventsEngine = (0, _dependency_injector2.default)({
            on: getHandler(normalizeOnArguments(iterate(function(element, eventName, selector, data, handler) {
                var handlersController = getHandlersController(element, eventName);
                handlersController.addHandler(handler, selector, data)
            }))),
            one: getHandler(normalizeOnArguments(function(element, eventName, selector, data, handler) {
                var oneTimeHandler = function oneTimeHandler() {
                    eventsEngine.off(element, eventName, selector, oneTimeHandler);
                    handler.apply(this, arguments)
                };
                eventsEngine.on(element, eventName, selector, data, oneTimeHandler)
            })),
            off: getHandler(normalizeOffArguments(iterate(function(element, eventName, selector, handler) {
                var handlersController = getHandlersController(element, eventName);
                handlersController.removeHandler(handler, selector)
            }))),
            trigger: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
                var eventName = event.type;
                var handlersController = getHandlersController(element, event.type);
                special.callMethod(eventName, "trigger", element, [event, extraParameters]);
                handlersController.callHandlers(event, extraParameters);
                var noBubble = special.getField(eventName, "noBubble") || event.isPropagationStopped() || NO_BUBBLE_EVENTS.indexOf(eventName) !== -1;
                if (!noBubble) {
                    var parents = [];
                    var getParents = function getParents(element) {
                        var parent = element.parentNode;
                        if (parent) {
                            parents.push(parent);
                            getParents(parent)
                        }
                    };
                    getParents(element);
                    parents.push(window);
                    var i = 0;
                    while (parents[i] && !event.isPropagationStopped()) {
                        var parentDataByEvent = getHandlersController(parents[i], event.type);
                        parentDataByEvent.callHandlers((0, _extend.extend)(event, {
                            currentTarget: parents[i]
                        }), extraParameters);
                        i++
                    }
                }
                if (element.nodeType || isWindow(element)) {
                    special.callMethod(eventName, "_default", element, [event, extraParameters]);
                    callNativeMethod(eventName, element)
                }
            })),
            triggerHandler: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
                var handlersController = getHandlersController(element, event.type);
                handlersController.callHandlers(event, extraParameters)
            }))
        });

        function applyForEach(args, method) {
            var element = args[0];
            if (!element) {
                return
            }
            if (_dom_adapter2.default.isNode(element) || isWindow(element)) {
                method.apply(eventsEngine, args)
            } else {
                if (!isString(element) && "length" in element) {
                    var itemArgs = Array.prototype.slice.call(args, 0);
                    Array.prototype.forEach.call(element, function(itemElement) {
                        itemArgs[0] = itemElement;
                        applyForEach(itemArgs, method)
                    })
                } else {
                    throw _errors2.default.Error("E0025")
                }
            }
        }

        function getHandler(method) {
            return function() {
                applyForEach(arguments, method)
            }
        }

        function detectPassiveEventHandlersSupport() {
            var isSupported = false;
            try {
                var options = Object.defineProperty({}, "passive", {
                    get: function() {
                        isSupported = true;
                        return true
                    }
                });
                window.addEventListener("test", null, options)
            } catch (e) {}
            return isSupported
        }
        var passiveEventHandlersSupported = (0, _call_once2.default)(detectPassiveEventHandlersSupport);
        var contains = function(container, element) {
            return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS)
        };

        function getHandlersController(element, eventName) {
            var elementData = elementDataMap.get(element);
            eventName = eventName || "";
            var eventNameParts = eventName.split(".");
            var namespaces = eventNameParts.slice(1);
            var eventNameIsDefined = !!eventNameParts[0];
            eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
            if (!elementData) {
                elementData = {};
                elementDataMap.set(element, elementData)
            }
            if (!elementData[eventName]) {
                elementData[eventName] = {
                    handleObjects: [],
                    nativeHandler: null
                }
            }
            var eventData = elementData[eventName];
            return {
                addHandler: function(handler, selector, data) {
                    var callHandler = function(e, extraParameters) {
                        var handlerArgs = [e];
                        var target = e.currentTarget;
                        var relatedTarget = e.relatedTarget;
                        var secondaryTargetIsInside;
                        var result;
                        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
                            secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget))
                        }
                        if (void 0 !== extraParameters) {
                            handlerArgs.push(extraParameters)
                        }
                        special.callMethod(eventName, "handle", element, [e, data]);
                        if (!secondaryTargetIsInside) {
                            result = handler.apply(target, handlerArgs)
                        }
                        if (false === result) {
                            e.preventDefault();
                            e.stopPropagation()
                        }
                    };
                    var wrappedHandler = function(e, extraParameters) {
                        if (skipEvent && e.type === skipEvent) {
                            return
                        }
                        e.data = data;
                        e.delegateTarget = element;
                        if (selector) {
                            var currentTarget = e.target;
                            while (currentTarget && currentTarget !== element) {
                                if (matchesSafe(currentTarget, selector)) {
                                    e.currentTarget = currentTarget;
                                    callHandler(e, extraParameters)
                                }
                                currentTarget = currentTarget.parentNode
                            }
                        } else {
                            e.currentTarget = e.delegateTarget || e.target;
                            callHandler(e, extraParameters)
                        }
                    };
                    var handleObject = {
                        handler: handler,
                        wrappedHandler: wrappedHandler,
                        selector: selector,
                        type: eventName,
                        data: data,
                        namespace: namespaces.join("."),
                        namespaces: namespaces,
                        guid: ++guid
                    };
                    eventData.handleObjects.push(handleObject);
                    var firstHandlerForTheType = 1 === eventData.handleObjects.length;
                    var shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
                    var nativeListenerOptions;
                    if (shouldAddNativeListener) {
                        shouldAddNativeListener = !special.callMethod(eventName, "setup", element, [data, namespaces, handler])
                    }
                    if (shouldAddNativeListener) {
                        eventData.nativeHandler = getNativeHandler(eventName);
                        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.indexOf(eventName) > -1) {
                            nativeListenerOptions = {
                                passive: false
                            }
                        }
                        eventData.removeListener = _dom_adapter2.default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData.nativeHandler, nativeListenerOptions)
                    }
                    special.callMethod(eventName, "add", element, [handleObject])
                },
                removeHandler: function(handler, selector) {
                    var removeByEventName = function(eventName) {
                        var eventData = elementData[eventName];
                        if (!eventData.handleObjects.length) {
                            delete elementData[eventName];
                            return
                        }
                        var removedHandler;
                        eventData.handleObjects = eventData.handleObjects.filter(function(handleObject) {
                            var skip = namespaces.length && !isSubset(handleObject.namespaces, namespaces) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
                            if (!skip) {
                                removedHandler = handleObject.handler;
                                special.callMethod(eventName, "remove", element, [handleObject])
                            }
                            return skip
                        });
                        var lastHandlerForTheType = !eventData.handleObjects.length;
                        var shouldRemoveNativeListener = lastHandlerForTheType && eventName !== EMPTY_EVENT_NAME;
                        if (shouldRemoveNativeListener) {
                            special.callMethod(eventName, "teardown", element, [namespaces, removedHandler]);
                            if (eventData.nativeHandler) {
                                eventData.removeListener()
                            }
                            delete elementData[eventName]
                        }
                    };
                    if (eventNameIsDefined) {
                        removeByEventName(eventName)
                    } else {
                        for (var name in elementData) {
                            removeByEventName(name)
                        }
                    }
                    var elementDataIsEmpty = 0 === Object.keys(elementData).length;
                    if (elementDataIsEmpty) {
                        elementDataMap.delete(element)
                    }
                },
                callHandlers: function(event, extraParameters) {
                    var forceStop = false;
                    var handleCallback = function(handleObject) {
                        if (forceStop) {
                            return
                        }
                        if (!namespaces.length || isSubset(handleObject.namespaces, namespaces)) {
                            handleObject.wrappedHandler(event, extraParameters);
                            forceStop = event.isImmediatePropagationStopped()
                        }
                    };
                    eventData.handleObjects.forEach(handleCallback);
                    if (namespaces.length && elementData[EMPTY_EVENT_NAME]) {
                        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback)
                    }
                }
            }
        }

        function getNativeHandler(subscribeName) {
            return function(event, extraParameters) {
                var handlersController = getHandlersController(this, subscribeName);
                event = eventsEngine.Event(event);
                handlersController.callHandlers(event, extraParameters)
            }
        }

        function isSubset(original, checked) {
            for (var i = 0; i < checked.length; i++) {
                if (original.indexOf(checked[i]) < 0) {
                    return false
                }
            }
            return true
        }

        function normalizeOnArguments(callback) {
            return function(element, eventName, selector, data, handler) {
                if (!handler) {
                    handler = data;
                    data = void 0
                }
                if ("string" !== typeof selector) {
                    data = selector;
                    selector = void 0
                }
                if (!handler && "string" === typeof eventName) {
                    handler = data || selector;
                    selector = void 0;
                    data = void 0
                }
                callback(element, eventName, selector, data, handler)
            }
        }

        function normalizeOffArguments(callback) {
            return function(element, eventName, selector, handler) {
                if ("function" === typeof selector) {
                    handler = selector;
                    selector = void 0
                }
                callback(element, eventName, selector, handler)
            }
        }

        function normalizeTriggerArguments(callback) {
            return function(element, src, extraParameters) {
                if ("string" === typeof src) {
                    src = {
                        type: src
                    }
                }
                if (!src.target) {
                    src.target = element
                }
                src.currentTarget = element;
                if (!src.delegateTarget) {
                    src.delegateTarget = element
                }
                if (!src.type && src.originalEvent) {
                    src.type = src.originalEvent.type
                }
                callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters)
            }
        }

        function normalizeEventArguments(callback) {
            return function(src, config) {
                if (!(this instanceof eventsEngine.Event)) {
                    return new eventsEngine.Event(src, config)
                }
                if (!src) {
                    src = {}
                }
                if ("string" === typeof src) {
                    src = {
                        type: src
                    }
                }
                if (!config) {
                    config = {}
                }
                callback.call(this, src, config)
            }
        }

        function iterate(callback) {
            var iterateEventNames = function(element, eventName) {
                if (eventName && eventName.indexOf(" ") > -1) {
                    var args = Array.prototype.slice.call(arguments, 0);
                    eventName.split(" ").forEach(function(eventName) {
                        args[1] = eventName;
                        callback.apply(this, args)
                    })
                } else {
                    callback.apply(this, arguments)
                }
            };
            return function(element, eventName) {
                if ("object" === _typeof(eventName)) {
                    var args = Array.prototype.slice.call(arguments, 0);
                    for (var name in eventName) {
                        args[1] = name;
                        args[args.length - 1] = eventName[name];
                        iterateEventNames.apply(this, args)
                    }
                } else {
                    iterateEventNames.apply(this, arguments)
                }
            }
        }

        function callNativeMethod(eventName, element) {
            var nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
            var isLinkClickEvent = function(eventName, element) {
                return "click" === eventName && "a" === element.localName
            };
            if (isLinkClickEvent(eventName, element)) {
                return
            }
            if (isFunction(element[nativeMethodName])) {
                skipEvent = eventName;
                element[nativeMethodName]();
                skipEvent = void 0
            }
        }

        function calculateWhich(event) {
            var setForMouseEvent = function(event) {
                var mouseEventRegex = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
                return !event.which && void 0 !== event.button && mouseEventRegex.test(event.type)
            };
            var setForKeyEvent = function(event) {
                return null == event.which && 0 === event.type.indexOf("key")
            };
            if (setForKeyEvent(event)) {
                return null != event.charCode ? event.charCode : event.keyCode
            }
            if (setForMouseEvent(event)) {
                var whichByButton = {
                    1: 1,
                    2: 3,
                    3: 1,
                    4: 2
                };
                return whichByButton[event.button]
            }
            return event.which
        }

        function initEvent(EventClass) {
            if (EventClass) {
                eventsEngine.Event = EventClass;
                eventsEngine.Event.prototype = EventClass.prototype
            }
        }
        initEvent(normalizeEventArguments(function(src, config) {
            var that = this;
            var propagationStopped = false;
            var immediatePropagationStopped = false;
            var defaultPrevented = false;
            (0, _extend.extend)(that, src);
            if (src instanceof eventsEngine.Event || _window2.default.hasWindow() && src instanceof window.Event) {
                that.originalEvent = src;
                that.currentTarget = void 0
            }
            if (!(src instanceof eventsEngine.Event)) {
                (0, _extend.extend)(that, {
                    isPropagationStopped: function() {
                        return !!(propagationStopped || that.originalEvent && that.originalEvent.propagationStopped)
                    },
                    stopPropagation: function() {
                        propagationStopped = true;
                        that.originalEvent && that.originalEvent.stopPropagation()
                    },
                    isImmediatePropagationStopped: function() {
                        return immediatePropagationStopped
                    },
                    stopImmediatePropagation: function() {
                        this.stopPropagation();
                        immediatePropagationStopped = true;
                        that.originalEvent && that.originalEvent.stopImmediatePropagation()
                    },
                    isDefaultPrevented: function() {
                        return !!(defaultPrevented || that.originalEvent && that.originalEvent.defaultPrevented)
                    },
                    preventDefault: function() {
                        defaultPrevented = true;
                        that.originalEvent && that.originalEvent.preventDefault()
                    }
                })
            }
            addProperty("which", calculateWhich, that);
            if (0 === src.type.indexOf("touch")) {
                delete config.pageX;
                delete config.pageY
            }(0, _extend.extend)(that, config);
            that.guid = ++guid
        }));

        function addProperty(propName, hook, eventInstance) {
            Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
                enumerable: true,
                configurable: true,
                get: function() {
                    return this.originalEvent && hook(this.originalEvent)
                },
                set: function(value) {
                    Object.defineProperty(this, propName, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    })
                }
            })
        }(0, _hook_touch_props2.default)(addProperty);
        var beforeSetStrategy = (0, _callbacks2.default)();
        var afterSetStrategy = (0, _callbacks2.default)();
        eventsEngine.set = function(engine) {
            beforeSetStrategy.fire();
            eventsEngine.inject(engine);
            initEvent(engine.Event);
            afterSetStrategy.fire()
        };
        eventsEngine.subscribeGlobal = function() {
            applyForEach(arguments, normalizeOnArguments(function() {
                var args = arguments;
                eventsEngine.on.apply(this, args);
                beforeSetStrategy.add(function() {
                    var offArgs = Array.prototype.slice.call(args, 0);
                    offArgs.splice(3, 1);
                    eventsEngine.off.apply(this, offArgs)
                });
                afterSetStrategy.add(function() {
                    eventsEngine.on.apply(this, args)
                })
            }))
        };
        eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
        eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
        eventsEngine.elementDataMap = elementDataMap;
        eventsEngine.detectPassiveEventHandlersSupport = detectPassiveEventHandlersSupport;
        module.exports = eventsEngine
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/core/utils/deferred.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var typeUtils = __webpack_require__( /*! ../utils/type */ 1);
        var isPromise = typeUtils.isPromise;
        var isDeferred = typeUtils.isDeferred;
        var extend = __webpack_require__( /*! ../utils/extend */ 0).extend;
        var Callbacks = __webpack_require__( /*! ../utils/callbacks */ 27);
        var deferredConfig = [{
            method: "resolve",
            handler: "done",
            state: "resolved"
        }, {
            method: "reject",
            handler: "fail",
            state: "rejected"
        }, {
            method: "notify",
            handler: "progress"
        }];
        var _Deferred = function() {
            var that = this;
            this._state = "pending";
            this._promise = {};
            deferredConfig.forEach(function(config) {
                var methodName = config.method;
                this[methodName + "Callbacks"] = new Callbacks;
                this[methodName] = function() {
                    return this[methodName + "With"](this._promise, arguments)
                }.bind(this);
                this._promise[config.handler] = function(handler) {
                    if (!handler) {
                        return this
                    }
                    var callbacks = that[methodName + "Callbacks"];
                    if (callbacks.fired()) {
                        handler.apply(that[methodName + "Context"], that[methodName + "Args"])
                    } else {
                        callbacks.add(function(context, args) {
                            handler.apply(context, args)
                        }.bind(this))
                    }
                    return this
                }
            }.bind(this));
            this._promise.always = function(handler) {
                return this.done(handler).fail(handler)
            };
            this._promise.catch = function(handler) {
                return this.then(null, handler)
            };
            this._promise.then = function(resolve, reject) {
                var result = new _Deferred;
                ["done", "fail"].forEach(function(method) {
                    var callback = "done" === method ? resolve : reject;
                    this[method](function() {
                        if (!callback) {
                            result["done" === method ? "resolve" : "reject"].apply(this, arguments);
                            return
                        }
                        var callbackResult = callback && callback.apply(this, arguments);
                        if (isDeferred(callbackResult)) {
                            callbackResult.done(result.resolve).fail(result.reject)
                        } else {
                            if (isPromise(callbackResult)) {
                                callbackResult.then(result.resolve, result.reject)
                            } else {
                                result.resolve.apply(this, typeUtils.isDefined(callbackResult) ? [callbackResult] : arguments)
                            }
                        }
                    })
                }.bind(this));
                return result.promise()
            };
            this._promise.state = function() {
                return that._state
            };
            this._promise.promise = function(args) {
                return args ? extend(args, that._promise) : that._promise
            };
            this._promise.promise(this)
        };
        deferredConfig.forEach(function(config) {
            var methodName = config.method;
            var state = config.state;
            _Deferred.prototype[methodName + "With"] = function(context, args) {
                var callbacks = this[methodName + "Callbacks"];
                if ("pending" === this.state()) {
                    this[methodName + "Args"] = args;
                    this[methodName + "Context"] = context;
                    if (state) {
                        this._state = state
                    }
                    callbacks.fire(context, args)
                }
                return this
            }
        });
        exports.fromPromise = function(promise, context) {
            if (isDeferred(promise)) {
                return promise
            } else {
                if (isPromise(promise)) {
                    var d = new _Deferred;
                    promise.then(function() {
                        d.resolveWith.apply(d, [context].concat([
                            [].slice.call(arguments)
                        ]))
                    }, function() {
                        d.rejectWith.apply(d, [context].concat([
                            [].slice.call(arguments)
                        ]))
                    });
                    return d
                }
            }
            return (new _Deferred).resolveWith(context, [promise])
        };
        var when = function() {
            if (1 === arguments.length) {
                return exports.fromPromise(arguments[0])
            }
            var values = [].slice.call(arguments);
            var contexts = [];
            var resolvedCount = 0;
            var deferred = new _Deferred;
            var updateState = function(i) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? [].slice.call(arguments) : value;
                    resolvedCount++;
                    if (resolvedCount === values.length) {
                        deferred.resolveWith(contexts, values)
                    }
                }
            };
            for (var i = 0; i < values.length; i++) {
                if (isDeferred(values[i])) {
                    values[i].promise().done(updateState(i)).fail(deferred.reject)
                } else {
                    resolvedCount++
                }
            }
            if (resolvedCount === values.length) {
                deferred.resolveWith(contexts, values)
            }
            return deferred.promise()
        };
        exports.setStrategy = function(value) {
            _Deferred = value.Deferred;
            when = value.when
        };
        exports.Deferred = function() {
            return new _Deferred
        };
        exports.when = function() {
            return when.apply(this, arguments)
        }
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/utils/window.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var domAdapter = __webpack_require__( /*! ../dom_adapter */ 12);
        var hasWindow = function() {
            return "undefined" !== typeof window
        };
        var windowObject = hasWindow() && window;
        if (!windowObject) {
            windowObject = {};
            windowObject.window = windowObject
        }
        var getWindow = function() {
            return windowObject
        };
        var hasProperty = function(prop) {
            return hasWindow() && prop in windowObject
        };
        var defaultScreenFactorFunc = function(width) {
            if (width < 768) {
                return "xs"
            } else {
                if (width < 992) {
                    return "sm"
                } else {
                    if (width < 1200) {
                        return "md"
                    } else {
                        return "lg"
                    }
                }
            }
        };
        var getCurrentScreenFactor = function(screenFactorCallback) {
            var screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
            var windowWidth = domAdapter.getDocumentElement().clientWidth;
            return screenFactorFunc(windowWidth)
        };
        var getNavigator = function() {
            return hasWindow() ? windowObject.navigator : {
                userAgent: ""
            }
        };
        module.exports = {
            hasWindow: hasWindow,
            getWindow: getWindow,
            hasProperty: hasProperty,
            defaultScreenFactorFunc: defaultScreenFactorFunc,
            getCurrentScreenFactor: getCurrentScreenFactor,
            getNavigator: getNavigator
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/events/utils/index.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.addNamespace = exports.getChar = exports.normalizeKeyName = exports.fireEvent = exports.createEvent = exports.setEventFixMethod = exports.needSkipEvent = exports.stopEventsSkipping = exports.forceSkipEvents = exports.hasTouches = exports.eventDelta = exports.eventData = exports.isFakeClickEvent = exports.isKeyboardEvent = exports.isTouchEvent = exports.isDxMouseWheelEvent = exports.isMouseEvent = exports.isPointerEvent = exports.eventSource = void 0;
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _add_namespace = __webpack_require__( /*! ./add_namespace */ 476);
        var _add_namespace2 = _interopRequireDefault(_add_namespace);
        var _events_engine = __webpack_require__( /*! ../core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _selectors = __webpack_require__( /*! ../../ui/widget/selectors */ 66);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var KEY_MAP = {
            backspace: "backspace",
            tab: "tab",
            enter: "enter",
            escape: "escape",
            pageup: "pageUp",
            pagedown: "pageDown",
            end: "end",
            home: "home",
            arrowleft: "leftArrow",
            arrowup: "upArrow",
            arrowright: "rightArrow",
            arrowdown: "downArrow",
            "delete": "del",
            " ": "space",
            f: "F",
            a: "A",
            "*": "asterisk",
            "-": "minus",
            alt: "alt",
            control: "control",
            shift: "shift",
            left: "leftArrow",
            up: "upArrow",
            right: "rightArrow",
            down: "downArrow",
            multiply: "asterisk",
            spacebar: "space",
            del: "del",
            subtract: "minus",
            esc: "escape"
        };
        var LEGACY_KEY_CODES = {
            8: "backspace",
            9: "tab",
            13: "enter",
            27: "escape",
            33: "pageUp",
            34: "pageDown",
            35: "end",
            36: "home",
            37: "leftArrow",
            38: "upArrow",
            39: "rightArrow",
            40: "downArrow",
            46: "del",
            32: "space",
            70: "F",
            65: "A",
            106: "asterisk",
            109: "minus",
            189: "minus",
            173: "minus",
            16: "shift",
            17: "control",
            18: "alt"
        };
        var EVENT_SOURCES_REGEX = {
            dx: /^dx/i,
            mouse: /(mouse|wheel)/i,
            touch: /^touch/i,
            keyboard: /^key/i,
            pointer: /^(ms)?pointer/i
        };
        var fixMethod = function(e) {
            return e
        };
        var copyEvent = function(originalEvent) {
            return fixMethod((0, _events_engine.Event)(originalEvent, originalEvent), originalEvent)
        };
        var isDxEvent = function(e) {
            return "dx" === eventSource(e)
        };
        var isNativeMouseEvent = function(e) {
            return "mouse" === eventSource(e)
        };
        var isNativeTouchEvent = function(e) {
            return "touch" === eventSource(e)
        };
        var eventSource = exports.eventSource = function(_ref) {
            var type = _ref.type;
            var result = "other";
            (0, _iterator.each)(EVENT_SOURCES_REGEX, function(key) {
                if (this.test(type)) {
                    result = key;
                    return false
                }
            });
            return result
        };
        var isPointerEvent = exports.isPointerEvent = function(e) {
            return "pointer" === eventSource(e)
        };
        var isMouseEvent = exports.isMouseEvent = function(e) {
            return isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType
        };
        var isDxMouseWheelEvent = exports.isDxMouseWheelEvent = function(e) {
            return e && "dxmousewheel" === e.type
        };
        var isTouchEvent = exports.isTouchEvent = function(e) {
            return isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType
        };
        exports.isKeyboardEvent = function(e) {
            return "keyboard" === eventSource(e)
        };
        exports.isFakeClickEvent = function(_ref2) {
            var screenX = _ref2.screenX,
                offsetX = _ref2.offsetX,
                pageX = _ref2.pageX;
            return 0 === screenX && !offsetX && 0 === pageX
        };
        exports.eventData = function(_ref3) {
            var pageX = _ref3.pageX,
                pageY = _ref3.pageY,
                timeStamp = _ref3.timeStamp;
            return {
                x: pageX,
                y: pageY,
                time: timeStamp
            }
        };
        exports.eventDelta = function(from, to) {
            return {
                x: to.x - from.x,
                y: to.y - from.y,
                time: to.time - from.time || 1
            }
        };
        exports.hasTouches = function(e) {
            var originalEvent = e.originalEvent,
                pointers = e.pointers;
            if (isNativeTouchEvent(e)) {
                return (originalEvent.touches || []).length
            }
            if (isDxEvent(e)) {
                return (pointers || []).length
            }
            return 0
        };
        var skipEvents = false;
        exports.forceSkipEvents = function() {
            return skipEvents = true
        };
        exports.stopEventsSkipping = function() {
            return skipEvents = false
        };
        exports.needSkipEvent = function(e) {
            if (skipEvents) {
                return true
            }
            var target = e.target;
            var $target = (0, _renderer2.default)(target);
            var touchInInput = $target.is("input, textarea, select");
            if ($target.is(".dx-skip-gesture-event *, .dx-skip-gesture-event")) {
                return true
            }
            if (isDxMouseWheelEvent(e)) {
                var isTextArea = $target.is("textarea") && $target.hasClass("dx-texteditor-input");
                if (isTextArea) {
                    return false
                }
                var isContentEditable = target.isContentEditable || target.hasAttribute("contenteditable");
                if (isContentEditable) {
                    return false
                }
                var isInputFocused = $target.is("input[type='number'], textarea, select") && $target.is(":focus");
                return isInputFocused
            }
            if (isMouseEvent(e)) {
                return touchInInput || e.which > 1
            }
            if (isTouchEvent(e)) {
                return touchInInput && (0, _selectors.focused)($target)
            }
        };
        exports.setEventFixMethod = function(func) {
            return fixMethod = func
        };
        var createEvent = exports.createEvent = function(originalEvent, args) {
            var event = copyEvent(originalEvent);
            args && (0, _extend.extend)(event, args);
            return event
        };
        exports.fireEvent = function(props) {
            var originalEvent = props.originalEvent,
                delegateTarget = props.delegateTarget;
            var event = createEvent(originalEvent, props);
            _events_engine2.default.trigger(delegateTarget || event.target, event);
            return event
        };
        exports.normalizeKeyName = function(_ref4) {
            var key = _ref4.key,
                which = _ref4.which;
            var isKeySupported = !!key;
            key = isKeySupported ? key : which;
            if (key) {
                if (isKeySupported) {
                    key = KEY_MAP[key.toLowerCase()] || key
                } else {
                    key = LEGACY_KEY_CODES[key] || String.fromCharCode(key)
                }
                return key
            }
        };
        exports.getChar = function(_ref5) {
            var key = _ref5.key,
                which = _ref5.which;
            return key || String.fromCharCode(which)
        };
        exports.addNamespace = _add_namespace2.default
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/core/component_registrator.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ./renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _component_registrator_callbacks = __webpack_require__( /*! ./component_registrator_callbacks */ 159);
        var _component_registrator_callbacks2 = _interopRequireDefault(_component_registrator_callbacks);
        var _errors = __webpack_require__( /*! ./errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _public_component = __webpack_require__( /*! ./utils/public_component */ 139);
        var _public_component2 = _interopRequireDefault(_public_component);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var registerComponent = function(name, namespace, componentClass) {
            if (!componentClass) {
                componentClass = namespace
            } else {
                namespace[name] = componentClass
            }
            _public_component2.default.name(componentClass, name);
            _component_registrator_callbacks2.default.fire(name, componentClass)
        };
        var registerRendererComponent = function(name, componentClass) {
            _renderer2.default.fn[name] = function(options) {
                var isMemberInvoke = "string" === typeof options;
                var result;
                if (isMemberInvoke) {
                    var memberName = options;
                    var memberArgs = [].slice.call(arguments).slice(1);
                    this.each(function() {
                        var instance = componentClass.getInstance(this);
                        if (!instance) {
                            throw _errors2.default.Error("E0009", name)
                        }
                        var member = instance[memberName];
                        var memberValue = member.apply(instance, memberArgs);
                        if (void 0 === result) {
                            result = memberValue
                        }
                    })
                } else {
                    this.each(function() {
                        var instance = componentClass.getInstance(this);
                        if (instance) {
                            instance.option(options)
                        } else {
                            new componentClass(this, options)
                        }
                    });
                    result = this
                }
                return result
            }
        };
        _component_registrator_callbacks2.default.add(registerRendererComponent);
        module.exports = registerComponent
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/localization/message.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _dependency_injector = __webpack_require__( /*! ../core/utils/dependency_injector */ 56);
        var _dependency_injector2 = _interopRequireDefault(_dependency_injector);
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _string = __webpack_require__( /*! ../core/utils/string */ 43);
        var _inflector = __webpack_require__( /*! ../core/utils/inflector */ 34);
        var _core = __webpack_require__( /*! ./core */ 83);
        var _core2 = _interopRequireDefault(_core);
        var _default_messages = __webpack_require__( /*! ./default_messages */ 467);
        var _default_messages2 = _interopRequireDefault(_default_messages);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var baseDictionary = (0, _extend.extend)(true, {}, _default_messages2.default);
        var getDataByLocale = function(localeData, locale) {
            return localeData[locale] || {}
        };
        var newMessages = {};
        var messageLocalization = (0, _dependency_injector2.default)({
            engine: function() {
                return "base"
            },
            _dictionary: baseDictionary,
            load: function(messages) {
                (0, _extend.extend)(true, this._dictionary, messages)
            },
            _localizablePrefix: "@",
            setup: function(localizablePrefix) {
                this._localizablePrefix = localizablePrefix
            },
            localizeString: function(text) {
                var that = this;
                var regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g");
                var escapeString = that._localizablePrefix + that._localizablePrefix;
                return text.replace(regex, function(str, prefix, escape, localizationKey) {
                    var defaultResult = that._localizablePrefix + localizationKey;
                    var result;
                    if (escape !== escapeString) {
                        result = that.format(localizationKey)
                    }
                    if (!result) {
                        newMessages[localizationKey] = (0, _inflector.humanize)(localizationKey)
                    }
                    return prefix + (result || defaultResult)
                })
            },
            localizeNode: function(node) {
                var that = this;
                (0, _renderer2.default)(node).each(function(index, nodeItem) {
                    if (!nodeItem.nodeType) {
                        return
                    }
                    if (3 === nodeItem.nodeType) {
                        nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue)
                    } else {
                        if (!(0, _renderer2.default)(nodeItem).is("iframe")) {
                            (0, _iterator.each)(nodeItem.attributes || [], function(index, attr) {
                                if ("string" === typeof attr.value) {
                                    var localizedValue = that.localizeString(attr.value);
                                    if (attr.value !== localizedValue) {
                                        attr.value = localizedValue
                                    }
                                }
                            });
                            (0, _renderer2.default)(nodeItem).contents().each(function(index, node) {
                                that.localizeNode(node)
                            })
                        }
                    }
                })
            },
            getMessagesByLocales: function() {
                return this._dictionary
            },
            getDictionary: function(onlyNew) {
                if (onlyNew) {
                    return newMessages
                }
                return (0, _extend.extend)({}, newMessages, this.getMessagesByLocales()[_core2.default.locale()])
            },
            getFormatter: function(key) {
                return this._getFormatterBase(key) || this._getFormatterBase(key, "en")
            },
            _getFormatterBase: function(key, locale) {
                var _this = this;
                var message = _core2.default.getValueByClosestLocale(function(locale) {
                    return getDataByLocale(_this._dictionary, locale)[key]
                });
                if (message) {
                    return function() {
                        var args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
                        args.unshift(message);
                        return _string.format.apply(this, args)
                    }
                }
            },
            format: function(key) {
                var formatter = this.getFormatter(key);
                var values = Array.prototype.slice.call(arguments, 1);
                return formatter && formatter.apply(this, values) || ""
            }
        });
        module.exports = messageLocalization
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/core/utils/dom.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var config = __webpack_require__( /*! ../../core/config */ 30);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var windowUtils = __webpack_require__( /*! ./window */ 7);
        var window = windowUtils.getWindow();
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var inArray = __webpack_require__( /*! ./array */ 14).inArray;
        var typeUtils = __webpack_require__( /*! ./type */ 1);
        var isDefined = typeUtils.isDefined;
        var isRenderer = typeUtils.isRenderer;
        var htmlParser = __webpack_require__( /*! ../../core/utils/html_parser */ 270);
        var elementStrategy;
        var resetActiveElement = function() {
            var activeElement = domAdapter.getActiveElement();
            var body = domAdapter.getBody();
            if (activeElement && activeElement !== body && activeElement.blur) {
                try {
                    activeElement.blur()
                } catch (e) {
                    body.blur()
                }
            }
        };
        var clearSelection = function() {
            var selection = window.getSelection();
            if (!selection) {
                return
            }
            if ("Caret" === selection.type) {
                return
            }
            if (selection.empty) {
                selection.empty()
            } else {
                if (selection.removeAllRanges) {
                    try {
                        selection.removeAllRanges()
                    } catch (e) {}
                }
            }
        };
        var closestCommonParent = function(startTarget, endTarget) {
            var $startTarget = $(startTarget);
            var $endTarget = $(endTarget);
            if ($startTarget[0] === $endTarget[0]) {
                return $startTarget[0]
            }
            var $startParents = $startTarget.parents();
            var $endParents = $endTarget.parents();
            var startingParent = Math.min($startParents.length, $endParents.length);
            for (var i = -startingParent; i < 0; i++) {
                if ($startParents.get(i) === $endParents.get(i)) {
                    return $startParents.get(i)
                }
            }
        };
        var triggerVisibilityChangeEvent = function(eventName) {
            var VISIBILITY_CHANGE_SELECTOR = ".dx-visibility-change-handler";
            return function(element) {
                var $element = $(element || "body");
                var changeHandlers = $element.filter(VISIBILITY_CHANGE_SELECTOR).add($element.find(VISIBILITY_CHANGE_SELECTOR));
                for (var i = 0; i < changeHandlers.length; i++) {
                    eventsEngine.triggerHandler(changeHandlers[i], eventName)
                }
            }
        };
        var uniqueId = function() {
            var counter = 0;
            return function(prefix) {
                return (prefix || "") + counter++
            }
        }();
        var dataOptionsAttributeName = "data-options";
        var getElementOptions = function(element) {
            var optionsString = $(element).attr(dataOptionsAttributeName) || "";
            return config().optionsParser(optionsString)
        };
        var createComponents = function(elements, componentTypes) {
            var result = [];
            var selector = "[" + dataOptionsAttributeName + "]";
            var $items = elements.find(selector).add(elements.filter(selector));
            $items.each(function(index, element) {
                var $element = $(element);
                var options = getElementOptions(element);
                for (var componentName in options) {
                    if (!componentTypes || inArray(componentName, componentTypes) > -1) {
                        if ($element[componentName]) {
                            $element[componentName](options[componentName]);
                            result.push($element[componentName]("instance"))
                        }
                    }
                }
            });
            return result
        };
        var createMarkupFromString = function(str) {
            if (!window.WinJS) {
                return $(htmlParser.parseHTML(str))
            }
            var tempElement = $("<div>");
            window.WinJS.Utilities.setInnerHTMLUnsafe(tempElement.get(0), str);
            return tempElement.contents()
        };
        var extractTemplateMarkup = function(element) {
            element = $(element);
            var templateTag = element.length && element.filter(function() {
                var $node = $(this);
                return $node.is("script[type]") && $node.attr("type").indexOf("script") < 0
            });
            if (templateTag.length) {
                return templateTag.eq(0).html()
            } else {
                element = $("<div>").append(element);
                return element.html()
            }
        };
        var normalizeTemplateElement = function normalizeTemplateElement(element) {
            var $element = isDefined(element) && (element.nodeType || isRenderer(element)) ? $(element) : $("<div>").html(element).contents();
            if (1 === $element.length) {
                if ($element.is("script")) {
                    $element = normalizeTemplateElement($element.html().trim())
                } else {
                    if ($element.is("table")) {
                        $element = $element.children("tbody").contents()
                    }
                }
            }
            return $element
        };
        var clipboardText = function(event, text) {
            var clipboard = event.originalEvent && event.originalEvent.clipboardData || window.clipboardData;
            if (1 === arguments.length) {
                return clipboard && clipboard.getData("Text")
            }
            clipboard && clipboard.setData("Text", text)
        };
        var contains = function(container, element) {
            if (!element) {
                return false
            }
            if (domAdapter.isTextNode(element)) {
                element = element.parentNode
            }
            if (domAdapter.isDocument(container)) {
                return container.documentElement.contains(element)
            }
            return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS)
        };
        var getPublicElement = function($element) {
            return elementStrategy($element)
        };
        var setPublicElementWrapper = function(value) {
            elementStrategy = value
        };
        setPublicElementWrapper(function(element) {
            return element && element.get(0)
        });
        var createTextElementHiddenCopy = function(element, text, options) {
            var elementStyles = window.getComputedStyle($(element).get(0));
            var includePaddings = options && options.includePaddings;
            return $("<div>").text(text).css({
                fontStyle: elementStyles.fontStyle,
                fontVariant: elementStyles.fontVariant,
                fontWeight: elementStyles.fontWeight,
                fontSize: elementStyles.fontSize,
                fontFamily: elementStyles.fontFamily,
                letterSpacing: elementStyles.letterSpacing,
                border: elementStyles.border,
                paddingTop: includePaddings ? elementStyles.paddingTop : "",
                paddingRight: includePaddings ? elementStyles.paddingRight : "",
                paddingBottom: includePaddings ? elementStyles.paddingBottom : "",
                paddingLeft: includePaddings ? elementStyles.paddingLeft : "",
                visibility: "hidden",
                whiteSpace: "nowrap",
                position: "absolute",
                "float": "left"
            })
        };
        exports.setPublicElementWrapper = setPublicElementWrapper;
        exports.resetActiveElement = resetActiveElement;
        exports.createMarkupFromString = createMarkupFromString;
        exports.triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
        exports.triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
        exports.triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");
        exports.getElementOptions = getElementOptions;
        exports.createComponents = createComponents;
        exports.extractTemplateMarkup = extractTemplateMarkup;
        exports.normalizeTemplateElement = normalizeTemplateElement;
        exports.clearSelection = clearSelection;
        exports.uniqueId = uniqueId;
        exports.closestCommonParent = closestCommonParent;
        exports.clipboardText = clipboardText;
        exports.contains = contains;
        exports.getPublicElement = getPublicElement;
        exports.createTextElementHiddenCopy = createTextElementHiddenCopy
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/core/dom_adapter.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _dependency_injector = __webpack_require__( /*! ./utils/dependency_injector */ 56);
        var _dependency_injector2 = _interopRequireDefault(_dependency_injector);
        var _common = __webpack_require__( /*! ./utils/common */ 3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var DOCUMENT_NODE = 9;
        var nativeDOMAdapterStrategy = {
            querySelectorAll: function(element, selector) {
                return element.querySelectorAll(selector)
            },
            elementMatches: function(element, selector) {
                var _this = this;
                var matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || function(selector) {
                    var doc = element.document || element.ownerDocument;
                    if (!doc) {
                        return false
                    }
                    var items = _this.querySelectorAll(doc, selector);
                    for (var i = 0; i < items.length; i++) {
                        if (items[i] === element) {
                            return true
                        }
                    }
                };
                return matches.call(element, selector)
            },
            createElement: function(tagName, context) {
                context = context || this._document;
                return context.createElement(tagName)
            },
            createElementNS: function(ns, tagName, context) {
                context = context || this._document;
                return context.createElementNS(ns, tagName)
            },
            createTextNode: function(text, context) {
                context = context || this._document;
                return context.createTextNode(text)
            },
            isNode: function(element) {
                return "object" === _typeof(element) && "nodeType" in element
            },
            isElementNode: function(element) {
                return element && element.nodeType === ELEMENT_NODE
            },
            isTextNode: function(element) {
                return element && element.nodeType === TEXT_NODE
            },
            isDocument: function(element) {
                return element && element.nodeType === DOCUMENT_NODE
            },
            removeElement: function(element) {
                var parentNode = element && element.parentNode;
                if (parentNode) {
                    parentNode.removeChild(element)
                }
            },
            insertElement: function(parentElement, newElement, nextSiblingElement) {
                if (parentElement && newElement && parentElement !== newElement) {
                    if (nextSiblingElement) {
                        parentElement.insertBefore(newElement, nextSiblingElement)
                    } else {
                        parentElement.appendChild(newElement)
                    }
                }
            },
            getAttribute: function(element, name) {
                return element.getAttribute(name)
            },
            setAttribute: function(element, name, value) {
                element.setAttribute(name, value)
            },
            removeAttribute: function(element, name) {
                element.removeAttribute(name)
            },
            setProperty: function(element, name, value) {
                element[name] = value
            },
            setText: function(element, text) {
                if (element) {
                    element.textContent = text
                }
            },
            setClass: function(element, className, isAdd) {
                if (1 === element.nodeType && className) {
                    if (element.classList) {
                        if (isAdd) {
                            element.classList.add(className)
                        } else {
                            element.classList.remove(className)
                        }
                    } else {
                        var classNameSupported = "string" === typeof element.className;
                        var elementClass = classNameSupported ? element.className : this.getAttribute(element, "class") || "";
                        var classNames = elementClass.split(" ");
                        var classIndex = classNames.indexOf(className);
                        var resultClassName;
                        if (isAdd && classIndex < 0) {
                            resultClassName = elementClass ? elementClass + " " + className : className
                        }
                        if (!isAdd && classIndex >= 0) {
                            classNames.splice(classIndex, 1);
                            resultClassName = classNames.join(" ")
                        }
                        if (void 0 !== resultClassName) {
                            if (classNameSupported) {
                                element.className = resultClassName
                            } else {
                                this.setAttribute(element, "class", resultClassName)
                            }
                        }
                    }
                }
            },
            setStyle: function(element, name, value) {
                element.style[name] = value || ""
            },
            _document: "undefined" === typeof document ? void 0 : document,
            getDocument: function() {
                return this._document
            },
            getActiveElement: function() {
                return this._document.activeElement
            },
            getBody: function() {
                return this._document.body
            },
            createDocumentFragment: function() {
                return this._document.createDocumentFragment()
            },
            getDocumentElement: function() {
                return this._document.documentElement
            },
            getLocation: function() {
                return this._document.location
            },
            getSelection: function() {
                return this._document.selection
            },
            getReadyState: function() {
                return this._document.readyState
            },
            getHead: function() {
                return this._document.head
            },
            hasDocumentProperty: function(property) {
                return property in this._document
            },
            listen: function(element, event, callback, options) {
                if (!element || !("addEventListener" in element)) {
                    return _common.noop
                }
                element.addEventListener(event, callback, options);
                return function() {
                    element.removeEventListener(event, callback)
                }
            }
        };
        module.exports = (0, _dependency_injector2.default)(nativeDOMAdapterStrategy)
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/viz/core/utils.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _math = __webpack_require__( /*! ../../core/utils/math */ 31);
        var _date = __webpack_require__( /*! ../../core/utils/date */ 24);
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _color = __webpack_require__( /*! ../../color */ 91);
        var _color2 = _interopRequireDefault(_color);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var PI = Math.PI,
            LN10 = Math.LN10,
            abs = Math.abs,
            log = Math.log,
            floor = Math.floor,
            ceil = Math.ceil,
            pow = Math.pow,
            sqrt = Math.sqrt,
            atan2 = Math.atan2;
        var _min = Math.min;
        var _max = Math.max;
        var _cos = Math.cos;
        var _sin = Math.sin;
        var _round = Math.round;
        var MAX_PIXEL_COUNT = 1e10;
        var PI_DIV_180 = PI / 180;
        var _isNaN = isNaN;
        var _Number = Number;
        var _NaN = NaN;
        var PANE_PADDING = 10;
        var getLog = function(value, base) {
            if (!value) {
                return _NaN
            }
            return log(value) / log(base)
        };
        var getAdjustedLog10 = function(value) {
            return (0, _math.adjust)(getLog(value, 10))
        };
        var raiseTo = function(power, base) {
            return pow(base, power)
        };
        var normalizeAngle = function(angle) {
            return (angle % 360 + 360) % 360
        };
        var convertAngleToRendererSpace = function(angle) {
            return 90 - angle
        };
        var degreesToRadians = function(value) {
            return PI * value / 180
        };
        var getCosAndSin = function(angle) {
            var angleInRadians = degreesToRadians(angle);
            return {
                cos: _cos(angleInRadians),
                sin: _sin(angleInRadians)
            }
        };
        var DECIMAL_ORDER_THRESHOLD = 1e-14;
        var getDistance = function(x1, y1, x2, y2) {
            var diffX = x2 - x1;
            var diffY = y2 - y1;
            return sqrt(diffY * diffY + diffX * diffX)
        };
        var getDecimalOrder = function(number) {
            var n = abs(number);
            var cn;
            if (!_isNaN(n)) {
                if (n > 0) {
                    n = log(n) / LN10;
                    cn = ceil(n);
                    return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n)
                }
                return 0
            }
            return _NaN
        };
        var getAppropriateFormat = function(start, end, count) {
            var order = _max(getDecimalOrder(start), getDecimalOrder(end));
            var precision = -getDecimalOrder(abs(end - start) / count);
            var format;
            if (!_isNaN(order) && !_isNaN(precision)) {
                if (abs(order) <= 4) {
                    format = "fixedPoint";
                    precision < 0 && (precision = 0);
                    precision > 4 && (precision = 4)
                } else {
                    format = "exponential";
                    precision += order - 1;
                    precision > 3 && (precision = 3)
                }
                return {
                    type: format,
                    precision: precision
                }
            }
            return null
        };
        var roundValue = function(value, precision) {
            if (precision > 20) {
                precision = 20
            }
            if ((0, _type.isNumeric)(value)) {
                if ((0, _type.isExponential)(value)) {
                    return _Number(value.toExponential(precision))
                } else {
                    return _Number(value.toFixed(precision))
                }
            }
        };
        var getPower = function(value) {
            return value.toExponential().split("e")[1]
        };

        function map(array, callback) {
            var i = 0;
            var len = array.length;
            var result = [];
            var value;
            while (i < len) {
                value = callback(array[i], i);
                if (null !== value) {
                    result.push(value)
                }
                i++
            }
            return result
        }

        function selectByKeys(object, keys) {
            return map(keys, function(key) {
                return object[key] ? object[key] : null
            })
        }

        function decreaseFields(object, keys, eachDecrease, decrease) {
            var dec = decrease;
            (0, _iterator.each)(keys, function(_, key) {
                if (object[key]) {
                    object[key] -= eachDecrease;
                    dec -= eachDecrease
                }
            });
            return dec
        }

        function normalizeEnum(value) {
            return String(value).toLowerCase()
        }

        function setCanvasValues(canvas) {
            if (canvas) {
                canvas.originalTop = canvas.top;
                canvas.originalBottom = canvas.bottom;
                canvas.originalLeft = canvas.left;
                canvas.originalRight = canvas.right
            }
            return canvas
        }

        function normalizeBBoxField(value) {
            return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0
        }

        function normalizeBBox(bBox) {
            var xl = normalizeBBoxField(floor(bBox.x));
            var yt = normalizeBBoxField(floor(bBox.y));
            var xr = normalizeBBoxField(ceil(bBox.width + bBox.x));
            var yb = normalizeBBoxField(ceil(bBox.height + bBox.y));
            var result = {
                x: xl,
                y: yt,
                width: xr - xl,
                height: yb - yt
            };
            result.isEmpty = !result.x && !result.y && !result.width && !result.height;
            return result
        }

        function rotateBBox(bBox, center, angle) {
            var cos = _Number(_cos(angle * PI_DIV_180).toFixed(3));
            var sin = _Number(_sin(angle * PI_DIV_180).toFixed(3));
            var w2 = bBox.width / 2;
            var h2 = bBox.height / 2;
            var centerX = bBox.x + w2;
            var centerY = bBox.y + h2;
            var w2_ = abs(w2 * cos) + abs(h2 * sin);
            var h2_ = abs(w2 * sin) + abs(h2 * cos);
            var centerX_ = center[0] + (centerX - center[0]) * cos + (centerY - center[1]) * sin;
            var centerY_ = center[1] - (centerX - center[0]) * sin + (centerY - center[1]) * cos;
            return normalizeBBox({
                x: centerX_ - w2_,
                y: centerY_ - h2_,
                width: 2 * w2_,
                height: 2 * h2_
            })
        }(0, _extend.extend)(exports, {
            decreaseGaps: function(object, keys, decrease) {
                var arrayGaps;
                do {
                    arrayGaps = selectByKeys(object, keys);
                    arrayGaps.push(ceil(decrease / arrayGaps.length));
                    decrease = decreaseFields(object, keys, _min.apply(null, arrayGaps), decrease)
                } while (decrease > 0 && arrayGaps.length > 1);
                return decrease
            },
            normalizeEnum: normalizeEnum,
            parseScalar: function(value, defaultValue) {
                return void 0 !== value ? value : defaultValue
            },
            enumParser: function(values) {
                var stored = {};
                var i;
                var ii;
                for (i = 0, ii = values.length; i < ii; ++i) {
                    stored[normalizeEnum(values[i])] = 1
                }
                return function(value, defaultValue) {
                    var _value = normalizeEnum(value);
                    return stored[_value] ? _value : defaultValue
                }
            },
            patchFontOptions: function(options) {
                var fontOptions = {};
                (0, _iterator.each)(options || {}, function(key, value) {
                    if (/^(cursor)$/i.test(key)) {} else {
                        if ("opacity" === key) {
                            value = null
                        } else {
                            if ("color" === key) {
                                key = "fill";
                                if ("opacity" in options) {
                                    var color = new _color2.default(value);
                                    value = "rgba(".concat(color.r, ",").concat(color.g, ",").concat(color.b, ",").concat(options.opacity, ")")
                                }
                            } else {
                                key = "font-" + key
                            }
                        }
                    }
                    fontOptions[key] = value
                });
                return fontOptions
            },
            checkElementHasPropertyFromStyleSheet: function(element, property) {
                var slice = Array.prototype.slice;
                var cssRules = slice.call(_dom_adapter2.default.getDocument().styleSheets).reduce(function(rules, styleSheet) {
                    return rules.concat(slice.call(styleSheet.cssRules || styleSheet.rules))
                }, []);
                var elementRules = cssRules.filter(function(rule) {
                    try {
                        return _dom_adapter2.default.elementMatches(element, rule.selectorText)
                    } catch (e) {
                        return false
                    }
                });
                return elementRules.some(function(rule) {
                    return !!rule.style[property]
                })
            },
            convertPolarToXY: function(centerCoords, startAngle, angle, radius) {
                var shiftAngle = 90;
                var normalizedRadius = radius > 0 ? radius : 0;
                angle = (0, _type.isDefined)(angle) ? angle + startAngle - shiftAngle : 0;
                var cosSin = getCosAndSin(angle);
                return {
                    x: _round(centerCoords.x + normalizedRadius * cosSin.cos),
                    y: _round(centerCoords.y + normalizedRadius * cosSin.sin)
                }
            },
            convertXYToPolar: function(centerCoords, x, y) {
                var radius = getDistance(centerCoords.x, centerCoords.y, x, y);
                var angle = atan2(y - centerCoords.y, x - centerCoords.x);
                return {
                    phi: _round(normalizeAngle(180 * angle / PI)),
                    r: _round(radius)
                }
            },
            processSeriesTemplate: function(seriesTemplate, items) {
                var customizeSeries = (0, _type.isFunction)(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : _common.noop;
                var nameField = seriesTemplate.nameField;
                var generatedSeries = {};
                var seriesOrder = [];
                var series;
                var i = 0;
                var length;
                var data;
                items = items || [];
                for (length = items.length; i < length; i++) {
                    data = items[i];
                    if (nameField in data) {
                        series = generatedSeries[data[nameField]];
                        if (!series) {
                            series = generatedSeries[data[nameField]] = {
                                name: data[nameField],
                                nameFieldValue: data[nameField]
                            };
                            seriesOrder.push(series.name)
                        }
                    }
                }
                return map(seriesOrder, function(orderedName) {
                    var group = generatedSeries[orderedName];
                    return (0, _extend.extend)(group, customizeSeries.call(null, group.name))
                })
            },
            getCategoriesInfo: function(categories, startValue, endValue) {
                if (0 === categories.length) {
                    return {
                        categories: []
                    }
                }
                startValue = (0, _type.isDefined)(startValue) ? startValue : categories[0];
                endValue = (0, _type.isDefined)(endValue) ? endValue : categories[categories.length - 1];
                var categoriesValue = map(categories, function(category) {
                    return null === category || void 0 === category ? void 0 : category.valueOf()
                });
                var indexStartValue = categoriesValue.indexOf(startValue.valueOf());
                var indexEndValue = categoriesValue.indexOf(endValue.valueOf());
                var swapBuf;
                var inverted = false;
                indexStartValue < 0 && (indexStartValue = 0);
                indexEndValue < 0 && (indexEndValue = categories.length - 1);
                if (indexEndValue < indexStartValue) {
                    swapBuf = indexEndValue;
                    indexEndValue = indexStartValue;
                    indexStartValue = swapBuf;
                    inverted = true
                }
                var visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);
                var lastIdx = visibleCategories.length - 1;
                return {
                    categories: visibleCategories,
                    start: visibleCategories[inverted ? lastIdx : 0],
                    end: visibleCategories[inverted ? 0 : lastIdx],
                    inverted: inverted
                }
            },
            setCanvasValues: setCanvasValues,
            normalizePanesHeight: function(panes) {
                panes.forEach(function(pane) {
                    var height = pane.height;
                    var unit = 0;
                    var parsedHeight = parseFloat(height) || void 0;
                    if ((0, _type.isString)(height) && height.indexOf("px") > -1 || (0, _type.isNumeric)(height) && height > 1) {
                        parsedHeight = _round(parsedHeight);
                        unit = 1
                    }
                    if (!unit && parsedHeight) {
                        if ((0, _type.isString)(height) && height.indexOf("%") > -1) {
                            parsedHeight /= 100
                        } else {
                            if (parsedHeight < 0) {
                                parsedHeight = parsedHeight < -1 ? 1 : abs(parsedHeight)
                            }
                        }
                    }
                    pane.height = parsedHeight;
                    pane.unit = unit
                });
                var weightSum = panes.filter(function(pane) {
                    return !pane.unit
                }).reduce(function(prev, next) {
                    return prev + (next.height || 0)
                }, 0);
                var weightHeightCount = panes.filter(function(pane) {
                    return !pane.unit
                }).length;
                var emptyHeightCount = panes.filter(function(pane) {
                    return !pane.unit && !pane.height
                }).length;
                if (weightSum < 1 && emptyHeightCount) {
                    panes.filter(function(pane) {
                        return !pane.unit && !pane.height
                    }).forEach(function(pane) {
                        return pane.height = (1 - weightSum) / emptyHeightCount
                    })
                } else {
                    if (weightSum > 1 || weightSum < 1 && !emptyHeightCount || 1 === weightSum && emptyHeightCount) {
                        if (emptyHeightCount) {
                            var weightForEmpty = weightSum / weightHeightCount;
                            var emptyWeightSum = emptyHeightCount * weightForEmpty;
                            panes.filter(function(pane) {
                                return !pane.unit && pane.height
                            }).forEach(function(pane) {
                                return pane.height *= (weightSum - emptyWeightSum) / weightSum
                            });
                            panes.filter(function(pane) {
                                return !pane.unit && !pane.height
                            }).forEach(function(pane) {
                                return pane.height = weightForEmpty
                            })
                        }
                        panes.forEach(function(pane) {
                            return !pane.unit && (pane.height *= 1 / weightSum)
                        })
                    }
                }
            },
            updatePanesCanvases: function(panes, canvas, rotated) {
                var distributedSpace = 0;
                var padding = PANE_PADDING;
                var paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom;
                var usefulSpace = paneSpace - padding * (panes.length - 1);
                var startName = rotated ? "left" : "top";
                var endName = rotated ? "right" : "bottom";
                var totalCustomSpace = panes.reduce(function(prev, cur) {
                    return prev + (cur.unit ? cur.height : 0)
                }, 0);
                usefulSpace -= totalCustomSpace;
                panes.forEach(function(pane) {
                    var calcLength = pane.unit ? pane.height : _round(pane.height * usefulSpace);
                    pane.canvas = pane.canvas || {};
                    (0, _extend.extend)(pane.canvas, canvas);
                    pane.canvas[startName] = canvas[startName] + distributedSpace;
                    pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);
                    distributedSpace = distributedSpace + calcLength + padding;
                    setCanvasValues(pane.canvas)
                })
            },
            unique: function(array) {
                var values = {};
                return map(array, function(item) {
                    var result = !values[item] ? item : null;
                    values[item] = true;
                    return result
                })
            },
            map: map,
            getVerticallyShiftedAngularCoords: function(bBox, dy, center) {
                var isPositive = bBox.x + bBox.width / 2 >= center.x;
                var horizontalOffset1 = (isPositive ? bBox.x : bBox.x + bBox.width) - center.x;
                var verticalOffset1 = bBox.y - center.y;
                var verticalOffset2 = verticalOffset1 + dy;
                var horizontalOffset2 = _round(sqrt(horizontalOffset1 * horizontalOffset1 + verticalOffset1 * verticalOffset1 - verticalOffset2 * verticalOffset2));
                var dx = (isPositive ? +horizontalOffset2 : -horizontalOffset2) || horizontalOffset1;
                return {
                    x: center.x + (isPositive ? dx : dx - bBox.width),
                    y: bBox.y + dy
                }
            },
            mergeMarginOptions: function(opt1, opt2) {
                return {
                    checkInterval: opt1.checkInterval || opt2.checkInterval,
                    size: _max(opt1.size || 0, opt2.size || 0),
                    percentStick: opt1.percentStick || opt2.percentStick,
                    sizePointNormalState: _max(opt1.sizePointNormalState || 0, opt2.sizePointNormalState || 0)
                }
            }
        });

        function getVizRangeObject(value) {
            if (Array.isArray(value)) {
                return {
                    startValue: value[0],
                    endValue: value[1]
                }
            } else {
                return value || {}
            }
        }

        function convertVisualRangeObject(visualRange, convertToVisualRange) {
            if (convertToVisualRange) {
                return visualRange
            }
            return [visualRange.startValue, visualRange.endValue]
        }

        function getAddFunction(range, correctZeroLevel) {
            if ("datetime" === range.dataType) {
                return function(rangeValue, marginValue) {
                    var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                    return new Date(rangeValue.getTime() + sign * marginValue)
                }
            }
            if ("logarithmic" === range.axisType) {
                return function(rangeValue, marginValue) {
                    var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                    var log = getLogExt(rangeValue, range.base) + sign * marginValue;
                    return raiseToExt(log, range.base)
                }
            }
            return function(rangeValue, marginValue) {
                var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                var newValue = rangeValue + sign * marginValue;
                return correctZeroLevel && newValue * rangeValue <= 0 ? 0 : newValue
            }
        }

        function adjustVisualRange(options, visualRange, wholeRange, dataRange) {
            var minDefined = (0, _type.isDefined)(visualRange.startValue);
            var maxDefined = (0, _type.isDefined)(visualRange.endValue);
            var nonDiscrete = "discrete" !== options.axisType;
            dataRange = dataRange || wholeRange;
            var add = getAddFunction(options, false);
            var min = minDefined ? visualRange.startValue : dataRange.min;
            var max = maxDefined ? visualRange.endValue : dataRange.max;
            var rangeLength = visualRange.length;
            var categories = dataRange.categories;
            if (nonDiscrete && !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {
                return {
                    startValue: min,
                    endValue: max
                }
            }
            if ((0, _type.isDefined)(rangeLength)) {
                if (nonDiscrete) {
                    if ("datetime" === options.dataType && !(0, _type.isNumeric)(rangeLength)) {
                        rangeLength = (0, _date.dateToMilliseconds)(rangeLength)
                    }
                    if (maxDefined && !minDefined || !maxDefined && !minDefined) {
                        (0, _type.isDefined)(wholeRange.max) && (max = max > wholeRange.max ? wholeRange.max : max);
                        min = add(max, rangeLength, -1)
                    } else {
                        if (minDefined && !maxDefined) {
                            (0, _type.isDefined)(wholeRange.min) && (min = min < wholeRange.min ? wholeRange.min : min);
                            max = add(min, rangeLength)
                        }
                    }
                } else {
                    rangeLength = parseInt(rangeLength);
                    if (!isNaN(rangeLength) && isFinite(rangeLength)) {
                        rangeLength--;
                        if (!maxDefined && !minDefined) {
                            max = categories[categories.length - 1];
                            min = categories[categories.length - 1 - rangeLength]
                        } else {
                            if (minDefined && !maxDefined) {
                                var categoriesInfo = exports.getCategoriesInfo(categories, min, void 0);
                                max = categoriesInfo.categories[rangeLength]
                            } else {
                                if (!minDefined && maxDefined) {
                                    var _categoriesInfo = exports.getCategoriesInfo(categories, void 0, max);
                                    min = _categoriesInfo.categories[_categoriesInfo.categories.length - 1 - rangeLength]
                                }
                            }
                        }
                    }
                }
            }
            if (nonDiscrete) {
                if ((0, _type.isDefined)(wholeRange.max) && max > wholeRange.max) {
                    max = wholeRange.max
                }
                if ((0, _type.isDefined)(wholeRange.min) && min < wholeRange.min) {
                    min = wholeRange.min
                }
            }
            return {
                startValue: min,
                endValue: max
            }
        }

        function getLogExt(value, base) {
            var allowNegatives = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
            var linearThreshold = arguments.length > 3 ? arguments[3] : void 0;
            if (!allowNegatives) {
                return getLog(value, base)
            }
            if (0 === value) {
                return 0
            }
            var transformValue = getLog(abs(value), base) - (linearThreshold - 1);
            if (transformValue < 0) {
                return 0
            }
            return (0, _math.adjust)((0, _math.sign)(value) * transformValue, Number(pow(base, linearThreshold - 1).toFixed(abs(linearThreshold))))
        }

        function raiseToExt(value, base) {
            var allowNegatives = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
            var linearThreshold = arguments.length > 3 ? arguments[3] : void 0;
            if (!allowNegatives) {
                return raiseTo(value, base)
            }
            if (0 === value) {
                return 0
            }
            var transformValue = raiseTo(abs(value) + (linearThreshold - 1), base);
            if (transformValue < 0) {
                return 0
            }
            return (0, _math.adjust)((0, _math.sign)(value) * transformValue, Number(pow(base, linearThreshold).toFixed(abs(linearThreshold))))
        }

        function rangesAreEqual(range, rangeFromOptions) {
            if (Array.isArray(rangeFromOptions)) {
                return range.length === rangeFromOptions.length && range.every(function(item, i) {
                    return valueOf(item) === valueOf(rangeFromOptions[i])
                })
            } else {
                return valueOf(range.startValue) === valueOf(rangeFromOptions.startValue) && valueOf(range.endValue) === valueOf(rangeFromOptions.endValue)
            }
        }

        function valueOf(value) {
            return value && value.valueOf()
        }

        function pointInCanvas(canvas, x, y) {
            return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom
        }
        exports.getVizRangeObject = getVizRangeObject;
        exports.convertVisualRangeObject = convertVisualRangeObject;
        exports.adjustVisualRange = adjustVisualRange;
        exports.getAddFunction = getAddFunction;
        exports.getLog = getLog;
        exports.getLogExt = getLogExt;
        exports.getAdjustedLog10 = getAdjustedLog10;
        exports.raiseTo = raiseTo;
        exports.raiseToExt = raiseToExt;
        exports.normalizeAngle = normalizeAngle;
        exports.convertAngleToRendererSpace = convertAngleToRendererSpace;
        exports.degreesToRadians = degreesToRadians;
        exports.getCosAndSin = getCosAndSin;
        exports.getDecimalOrder = getDecimalOrder;
        exports.getAppropriateFormat = getAppropriateFormat;
        exports.getDistance = getDistance;
        exports.roundValue = roundValue;
        exports.getPower = getPower;
        exports.valueOf = valueOf;
        exports.rotateBBox = rotateBBox;
        exports.normalizeBBox = normalizeBBox;
        exports.PANE_PADDING = PANE_PADDING;
        exports.rangesAreEqual = rangesAreEqual;
        exports.pointInCanvas = pointInCanvas
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/core/utils/array.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var isDefined = __webpack_require__( /*! ./type */ 1).isDefined;
        var each = __webpack_require__( /*! ./iterator */ 4).each;
        var objectUtils = __webpack_require__( /*! ./object */ 47);
        var config = __webpack_require__( /*! ../config */ 30);
        var isEmpty = function(entity) {
            return Array.isArray(entity) && !entity.length
        };
        var wrapToArray = function(entity) {
            return Array.isArray(entity) ? entity : [entity]
        };
        var inArray = function(value, object) {
            if (!object) {
                return -1
            }
            var array = Array.isArray(object) ? object : object.toArray();
            return array.indexOf(value)
        };
        var intersection = function(a, b) {
            if (!Array.isArray(a) || 0 === a.length || !Array.isArray(b) || 0 === b.length) {
                return []
            }
            var result = [];
            each(a, function(_, value) {
                var index = inArray(value, b);
                if (index !== -1) {
                    result.push(value)
                }
            });
            return result
        };
        var removeDuplicates = function(from, what) {
            if (!Array.isArray(from) || 0 === from.length) {
                return []
            }
            if (!Array.isArray(what) || 0 === what.length) {
                return from.slice()
            }
            var result = [];
            each(from, function(_, value) {
                var index = inArray(value, what);
                if (index === -1) {
                    result.push(value)
                }
            });
            return result
        };
        var normalizeIndexes = function(items, indexParameterName, currentItem, needIndexCallback) {
            var indexedItems = {};
            var parameterIndex = 0;
            var useLegacyVisibleIndex = config().useLegacyVisibleIndex;
            each(items, function(index, item) {
                index = item[indexParameterName];
                if (index >= 0) {
                    indexedItems[index] = indexedItems[index] || [];
                    if (item === currentItem) {
                        indexedItems[index].unshift(item)
                    } else {
                        indexedItems[index].push(item)
                    }
                } else {
                    item[indexParameterName] = void 0
                }
            });
            if (!useLegacyVisibleIndex) {
                each(items, function() {
                    if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
                        while (indexedItems[parameterIndex]) {
                            parameterIndex++
                        }
                        indexedItems[parameterIndex] = [this];
                        parameterIndex++
                    }
                })
            }
            parameterIndex = 0;
            objectUtils.orderEach(indexedItems, function(index, items) {
                each(items, function() {
                    if (index >= 0) {
                        this[indexParameterName] = parameterIndex++
                    }
                })
            });
            if (useLegacyVisibleIndex) {
                each(items, function() {
                    if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
                        this[indexParameterName] = parameterIndex++
                    }
                })
            }
            return parameterIndex
        };
        var merge = function(array1, array2) {
            for (var i = 0; i < array2.length; i++) {
                array1[array1.length] = array2[i]
            }
            return array1
        };
        var find = function(array, condition) {
            for (var i = 0; i < array.length; i++) {
                if (condition(array[i])) {
                    return array[i]
                }
            }
        };
        exports.isEmpty = isEmpty;
        exports.wrapToArray = wrapToArray;
        exports.intersection = intersection;
        exports.removeDuplicates = removeDuplicates;
        exports.normalizeIndexes = normalizeIndexes;
        exports.inArray = inArray;
        exports.merge = merge;
        exports.find = find
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/core/devices.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _window = __webpack_require__( /*! ./utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _extend = __webpack_require__( /*! ./utils/extend */ 0);
        var _type = __webpack_require__( /*! ./utils/type */ 1);
        var _iterator = __webpack_require__( /*! ./utils/iterator */ 4);
        var _errors = __webpack_require__( /*! ./errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _callbacks = __webpack_require__( /*! ./utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);
        var _resize_callbacks = __webpack_require__( /*! ./utils/resize_callbacks */ 114);
        var _resize_callbacks2 = _interopRequireDefault(_resize_callbacks);
        var _events_strategy = __webpack_require__( /*! ./events_strategy */ 100);
        var _storage = __webpack_require__( /*! ./utils/storage */ 299);
        var _view_port = __webpack_require__( /*! ./utils/view_port */ 76);
        var _view_port2 = _interopRequireDefault(_view_port);
        var _config = __webpack_require__( /*! ./config */ 30);
        var _config2 = _interopRequireDefault(_config);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var navigator = _window2.default.getNavigator();
        var window = _window2.default.getWindow();
        var KNOWN_UA_TABLE = {
            iPhone: "iPhone",
            iPhone5: "iPhone",
            iPhone6: "iPhone",
            iPhone6plus: "iPhone",
            iPad: "iPad",
            iPadMini: "iPad Mini",
            androidPhone: "Android Mobile",
            androidTablet: "Android",
            msSurface: "Windows ARM Tablet PC",
            desktop: "desktop"
        };
        var DEFAULT_DEVICE = {
            deviceType: "desktop",
            platform: "generic",
            version: [],
            phone: false,
            tablet: false,
            android: false,
            ios: false,
            generic: true,
            grade: "A",
            mac: false
        };
        var uaParsers = {
            generic: function(userAgent) {
                var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
                var isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
                var isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
                var isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
                if (!(isPhone || isTablet || isDesktop || isMac)) {
                    return
                }
                return {
                    deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
                    platform: "generic",
                    version: [],
                    grade: "A",
                    mac: isMac
                }
            },
            ios: function(userAgent) {
                if (!/ip(hone|od|ad)/i.test(userAgent)) {
                    return
                }
                var isPhone = /ip(hone|od)/i.test(userAgent);
                var matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i);
                var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
                var isIPhone4 = 480 === window.screen.height;
                var grade = isIPhone4 ? "B" : "A";
                return {
                    deviceType: isPhone ? "phone" : "tablet",
                    platform: "ios",
                    version: version,
                    grade: grade
                }
            },
            android: function(userAgent) {
                if (!/android|htc_|silk/i.test(userAgent)) {
                    return
                }
                var isPhone = /mobile/i.test(userAgent);
                var matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
                var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
                var worseThan4_4 = version.length > 1 && (version[0] < 4 || 4 === version[0] && version[1] < 4);
                var grade = worseThan4_4 ? "B" : "A";
                return {
                    deviceType: isPhone ? "phone" : "tablet",
                    platform: "android",
                    version: version,
                    grade: grade
                }
            }
        };
        var Devices = function() {
            function Devices(options) {
                _classCallCheck(this, Devices);
                this._window = (null === options || void 0 === options ? void 0 : options.window) || window;
                this._realDevice = this._getDevice();
                this._currentDevice = void 0;
                this._currentOrientation = void 0;
                this._eventsStrategy = new _events_strategy.EventsStrategy(this);
                this.changed = (0, _callbacks2.default)();
                if (_window2.default.hasWindow()) {
                    this._recalculateOrientation();
                    _resize_callbacks2.default.add(this._recalculateOrientation.bind(this))
                }
            }
            _createClass(Devices, [{
                key: "current",
                value: function(deviceOrName) {
                    if (deviceOrName) {
                        this._currentDevice = this._getDevice(deviceOrName);
                        this._forced = true;
                        this.changed.fire();
                        return
                    }
                    if (!this._currentDevice) {
                        deviceOrName = void 0;
                        try {
                            deviceOrName = this._getDeviceOrNameFromWindowScope()
                        } catch (e) {
                            deviceOrName = this._getDeviceNameFromSessionStorage()
                        } finally {
                            if (!deviceOrName) {
                                deviceOrName = this._getDeviceNameFromSessionStorage()
                            }
                            if (deviceOrName) {
                                this._forced = true
                            }
                        }
                        this._currentDevice = this._getDevice(deviceOrName)
                    }
                    return this._currentDevice
                }
            }, {
                key: "real",
                value: function(forceDevice) {
                    if ((0, _type.isPlainObject)(forceDevice)) {
                        (0, _extend.extend)(this._realDevice, forceDevice);
                        return
                    }
                    return (0, _extend.extend)({}, this._realDevice)
                }
            }, {
                key: "orientation",
                value: function() {
                    return this._currentOrientation
                }
            }, {
                key: "isForced",
                value: function() {
                    return this._forced
                }
            }, {
                key: "isRippleEmulator",
                value: function() {
                    return !!this._window.tinyHippos
                }
            }, {
                key: "_getCssClasses",
                value: function(device) {
                    var result = [];
                    var realDevice = this._realDevice;
                    device = device || this.current();
                    if (device.deviceType) {
                        result.push("dx-device-".concat(device.deviceType));
                        if ("desktop" !== device.deviceType) {
                            result.push("dx-device-mobile")
                        }
                    }
                    result.push("dx-device-".concat(realDevice.platform));
                    if (realDevice.version && realDevice.version.length) {
                        result.push("dx-device-".concat(realDevice.platform, "-").concat(realDevice.version[0]))
                    }
                    if (this.isSimulator()) {
                        result.push("dx-simulator")
                    }
                    if ((0, _config2.default)().rtlEnabled) {
                        result.push("dx-rtl")
                    }
                    return result
                }
            }, {
                key: "attachCssClasses",
                value: function(element, device) {
                    this._deviceClasses = this._getCssClasses(device).join(" ");
                    (0, _renderer2.default)(element).addClass(this._deviceClasses)
                }
            }, {
                key: "detachCssClasses",
                value: function(element) {
                    (0, _renderer2.default)(element).removeClass(this._deviceClasses)
                }
            }, {
                key: "isSimulator",
                value: function() {
                    try {
                        return this._isSimulator || _window2.default.hasWindow() && this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator()
                    } catch (e) {
                        return false
                    }
                }
            }, {
                key: "forceSimulator",
                value: function() {
                    this._isSimulator = true
                }
            }, {
                key: "_getDevice",
                value: function(deviceName) {
                    if ("genericPhone" === deviceName) {
                        deviceName = {
                            deviceType: "phone",
                            platform: "generic",
                            generic: true
                        }
                    }
                    if ((0, _type.isPlainObject)(deviceName)) {
                        return this._fromConfig(deviceName)
                    } else {
                        var ua;
                        if (deviceName) {
                            ua = KNOWN_UA_TABLE[deviceName];
                            if (!ua) {
                                throw _errors2.default.Error("E0005")
                            }
                        } else {
                            ua = navigator.userAgent
                        }
                        return this._fromUA(ua)
                    }
                }
            }, {
                key: "_getDeviceOrNameFromWindowScope",
                value: function() {
                    var result;
                    if (_window2.default.hasWindow() && (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"])) {
                        result = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"]
                    }
                    return result
                }
            }, {
                key: "_getDeviceNameFromSessionStorage",
                value: function() {
                    var sessionStorage = (0, _storage.sessionStorage)();
                    if (!sessionStorage) {
                        return
                    }
                    var deviceOrName = sessionStorage.getItem("dx-force-device");
                    try {
                        return JSON.parse(deviceOrName)
                    } catch (ex) {
                        return deviceOrName
                    }
                }
            }, {
                key: "_fromConfig",
                value: function(config) {
                    var result = (0, _extend.extend)({}, DEFAULT_DEVICE, this._currentDevice, config);
                    var shortcuts = {
                        phone: "phone" === result.deviceType,
                        tablet: "tablet" === result.deviceType,
                        android: "android" === result.platform,
                        ios: "ios" === result.platform,
                        generic: "generic" === result.platform
                    };
                    return (0, _extend.extend)(result, shortcuts)
                }
            }, {
                key: "_fromUA",
                value: function(ua) {
                    var config;
                    (0, _iterator.each)(uaParsers, function(platform, parser) {
                        config = parser(ua);
                        return !config
                    });
                    if (config) {
                        return this._fromConfig(config)
                    }
                    return DEFAULT_DEVICE
                }
            }, {
                key: "_changeOrientation",
                value: function() {
                    var $window = (0, _renderer2.default)(this._window);
                    var orientation = $window.height() > $window.width() ? "portrait" : "landscape";
                    if (this._currentOrientation === orientation) {
                        return
                    }
                    this._currentOrientation = orientation;
                    this._eventsStrategy.fireEvent("orientationChanged", [{
                        orientation: orientation
                    }])
                }
            }, {
                key: "_recalculateOrientation",
                value: function() {
                    var windowWidth = (0, _renderer2.default)(this._window).width();
                    if (this._currentWidth === windowWidth) {
                        return
                    }
                    this._currentWidth = windowWidth;
                    this._changeOrientation()
                }
            }, {
                key: "on",
                value: function(eventName, eventHandler) {
                    this._eventsStrategy.on(eventName, eventHandler);
                    return this
                }
            }, {
                key: "off",
                value: function(eventName, eventHandler) {
                    this._eventsStrategy.off(eventName, eventHandler);
                    return this
                }
            }]);
            return Devices
        }();
        var devices = new Devices;
        _view_port2.default.changeCallback.add(function(viewPort, prevViewport) {
            devices.detachCssClasses(prevViewport);
            devices.attachCssClasses(viewPort)
        });
        module.exports = devices
    },
    /*!********************************************!*\
      !*** ./artifacts/transpiled/core/class.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errors = __webpack_require__( /*! ./errors */ 22);
        var typeUtils = __webpack_require__( /*! ./utils/type */ 1);
        var wrapOverridden = function(baseProto, methodName, method) {
            return function() {
                var prevCallBase = this.callBase;
                this.callBase = baseProto[methodName];
                try {
                    return method.apply(this, arguments)
                } finally {
                    this.callBase = prevCallBase
                }
            }
        };
        var clonePrototype = function(obj) {
            var func = function() {};
            func.prototype = obj.prototype;
            return new func
        };
        var redefine = function(members) {
            var that = this;
            var overridden;
            var memberName;
            var member;
            if (!members) {
                return that
            }
            for (memberName in members) {
                member = members[memberName];
                overridden = "function" === typeof that.prototype[memberName] && "function" === typeof member;
                that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member
            }
            return that
        };
        var include = function() {
            var classObj = this;
            var argument;
            var name;
            var i;
            var hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
            var isES6Class = !hasClassObjOwnProperty("_includedCtors") && !hasClassObjOwnProperty("_includedPostCtors");
            if (isES6Class) {
                classObj._includedCtors = classObj._includedCtors.slice(0);
                classObj._includedPostCtors = classObj._includedPostCtors.slice(0)
            }
            for (i = 0; i < arguments.length; i++) {
                argument = arguments[i];
                if (argument.ctor) {
                    classObj._includedCtors.push(argument.ctor)
                }
                if (argument.postCtor) {
                    classObj._includedPostCtors.push(argument.postCtor)
                }
                for (name in argument) {
                    if ("ctor" === name || "postCtor" === name) {
                        continue
                    }
                    if (name in classObj.prototype) {
                        throw errors.Error("E0002", name)
                    }
                    classObj.prototype[name] = argument[name]
                }
            }
            return classObj
        };
        var subclassOf = function(parentClass) {
            var hasParentProperty = Object.prototype.hasOwnProperty.bind(this)("parent");
            var isES6Class = !hasParentProperty && this.parent;
            if (isES6Class) {
                var baseClass = Object.getPrototypeOf(this);
                return baseClass === parentClass || baseClass.subclassOf(parentClass)
            } else {
                if (this.parent === parentClass) {
                    return true
                }
                if (!this.parent || !this.parent.subclassOf) {
                    return false
                }
                return this.parent.subclassOf(parentClass)
            }
        };
        var abstract = function() {
            throw errors.Error("E0001")
        };
        var copyStatic = function() {
            var hasOwn = Object.prototype.hasOwnProperty;
            return function(source, destination) {
                for (var key in source) {
                    if (!hasOwn.call(source, key)) {
                        return
                    }
                    destination[key] = source[key]
                }
            }
        }();
        var classImpl = function() {};
        classImpl.inherit = function(members) {
            var inheritor = function() {
                if (!this || typeUtils.isWindow(this) || "function" !== typeof this.constructor) {
                    throw errors.Error("E0003")
                }
                var instance = this;
                var ctor = instance.ctor;
                var includedCtors = instance.constructor._includedCtors;
                var includedPostCtors = instance.constructor._includedPostCtors;
                var i;
                for (i = 0; i < includedCtors.length; i++) {
                    includedCtors[i].call(instance)
                }
                if (ctor) {
                    ctor.apply(instance, arguments)
                }
                for (i = 0; i < includedPostCtors.length; i++) {
                    includedPostCtors[i].call(instance)
                }
            };
            inheritor.prototype = clonePrototype(this);
            copyStatic(this, inheritor);
            inheritor.inherit = this.inherit;
            inheritor.abstract = abstract;
            inheritor.redefine = redefine;
            inheritor.include = include;
            inheritor.subclassOf = subclassOf;
            inheritor.parent = this;
            inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
            inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
            inheritor.prototype.constructor = inheritor;
            inheritor.redefine(members);
            return inheritor
        };
        classImpl.abstract = abstract;
        module.exports = classImpl
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/ui/widget/ui.widget.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _action = __webpack_require__( /*! ../../core/action */ 105);
        var _action2 = _interopRequireDefault(_action);
        var _dom_component = __webpack_require__( /*! ../../core/dom_component */ 68);
        var _dom_component2 = _interopRequireDefault(_dom_component);
        var _short = __webpack_require__( /*! ../../events/short */ 116);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _extend2 = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _selectors = __webpack_require__( /*! ./selectors */ 66);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _utils = __webpack_require__( /*! ../../events/utils */ 8);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        __webpack_require__( /*! ../../events/click */ 19);
        __webpack_require__( /*! ../../events/core/emitter.feedback */ 134);
        __webpack_require__( /*! ../../events/hover */ 156);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }

        function setAttribute(name, value, target) {
            name = "role" === name || "id" === name ? name : "aria-".concat(name);
            value = (0, _type.isDefined)(value) ? value.toString() : null;
            target.attr(name, value)
        }
        var Widget = _dom_component2.default.inherit({
            _feedbackHideTimeout: 400,
            _feedbackShowTimeout: 30,
            _supportedKeys: function() {
                return {}
            },
            _getDefaultOptions: function() {
                return (0, _extend2.extend)(this.callBase(), {
                    hoveredElement: null,
                    isActive: false,
                    disabled: false,
                    visible: true,
                    hint: void 0,
                    activeStateEnabled: false,
                    onContentReady: null,
                    hoverStateEnabled: false,
                    focusStateEnabled: false,
                    tabIndex: 0,
                    accessKey: null,
                    onFocusIn: null,
                    onFocusOut: null,
                    onKeyboardHandled: null
                })
            },
            _init: function() {
                this.callBase();
                this._initContentReadyAction()
            },
            _innerWidgetOptionChanged: function(innerWidget, args) {
                var options = Widget.getOptionsFromContainer(args);
                innerWidget && innerWidget.option(options);
                this._options.cache(args.name, options)
            },
            _bindInnerWidgetOptions: function(innerWidget, optionsContainer) {
                var _this = this;
                var syncOptions = function() {
                    return _this._options.silent(optionsContainer, (0, _extend2.extend)({}, innerWidget.option()))
                };
                syncOptions();
                innerWidget.on("optionChanged", syncOptions)
            },
            _getAriaTarget: function() {
                return this._focusTarget()
            },
            _initContentReadyAction: function() {
                this._contentReadyAction = this._createActionByOption("onContentReady", {
                    excludeValidators: ["disabled", "readOnly"]
                })
            },
            _initMarkup: function() {
                var _this$option = this.option(),
                    disabled = _this$option.disabled,
                    visible = _this$option.visible;
                this.$element().addClass("dx-widget");
                this._toggleDisabledState(disabled);
                this._toggleVisibility(visible);
                this._renderHint();
                this._isFocusable() && this._renderFocusTarget();
                this.callBase()
            },
            _render: function() {
                this.callBase();
                this._renderContent();
                this._renderFocusState();
                this._attachFeedbackEvents();
                this._attachHoverEvents()
            },
            _renderHint: function() {
                var _this$option2 = this.option(),
                    hint = _this$option2.hint;
                this.$element().attr("title", hint || null)
            },
            _renderContent: function() {
                var _this2 = this;
                (0, _common.deferRender)(function() {
                    return !_this2._disposed ? _this2._renderContentImpl() : void 0
                }).done(function() {
                    return !_this2._disposed ? _this2._fireContentReadyAction() : void 0
                })
            },
            _renderContentImpl: _common.noop,
            _fireContentReadyAction: (0, _common.deferRenderer)(function() {
                return this._contentReadyAction()
            }),
            _dispose: function() {
                this._contentReadyAction = null;
                this._detachKeyboardEvents();
                this.callBase()
            },
            _resetActiveState: function() {
                this._toggleActiveState(this._eventBindingTarget(), false)
            },
            _clean: function() {
                this._cleanFocusState();
                this._resetActiveState();
                this.callBase();
                this.$element().empty()
            },
            _toggleVisibility: function(visible) {
                this.$element().toggleClass("dx-state-invisible", !visible);
                this.setAria("hidden", !visible || void 0)
            },
            _renderFocusState: function() {
                this._attachKeyboardEvents();
                if (this._isFocusable()) {
                    this._renderFocusTarget();
                    this._attachFocusEvents();
                    this._renderAccessKey()
                }
            },
            _renderAccessKey: function() {
                var _this3 = this;
                var $el = this._focusTarget();
                var _this$option3 = this.option(),
                    accessKey = _this$option3.accessKey;
                var namespace = "UIFeedback";
                $el.attr("accesskey", accessKey);
                _short.dxClick.off($el, {
                    namespace: namespace
                });
                accessKey && _short.dxClick.on($el, function(e) {
                    if ((0, _utils.isFakeClickEvent)(e)) {
                        e.stopImmediatePropagation();
                        _this3.focus()
                    }
                }, {
                    namespace: namespace
                })
            },
            _isFocusable: function() {
                var _this$option4 = this.option(),
                    focusStateEnabled = _this$option4.focusStateEnabled,
                    disabled = _this$option4.disabled;
                return focusStateEnabled && !disabled
            },
            _eventBindingTarget: function() {
                return this.$element()
            },
            _focusTarget: function() {
                return this._getActiveElement()
            },
            _getActiveElement: function() {
                var activeElement = this._eventBindingTarget();
                if (this._activeStateUnit) {
                    return activeElement.find(this._activeStateUnit).not(".dx-state-disabled")
                }
                return activeElement
            },
            _renderFocusTarget: function() {
                var _this$option5 = this.option(),
                    tabIndex = _this$option5.tabIndex;
                this._focusTarget().attr("tabIndex", tabIndex)
            },
            _keyboardEventBindingTarget: function() {
                return this._eventBindingTarget()
            },
            _refreshFocusEvent: function() {
                this._detachFocusEvents();
                this._attachFocusEvents()
            },
            _focusEventTarget: function() {
                return this._focusTarget()
            },
            _focusInHandler: function(event) {
                var _this4 = this;
                if (!event.isDefaultPrevented()) {
                    this._createActionByOption("onFocusIn", {
                        beforeExecute: function() {
                            return _this4._updateFocusState(event, true)
                        },
                        excludeValidators: ["readOnly"]
                    })({
                        event: event
                    })
                }
            },
            _focusOutHandler: function(event) {
                var _this5 = this;
                if (!event.isDefaultPrevented()) {
                    this._createActionByOption("onFocusOut", {
                        beforeExecute: function() {
                            return _this5._updateFocusState(event, false)
                        },
                        excludeValidators: ["readOnly", "disabled"]
                    })({
                        event: event
                    })
                }
            },
            _updateFocusState: function(_ref, isFocused) {
                var target = _ref.target;
                if ((0, _array.inArray)(target, this._focusTarget()) !== -1) {
                    this._toggleFocusClass(isFocused, (0, _renderer2.default)(target))
                }
            },
            _toggleFocusClass: function(isFocused, $element) {
                var $focusTarget = $element && $element.length ? $element : this._focusTarget();
                $focusTarget.toggleClass("dx-state-focused", isFocused)
            },
            _hasFocusClass: function(element) {
                var $focusTarget = (0, _renderer2.default)(element || this._focusTarget());
                return $focusTarget.hasClass("dx-state-focused")
            },
            _isFocused: function() {
                return this._hasFocusClass()
            },
            _getKeyboardListeners: function() {
                return []
            },
            _attachKeyboardEvents: function() {
                var _this6 = this;
                this._detachKeyboardEvents();
                var _this$option6 = this.option(),
                    focusStateEnabled = _this$option6.focusStateEnabled,
                    onKeyboardHandled = _this$option6.onKeyboardHandled;
                var hasChildListeners = this._getKeyboardListeners().length;
                var hasKeyboardEventHandler = !!onKeyboardHandled;
                var shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
                if (shouldAttach) {
                    this._keyboardListenerId = _short.keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), function(opts) {
                        return _this6._keyboardHandler(opts)
                    })
                }
            },
            _keyboardHandler: function(options, onlyChildProcessing) {
                if (!onlyChildProcessing) {
                    var originalEvent = options.originalEvent,
                        keyName = options.keyName,
                        which = options.which;
                    var keys = this._supportedKeys(originalEvent);
                    var func = keys[keyName] || keys[which];
                    if (void 0 !== func) {
                        var handler = func.bind(this);
                        var result = handler(originalEvent, options);
                        if (!result) {
                            return false
                        }
                    }
                }
                var keyboardListeners = this._getKeyboardListeners();
                var _this$option7 = this.option(),
                    onKeyboardHandled = _this$option7.onKeyboardHandled;
                keyboardListeners.forEach(function(listener) {
                    return listener && listener._keyboardHandler(options)
                });
                onKeyboardHandled && onKeyboardHandled(options);
                return true
            },
            _refreshFocusState: function() {
                this._cleanFocusState();
                this._renderFocusState()
            },
            _cleanFocusState: function() {
                var $element = this._focusTarget();
                $element.removeAttr("tabIndex");
                this._toggleFocusClass(false);
                this._detachFocusEvents();
                this._detachKeyboardEvents()
            },
            _detachKeyboardEvents: function() {
                _short.keyboard.off(this._keyboardListenerId);
                this._keyboardListenerId = null
            },
            _attachHoverEvents: function() {
                var _this7 = this;
                var _this$option8 = this.option(),
                    hoverStateEnabled = _this$option8.hoverStateEnabled;
                var selector = this._activeStateUnit;
                var namespace = "UIFeedback";
                var $el = this._eventBindingTarget();
                _short.hover.off($el, {
                    selector: selector,
                    namespace: namespace
                });
                if (hoverStateEnabled) {
                    _short.hover.on($el, new _action2.default(function(_ref2) {
                        var event = _ref2.event,
                            element = _ref2.element;
                        _this7._hoverStartHandler(event);
                        _this7.option("hoveredElement", (0, _renderer2.default)(element))
                    }, {
                        excludeValidators: ["readOnly"]
                    }), function(event) {
                        _this7.option("hoveredElement", null);
                        _this7._hoverEndHandler(event)
                    }, {
                        selector: selector,
                        namespace: namespace
                    })
                }
            },
            _attachFeedbackEvents: function() {
                var _this8 = this;
                var _this$option9 = this.option(),
                    activeStateEnabled = _this$option9.activeStateEnabled;
                var selector = this._activeStateUnit;
                var namespace = "UIFeedback";
                var $el = this._eventBindingTarget();
                _short.active.off($el, {
                    namespace: namespace,
                    selector: selector
                });
                if (activeStateEnabled) {
                    _short.active.on($el, new _action2.default(function(_ref3) {
                        var event = _ref3.event,
                            element = _ref3.element;
                        return _this8._toggleActiveState((0, _renderer2.default)(element), true, event)
                    }), new _action2.default(function(_ref4) {
                        var event = _ref4.event,
                            element = _ref4.element;
                        return _this8._toggleActiveState((0, _renderer2.default)(element), false, event)
                    }, {
                        excludeValidators: ["disabled", "readOnly"]
                    }), {
                        showTimeout: this._feedbackShowTimeout,
                        hideTimeout: this._feedbackHideTimeout,
                        selector: selector,
                        namespace: namespace
                    })
                }
            },
            _detachFocusEvents: function() {
                var $el = this._focusEventTarget();
                _short.focus.off($el, {
                    namespace: "".concat(this.NAME, "Focus")
                })
            },
            _attachFocusEvents: function() {
                var _this9 = this;
                var $el = this._focusEventTarget();
                _short.focus.on($el, function(e) {
                    return _this9._focusInHandler(e)
                }, function(e) {
                    return _this9._focusOutHandler(e)
                }, {
                    namespace: "".concat(this.NAME, "Focus"),
                    isFocusable: function(el) {
                        return (0, _renderer2.default)(el).is(_selectors.focusable)
                    }
                })
            },
            _hoverStartHandler: _common.noop,
            _hoverEndHandler: _common.noop,
            _toggleActiveState: function($element, value) {
                this.option("isActive", value);
                $element.toggleClass("dx-state-active", value)
            },
            _updatedHover: function() {
                var hoveredElement = this._options.silent("hoveredElement");
                this._hover(hoveredElement, hoveredElement)
            },
            _findHoverTarget: function($el) {
                return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget())
            },
            _hover: function($el, $previous) {
                var _this$option10 = this.option(),
                    hoverStateEnabled = _this$option10.hoverStateEnabled,
                    disabled = _this$option10.disabled,
                    isActive = _this$option10.isActive;
                $previous = this._findHoverTarget($previous);
                $previous && $previous.toggleClass("dx-state-hover", false);
                if ($el && hoverStateEnabled && !disabled && !isActive) {
                    var newHoveredElement = this._findHoverTarget($el);
                    newHoveredElement && newHoveredElement.toggleClass("dx-state-hover", true)
                }
            },
            _toggleDisabledState: function(value) {
                this.$element().toggleClass("dx-state-disabled", Boolean(value));
                this.setAria("disabled", value || void 0)
            },
            _setWidgetOption: function(widgetName, args) {
                var _this10 = this;
                if (!this[widgetName]) {
                    return
                }
                if ((0, _type.isPlainObject)(args[0])) {
                    (0, _iterator.each)(args[0], function(option, value) {
                        return _this10._setWidgetOption(widgetName, [option, value])
                    });
                    return
                }
                var optionName = args[0];
                var value = args[1];
                if (1 === args.length) {
                    value = this.option(optionName)
                }
                var widgetOptionMap = this["".concat(widgetName, "OptionMap")];
                this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value)
            },
            _optionChanged: function(args) {
                var name = args.name,
                    value = args.value,
                    previousValue = args.previousValue;
                switch (name) {
                    case "disabled":
                        this._toggleDisabledState(value);
                        this._updatedHover();
                        this._refreshFocusState();
                        break;
                    case "hint":
                        this._renderHint();
                        break;
                    case "activeStateEnabled":
                        this._attachFeedbackEvents();
                        break;
                    case "hoverStateEnabled":
                        this._attachHoverEvents();
                        this._updatedHover();
                        break;
                    case "tabIndex":
                    case "focusStateEnabled":
                        this._refreshFocusState();
                        break;
                    case "onFocusIn":
                    case "onFocusOut":
                        break;
                    case "accessKey":
                        this._renderAccessKey();
                        break;
                    case "hoveredElement":
                        this._hover(value, previousValue);
                        break;
                    case "isActive":
                        this._updatedHover();
                        break;
                    case "visible":
                        this._toggleVisibility(value);
                        if (this._isVisibilityChangeSupported()) {
                            this._checkVisibilityChanged(value ? "shown" : "hiding")
                        }
                        break;
                    case "onKeyboardHandled":
                        this._attachKeyboardEvents();
                        break;
                    case "onContentReady":
                        this._initContentReadyAction();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _isVisible: function() {
                var _this$option11 = this.option(),
                    visible = _this$option11.visible;
                return this.callBase() && visible
            },
            beginUpdate: function() {
                this._ready(false);
                this.callBase()
            },
            endUpdate: function() {
                this.callBase();
                if (this._initialized) {
                    this._ready(true)
                }
            },
            _ready: function(value) {
                if (0 === arguments.length) {
                    return this._isReady
                }
                this._isReady = value
            },
            setAria: function() {
                if (!(0, _type.isPlainObject)(arguments.length <= 0 ? void 0 : arguments[0])) {
                    setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget())
                } else {
                    var target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();
                    (0, _iterator.each)(arguments.length <= 0 ? void 0 : arguments[0], function(name, value) {
                        return setAttribute(name, value, target)
                    })
                }
            },
            isReady: function() {
                return this._ready()
            },
            repaint: function() {
                this._refresh()
            },
            focus: function() {
                _short.focus.trigger(this._focusTarget())
            },
            registerKeyHandler: function(key, handler) {
                var currentKeys = this._supportedKeys();
                this._supportedKeys = function() {
                    return (0, _extend2.extend)(currentKeys, _defineProperty({}, key, handler))
                }
            }
        });
        Widget.getOptionsFromContainer = function(_ref5) {
            var name = _ref5.name,
                fullName = _ref5.fullName,
                value = _ref5.value;
            var options = {};
            if (name === fullName) {
                options = value
            } else {
                var option = fullName.split(".").pop();
                options[option] = value
            }
            return options
        };
        module.exports = Widget
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/ui/widget/ui.errors.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errorUtils = __webpack_require__( /*! ../../core/utils/error */ 138);
        var errors = __webpack_require__( /*! ../../core/errors */ 22);
        module.exports = errorUtils(errors.ERROR_MESSAGES, {
            E1001: "Module '{0}'. Controller '{1}' is already registered",
            E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
            E1003: "Module '{0}'. View '{1}' is already registered",
            E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
            E1005: "Public method '{0}' is already registered",
            E1006: "Public method '{0}.{1}' does not exist",
            E1007: "State storing cannot be provided due to the restrictions of the browser",
            E1010: "The template does not contain the TextBox widget",
            E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
            E1012: "Editing type '{0}' with the name '{1}' is unsupported",
            E1016: "Unexpected type of data source is provided for a lookup column",
            E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
            E1019: "Search mode '{0}' is unavailable",
            E1020: "The type cannot be changed after initialization",
            E1021: "{0} '{1}' you are trying to remove does not exist",
            E1022: 'The "markers" option is given an invalid value. Assign an array instead',
            E1023: 'The "routes" option is given an invalid value. Assign an array instead',
            E1025: "This layout is too complex to render",
            E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
            E1030: "Unknown ScrollView refresh strategy: '{0}'",
            E1031: "Unknown subscription in the Scheduler widget: '{0}'",
            E1032: "Unknown start date in an appointment: '{0}'",
            E1033: "Unknown step in the date navigator: '{0}'",
            E1034: "The browser does not implement an API for saving files",
            E1035: "The editor cannot be created because of an internal error: {0}",
            E1037: "Invalid structure of grouped data",
            E1038: "The browser does not support local storages for local web pages",
            E1039: "A cell's position cannot be calculated",
            E1040: "The '{0}' key value is not unique within the data array",
            E1041: "The '{0}' script is referenced after the DevExtreme scripts or not referenced at all",
            E1042: "{0} requires the key field to be specified",
            E1043: "Changes cannot be processed due to the incorrectly set key",
            E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
            E1045: "Editing requires the key field to be specified in the data store",
            E1046: "The '{0}' key field is not found in data objects",
            E1047: 'The "{0}" field is not found in the fields array',
            E1048: 'The "{0}" operation is not found in the filterOperations array',
            E1049: "Column '{0}': filtering is allowed but the 'dataField' or 'name' option is not specified",
            E1050: "The validationRules option does not apply to third-party editors defined in the editCellTemplate",
            E1051: 'HtmlEditor\'s valueType is "{0}", but the {0} converter was not imported.',
            E1052: '{0} should have the "dataSource" option specified',
            E1053: 'The "buttons" option accepts an array that contains only objects or string values',
            E1054: "All text editor buttons must have names",
            E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
            E1056: 'The {0} widget does not support buttons of the "{1}" type',
            E1058: 'The "startDayHour" must be earlier than the "endDayHour"',
            W1001: 'The "key" option cannot be modified after initialization',
            W1002: "An item with the key '{0}' does not exist",
            W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
            W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
            W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
            W1006: "The map service returned the following error: '{0}'",
            W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
            W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view",
            W1009: "Searching works only if data is specified using the dataSource option",
            W1010: "The capability to select all items works with source data of plain structure only",
            W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
            W1012: "The '{0}' key field is not found in data objects",
            W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
            W1014: "The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.",
            W1015: 'The "cellDuration" should divide the range from the "startDayHour" to the "endDayHour" into even intervals'
        })
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/events/click.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../core/renderer */ 2);
        var eventsEngine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var devices = __webpack_require__( /*! ../core/devices */ 15);
        var domAdapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var domUtils = __webpack_require__( /*! ../core/utils/dom */ 11);
        var animationFrame = __webpack_require__( /*! ../animation/frame */ 117);
        var eventUtils = __webpack_require__( /*! ./utils */ 8);
        var pointerEvents = __webpack_require__( /*! ./pointer */ 23);
        var Emitter = __webpack_require__( /*! ./core/emitter */ 132);
        var registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 101);
        var compareVersions = __webpack_require__( /*! ../core/utils/version */ 60).compare;
        var CLICK_EVENT_NAME = "dxclick";
        var TOUCH_BOUNDARY = 10;
        var abs = Math.abs;
        var isInput = function(element) {
            return $(element).is("input, textarea, select, button ,:focus, :focus *")
        };
        var misc = {
            requestAnimationFrame: animationFrame.requestAnimationFrame,
            cancelAnimationFrame: animationFrame.cancelAnimationFrame
        };
        var ClickEmitter = Emitter.inherit({
            ctor: function(element) {
                this.callBase(element);
                this._makeElementClickable($(element))
            },
            _makeElementClickable: function($element) {
                if (!$element.attr("onclick")) {
                    $element.attr("onclick", "void(0)")
                }
            },
            start: function(e) {
                this._blurPrevented = e.isDefaultPrevented();
                this._startTarget = e.target;
                this._startEventData = eventUtils.eventData(e)
            },
            end: function(e) {
                if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === pointerEvents.cancel) {
                    this._cancel(e);
                    return
                }
                if (!isInput(e.target) && !this._blurPrevented) {
                    domUtils.resetActiveElement()
                }
                this._accept(e);
                this._clickAnimationFrame = misc.requestAnimationFrame(function() {
                    this._fireClickEvent(e)
                }.bind(this))
            },
            _eventOutOfElement: function(e, element) {
                var target = e.target;
                var targetChanged = !domUtils.contains(element, target) && element !== target;
                var gestureDelta = eventUtils.eventDelta(eventUtils.eventData(e), this._startEventData);
                var boundsExceeded = abs(gestureDelta.x) > TOUCH_BOUNDARY || abs(gestureDelta.y) > TOUCH_BOUNDARY;
                return targetChanged || boundsExceeded
            },
            _fireClickEvent: function(e) {
                this._fireEvent(CLICK_EVENT_NAME, e, {
                    target: domUtils.closestCommonParent(this._startTarget, e.target)
                })
            },
            dispose: function() {
                misc.cancelAnimationFrame(this._clickAnimationFrame)
            }
        });
        ! function() {
            var NATIVE_CLICK_CLASS = "dx-native-click";
            var realDevice = devices.real();
            var useNativeClick = realDevice.generic || realDevice.ios && compareVersions(realDevice.version, [9, 3]) >= 0 || realDevice.android && compareVersions(realDevice.version, [5]) >= 0;
            var isNativeClickEvent = function(target) {
                return useNativeClick || $(target).closest("." + NATIVE_CLICK_CLASS).length
            };
            var prevented = null;
            var lastFiredEvent = null;
            var clickHandler = function(e) {
                var originalEvent = e.originalEvent;
                var eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
                var leftButton = !e.which || 1 === e.which;
                if (leftButton && !prevented && isNativeClickEvent(e.target) && !eventAlreadyFired) {
                    if (originalEvent) {
                        originalEvent.DXCLICK_FIRED = true
                    }
                    lastFiredEvent = originalEvent;
                    eventUtils.fireEvent({
                        type: CLICK_EVENT_NAME,
                        originalEvent: e
                    })
                }
            };
            ClickEmitter = ClickEmitter.inherit({
                _makeElementClickable: function($element) {
                    if (!isNativeClickEvent($element)) {
                        this.callBase($element)
                    }
                    eventsEngine.on($element, "click", clickHandler)
                },
                configure: function(data) {
                    this.callBase(data);
                    if (data.useNative) {
                        this.getElement().addClass(NATIVE_CLICK_CLASS)
                    }
                },
                start: function(e) {
                    prevented = null;
                    if (!isNativeClickEvent(e.target)) {
                        this.callBase(e)
                    }
                },
                end: function(e) {
                    if (!isNativeClickEvent(e.target)) {
                        this.callBase(e)
                    }
                },
                cancel: function() {
                    prevented = true
                },
                dispose: function() {
                    this.callBase();
                    eventsEngine.off(this.getElement(), "click", clickHandler)
                }
            });
            exports.useNativeClick = useNativeClick
        }();
        ! function() {
            var desktopDevice = devices.real().generic;
            if (!desktopDevice) {
                var startTarget = null;
                var blurPrevented = false;
                var pointerDownHandler = function(e) {
                    startTarget = e.target;
                    blurPrevented = e.isDefaultPrevented()
                };
                var clickHandler = function(e) {
                    var $target = $(e.target);
                    if (!blurPrevented && startTarget && !$target.is(startTarget) && !$(startTarget).is("label") && isInput($target)) {
                        domUtils.resetActiveElement()
                    }
                    startTarget = null;
                    blurPrevented = false
                };
                var NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
                var document = domAdapter.getDocument();
                eventsEngine.subscribeGlobal(document, eventUtils.addNamespace(pointerEvents.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler);
                eventsEngine.subscribeGlobal(document, eventUtils.addNamespace("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler)
            }
        }();
        registerEmitter({
            emitter: ClickEmitter,
            bubble: true,
            events: [CLICK_EVENT_NAME]
        });
        exports.name = CLICK_EVENT_NAME;
        exports.misc = misc
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/core/utils/data.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errors = __webpack_require__( /*! ../errors */ 22);
        var Class = __webpack_require__( /*! ../class */ 16);
        var objectUtils = __webpack_require__( /*! ./object */ 47);
        var typeUtils = __webpack_require__( /*! ./type */ 1);
        var each = __webpack_require__( /*! ./iterator */ 4).each;
        var variableWrapper = __webpack_require__( /*! ./variable_wrapper */ 94);
        var unwrapVariable = variableWrapper.unwrap;
        var isWrapped = variableWrapper.isWrapped;
        var assign = variableWrapper.assign;
        var bracketsToDots = function(expr) {
            return expr.replace(/\[/g, ".").replace(/\]/g, "")
        };
        var readPropValue = function(obj, propName, options) {
            options = options || {};
            if ("this" === propName) {
                return unwrap(obj, options)
            }
            return unwrap(obj[propName], options)
        };
        var assignPropValue = function(obj, propName, value, options) {
            if ("this" === propName) {
                throw new errors.Error("E4016")
            }
            var propValue = obj[propName];
            if (options.unwrapObservables && isWrapped(propValue)) {
                assign(propValue, value)
            } else {
                obj[propName] = value
            }
        };
        var prepareOptions = function(options) {
            options = options || {};
            options.unwrapObservables = void 0 !== options.unwrapObservables ? options.unwrapObservables : true;
            return options
        };

        function unwrap(value, options) {
            return options.unwrapObservables ? unwrapVariable(value) : value
        }
        var compileGetter = function(expr) {
            if (arguments.length > 1) {
                expr = [].slice.call(arguments)
            }
            if (!expr || "this" === expr) {
                return function(obj) {
                    return obj
                }
            }
            if ("string" === typeof expr) {
                expr = bracketsToDots(expr);
                var path = expr.split(".");
                return function(obj, options) {
                    options = prepareOptions(options);
                    var functionAsIs = options.functionsAsIs;
                    var hasDefaultValue = "defaultValue" in options;
                    var current = unwrap(obj, options);
                    for (var i = 0; i < path.length; i++) {
                        if (!current) {
                            if (null == current && hasDefaultValue) {
                                return options.defaultValue
                            }
                            break
                        }
                        var pathPart = path[i];
                        if (hasDefaultValue && typeUtils.isObject(current) && !(pathPart in current)) {
                            return options.defaultValue
                        }
                        var next = unwrap(current[pathPart], options);
                        if (!functionAsIs && typeUtils.isFunction(next)) {
                            next = next.call(current)
                        }
                        current = next
                    }
                    return current
                }
            }
            if (Array.isArray(expr)) {
                return combineGetters(expr)
            }
            if (typeUtils.isFunction(expr)) {
                return expr
            }
        };

        function combineGetters(getters) {
            var compiledGetters = {};
            for (var i = 0, l = getters.length; i < l; i++) {
                var getter = getters[i];
                compiledGetters[getter] = compileGetter(getter)
            }
            return function(obj, options) {
                var result;
                each(compiledGetters, function(name) {
                    var value = this(obj, options);
                    if (void 0 === value) {
                        return
                    }
                    var current = result || (result = {});
                    var path = name.split(".");
                    var last = path.length - 1;
                    for (var _i = 0; _i < last; _i++) {
                        var pathItem = path[_i];
                        if (!(pathItem in current)) {
                            current[pathItem] = {}
                        }
                        current = current[pathItem]
                    }
                    current[path[last]] = value
                });
                return result
            }
        }
        var ensurePropValueDefined = function(obj, propName, value, options) {
            if (typeUtils.isDefined(value)) {
                return value
            }
            var newValue = {};
            assignPropValue(obj, propName, newValue, options);
            return newValue
        };
        var compileSetter = function(expr) {
            expr = bracketsToDots(expr || "this").split(".");
            var lastLevelIndex = expr.length - 1;
            return function(obj, value, options) {
                options = prepareOptions(options);
                var currentValue = unwrap(obj, options);
                expr.forEach(function(propertyName, levelIndex) {
                    var propertyValue = readPropValue(currentValue, propertyName, options);
                    var isPropertyFunc = !options.functionsAsIs && typeUtils.isFunction(propertyValue) && !isWrapped(propertyValue);
                    if (levelIndex === lastLevelIndex) {
                        if (options.merge && typeUtils.isPlainObject(value) && (!typeUtils.isDefined(propertyValue) || typeUtils.isPlainObject(propertyValue))) {
                            propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
                            objectUtils.deepExtendArraySafe(propertyValue, value, false, true)
                        } else {
                            if (isPropertyFunc) {
                                currentValue[propertyName](value)
                            } else {
                                assignPropValue(currentValue, propertyName, value, options)
                            }
                        }
                    } else {
                        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
                        if (isPropertyFunc) {
                            propertyValue = propertyValue.call(currentValue)
                        }
                        currentValue = propertyValue
                    }
                })
            }
        };
        var toComparable = function(value, caseSensitive) {
            if (value instanceof Date) {
                return value.getTime()
            }
            if (value && value instanceof Class && value.valueOf) {
                return value.valueOf()
            }
            if (!caseSensitive && "string" === typeof value) {
                return value.toLowerCase()
            }
            return value
        };
        exports.compileGetter = compileGetter;
        exports.compileSetter = compileSetter;
        exports.toComparable = toComparable
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/core/utils/position.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _config = __webpack_require__( /*! ../config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _type = __webpack_require__( /*! ../utils/type */ 1);
        var _type2 = _interopRequireDefault(_type);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var getDefaultAlignment = function(isRtlEnabled) {
            var rtlEnabled = null !== isRtlEnabled && void 0 !== isRtlEnabled ? isRtlEnabled : (0, _config2.default)().rtlEnabled;
            return rtlEnabled ? "right" : "left"
        };
        var getBoundingRect = function(element) {
            if (_type2.default.isWindow(element)) {
                return {
                    width: element.outerWidth,
                    height: element.outerHeight
                }
            }
            var rect;
            try {
                rect = element.getBoundingClientRect()
            } catch (e) {
                rect = {
                    width: 0,
                    height: 0,
                    bottom: 0,
                    top: 0,
                    left: 0,
                    right: 0
                }
            }
            return rect
        };
        exports.getDefaultAlignment = getDefaultAlignment;
        exports.getBoundingRect = getBoundingRect
    },
    /*!*********************************************!*\
      !*** ./artifacts/transpiled/core/errors.js ***!
      \*********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errorUtils = __webpack_require__( /*! ./utils/error */ 138);
        module.exports = errorUtils({
            E0001: "Method is not implemented",
            E0002: "Member name collision: {0}",
            E0003: "A class must be instantiated using the 'new' keyword",
            E0004: "The NAME property of the component is not specified",
            E0005: "Unknown device",
            E0006: "Unknown endpoint key is requested",
            E0007: "'Invalidate' method is called outside the update transaction",
            E0008: "Type of the option name is not appropriate to create an action",
            E0009: "Component '{0}' has not been initialized for an element",
            E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
            E0011: "Unknown animation type '{0}'",
            E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
            E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
            E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
            E0015: "Queued task returned an unexpected result",
            E0017: "Event namespace is not defined",
            E0018: "DevExpress.ui.DevExpressPopup widget is required",
            E0020: "Template engine '{0}' is not supported",
            E0021: "Unknown theme is set: {0}",
            E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
            E0023: "Template name is not specified",
            E0024: "DevExtreme bundle already included",
            E0025: "Unexpected argument type",
            E0100: "Unknown validation type is detected",
            E0101: "Misconfigured range validation rule is detected",
            E0102: "Misconfigured comparison validation rule is detected",
            E0103: "validationCallback of an asynchronous rule should return a jQuery or a native promise",
            E0110: "Unknown validation group is detected",
            E0120: "Adapter for a DevExpressValidator component cannot be configured",
            E0121: "The 'customItem' field of the 'onCustomItemCreating' function's parameter should contain a custom item or Promise that is resolved after the item is created.",
            W0000: "'{0}' is deprecated in {1}. {2}",
            W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
            W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
            W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
            W0004: "Timeout for theme loading is over: {0}",
            W0005: "'{0}' event is deprecated in {1}. {2}",
            W0006: "Invalid recurrence rule: '{0}'",
            W0007: "'{0}' Globalize culture is not defined",
            W0008: "Invalid view name: '{0}'",
            W0009: "Invalid time zone name: '{0}'",
            W0010: "{0} is deprecated in {1}. {2}",
            W0011: "Number parsing is invoked while the parser is not defined",
            W0012: "Date parsing is invoked while the parser is not defined",
            W0013: "'{0}' file is deprecated in {1}. {2}",
            W0014: "{0} - '{1}' type is deprecated in {2}. {3}",
            W0015: "Instead of returning a value from the '{0}' function, write it into the '{1}' field of the function's parameter.",
            W0016: 'The "{0}" option does not accept the "{1}" value since v.{2}. {3}.'
        })
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/events/pointer.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _support = __webpack_require__( /*! ../core/utils/support */ 46);
        var _support2 = _interopRequireDefault(_support);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _browser = __webpack_require__( /*! ../core/utils/browser */ 26);
        var _browser2 = _interopRequireDefault(_browser);
        var _devices = __webpack_require__( /*! ../core/devices */ 15);
        var _devices2 = _interopRequireDefault(_devices);
        var _event_registrator = __webpack_require__( /*! ./core/event_registrator */ 77);
        var _event_registrator2 = _interopRequireDefault(_event_registrator);
        var _touch = __webpack_require__( /*! ./pointer/touch */ 282);
        var _touch2 = _interopRequireDefault(_touch);
        var _mspointer = __webpack_require__( /*! ./pointer/mspointer */ 479);
        var _mspointer2 = _interopRequireDefault(_mspointer);
        var _mouse = __webpack_require__( /*! ./pointer/mouse */ 284);
        var _mouse2 = _interopRequireDefault(_mouse);
        var _mouse_and_touch = __webpack_require__( /*! ./pointer/mouse_and_touch */ 480);
        var _mouse_and_touch2 = _interopRequireDefault(_mouse_and_touch);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var getStrategy = function(support, device, browser) {
            if (support.pointerEvents && browser.msie) {
                return _mspointer2.default
            }
            var tablet = device.tablet,
                phone = device.phone;
            if (support.touch && !(tablet || phone)) {
                return _mouse_and_touch2.default
            }
            if (support.touch) {
                return _touch2.default
            }
            return _mouse2.default
        };
        var EventStrategy = getStrategy(_support2.default, _devices2.default.real(), _browser2.default);
        (0, _iterator.each)(EventStrategy.map, function(pointerEvent, originalEvents) {
            (0, _event_registrator2.default)(pointerEvent, new EventStrategy(pointerEvent, originalEvents))
        });
        var pointer = {
            down: "dxpointerdown",
            up: "dxpointerup",
            move: "dxpointermove",
            cancel: "dxpointercancel",
            enter: "dxpointerenter",
            leave: "dxpointerleave",
            over: "dxpointerover",
            out: "dxpointerout"
        };
        pointer.getStrategy = getStrategy;
        module.exports = pointer
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/core/utils/date.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var typeUtils = __webpack_require__( /*! ./type */ 1);
        var adjust = __webpack_require__( /*! ./math */ 31).adjust;
        var each = __webpack_require__( /*! ./iterator */ 4).each;
        var camelize = __webpack_require__( /*! ./inflector */ 34).camelize;
        var isObject = typeUtils.isObject;
        var isString = typeUtils.isString;
        var isDate = typeUtils.isDate;
        var isDefined = typeUtils.isDefined;
        var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
        var toMilliseconds = function toMilliseconds(value) {
            switch (value) {
                case "millisecond":
                    return 1;
                case "second":
                    return 1e3 * toMilliseconds("millisecond");
                case "minute":
                    return 60 * toMilliseconds("second");
                case "hour":
                    return 60 * toMilliseconds("minute");
                case "day":
                    return 24 * toMilliseconds("hour");
                case "week":
                    return 7 * toMilliseconds("day");
                case "month":
                    return 30 * toMilliseconds("day");
                case "quarter":
                    return 3 * toMilliseconds("month");
                case "year":
                    return 365 * toMilliseconds("day");
                default:
                    return 0
            }
        };
        var getDatesInterval = function(startDate, endDate, intervalUnit) {
            var delta = endDate.getTime() - startDate.getTime();
            var millisecondCount = toMilliseconds(intervalUnit) || 1;
            return Math.floor(delta / millisecondCount)
        };
        var getNextDateUnit = function(unit, withWeeks) {
            var interval = getDateUnitInterval(unit);
            switch (interval) {
                case "millisecond":
                    return "second";
                case "second":
                    return "minute";
                case "minute":
                    return "hour";
                case "hour":
                    return "day";
                case "day":
                    return withWeeks ? "week" : "month";
                case "week":
                    return "month";
                case "month":
                    return "quarter";
                case "quarter":
                    return "year";
                case "year":
                    return "year";
                default:
                    return 0
            }
        };
        var convertMillisecondsToDateUnits = function(value) {
            var i;
            var dateUnitCount;
            var dateUnitInterval;
            var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
            var result = {};
            for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
                dateUnitInterval = dateUnitIntervals[i];
                dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
                if (dateUnitCount > 0) {
                    result[dateUnitInterval + "s"] = dateUnitCount;
                    value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
                }
            }
            return result
        };
        var dateToMilliseconds = function(tickInterval) {
            var milliseconds = 0;
            if (isObject(tickInterval)) {
                each(tickInterval, function(key, value) {
                    milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
                })
            }
            if (isString(tickInterval)) {
                milliseconds = convertDateUnitToMilliseconds(tickInterval, 1)
            }
            return milliseconds
        };

        function convertDateUnitToMilliseconds(dateUnit, count) {
            return toMilliseconds(dateUnit) * count
        }

        function getDateUnitInterval(tickInterval) {
            var maxInterval = -1;
            var i;
            if (isString(tickInterval)) {
                return tickInterval
            }
            if (isObject(tickInterval)) {
                each(tickInterval, function(key, value) {
                    for (i = 0; i < dateUnitIntervals.length; i++) {
                        if (value && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
                            maxInterval = i
                        }
                    }
                });
                return dateUnitIntervals[maxInterval]
            }
            return ""
        }
        var tickIntervalToFormatMap = {
            millisecond: "millisecond",
            second: "longtime",
            minute: "shorttime",
            hour: "shorttime",
            day: "day",
            week: "day",
            month: "month",
            quarter: "quarter",
            year: "year"
        };

        function getDateFormatByTickInterval(tickInterval) {
            return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || ""
        }
        var getQuarter = function(month) {
            return Math.floor(month / 3)
        };
        var getFirstQuarterMonth = function(month) {
            return 3 * getQuarter(month)
        };

        function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
            date = new Date(date.getTime());
            var oldDate = new Date(date.getTime());
            var firstQuarterMonth;
            var month;
            var dateUnitInterval = getDateUnitInterval(dateInterval);
            switch (dateUnitInterval) {
                case "second":
                    date = new Date(1e3 * Math.floor(oldDate.getTime() / 1e3));
                    break;
                case "minute":
                    date = new Date(6e4 * Math.floor(oldDate.getTime() / 6e4));
                    break;
                case "hour":
                    date = new Date(36e5 * Math.floor(oldDate.getTime() / 36e5));
                    break;
                case "year":
                    date.setMonth(0);
                case "month":
                    date.setDate(1);
                case "day":
                    date.setHours(0, 0, 0, 0);
                    break;
                case "week":
                    date = getFirstWeekDate(date, firstDayOfWeek || 0);
                    date.setHours(0, 0, 0, 0);
                    break;
                case "quarter":
                    firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
                    month = date.getMonth();
                    date.setDate(1);
                    date.setHours(0, 0, 0, 0);
                    if (month !== firstQuarterMonth) {
                        date.setMonth(firstQuarterMonth)
                    }
            }
            if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
                fixTimezoneGap(oldDate, date)
            }
            return date
        }

        function trimTime(date) {
            return correctDateWithUnitBeginning(date, "day")
        }
        var setToDayEnd = function(date) {
            var result = trimTime(date);
            result.setDate(result.getDate() + 1);
            return new Date(result.getTime() - 1)
        };
        var getDatesDifferences = function(date1, date2) {
            var counter = 0;
            var differences = {
                year: date1.getFullYear() !== date2.getFullYear(),
                month: date1.getMonth() !== date2.getMonth(),
                day: date1.getDate() !== date2.getDate(),
                hour: date1.getHours() !== date2.getHours(),
                minute: date1.getMinutes() !== date2.getMinutes(),
                second: date1.getSeconds() !== date2.getSeconds(),
                millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
            };
            each(differences, function(key, value) {
                if (value) {
                    counter++
                }
            });
            if (0 === counter && 0 !== getTimezonesDifference(date1, date2)) {
                differences.hour = true;
                counter++
            }
            differences.count = counter;
            return differences
        };

        function addDateInterval(value, interval, dir) {
            var result = new Date(value.getTime());
            var intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : typeUtils.isNumeric(interval) ? convertMillisecondsToDateUnits(interval) : interval;
            if (intervalObject.years) {
                result.setFullYear(result.getFullYear() + intervalObject.years * dir)
            }
            if (intervalObject.quarters) {
                result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir)
            }
            if (intervalObject.months) {
                result.setMonth(result.getMonth() + intervalObject.months * dir)
            }
            if (intervalObject.weeks) {
                result.setDate(result.getDate() + 7 * intervalObject.weeks * dir)
            }
            if (intervalObject.days) {
                result.setDate(result.getDate() + intervalObject.days * dir)
            }
            if (intervalObject.hours) {
                result.setTime(result.getTime() + 36e5 * intervalObject.hours * dir)
            }
            if (intervalObject.minutes) {
                result.setTime(result.getTime() + 6e4 * intervalObject.minutes * dir)
            }
            if (intervalObject.seconds) {
                result.setTime(result.getTime() + 1e3 * intervalObject.seconds * dir)
            }
            if (intervalObject.milliseconds) {
                result.setTime(result.getTime() + intervalObject.milliseconds * dir)
            }
            return result
        }
        var addInterval = function(value, interval, isNegative) {
            var dir = isNegative ? -1 : 1;
            return isDate(value) ? addDateInterval(value, interval, dir) : adjust(value + interval * dir, interval)
        };
        var getSequenceByInterval = function(min, max, interval) {
            var intervals = [];
            var cur;
            intervals.push(isDate(min) ? new Date(min.getTime()) : min);
            cur = min;
            while (cur < max) {
                cur = addInterval(cur, interval);
                intervals.push(cur)
            }
            return intervals
        };
        var getViewFirstCellDate = function(viewType, date) {
            if ("month" === viewType) {
                return new Date(date.getFullYear(), date.getMonth(), 1)
            }
            if ("year" === viewType) {
                return new Date(date.getFullYear(), 0, date.getDate())
            }
            if ("decade" === viewType) {
                return new Date(getFirstYearInDecade(date), date.getMonth(), date.getDate())
            }
            if ("century" === viewType) {
                return new Date(getFirstDecadeInCentury(date), date.getMonth(), date.getDate())
            }
        };
        var getViewLastCellDate = function(viewType, date) {
            if ("month" === viewType) {
                return new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date))
            }
            if ("year" === viewType) {
                return new Date(date.getFullYear(), 11, date.getDate())
            }
            if ("decade" === viewType) {
                return new Date(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate())
            }
            if ("century" === viewType) {
                return new Date(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate())
            }
        };
        var getViewMinBoundaryDate = function(viewType, date) {
            var resultDate = new Date(date.getFullYear(), date.getMonth(), 1);
            if ("month" === viewType) {
                return resultDate
            }
            resultDate.setMonth(0);
            if ("year" === viewType) {
                return resultDate
            }
            if ("decade" === viewType) {
                resultDate.setFullYear(getFirstYearInDecade(date))
            }
            if ("century" === viewType) {
                resultDate.setFullYear(getFirstDecadeInCentury(date))
            }
            return resultDate
        };
        var getViewMaxBoundaryDate = function(viewType, date) {
            var resultDate = new Date(date);
            resultDate.setDate(getLastMonthDay(date));
            if ("month" === viewType) {
                return resultDate
            }
            resultDate.setMonth(11);
            resultDate.setDate(getLastMonthDay(resultDate));
            if ("year" === viewType) {
                return resultDate
            }
            if ("decade" === viewType) {
                resultDate.setFullYear(getFirstYearInDecade(date) + 9)
            }
            if ("century" === viewType) {
                resultDate.setFullYear(getFirstDecadeInCentury(date) + 99)
            }
            return resultDate
        };

        function getLastMonthDay(date) {
            var resultDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
            return resultDate.getDate()
        }
        var getViewUp = function(typeView) {
            switch (typeView) {
                case "month":
                    return "year";
                case "year":
                    return "decade";
                case "decade":
                    return "century"
            }
        };
        var getViewDown = function(typeView) {
            switch (typeView) {
                case "century":
                    return "decade";
                case "decade":
                    return "year";
                case "year":
                    return "month"
            }
        };
        var getDifferenceInMonth = function(typeView) {
            var difference = 1;
            if ("year" === typeView) {
                difference = 12
            }
            if ("decade" === typeView) {
                difference = 120
            }
            if ("century" === typeView) {
                difference = 1200
            }
            return difference
        };
        var getDifferenceInMonthForCells = function(typeView) {
            var difference = 1;
            if ("decade" === typeView) {
                difference = 12
            }
            if ("century" === typeView) {
                difference = 120
            }
            return difference
        };

        function getDateIntervalByString(intervalString) {
            var result = {};
            switch (intervalString) {
                case "year":
                    result.years = 1;
                    break;
                case "month":
                    result.months = 1;
                    break;
                case "quarter":
                    result.months = 3;
                    break;
                case "week":
                    result.weeks = 1;
                    break;
                case "day":
                    result.days = 1;
                    break;
                case "hour":
                    result.hours = 1;
                    break;
                case "minute":
                    result.minutes = 1;
                    break;
                case "second":
                    result.seconds = 1;
                    break;
                case "millisecond":
                    result.milliseconds = 1
            }
            return result
        }

        function sameDate(date1, date2) {
            return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate()
        }

        function sameMonthAndYear(date1, date2) {
            return sameYear(date1, date2) && date1.getMonth() === date2.getMonth()
        }

        function sameYear(date1, date2) {
            return date1 && date2 && date1.getFullYear() === date2.getFullYear()
        }
        var sameDecade = function(date1, date2) {
            if (!isDefined(date1) || !isDefined(date2)) {
                return
            }
            var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
            var startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
            return date1 && date2 && startDecadeDate1 === startDecadeDate2
        };
        var sameCentury = function(date1, date2) {
            if (!isDefined(date1) || !isDefined(date2)) {
                return
            }
            var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
            var startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
            return date1 && date2 && startCenturyDate1 === startCenturyDate2
        };

        function getFirstDecadeInCentury(date) {
            return date && date.getFullYear() - date.getFullYear() % 100
        }

        function getFirstYearInDecade(date) {
            return date && date.getFullYear() - date.getFullYear() % 10
        }
        var getShortDateFormat = function() {
            return "yyyy/MM/dd"
        };
        var getFirstMonthDate = function(date) {
            if (!isDefined(date)) {
                return
            }
            var newDate = new Date(date.getFullYear(), date.getMonth(), 1);
            return newDate
        };
        var getLastMonthDate = function(date) {
            if (!isDefined(date)) {
                return
            }
            var newDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
            return newDate
        };

        function getFirstWeekDate(date, firstDayOfWeek) {
            var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
            var result = new Date(date);
            result.setDate(date.getDate() - delta);
            return result
        }
        var normalizeDateByWeek = function(date, currentDate) {
            var differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day");
            var resultDate = new Date(date);
            if (differenceInDays >= 6) {
                resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7))
            }
            return resultDate
        };
        var dateInRange = function(date, min, max, format) {
            if ("date" === format) {
                min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
                max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
                date = date && dateUtils.correctDateWithUnitBeginning(date, "day")
            }
            return normalizeDate(date, min, max) === date
        };
        var dateTimeFromDecimal = function(number) {
            var hours = Math.floor(number);
            var minutes = number % 1 * 60;
            return {
                hours: hours,
                minutes: minutes
            }
        };
        var roundDateByStartDayHour = function(date, startDayHour) {
            var startTime = this.dateTimeFromDecimal(startDayHour);
            var result = new Date(date);
            if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
                result.setHours(startTime.hours, startTime.minutes, 0, 0)
            }
            return result
        };

        function normalizeDate(date, min, max) {
            var normalizedDate = date;
            if (!isDefined(date)) {
                return date
            }
            if (isDefined(min) && date < min) {
                normalizedDate = min
            }
            if (isDefined(max) && date > max) {
                normalizedDate = max
            }
            return normalizedDate
        }

        function fixTimezoneGap(oldDate, newDate) {
            if (!isDefined(oldDate)) {
                return
            }
            var diff = newDate.getHours() - oldDate.getHours();
            if (0 === diff) {
                return
            }
            var sign = 1 === diff || diff === -23 ? -1 : 1;
            var trial = new Date(newDate.getTime() + 36e5 * sign);
            if (sign > 0 || trial.getDate() === newDate.getDate()) {
                newDate.setTime(trial.getTime())
            }
        }
        var roundToHour = function(date) {
            date.setHours(date.getHours() + 1);
            date.setMinutes(0);
            return date
        };

        function getTimezonesDifference(min, max) {
            return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3
        }
        var makeDate = function(date) {
            return new Date(date)
        };
        var getDatesOfInterval = function(startDate, endDate, step) {
            var result = [];
            var currentDate = new Date(startDate.getTime());
            if (startDate.getTime() === endDate.getTime()) {
                result.push(new Date(startDate.getTime()))
            }
            while (currentDate < endDate) {
                result.push(new Date(currentDate.getTime()));
                currentDate = this.addInterval(currentDate, step)
            }
            return result
        };
        var dateUtils = {
            dateUnitIntervals: dateUnitIntervals,
            convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
            dateToMilliseconds: dateToMilliseconds,
            getNextDateUnit: getNextDateUnit,
            convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
            getDateUnitInterval: getDateUnitInterval,
            getDateFormatByTickInterval: getDateFormatByTickInterval,
            getDatesDifferences: getDatesDifferences,
            correctDateWithUnitBeginning: correctDateWithUnitBeginning,
            trimTime: trimTime,
            setToDayEnd: setToDayEnd,
            roundDateByStartDayHour: roundDateByStartDayHour,
            dateTimeFromDecimal: dateTimeFromDecimal,
            addDateInterval: addDateInterval,
            addInterval: addInterval,
            getSequenceByInterval: getSequenceByInterval,
            getDateIntervalByString: getDateIntervalByString,
            sameDate: sameDate,
            sameMonthAndYear: sameMonthAndYear,
            sameMonth: sameMonthAndYear,
            sameYear: sameYear,
            sameDecade: sameDecade,
            sameCentury: sameCentury,
            getDifferenceInMonth: getDifferenceInMonth,
            getDifferenceInMonthForCells: getDifferenceInMonthForCells,
            getFirstYearInDecade: getFirstYearInDecade,
            getFirstDecadeInCentury: getFirstDecadeInCentury,
            getShortDateFormat: getShortDateFormat,
            getViewFirstCellDate: getViewFirstCellDate,
            getViewLastCellDate: getViewLastCellDate,
            getViewDown: getViewDown,
            getViewUp: getViewUp,
            getLastMonthDay: getLastMonthDay,
            getLastMonthDate: getLastMonthDate,
            getFirstMonthDate: getFirstMonthDate,
            getFirstWeekDate: getFirstWeekDate,
            normalizeDateByWeek: normalizeDateByWeek,
            getQuarter: getQuarter,
            getFirstQuarterMonth: getFirstQuarterMonth,
            dateInRange: dateInRange,
            roundToHour: roundToHour,
            normalizeDate: normalizeDate,
            getViewMinBoundaryDate: getViewMinBoundaryDate,
            getViewMaxBoundaryDate: getViewMaxBoundaryDate,
            fixTimezoneGap: fixTimezoneGap,
            getTimezonesDifference: getTimezonesDifference,
            makeDate: makeDate,
            getDatesInterval: getDatesInterval,
            getDatesOfInterval: getDatesOfInterval
        };
        dateUtils.sameView = function(view, date1, date2) {
            return dateUtils[camelize("same " + view)](date1, date2)
        };
        module.exports = dateUtils
    }, ,
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/utils/browser.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ./extend */ 0).extend;
        var windowUtils = __webpack_require__( /*! ./window */ 7);
        var navigator = windowUtils.getNavigator();
        var webkitRegExp = /(webkit)[ \/]([\w.]+)/;
        var ieRegExp = /(msie) (\d{1,2}\.\d)/;
        var ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/;
        var msEdge = /(edge)\/((\d+)?[\w.]+)/;
        var mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
        var browserFromUA = function(ua) {
            ua = ua.toLowerCase();
            var result = {};
            var matches = ieRegExp.exec(ua) || ie11RegExp.exec(ua) || msEdge.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || webkitRegExp.exec(ua) || [];
            var browserName = matches[1];
            var browserVersion = matches[2];
            if ("webkit" === browserName) {
                result.webkit = true;
                if (ua.indexOf("chrome") >= 0 || ua.indexOf("crios") >= 0) {
                    browserName = "chrome";
                    browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua);
                    browserVersion = browserVersion && browserVersion[1]
                } else {
                    if (ua.indexOf("fxios") >= 0) {
                        browserName = "mozilla";
                        browserVersion = /fxios\/(\d+\.\d+)/.exec(ua);
                        browserVersion = browserVersion && browserVersion[1]
                    } else {
                        if (ua.indexOf("safari") >= 0 && /version|phantomjs/.test(ua)) {
                            browserName = "safari";
                            browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua);
                            browserVersion = browserVersion && browserVersion[1]
                        } else {
                            browserName = "unknown";
                            browserVersion = /applewebkit\/([0-9.]+)/.exec(ua);
                            browserVersion = browserVersion && browserVersion[1]
                        }
                    }
                }
            }
            if ("trident" === browserName || "edge" === browserName) {
                browserName = "msie"
            }
            if (browserName) {
                result[browserName] = true;
                result.version = browserVersion
            }
            return result
        };
        module.exports = extend({
            _fromUA: browserFromUA
        }, browserFromUA(navigator.userAgent))
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/core/utils/callbacks.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Callback = function(options) {
            this._options = options || {};
            this._list = [];
            this._queue = [];
            this._firing = false;
            this._fired = false;
            this._firingIndexes = []
        };
        Callback.prototype._fireCore = function(context, args) {
            var firingIndexes = this._firingIndexes;
            var list = this._list;
            var stopOnFalse = this._options.stopOnFalse;
            var step = firingIndexes.length;
            for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
                var result = list[firingIndexes[step]].apply(context, args);
                if (false === result && stopOnFalse) {
                    break
                }
            }
            firingIndexes.pop()
        };
        Callback.prototype.add = function(fn) {
            if ("function" === typeof fn && (!this._options.unique || !this.has(fn))) {
                this._list.push(fn)
            }
            return this
        };
        Callback.prototype.remove = function(fn) {
            var list = this._list;
            var firingIndexes = this._firingIndexes;
            var index = list.indexOf(fn);
            if (index > -1) {
                list.splice(index, 1);
                if (this._firing && firingIndexes.length) {
                    for (var step = 0; step < firingIndexes.length; step++) {
                        if (index <= firingIndexes[step]) {
                            firingIndexes[step]--
                        }
                    }
                }
            }
            return this
        };
        Callback.prototype.has = function(fn) {
            var list = this._list;
            return fn ? list.indexOf(fn) > -1 : !!list.length
        };
        Callback.prototype.empty = function(fn) {
            this._list = [];
            return this
        };
        Callback.prototype.fireWith = function(context, args) {
            var queue = this._queue;
            args = args || [];
            args = args.slice ? args.slice() : args;
            if (this._options.syncStrategy) {
                this._firing = true;
                this._fireCore(context, args)
            } else {
                queue.push([context, args]);
                if (this._firing) {
                    return
                }
                this._firing = true;
                while (queue.length) {
                    var memory = queue.shift();
                    this._fireCore(memory[0], memory[1])
                }
            }
            this._firing = false;
            this._fired = true;
            return this
        };
        Callback.prototype.fire = function() {
            this.fireWith(this, arguments)
        };
        Callback.prototype.fired = function() {
            return this._fired
        };
        var Callbacks = function(options) {
            return new Callback(options)
        };
        module.exports = Callbacks
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/animation/translator.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dataUtils = __webpack_require__( /*! ../core/element_data */ 41);
        var type = __webpack_require__( /*! ../core/utils/type */ 1).type;
        var TRANSLATOR_DATA_KEY = "dxTranslator";
        var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
        var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
        var locate = function($element) {
            var translate = getTranslate($element);
            return {
                left: translate.x,
                top: translate.y
            }
        };

        function isPercentValue(value) {
            return "string" === type(value) && "%" === value[value.length - 1]
        }

        function cacheTranslate($element, translate) {
            if ($element.length) {
                dataUtils.data($element.get(0), TRANSLATOR_DATA_KEY, translate)
            }
        }
        var clearCache = function($element) {
            if ($element.length) {
                dataUtils.removeData($element.get(0), TRANSLATOR_DATA_KEY)
            }
        };
        var getTranslateCss = function(translate) {
            translate.x = translate.x || 0;
            translate.y = translate.y || 0;
            var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
            var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
            return "translate(" + xValueString + ", " + yValueString + ")"
        };
        var getTranslate = function($element) {
            var result = $element.length ? dataUtils.data($element.get(0), TRANSLATOR_DATA_KEY) : null;
            if (!result) {
                var transformValue = $element.css("transform") || getTranslateCss({
                    x: 0,
                    y: 0
                });
                var matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
                var is3D = matrix && matrix[1];
                if (matrix) {
                    matrix = matrix[2].split(",");
                    if ("3d" === is3D) {
                        matrix = matrix.slice(12, 15)
                    } else {
                        matrix.push(0);
                        matrix = matrix.slice(4, 7)
                    }
                } else {
                    matrix = [0, 0, 0]
                }
                result = {
                    x: parseFloat(matrix[0]),
                    y: parseFloat(matrix[1]),
                    z: parseFloat(matrix[2])
                };
                cacheTranslate($element, result)
            }
            return result
        };
        var move = function($element, position) {
            var left = position.left;
            var top = position.top;
            var translate;
            if (void 0 === left) {
                translate = getTranslate($element);
                translate.y = top || 0
            } else {
                if (void 0 === top) {
                    translate = getTranslate($element);
                    translate.x = left || 0
                } else {
                    translate = {
                        x: left || 0,
                        y: top || 0,
                        z: 0
                    };
                    cacheTranslate($element, translate)
                }
            }
            $element.css({
                transform: getTranslateCss(translate)
            });
            if (isPercentValue(left) || isPercentValue(top)) {
                clearCache($element)
            }
        };
        var resetPosition = function($element, finishTransition) {
            var originalTransition;
            var stylesConfig = {
                left: 0,
                top: 0,
                transform: "none"
            };
            if (finishTransition) {
                originalTransition = $element.css("transition");
                stylesConfig.transition = "none"
            }
            $element.css(stylesConfig);
            clearCache($element);
            if (finishTransition) {
                $element.get(0).offsetHeight;
                $element.css("transition", originalTransition)
            }
        };
        var parseTranslate = function(translateString) {
            var result = translateString.match(TRANSLATE_REGEX);
            if (!result || !result[1]) {
                return
            }
            result = result[1].split(",");
            result = {
                x: parseFloat(result[0]),
                y: parseFloat(result[1]),
                z: parseFloat(result[2])
            };
            return result
        };
        exports.move = move;
        exports.locate = locate;
        exports.clearCache = clearCache;
        exports.parseTranslate = parseTranslate;
        exports.getTranslate = getTranslate;
        exports.getTranslateCss = getTranslateCss;
        exports.resetPosition = resetPosition
    }, ,
    /*!*********************************************!*\
      !*** ./artifacts/transpiled/core/config.js ***!
      \*********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend = __webpack_require__( /*! ./utils/extend */ 0);
        var _extend2 = _interopRequireDefault(_extend);
        var _errors = __webpack_require__( /*! ./errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var config = {
            rtlEnabled: false,
            defaultCurrency: "USD",
            oDataFilterToLower: true,
            serverDecimalSeparator: ".",
            decimalSeparator: ".",
            thousandsSeparator: ",",
            forceIsoDateParsing: true,
            wrapActionsBeforeExecute: true,
            useLegacyStoreResult: false,
            useJQuery: void 0,
            editorStylingMode: void 0,
            useLegacyVisibleIndex: false,
            floatingActionButtonConfig: {
                icon: "add",
                closeIcon: "close",
                label: "",
                position: {
                    at: "right bottom",
                    my: "right bottom",
                    offset: {
                        x: -16,
                        y: -16
                    }
                },
                maxSpeedDialActionCount: 5,
                shading: false,
                direction: "auto"
            },
            optionsParser: function(optionsString) {
                if ("{" !== optionsString.trim().charAt(0)) {
                    optionsString = "{" + optionsString + "}"
                }
                try {
                    return new Function("return " + optionsString)()
                } catch (ex) {
                    throw _errors2.default.Error("E3018", ex, optionsString)
                }
            }
        };
        var deprecatedFields = ["decimalSeparator", "thousandsSeparator"];
        var configMethod = function() {
            if (!arguments.length) {
                return config
            }
            var newConfig = arguments.length <= 0 ? void 0 : arguments[0];
            deprecatedFields.forEach(function(deprecatedField) {
                if (newConfig[deprecatedField]) {
                    var message = "Now, the ".concat(deprecatedField, " is selected based on the specified locale.");
                    _errors2.default.log("W0003", "config", deprecatedField, "19.2", message)
                }
            });
            _extend2.default.extend(config, newConfig)
        };
        if ("undefined" !== typeof DevExpress && DevExpress.config) {
            configMethod(DevExpress.config)
        }
        module.exports = configMethod
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/core/utils/math.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var isExponential = __webpack_require__( /*! ./type */ 1).isExponential;
        var sign = function(value) {
            if (0 === value) {
                return 0
            }
            return value / Math.abs(value)
        };
        var fitIntoRange = function(value, minValue, maxValue) {
            var isMinValueUndefined = !minValue && 0 !== minValue;
            var isMaxValueUndefined = !maxValue && 0 !== maxValue;
            isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value, maxValue) : value);
            isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value, minValue) : value);
            return Math.min(Math.max(value, minValue), maxValue)
        };
        var inRange = function(value, minValue, maxValue) {
            return value >= minValue && value <= maxValue
        };

        function getExponent(value) {
            return Math.abs(parseInt(value.toExponential().split("e")[1]))
        }

        function _isEdgeBug() {
            var value = 3e-4;
            var correctValue = "0.000300";
            var precisionValue = 3;
            return correctValue !== value.toPrecision(precisionValue)
        }

        function adjust(value, interval) {
            var precision = getPrecision(interval || 0) + 2;
            var separatedValue = value.toString().split(".");
            var sourceValue = value;
            var absValue = Math.abs(value);
            var separatedAdjustedValue;
            var isExponentValue = isExponential(value);
            var integerPart = absValue > 1 ? 10 : 0;
            if (1 === separatedValue.length) {
                return value
            }
            if (!isExponentValue) {
                if (isExponential(interval)) {
                    precision = separatedValue[0].length + getExponent(interval)
                }
                value = absValue;
                value = value - Math.floor(value) + integerPart
            }
            precision = _isEdgeBug() && getExponent(value) > 6 || precision > 7 ? 15 : 7;
            if (!isExponentValue) {
                separatedAdjustedValue = parseFloat(value.toPrecision(precision)).toString().split(".");
                if (separatedAdjustedValue[0] === integerPart.toString()) {
                    return parseFloat(separatedValue[0] + "." + separatedAdjustedValue[1])
                }
            }
            return parseFloat(sourceValue.toPrecision(precision))
        }

        function getPrecision(value) {
            var str = value.toString();
            if (str.indexOf(".") < 0) {
                return 0
            }
            var mantissa = str.split(".");
            var positionOfDelimiter = mantissa[1].indexOf("e");
            return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length
        }

        function getRoot(x, n) {
            if (x < 0 && n % 2 !== 1) {
                return NaN
            }
            var y = Math.pow(Math.abs(x), 1 / n);
            return n % 2 === 1 && x < 0 ? -y : y
        }

        function solveCubicEquation(a, b, c, d) {
            var min = 1e-8;
            if (Math.abs(a) < min) {
                a = b;
                b = c;
                c = d;
                if (Math.abs(a) < min) {
                    a = b;
                    b = c;
                    if (Math.abs(a) < min) {
                        return []
                    }
                    return [-b / a]
                }
                var D2 = b * b - 4 * a * c;
                if (Math.abs(D2) < min) {
                    return [-b / (2 * a)]
                } else {
                    if (D2 > 0) {
                        return [(-b + Math.sqrt(D2)) / (2 * a), (-b - Math.sqrt(D2)) / (2 * a)]
                    }
                }
                return []
            }
            var p = (3 * a * c - b * b) / (3 * a * a);
            var q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a);
            var roots;
            var u;
            if (Math.abs(p) < min) {
                roots = [getRoot(-q, 3)]
            } else {
                if (Math.abs(q) < min) {
                    roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : [])
                } else {
                    var D3 = q * q / 4 + p * p * p / 27;
                    if (Math.abs(D3) < min) {
                        roots = [-1.5 * q / p, 3 * q / p]
                    } else {
                        if (D3 > 0) {
                            u = getRoot(-q / 2 - Math.sqrt(D3), 3);
                            roots = [u - p / (3 * u)]
                        } else {
                            u = 2 * Math.sqrt(-p / 3);
                            var t = Math.acos(3 * q / p / u) / 3;
                            var k = 2 * Math.PI / 3;
                            roots = [u * Math.cos(t), u * Math.cos(t - k), u * Math.cos(t - 2 * k)]
                        }
                    }
                }
            }
            for (var i = 0; i < roots.length; i++) {
                roots[i] -= b / (3 * a)
            }
            return roots
        }

        function trunc(value) {
            return Math.trunc ? Math.trunc(value) : value > 0 ? Math.floor(value) : Math.ceil(value)
        }
        exports.sign = sign;
        exports.fitIntoRange = fitIntoRange;
        exports.inRange = inRange;
        exports.adjust = adjust;
        exports.getPrecision = getPrecision;
        exports.getExponent = getExponent;
        exports.getRoot = getRoot;
        exports.solveCubicEquation = solveCubicEquation;
        exports.trunc = trunc
    },
    /*!*******************************************!*\
      !*** ./artifacts/transpiled/ui/themes.js ***!
      \*******************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../core/renderer */ 2);
        var domAdapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var windowUtils = __webpack_require__( /*! ../core/utils/window */ 7);
        var window = windowUtils.getWindow();
        var Deferred = __webpack_require__( /*! ../core/utils/deferred */ 6).Deferred;
        var errors = __webpack_require__( /*! ./widget/ui.errors */ 18);
        var domUtils = __webpack_require__( /*! ../core/utils/dom */ 11);
        var readyCallbacks = __webpack_require__( /*! ../core/utils/ready_callbacks */ 51);
        var ready = readyCallbacks.add;
        var each = __webpack_require__( /*! ../core/utils/iterator */ 4).each;
        var devices = __webpack_require__( /*! ../core/devices */ 15);
        var viewPortUtils = __webpack_require__( /*! ../core/utils/view_port */ 76);
        var themeReadyCallback = __webpack_require__( /*! ./themes_callback */ 286);
        var viewPort = viewPortUtils.value;
        var Promise = __webpack_require__( /*! ../core/polyfills/promise */ 67);
        var viewPortChanged = viewPortUtils.changeCallback;
        var DX_LINK_SELECTOR = "link[rel=dx-theme]";
        var THEME_ATTR = "data-theme";
        var ACTIVE_ATTR = "data-active";
        var DX_HAIRLINES_CLASS = "dx-hairlines";
        var context;
        var $activeThemeLink;
        var knownThemes;
        var currentThemeName;
        var pendingThemeName;
        var timerId;
        var THEME_MARKER_PREFIX = "dx.";

        function readThemeMarker() {
            if (!windowUtils.hasWindow()) {
                return null
            }
            var element = $("<div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
            var result;
            try {
                result = element.css("fontFamily");
                if (!result) {
                    return null
                }
                result = result.replace(/["']/g, "");
                if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
                    return null
                }
                return result.substr(THEME_MARKER_PREFIX.length)
            } finally {
                element.remove()
            }
        }

        function waitForThemeLoad(themeName) {
            var waitStartTime;
            pendingThemeName = themeName;

            function handleLoaded() {
                pendingThemeName = null;
                themeReadyCallback.fire();
                themeReadyCallback.empty()
            }
            if (isPendingThemeLoaded()) {
                handleLoaded()
            } else {
                waitStartTime = Date.now();
                timerId = setInterval(function() {
                    var isLoaded = isPendingThemeLoaded();
                    var isTimeout = !isLoaded && Date.now() - waitStartTime > 15e3;
                    if (isTimeout) {
                        errors.log("W0004", pendingThemeName)
                    }
                    if (isLoaded || isTimeout) {
                        clearInterval(timerId);
                        timerId = void 0;
                        handleLoaded()
                    }
                }, 10)
            }
        }

        function isPendingThemeLoaded() {
            return !pendingThemeName || readThemeMarker() === pendingThemeName
        }

        function processMarkup() {
            var $allThemeLinks = $(DX_LINK_SELECTOR, context);
            if (!$allThemeLinks.length) {
                return
            }
            knownThemes = {};
            $activeThemeLink = $(domUtils.createMarkupFromString("<link rel=stylesheet>"), context);
            $allThemeLinks.each(function() {
                var link = $(this, context);
                var fullThemeName = link.attr(THEME_ATTR);
                var url = link.attr("href");
                var isActive = "true" === link.attr(ACTIVE_ATTR);
                knownThemes[fullThemeName] = {
                    url: url,
                    isActive: isActive
                }
            });
            $allThemeLinks.last().after($activeThemeLink);
            $allThemeLinks.remove()
        }

        function resolveFullThemeName(desiredThemeName) {
            var desiredThemeParts = desiredThemeName ? desiredThemeName.split(".") : [];
            var result = null;
            if (knownThemes) {
                if (desiredThemeName in knownThemes) {
                    return desiredThemeName
                }
                each(knownThemes, function(knownThemeName, themeData) {
                    var knownThemeParts = knownThemeName.split(".");
                    if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
                        return
                    }
                    if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
                        return
                    }
                    if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
                        return
                    }
                    if (!result || themeData.isActive) {
                        result = knownThemeName
                    }
                    if (themeData.isActive) {
                        return false
                    }
                })
            }
            return result
        }

        function initContext(newContext) {
            try {
                if (newContext !== context) {
                    knownThemes = null
                }
            } catch (x) {
                knownThemes = null
            }
            context = newContext
        }

        function init(options) {
            options = options || {};
            initContext(options.context || domAdapter.getDocument());
            if (!context) {
                return
            }
            processMarkup();
            currentThemeName = void 0;
            current(options)
        }

        function current(options) {
            if (!arguments.length) {
                currentThemeName = currentThemeName || readThemeMarker();
                return currentThemeName
            }
            detachCssClasses(viewPort());
            options = options || {};
            if ("string" === typeof options) {
                options = {
                    theme: options
                }
            }
            var isAutoInit = options._autoInit;
            var loadCallback = options.loadCallback;
            var currentThemeData;
            currentThemeName = resolveFullThemeName(options.theme || currentThemeName);
            if (currentThemeName) {
                currentThemeData = knownThemes[currentThemeName]
            }
            if (loadCallback) {
                themeReadyCallback.add(loadCallback)
            }
            if (currentThemeData) {
                $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
                if ((themeReadyCallback.has() || options._forceTimeout) && !timerId) {
                    waitForThemeLoad(currentThemeName)
                } else {
                    if (pendingThemeName) {
                        pendingThemeName = currentThemeName
                    }
                }
            } else {
                if (isAutoInit) {
                    themeReadyCallback.fire();
                    themeReadyCallback.empty()
                } else {
                    throw errors.Error("E0021", currentThemeName)
                }
            }
            checkThemeDeprecation();
            attachCssClasses(viewPortUtils.originalViewPort(), currentThemeName)
        }

        function getCssClasses(themeName) {
            themeName = themeName || current();
            var result = [];
            var themeNameParts = themeName && themeName.split(".");
            if (themeNameParts) {
                result.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
                if (themeNameParts.length > 1) {
                    result.push("dx-color-scheme-" + themeNameParts[1] + (isMaterial(themeName) ? "-" + themeNameParts[2] : ""))
                }
            }
            return result
        }
        var themeClasses;

        function attachCssClasses(element, themeName) {
            themeClasses = getCssClasses(themeName).join(" ");
            $(element).addClass(themeClasses);
            var activateHairlines = function() {
                var pixelRatio = windowUtils.hasWindow() && window.devicePixelRatio;
                if (!pixelRatio || pixelRatio < 2) {
                    return
                }
                var $tester = $("<div>");
                $tester.css("border", ".5px solid transparent");
                $("body").append($tester);
                if (1 === $tester.outerHeight()) {
                    $(element).addClass(DX_HAIRLINES_CLASS);
                    themeClasses += " " + DX_HAIRLINES_CLASS
                }
                $tester.remove()
            };
            activateHairlines()
        }

        function detachCssClasses(element) {
            $(element).removeClass(themeClasses)
        }

        function themeReady(callback) {
            themeReadyCallback.add(callback)
        }

        function isTheme(themeRegExp, themeName) {
            if (!themeName) {
                themeName = currentThemeName || readThemeMarker()
            }
            return new RegExp(themeRegExp).test(themeName)
        }

        function isMaterial(themeName) {
            return isTheme("material", themeName)
        }

        function isIos7(themeName) {
            return isTheme("ios7", themeName)
        }

        function isGeneric(themeName) {
            return isTheme("generic", themeName)
        }

        function isDark(themeName) {
            return isTheme("dark", themeName)
        }

        function checkThemeDeprecation() {
            if (isIos7()) {
                errors.log("W0010", "The 'ios7' theme", "19.1", "Use the 'generic' theme instead.")
            }
        }

        function isWebFontLoaded(text, fontWeight) {
            var testedFont = "Roboto, RobotoFallback, Arial";
            var etalonFont = "Arial";
            var document = domAdapter.getDocument();
            var testElement = document.createElement("span");
            testElement.style.position = "absolute";
            testElement.style.top = "-9999px";
            testElement.style.left = "-9999px";
            testElement.style.visibility = "hidden";
            testElement.style.fontFamily = etalonFont;
            testElement.style.fontSize = "250px";
            testElement.style.fontWeight = fontWeight;
            testElement.innerHTML = text;
            document.body.appendChild(testElement);
            var etalonFontWidth = testElement.offsetWidth;
            testElement.style.fontFamily = testedFont;
            var testedFontWidth = testElement.offsetWidth;
            testElement.parentNode.removeChild(testElement);
            return etalonFontWidth !== testedFontWidth
        }

        function waitWebFont(text, fontWeight) {
            var interval = 15;
            var timeout = 2e3;
            return new Promise(function(resolve) {
                var check = function() {
                    if (isWebFontLoaded(text, fontWeight)) {
                        clear()
                    }
                };
                var clear = function() {
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    resolve()
                };
                var intervalId = setInterval(check, interval);
                var timeoutId = setTimeout(clear, timeout)
            })
        }
        var initDeferred = new Deferred;

        function autoInit() {
            init({
                _autoInit: true,
                _forceTimeout: true
            });
            if ($(DX_LINK_SELECTOR, context).length) {
                throw errors.Error("E0022")
            }
            initDeferred.resolve()
        }
        if (windowUtils.hasWindow()) {
            autoInit()
        } else {
            ready(autoInit)
        }
        viewPortChanged.add(function(viewPort, prevViewPort) {
            initDeferred.done(function() {
                detachCssClasses(prevViewPort);
                attachCssClasses(viewPort)
            })
        });
        devices.changed.add(function() {
            init({
                _autoInit: true
            })
        });
        exports.current = current;
        exports.ready = themeReady;
        exports.init = init;
        exports.attachCssClasses = attachCssClasses;
        exports.detachCssClasses = detachCssClasses;
        exports.waitForThemeLoad = waitForThemeLoad;
        exports.isMaterial = isMaterial;
        exports.isIos7 = isIos7;
        exports.isGeneric = isGeneric;
        exports.isDark = isDark;
        exports.isWebFontLoaded = isWebFontLoaded;
        exports.waitWebFont = waitWebFont;
        exports.resetTheme = function() {
            $activeThemeLink && $activeThemeLink.attr("href", "about:blank");
            currentThemeName = null;
            pendingThemeName = null
        }
    }, ,
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/core/utils/inflector.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var map = __webpack_require__( /*! ./iterator */ 4).map;
        var _normalize = function(text) {
            if (void 0 === text || null === text) {
                return ""
            }
            return String(text)
        };
        var _upperCaseFirst = function(text) {
            return _normalize(text).charAt(0).toUpperCase() + text.substr(1)
        };
        var _chop = function(text) {
            return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/)
        };
        var dasherize = function(text) {
            return map(_chop(text), function(p) {
                return p.toLowerCase()
            }).join("-")
        };
        var underscore = function(text) {
            return dasherize(text).replace(/-/g, "_")
        };
        var camelize = function(text, upperFirst) {
            return map(_chop(text), function(p, i) {
                p = p.toLowerCase();
                if (upperFirst || i > 0) {
                    p = _upperCaseFirst(p)
                }
                return p
            }).join("")
        };
        var humanize = function(text) {
            return _upperCaseFirst(dasherize(text).replace(/-/g, " "))
        };
        var titleize = function(text) {
            return map(_chop(text), function(p) {
                return _upperCaseFirst(p.toLowerCase())
            }).join(" ")
        };
        var DIGIT_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
        var captionize = function(name) {
            var captionList = [];
            var i;
            var char;
            var isPrevCharNewWord = false;
            var isNewWord = false;
            for (i = 0; i < name.length; i++) {
                char = name.charAt(i);
                isNewWord = char === char.toUpperCase() && "-" !== char && ")" !== char && "/" !== char || char in DIGIT_CHARS;
                if ("_" === char || "." === char) {
                    char = " ";
                    isNewWord = true
                } else {
                    if (0 === i) {
                        char = char.toUpperCase();
                        isNewWord = true
                    } else {
                        if (!isPrevCharNewWord && isNewWord) {
                            if (captionList.length > 0) {
                                captionList.push(" ")
                            }
                        }
                    }
                }
                captionList.push(char);
                isPrevCharNewWord = isNewWord
            }
            return captionList.join("")
        };
        exports.dasherize = dasherize;
        exports.camelize = camelize;
        exports.humanize = humanize;
        exports.titleize = titleize;
        exports.underscore = underscore;
        exports.captionize = captionize
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/localization/date.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _dependency_injector = __webpack_require__( /*! ../core/utils/dependency_injector */ 56);
        var _dependency_injector2 = _interopRequireDefault(_dependency_injector);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _iterator2 = _interopRequireDefault(_iterator);
        var _array = __webpack_require__( /*! ../core/utils/array */ 14);
        var _errors = __webpack_require__( /*! ../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _date = __webpack_require__( /*! ./ldml/date.formatter */ 273);
        var _date2 = __webpack_require__( /*! ./ldml/date.format */ 215);
        var _date3 = __webpack_require__( /*! ./ldml/date.parser */ 217);
        var _default_date_names = __webpack_require__( /*! ./default_date_names */ 274);
        var _default_date_names2 = _interopRequireDefault(_default_date_names);
        var _first_day_of_week_data = __webpack_require__( /*! ./cldr-data/first_day_of_week_data */ 455);
        var _first_day_of_week_data2 = _interopRequireDefault(_first_day_of_week_data);
        var _core = __webpack_require__( /*! ./core */ 83);
        var _number = __webpack_require__( /*! ./number */ 49);
        var _number2 = _interopRequireDefault(_number);
        var _date4 = __webpack_require__( /*! ./intl/date */ 456);
        var _date5 = _interopRequireDefault(_date4);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var DEFAULT_DAY_OF_WEEK_INDEX = 0;
        var hasIntl = "undefined" !== typeof Intl;
        var FORMATS_TO_PATTERN_MAP = {
            shortdate: "M/d/y",
            shorttime: "h:mm a",
            longdate: "EEEE, MMMM d, y",
            longtime: "h:mm:ss a",
            monthandday: "MMMM d",
            monthandyear: "MMMM y",
            quarterandyear: "QQQ y",
            day: "d",
            year: "y",
            shortdateshorttime: "M/d/y, h:mm a",
            longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
            month: "LLLL",
            shortyear: "yy",
            dayofweek: "EEEE",
            quarter: "QQQ",
            hour: "HH",
            minute: "mm",
            second: "ss",
            millisecond: "SSS",
            "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
        };
        var possiblePartPatterns = {
            year: ["y", "yy", "yyyy"],
            day: ["d", "dd"],
            month: ["M", "MM", "MMM", "MMMM"],
            hours: ["H", "HH", "h", "hh", "ah"],
            minutes: ["m", "mm"],
            seconds: ["s", "ss"],
            milliseconds: ["S", "SS", "SSS"]
        };
        var dateLocalization = (0, _dependency_injector2.default)({
            engine: function() {
                return "base"
            },
            _getPatternByFormat: function(format) {
                return FORMATS_TO_PATTERN_MAP[format.toLowerCase()]
            },
            _expandPattern: function(pattern) {
                return this._getPatternByFormat(pattern) || pattern
            },
            formatUsesMonthName: function(format) {
                return this._expandPattern(format).indexOf("MMMM") !== -1
            },
            formatUsesDayName: function(format) {
                return this._expandPattern(format).indexOf("EEEE") !== -1
            },
            getFormatParts: function(format) {
                var pattern = this._getPatternByFormat(format) || format;
                var result = [];
                _iterator2.default.each(pattern.split(/\W+/), function(_, formatPart) {
                    _iterator2.default.each(possiblePartPatterns, function(partName, possiblePatterns) {
                        if ((0, _array.inArray)(formatPart, possiblePatterns) > -1) {
                            result.push(partName)
                        }
                    })
                });
                return result
            },
            getMonthNames: function(format) {
                return _default_date_names2.default.getMonthNames(format)
            },
            getDayNames: function(format) {
                return _default_date_names2.default.getDayNames(format)
            },
            getQuarterNames: function(format) {
                return _default_date_names2.default.getQuarterNames(format)
            },
            getPeriodNames: function(format) {
                return _default_date_names2.default.getPeriodNames(format)
            },
            getTimeSeparator: function() {
                return ":"
            },
            is24HourFormat: function(format) {
                var amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
                var pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
                var amTimeFormatted = this.format(amTime, format);
                var pmTimeFormatted = this.format(pmTime, format);
                for (var i = 0; i < amTimeFormatted.length; i++) {
                    if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
                        return !isNaN(parseInt(amTimeFormatted[i]))
                    }
                }
            },
            format: function(date, _format) {
                if (!date) {
                    return
                }
                if (!_format) {
                    return date
                }
                var formatter;
                if ("function" === typeof _format) {
                    formatter = _format
                } else {
                    if (_format.formatter) {
                        formatter = _format.formatter
                    } else {
                        _format = _format.type || _format;
                        if ((0, _type.isString)(_format)) {
                            _format = FORMATS_TO_PATTERN_MAP[_format.toLowerCase()] || _format;
                            return _number2.default.convertDigits((0, _date.getFormatter)(_format, this)(date))
                        }
                    }
                }
                if (!formatter) {
                    return
                }
                return formatter(date)
            },
            parse: function(text, format) {
                var that = this;
                var ldmlFormat;
                var formatter;
                if (!text) {
                    return
                }
                if (!format) {
                    return this.parse(text, "shortdate")
                }
                if (format.parser) {
                    return format.parser(text)
                }
                if ("string" === typeof format && !FORMATS_TO_PATTERN_MAP[format.toLowerCase()]) {
                    ldmlFormat = format
                } else {
                    formatter = function(value) {
                        var text = that.format(value, format);
                        return _number2.default.convertDigits(text, true)
                    };
                    try {
                        ldmlFormat = (0, _date2.getFormat)(formatter)
                    } catch (e) {}
                }
                if (ldmlFormat) {
                    text = _number2.default.convertDigits(text, true);
                    return (0, _date3.getParser)(ldmlFormat, this)(text)
                }
                _errors2.default.log("W0012");
                var result = new Date(text);
                if (!result || isNaN(result.getTime())) {
                    return
                }
                return result
            },
            firstDayOfWeekIndex: function() {
                var index = (0, _core.getValueByClosestLocale)(function(locale) {
                    return _first_day_of_week_data2.default[locale]
                });
                return void 0 === index ? DEFAULT_DAY_OF_WEEK_INDEX : index
            }
        });
        if (hasIntl) {
            dateLocalization.inject(_date5.default)
        }
        module.exports = dateLocalization
    },
    /*!*******************************************!*\
      !*** ./artifacts/transpiled/core/guid.js ***!
      \*******************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Class = __webpack_require__( /*! ./class */ 16);
        var Guid = Class.inherit({
            ctor: function(value) {
                if (value) {
                    value = String(value)
                }
                this._value = this._normalize(value || this._generate())
            },
            _normalize: function(value) {
                value = value.replace(/[^a-f0-9]/gi, "").toLowerCase();
                while (value.length < 32) {
                    value += "0"
                }
                return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join("-")
            },
            _generate: function() {
                var value = "";
                for (var i = 0; i < 32; i++) {
                    value += Math.round(15 * Math.random()).toString(16)
                }
                return value
            },
            toString: function() {
                return this._value
            },
            valueOf: function() {
                return this._value
            },
            toJSON: function() {
                return this._value
            }
        });
        module.exports = Guid
    }, ,
    /*!*********************************************!*\
      !*** ./artifacts/transpiled/data/errors.js ***!
      \*********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errorUtils = __webpack_require__( /*! ../core/utils/error */ 138);
        var coreErrors = __webpack_require__( /*! ../core/errors */ 22);
        var handlers = {};
        var errors = errorUtils(coreErrors.ERROR_MESSAGES, {
            E4000: "[DevExpress.data]: {0}",
            E4001: "Unknown aggregating function is detected: '{0}'",
            E4002: "Unsupported OData protocol version is used",
            E4003: "Unknown filter operation is used: {0}",
            E4004: "The thenby() method is called before the sortby() method",
            E4005: "Store requires a key expression for this operation",
            E4006: "ArrayStore 'data' option must be an array",
            E4007: "Compound keys cannot be auto-generated",
            E4008: "Attempt to insert an item with the a duplicated key",
            E4009: "Data item cannot be found",
            E4010: "CustomStore does not support creating queries",
            E4011: "Custom Store method is not implemented or is not a function: {0}",
            E4012: "Custom Store method returns an invalid value: {0}",
            E4013: "Local Store requires the 'name' configuration option is specified",
            E4014: "Unknown data type is specified for ODataStore: {0}",
            E4015: "Unknown entity name or alias is used: {0}",
            E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
            E4017: "Keys cannot be modified",
            E4018: "The server has returned a non-numeric value in a response to an item count request",
            E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
            E4020: "Unknown store type is detected: {0}",
            E4021: "The server response does not provide the totalCount value",
            E4022: "The server response does not provide the groupCount value",
            E4023: "Could not parse the following XML: {0}",
            E4024: "String function {0} cannot be used with the data field {1} of type {2}.",
            W4000: "Data returned from the server has an incorrect structure",
            W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
            W4002: "Data loading has failed for some cells due to the following error: {0}"
        });

        function handleError(error) {
            var id = "E4000";
            if (error && "__id" in error) {
                id = error.__id
            }
            errors.log(id, error)
        }
        var errorHandler = null;
        var _errorHandler = function(error) {
            handleError(error);
            if (handlers.errorHandler) {
                handlers.errorHandler(error)
            }
        };
        handlers = {
            errors: errors,
            errorHandler: errorHandler,
            _errorHandler: _errorHandler
        };
        module.exports = handlers
    }, ,
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/animation/fx.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var $ = __webpack_require__( /*! ../core/renderer */ 2);
        var window = __webpack_require__( /*! ../core/utils/window */ 7).getWindow();
        var eventsEngine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var errors = __webpack_require__( /*! ../core/errors */ 22);
        var getPublicElement = __webpack_require__( /*! ../core/utils/dom */ 11).getPublicElement;
        var extend = __webpack_require__( /*! ../core/utils/extend */ 0).extend;
        var typeUtils = __webpack_require__( /*! ../core/utils/type */ 1);
        var iteratorUtils = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var translator = __webpack_require__( /*! ./translator */ 28);
        var easing = __webpack_require__( /*! ./easing */ 281);
        var animationFrame = __webpack_require__( /*! ./frame */ 117);
        var support = __webpack_require__( /*! ../core/utils/support */ 46);
        var positionUtils = __webpack_require__( /*! ./position */ 74);
        var removeEvent = __webpack_require__( /*! ../core/remove_event */ 140);
        var eventUtils = __webpack_require__( /*! ../events/utils */ 8);
        var deferredUtils = __webpack_require__( /*! ../core/utils/deferred */ 6);
        var when = deferredUtils.when;
        var Deferred = deferredUtils.Deferred;
        var removeEventName = eventUtils.addNamespace(removeEvent, "dxFX");
        var isFunction = typeUtils.isFunction;
        var isPlainObject = typeUtils.isPlainObject;
        var noop = __webpack_require__( /*! ../core/utils/common */ 3).noop;
        var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
        var ANIM_DATA_KEY = "dxAnimData";
        var ANIM_QUEUE_KEY = "dxAnimQueue";
        var TRANSFORM_PROP = "transform";
        var TransitionAnimationStrategy = {
            initAnimation: function($element, config) {
                $element.css({
                    transitionProperty: "none"
                });
                if ("string" === typeof config.from) {
                    $element.addClass(config.from)
                } else {
                    setProps($element, config.from)
                }
                var that = this;
                var deferred = new Deferred;
                var cleanupWhen = config.cleanupWhen;
                config.transitionAnimation = {
                    deferred: deferred,
                    finish: function() {
                        that._finishTransition($element);
                        if (cleanupWhen) {
                            when(deferred, cleanupWhen).always(function() {
                                that._cleanup($element, config)
                            })
                        } else {
                            that._cleanup($element, config)
                        }
                        deferred.resolveWith($element, [config, $element])
                    }
                };
                this._completeAnimationCallback($element, config).done(function() {
                    config.transitionAnimation.finish()
                }).fail(function() {
                    deferred.rejectWith($element, [config, $element])
                });
                if (!config.duration) {
                    config.transitionAnimation.finish()
                }
                $element.css("transform")
            },
            animate: function($element, config) {
                this._startAnimation($element, config);
                return config.transitionAnimation.deferred.promise()
            },
            _completeAnimationCallback: function($element, config) {
                var that = this;
                var startTime = Date.now() + config.delay;
                var deferred = new Deferred;
                var transitionEndFired = new Deferred;
                var simulatedTransitionEndFired = new Deferred;
                var simulatedEndEventTimer;
                var transitionEndEventName = support.transitionEndEventName() + ".dxFX";
                config.transitionAnimation.cleanup = function() {
                    clearTimeout(simulatedEndEventTimer);
                    clearTimeout(waitForJSCompleteTimer);
                    eventsEngine.off($element, transitionEndEventName);
                    eventsEngine.off($element, removeEventName)
                };
                eventsEngine.one($element, transitionEndEventName, function() {
                    if (Date.now() - startTime >= config.duration) {
                        transitionEndFired.reject()
                    }
                });
                eventsEngine.off($element, removeEventName);
                eventsEngine.on($element, removeEventName, function() {
                    that.stop($element, config);
                    deferred.reject()
                });
                var waitForJSCompleteTimer = setTimeout(function() {
                    simulatedEndEventTimer = setTimeout(function() {
                        simulatedTransitionEndFired.reject()
                    }, config.duration + config.delay + fx._simulatedTransitionEndDelay);
                    when(transitionEndFired, simulatedTransitionEndFired).fail(function() {
                        deferred.resolve()
                    }.bind(this))
                });
                return deferred.promise()
            },
            _startAnimation: function($element, config) {
                $element.css({
                    transitionProperty: "all",
                    transitionDelay: config.delay + "ms",
                    transitionDuration: config.duration + "ms",
                    transitionTimingFunction: config.easing
                });
                if ("string" === typeof config.to) {
                    $element[0].className += " " + config.to
                } else {
                    if (config.to) {
                        setProps($element, config.to)
                    }
                }
            },
            _finishTransition: function($element) {
                $element.css("transition", "none")
            },
            _cleanup: function($element, config) {
                config.transitionAnimation.cleanup();
                if ("string" === typeof config.from) {
                    $element.removeClass(config.from);
                    $element.removeClass(config.to)
                }
            },
            stop: function($element, config, jumpToEnd) {
                if (!config) {
                    return
                }
                if (jumpToEnd) {
                    config.transitionAnimation.finish()
                } else {
                    if (isPlainObject(config.to)) {
                        iteratorUtils.each(config.to, function(key) {
                            $element.css(key, $element.css(key))
                        })
                    }
                    this._finishTransition($element);
                    this._cleanup($element, config)
                }
            }
        };
        var FrameAnimationStrategy = {
            initAnimation: function($element, config) {
                setProps($element, config.from)
            },
            animate: function($element, config) {
                var deferred = new Deferred;
                var that = this;
                if (!config) {
                    return deferred.reject().promise()
                }
                iteratorUtils.each(config.to, function(prop) {
                    if (void 0 === config.from[prop]) {
                        config.from[prop] = that._normalizeValue($element.css(prop))
                    }
                });
                if (config.to[TRANSFORM_PROP]) {
                    config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
                    config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP])
                }
                config.frameAnimation = {
                    to: config.to,
                    from: config.from,
                    currentValue: config.from,
                    easing: easing.convertTransitionTimingFuncToEasing(config.easing),
                    duration: config.duration,
                    startTime: (new Date).valueOf(),
                    finish: function() {
                        this.currentValue = this.to;
                        this.draw();
                        animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId);
                        deferred.resolve()
                    },
                    draw: function() {
                        if (config.draw) {
                            config.draw(this.currentValue);
                            return
                        }
                        var currentValue = extend({}, this.currentValue);
                        if (currentValue[TRANSFORM_PROP]) {
                            currentValue[TRANSFORM_PROP] = iteratorUtils.map(currentValue[TRANSFORM_PROP], function(value, prop) {
                                if ("translate" === prop) {
                                    return translator.getTranslateCss(value)
                                } else {
                                    if ("scale" === prop) {
                                        return "scale(" + value + ")"
                                    } else {
                                        if ("rotate" === prop.substr(0, prop.length - 1)) {
                                            return prop + "(" + value + "deg)"
                                        }
                                    }
                                }
                            }).join(" ")
                        }
                        $element.css(currentValue)
                    }
                };
                if (config.delay) {
                    config.frameAnimation.startTime += config.delay;
                    config.frameAnimation.delayTimeout = setTimeout(function() {
                        that._startAnimation($element, config)
                    }, config.delay)
                } else {
                    that._startAnimation($element, config)
                }
                return deferred.promise()
            },
            _startAnimation: function($element, config) {
                eventsEngine.off($element, removeEventName);
                eventsEngine.on($element, removeEventName, function() {
                    if (config.frameAnimation) {
                        animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId)
                    }
                });
                this._animationStep($element, config)
            },
            _parseTransform: function(transformString) {
                var result = {};
                iteratorUtils.each(transformString.match(/(\w|\d)+\([^)]*\)\s*/g), function(i, part) {
                    var translateData = translator.parseTranslate(part);
                    var scaleData = part.match(/scale\((.+?)\)/);
                    var rotateData = part.match(/(rotate.)\((.+)deg\)/);
                    if (translateData) {
                        result.translate = translateData
                    }
                    if (scaleData && scaleData[1]) {
                        result.scale = parseFloat(scaleData[1])
                    }
                    if (rotateData && rotateData[1]) {
                        result[rotateData[1]] = parseFloat(rotateData[2])
                    }
                });
                return result
            },
            stop: function($element, config, jumpToEnd) {
                var frameAnimation = config && config.frameAnimation;
                if (!frameAnimation) {
                    return
                }
                animationFrame.cancelAnimationFrame(frameAnimation.animationFrameId);
                clearTimeout(frameAnimation.delayTimeout);
                if (jumpToEnd) {
                    frameAnimation.finish()
                }
                delete config.frameAnimation
            },
            _animationStep: function($element, config) {
                var frameAnimation = config && config.frameAnimation;
                if (!frameAnimation) {
                    return
                }
                var now = (new Date).valueOf();
                if (now >= frameAnimation.startTime + frameAnimation.duration) {
                    frameAnimation.finish();
                    return
                }
                frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
                frameAnimation.draw();
                var that = this;
                frameAnimation.animationFrameId = animationFrame.requestAnimationFrame(function() {
                    that._animationStep($element, config)
                })
            },
            _calcStepValue: function(frameAnimation, currentDuration) {
                var calcValueRecursively = function calcValueRecursively(from, to) {
                    var result = Array.isArray(to) ? [] : {};
                    var calcEasedValue = function(propName) {
                        var x = currentDuration / frameAnimation.duration;
                        var t = currentDuration;
                        var b = 1 * from[propName];
                        var c = to[propName] - from[propName];
                        var d = frameAnimation.duration;
                        return easing.getEasing(frameAnimation.easing)(x, t, b, c, d)
                    };
                    iteratorUtils.each(to, function(propName, endPropValue) {
                        if ("string" === typeof endPropValue && false === parseFloat(endPropValue, 10)) {
                            return true
                        }
                        result[propName] = "object" === _typeof(endPropValue) ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
                    });
                    return result
                };
                return calcValueRecursively(frameAnimation.from, frameAnimation.to)
            },
            _normalizeValue: function(value) {
                var numericValue = parseFloat(value, 10);
                if (false === numericValue) {
                    return value
                }
                return numericValue
            }
        };
        var FallbackToNoAnimationStrategy = {
            initAnimation: function() {},
            animate: function() {
                return (new Deferred).resolve().promise()
            },
            stop: noop,
            isSynchronous: true
        };
        var getAnimationStrategy = function(config) {
            config = config || {};
            var animationStrategies = {
                transition: support.transition() ? TransitionAnimationStrategy : FrameAnimationStrategy,
                frame: FrameAnimationStrategy,
                noAnimation: FallbackToNoAnimationStrategy
            };
            var strategy = config.strategy || "transition";
            if ("css" === config.type && !support.transition()) {
                strategy = "noAnimation"
            }
            return animationStrategies[strategy]
        };
        var baseConfigValidator = function(config, animationType, validate, typeMessage) {
            iteratorUtils.each(["from", "to"], function() {
                if (!validate(config[this])) {
                    throw errors.Error("E0010", animationType, this, typeMessage)
                }
            })
        };
        var isObjectConfigValidator = function(config, animationType) {
            return baseConfigValidator(config, animationType, function(target) {
                return isPlainObject(target)
            }, "a plain object")
        };
        var isStringConfigValidator = function(config, animationType) {
            return baseConfigValidator(config, animationType, function(target) {
                return "string" === typeof target
            }, "a string")
        };
        var CustomAnimationConfigurator = {
            setup: function() {}
        };
        var CssAnimationConfigurator = {
            validateConfig: function(config) {
                isStringConfigValidator(config, "css")
            },
            setup: function() {}
        };
        var positionAliases = {
            top: {
                my: "bottom center",
                at: "top center"
            },
            bottom: {
                my: "top center",
                at: "bottom center"
            },
            right: {
                my: "left center",
                at: "right center"
            },
            left: {
                my: "right center",
                at: "left center"
            }
        };
        var SlideAnimationConfigurator = {
            validateConfig: function(config) {
                isObjectConfigValidator(config, "slide")
            },
            setup: function($element, config) {
                var location = translator.locate($element);
                if ("slide" !== config.type) {
                    var positioningConfig = "slideIn" === config.type ? config.from : config.to;
                    positioningConfig.position = extend({
                        of: window
                    }, positionAliases[config.direction]);
                    setupPosition($element, positioningConfig)
                }
                this._setUpConfig(location, config.from);
                this._setUpConfig(location, config.to);
                translator.clearCache($element)
            },
            _setUpConfig: function(location, config) {
                config.left = "left" in config ? config.left : "+=0";
                config.top = "top" in config ? config.top : "+=0";
                this._initNewPosition(location, config)
            },
            _initNewPosition: function(location, config) {
                var position = {
                    left: config.left,
                    top: config.top
                };
                delete config.left;
                delete config.top;
                var relativeValue = this._getRelativeValue(position.left);
                if (void 0 !== relativeValue) {
                    position.left = relativeValue + location.left
                } else {
                    config.left = 0
                }
                relativeValue = this._getRelativeValue(position.top);
                if (void 0 !== relativeValue) {
                    position.top = relativeValue + location.top
                } else {
                    config.top = 0
                }
                config[TRANSFORM_PROP] = translator.getTranslateCss({
                    x: position.left,
                    y: position.top
                })
            },
            _getRelativeValue: function(value) {
                var relativeValue;
                if ("string" === typeof value && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {
                    return parseInt(relativeValue[1] + "1") * relativeValue[2]
                }
            }
        };
        var FadeAnimationConfigurator = {
            setup: function($element, config) {
                var from = config.from;
                var fromOpacity = isPlainObject(from) ? config.skipElementInitialStyles ? 0 : $element.css("opacity") : String(from);
                var toOpacity;
                switch (config.type) {
                    case "fadeIn":
                        toOpacity = 1;
                        break;
                    case "fadeOut":
                        toOpacity = 0;
                        break;
                    default:
                        toOpacity = String(config.to)
                }
                config.from = {
                    visibility: "visible",
                    opacity: fromOpacity
                };
                config.to = {
                    opacity: toOpacity
                }
            }
        };
        var PopAnimationConfigurator = {
            validateConfig: function(config) {
                isObjectConfigValidator(config, "pop")
            },
            setup: function($element, config) {
                var from = config.from;
                var to = config.to;
                var fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity");
                var toOpacity = "opacity" in to ? to.opacity : 1;
                var fromScale = "scale" in from ? from.scale : 0;
                var toScale = "scale" in to ? to.scale : 1;
                config.from = {
                    opacity: fromOpacity
                };
                var translate = translator.getTranslate($element);
                config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
                config.to = {
                    opacity: toOpacity
                };
                config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale)
            },
            _getCssTransform: function(translate, scale) {
                return translator.getTranslateCss(translate) + "scale(" + scale + ")"
            }
        };
        var animationConfigurators = {
            custom: CustomAnimationConfigurator,
            slide: SlideAnimationConfigurator,
            slideIn: SlideAnimationConfigurator,
            slideOut: SlideAnimationConfigurator,
            fade: FadeAnimationConfigurator,
            fadeIn: FadeAnimationConfigurator,
            fadeOut: FadeAnimationConfigurator,
            pop: PopAnimationConfigurator,
            css: CssAnimationConfigurator
        };
        var getAnimationConfigurator = function(config) {
            var result = animationConfigurators[config.type];
            if (!result) {
                throw errors.Error("E0011", config.type)
            }
            return result
        };
        var defaultJSConfig = {
            type: "custom",
            from: {},
            to: {},
            duration: 400,
            start: noop,
            complete: noop,
            easing: "ease",
            delay: 0
        };
        var defaultCssConfig = {
            duration: 400,
            easing: "ease",
            delay: 0
        };

        function setupAnimationOnElement() {
            var animation = this;
            var $element = animation.element;
            var config = animation.config;
            setupPosition($element, config.from);
            setupPosition($element, config.to);
            animation.configurator.setup($element, config);
            $element.data(ANIM_DATA_KEY, animation);
            if (fx.off) {
                config.duration = 0;
                config.delay = 0
            }
            animation.strategy.initAnimation($element, config);
            if (config.start) {
                var element = getPublicElement($element);
                config.start.apply(this, [element, config])
            }
        }
        var onElementAnimationComplete = function(animation) {
            var $element = animation.element;
            var config = animation.config;
            $element.removeData(ANIM_DATA_KEY);
            if (config.complete) {
                var element = getPublicElement($element);
                config.complete.apply(this, [element, config])
            }
            animation.deferred.resolveWith(this, [$element, config])
        };
        var startAnimationOnElement = function() {
            var animation = this;
            var $element = animation.element;
            var config = animation.config;
            animation.isStarted = true;
            return animation.strategy.animate($element, config).done(function() {
                onElementAnimationComplete(animation)
            }).fail(function() {
                animation.deferred.rejectWith(this, [$element, config])
            })
        };
        var stopAnimationOnElement = function(jumpToEnd) {
            var animation = this;
            var $element = animation.element;
            var config = animation.config;
            clearTimeout(animation.startTimeout);
            if (!animation.isStarted) {
                animation.start()
            }
            animation.strategy.stop($element, config, jumpToEnd)
        };
        var scopedRemoveEvent = eventUtils.addNamespace(removeEvent, "dxFXStartAnimation");
        var subscribeToRemoveEvent = function(animation) {
            eventsEngine.off(animation.element, scopedRemoveEvent);
            eventsEngine.on(animation.element, scopedRemoveEvent, function() {
                fx.stop(animation.element)
            });
            animation.deferred.always(function() {
                eventsEngine.off(animation.element, scopedRemoveEvent)
            })
        };
        var createAnimation = function(element, initialConfig) {
            var defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig;
            var config = extend(true, {}, defaultConfig, initialConfig);
            var configurator = getAnimationConfigurator(config);
            var strategy = getAnimationStrategy(config);
            var animation = {
                element: $(element),
                config: config,
                configurator: configurator,
                strategy: strategy,
                isSynchronous: strategy.isSynchronous,
                setup: setupAnimationOnElement,
                start: startAnimationOnElement,
                stop: stopAnimationOnElement,
                deferred: new Deferred
            };
            if (isFunction(configurator.validateConfig)) {
                configurator.validateConfig(config)
            }
            subscribeToRemoveEvent(animation);
            return animation
        };
        var animate = function(element, config) {
            var $element = $(element);
            if (!$element.length) {
                return (new Deferred).resolve().promise()
            }
            var animation = createAnimation($element, config);
            pushInAnimationQueue($element, animation);
            return animation.deferred.promise()
        };

        function pushInAnimationQueue($element, animation) {
            var queueData = getAnimQueueData($element);
            writeAnimQueueData($element, queueData);
            queueData.push(animation);
            if (!isAnimating($element)) {
                shiftFromAnimationQueue($element, queueData)
            }
        }

        function getAnimQueueData($element) {
            return $element.data(ANIM_QUEUE_KEY) || []
        }

        function writeAnimQueueData($element, queueData) {
            $element.data(ANIM_QUEUE_KEY, queueData)
        }
        var destroyAnimQueueData = function($element) {
            $element.removeData(ANIM_QUEUE_KEY)
        };

        function isAnimating($element) {
            return !!$element.data(ANIM_DATA_KEY)
        }

        function shiftFromAnimationQueue($element, queueData) {
            queueData = getAnimQueueData($element);
            if (!queueData.length) {
                return
            }
            var animation = queueData.shift();
            if (0 === queueData.length) {
                destroyAnimQueueData($element)
            }
            executeAnimation(animation).done(function() {
                if (!isAnimating($element)) {
                    shiftFromAnimationQueue($element)
                }
            })
        }

        function executeAnimation(animation) {
            animation.setup();
            if (fx.off || animation.isSynchronous) {
                animation.start()
            } else {
                animation.startTimeout = setTimeout(function() {
                    animation.start()
                })
            }
            return animation.deferred.promise()
        }

        function setupPosition($element, config) {
            if (!config || !config.position) {
                return
            }
            var win = $(window);
            var left = 0;
            var top = 0;
            var position = positionUtils.calculate($element, config.position);
            var offset = $element.offset();
            var currentPosition = $element.position();
            if (currentPosition.top > offset.top) {
                top = win.scrollTop()
            }
            if (currentPosition.left > offset.left) {
                left = win.scrollLeft()
            }
            extend(config, {
                left: position.h.location - offset.left + currentPosition.left - left,
                top: position.v.location - offset.top + currentPosition.top - top
            });
            delete config.position
        }

        function setProps($element, props) {
            iteratorUtils.each(props, function(key, value) {
                try {
                    $element.css(key, typeUtils.isFunction(value) ? value() : value)
                } catch (e) {}
            })
        }
        var stop = function(element, jumpToEnd) {
            var $element = $(element);
            var queueData = getAnimQueueData($element);
            iteratorUtils.each(queueData, function(_, animation) {
                animation.config.delay = 0;
                animation.config.duration = 0;
                animation.isSynchronous = true
            });
            if (!isAnimating($element)) {
                shiftFromAnimationQueue($element, queueData)
            }
            var animation = $element.data(ANIM_DATA_KEY);
            if (animation) {
                animation.stop(jumpToEnd)
            }
            $element.removeData(ANIM_DATA_KEY);
            destroyAnimQueueData($element)
        };
        var fx = {
            off: false,
            animationTypes: animationConfigurators,
            animate: animate,
            createAnimation: createAnimation,
            isAnimating: isAnimating,
            stop: stop,
            _simulatedTransitionEndDelay: 100
        };
        module.exports = fx
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/element_data.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _weak_map = __webpack_require__( /*! ./polyfills/weak_map */ 184);
        var _weak_map2 = _interopRequireDefault(_weak_map);
        var _dom_adapter = __webpack_require__( /*! ./dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _events_engine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _memorized_callbacks = __webpack_require__( /*! ./memorized_callbacks */ 185);
        var _memorized_callbacks2 = _interopRequireDefault(_memorized_callbacks);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var dataMap = new _weak_map2.default;
        var strategy;
        var strategyChanging = new _memorized_callbacks2.default;
        var beforeCleanData = function() {};
        var afterCleanData = function() {};
        var setDataStrategy = exports.setDataStrategy = function(value) {
            strategyChanging.fire(value);
            strategy = value;
            var cleanData = strategy.cleanData;
            strategy.cleanData = function(nodes) {
                beforeCleanData(nodes);
                var result = cleanData.call(this, nodes);
                afterCleanData(nodes);
                return result
            }
        };
        setDataStrategy({
            data: function() {
                var element = arguments[0];
                var key = arguments[1];
                var value = arguments[2];
                if (!element) {
                    return
                }
                var elementData = dataMap.get(element);
                if (!elementData) {
                    elementData = {};
                    dataMap.set(element, elementData)
                }
                if (void 0 === key) {
                    return elementData
                }
                if (2 === arguments.length) {
                    return elementData[key]
                }
                elementData[key] = value;
                return value
            },
            removeData: function(element, key) {
                if (!element) {
                    return
                }
                if (void 0 === key) {
                    dataMap.delete(element)
                } else {
                    var elementData = dataMap.get(element);
                    if (elementData) {
                        delete elementData[key]
                    }
                }
            },
            cleanData: function(elements) {
                for (var i = 0; i < elements.length; i++) {
                    _events_engine2.default.off(elements[i]);
                    dataMap.delete(elements[i])
                }
            }
        });
        exports.setDataStrategy = setDataStrategy;
        exports.getDataStrategy = function() {
            return strategy
        };
        exports.data = function() {
            return strategy.data.apply(this, arguments)
        };
        exports.strategyChanging = strategyChanging;
        exports.beforeCleanData = function(callback) {
            beforeCleanData = callback
        };
        exports.afterCleanData = function(callback) {
            afterCleanData = callback
        };
        exports.cleanData = function(nodes) {
            return strategy.cleanData.call(this, nodes)
        };
        exports.removeData = function(element, key) {
            return strategy.removeData.call(this, element, key)
        };
        exports.cleanDataRecursive = function(element, cleanSelf) {
            if (!_dom_adapter2.default.isElementNode(element)) {
                return
            }
            var childElements = element.getElementsByTagName("*");
            strategy.cleanData(childElements);
            if (cleanSelf) {
                strategy.cleanData([element])
            }
        }
    },
    /*!********************************************!*\
      !*** ./artifacts/transpiled/data/utils.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _type2 = _interopRequireDefault(_type);
        var _dom_adapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _ready_callbacks = __webpack_require__( /*! ../core/utils/ready_callbacks */ 51);
        var _window = __webpack_require__( /*! ../core/utils/window */ 7);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _deferred = __webpack_require__( /*! ../core/utils/deferred */ 6);
        var _common = __webpack_require__( /*! ../core/utils/common */ 3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _toConsumableArray(arr) {
            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
        }

        function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) {
                return
            }
            if ("string" === typeof o) {
                return _arrayLikeToArray(o, minLen)
            }
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if ("Object" === n && o.constructor) {
                n = o.constructor.name
            }
            if ("Map" === n || "Set" === n) {
                return Array.from(o)
            }
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return _arrayLikeToArray(o, minLen)
            }
        }

        function _iterableToArray(iter) {
            if ("undefined" !== typeof Symbol && Symbol.iterator in Object(iter)) {
                return Array.from(iter)
            }
        }

        function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
                return _arrayLikeToArray(arr)
            }
        }

        function _arrayLikeToArray(arr, len) {
            if (null == len || len > arr.length) {
                len = arr.length
            }
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
            }
            return arr2
        }
        var XHR_ERROR_UNLOAD = "DEVEXTREME_XHR_ERROR_UNLOAD";
        var normalizeBinaryCriterion = function(crit) {
            return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]]
        };
        var normalizeSortingInfo = function(info) {
            if (!Array.isArray(info)) {
                info = [info]
            }
            return (0, _iterator.map)(info, function(i) {
                var result = {
                    selector: (0, _type.isFunction)(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
                    desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
                };
                if (i.compare) {
                    result.compare = i.compare
                }
                return result
            })
        };
        var errorMessageFromXhr = function() {
            var textStatusMessages = {
                timeout: "Network connection timeout",
                error: "Unspecified network error",
                parsererror: "Unexpected server response"
            };
            var textStatusDetails = {
                timeout: "possible causes: the remote host is not accessible, overloaded or is not included into the domain white-list when being run in the native container",
                error: "if the remote host is located on another domain, make sure it properly supports cross-origin resource sharing (CORS), or use the JSONP approach instead",
                parsererror: "the remote host did not respond with valid JSON data"
            };
            var explainTextStatus = function(textStatus) {
                var result = textStatusMessages[textStatus];
                if (!result) {
                    return textStatus
                }
                result += " (" + textStatusDetails[textStatus] + ")";
                return result
            };
            var unloading;
            (0, _ready_callbacks.add)(function() {
                var window = (0, _window.getWindow)();
                _dom_adapter2.default.listen(window, "beforeunload", function() {
                    unloading = true
                })
            });
            return function(xhr, textStatus) {
                if (unloading) {
                    return XHR_ERROR_UNLOAD
                }
                if (xhr.status < 400) {
                    return explainTextStatus(textStatus)
                }
                return xhr.statusText
            }
        }();
        var aggregators = {
            count: {
                seed: 0,
                step: function(count) {
                    return 1 + count
                }
            },
            sum: {
                seed: 0,
                step: function(sum, item) {
                    return sum + item
                }
            },
            min: {
                step: function(min, item) {
                    return item < min ? item : min
                }
            },
            max: {
                step: function(max, item) {
                    return item > max ? item : max
                }
            },
            avg: {
                seed: [0, 0],
                step: function(pair, value) {
                    return [pair[0] + value, pair[1] + 1]
                },
                finalize: function(pair) {
                    return pair[1] ? pair[0] / pair[1] : NaN
                }
            }
        };
        var processRequestResultLock = function() {
            var lockCount = 0;
            var lockDeferred;
            var obtain = function() {
                if (0 === lockCount) {
                    lockDeferred = new _deferred.Deferred
                }
                lockCount++
            };
            var release = function() {
                lockCount--;
                if (lockCount < 1) {
                    lockDeferred.resolve()
                }
            };
            var promise = function() {
                var deferred = 0 === lockCount ? (new _deferred.Deferred).resolve() : lockDeferred;
                return deferred.promise()
            };
            var reset = function() {
                lockCount = 0;
                if (lockDeferred) {
                    lockDeferred.resolve()
                }
            };
            return {
                obtain: obtain,
                release: release,
                promise: promise,
                reset: reset
            }
        }();

        function isDisjunctiveOperator(condition) {
            return /^(or|\|\||\|)$/i.test(condition)
        }

        function isConjunctiveOperator(condition) {
            return /^(and|&&|&)$/i.test(condition)
        }
        var keysEqual = function(keyExpr, key1, key2) {
            if (Array.isArray(keyExpr)) {
                var names = (0, _iterator.map)(key1, function(v, k) {
                    return k
                });
                var name;
                for (var i = 0; i < names.length; i++) {
                    name = names[i];
                    if (!(0, _common.equalByValue)(key1[name], key2[name], 0, false)) {
                        return false
                    }
                }
                return true
            }
            return (0, _common.equalByValue)(key1, key2, 0, false)
        };
        var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var base64_encode = function(input) {
            if (!Array.isArray(input)) {
                input = stringToByteArray(String(input))
            }
            var result = "";

            function getBase64Char(index) {
                return BASE64_CHARS.charAt(index)
            }
            for (var i = 0; i < input.length; i += 3) {
                var octet1 = input[i];
                var octet2 = input[i + 1];
                var octet3 = input[i + 2];
                result += (0, _iterator.map)([octet1 >> 2, (3 & octet1) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (15 & octet2) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : 63 & octet3], getBase64Char).join("")
            }
            return result
        };

        function stringToByteArray(str) {
            var bytes = [];
            var code;
            var i;
            for (i = 0; i < str.length; i++) {
                code = str.charCodeAt(i);
                if (code < 128) {
                    bytes.push(code)
                } else {
                    if (code < 2048) {
                        bytes.push(192 + (code >> 6), 128 + (63 & code))
                    } else {
                        if (code < 65536) {
                            bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (63 & code))
                        } else {
                            if (code < 2097152) {
                                bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (63 & code))
                            }
                        }
                    }
                }
            }
            return bytes
        }
        var isUnaryOperation = function(crit) {
            return "!" === crit[0] && Array.isArray(crit[1])
        };
        var isGroupOperator = function(value) {
            return "and" === value || "or" === value
        };
        var isGroupCriterion = function(crit) {
            var first = crit[0];
            var second = crit[1];
            if (Array.isArray(first)) {
                return true
            }
            if (_type2.default.isFunction(first)) {
                if (Array.isArray(second) || _type2.default.isFunction(second) || isGroupOperator(second)) {
                    return true
                }
            }
            return false
        };
        var trivialPromise = function() {
            var d = new _deferred.Deferred;
            return d.resolve.apply(d, arguments).promise()
        };
        var rejectedPromise = function() {
            var d = new _deferred.Deferred;
            return d.reject.apply(d, arguments).promise()
        };

        function throttle(func, timeout) {
            var timeoutId;
            var lastArgs;
            return function() {
                var _this = this;
                lastArgs = arguments;
                if (!timeoutId) {
                    timeoutId = setTimeout(function() {
                        timeoutId = void 0;
                        if (lastArgs) {
                            func.call(_this, lastArgs)
                        }
                    }, (0, _type.isFunction)(timeout) ? timeout() : timeout)
                }
                return timeoutId
            }
        }

        function throttleChanges(func, timeout) {
            var cache = [];
            var throttled = throttle(function() {
                func.call(this, cache);
                cache = []
            }, timeout);
            return function(changes) {
                if (Array.isArray(changes)) {
                    var _cache;
                    (_cache = cache).push.apply(_cache, _toConsumableArray(changes))
                }
                return throttled.call(this, cache)
            }
        }
        var utils = {
            XHR_ERROR_UNLOAD: XHR_ERROR_UNLOAD,
            normalizeBinaryCriterion: normalizeBinaryCriterion,
            normalizeSortingInfo: normalizeSortingInfo,
            errorMessageFromXhr: errorMessageFromXhr,
            aggregators: aggregators,
            keysEqual: keysEqual,
            throttleChanges: throttleChanges,
            trivialPromise: trivialPromise,
            rejectedPromise: rejectedPromise,
            isDisjunctiveOperator: isDisjunctiveOperator,
            isConjunctiveOperator: isConjunctiveOperator,
            processRequestResultLock: processRequestResultLock,
            isUnaryOperation: isUnaryOperation,
            isGroupCriterion: isGroupCriterion,
            base64_encode: base64_encode
        };
        module.exports = utils
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/utils/string.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var typeUtils = __webpack_require__( /*! ./type */ 1);
        var encodeHtml = function() {
            var encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
            return function(str) {
                return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;")
            }
        }();
        var splitQuad = function(raw) {
            switch (_typeof(raw)) {
                case "string":
                    return raw.split(/\s+/, 4);
                case "object":
                    return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
                case "number":
                    return [raw];
                default:
                    return raw
            }
        };
        var quadToObject = function(raw) {
            var quad = splitQuad(raw);
            var left = parseInt(quad && quad[0], 10);
            var top = parseInt(quad && quad[1], 10);
            var right = parseInt(quad && quad[2], 10);
            var bottom = parseInt(quad && quad[3], 10);
            if (!isFinite(left)) {
                left = 0
            }
            if (!isFinite(top)) {
                top = left
            }
            if (!isFinite(right)) {
                right = left
            }
            if (!isFinite(bottom)) {
                bottom = top
            }
            return {
                top: top,
                right: right,
                bottom: bottom,
                left: left
            }
        };
        var stringFormat = function() {
            var s = arguments[0];
            var values = [].slice.call(arguments).slice(1);
            var replaceDollarCount;
            var reg;
            var value;
            if (typeUtils.isFunction(s)) {
                return s.apply(this, values)
            }
            for (var i = 0; i < values.length; i++) {
                reg = new RegExp("\\{" + i + "\\}", "gm");
                value = values[i];
                if ("string" === typeUtils.type(value) && value.indexOf("$") >= 0) {
                    replaceDollarCount = "$".replace("$", "$$").length;
                    value = value.replace("$", 1 === replaceDollarCount ? "$$$$" : "$$")
                }
                s = s.replace(reg, value)
            }
            return s
        };
        var replaceAll = function() {
            var quote = function(str) {
                return (str + "").replace(/([+*?.[^\]$(){}><|=!:])/g, "\\$1")
            };
            return function(text, searchToken, replacementToken) {
                return text.replace(new RegExp("(" + quote(searchToken) + ")", "gi"), replacementToken)
            }
        }();
        var isEmpty = function() {
            var SPACE_REGEXP = /\s/g;
            return function(text) {
                return !text || !text.replace(SPACE_REGEXP, "")
            }
        }();
        exports.encodeHtml = encodeHtml;
        exports.quadToObject = quadToObject;
        exports.format = stringFormat;
        exports.replaceAll = replaceAll;
        exports.isEmpty = isEmpty
    }, ,
    /*!********************************************!*\
      !*** ./artifacts/transpiled/data/query.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var arrayQueryImpl = __webpack_require__( /*! ./array_query */ 161);
        var remoteQueryImpl = __webpack_require__( /*! ./remote_query */ 497);
        var queryImpl = {
            array: arrayQueryImpl,
            remote: remoteQueryImpl
        };
        var query = function() {
            var impl = Array.isArray(arguments[0]) ? "array" : "remote";
            return queryImpl[impl].apply(this, arguments)
        };
        module.exports = query;
        module.exports.queryImpl = queryImpl
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/utils/support.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _array = __webpack_require__( /*! ./array */ 14);
        var _dom_adapter = __webpack_require__( /*! ../dom_adapter */ 12);
        var _common = __webpack_require__( /*! ./common */ 3);
        var _call_once = __webpack_require__( /*! ./call_once */ 80);
        var _call_once2 = _interopRequireDefault(_call_once);
        var _window = __webpack_require__( /*! ./window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _devices = __webpack_require__( /*! ../devices */ 15);
        var _devices2 = _interopRequireDefault(_devices);
        var _style = __webpack_require__( /*! ./style */ 93);
        var _style2 = _interopRequireDefault(_style);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _windowUtils$getNavig = _window2.default.getNavigator(),
            maxTouchPoints = _windowUtils$getNavig.maxTouchPoints,
            msMaxTouchPoints = _windowUtils$getNavig.msMaxTouchPoints,
            pointerEnabled = _windowUtils$getNavig.pointerEnabled;
        var hasProperty = _window2.default.hasProperty.bind(_window2.default);
        var transitionEndEventNames = {
            webkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd",
            msTransition: "MsTransitionEnd",
            transition: "transitionend"
        };
        var supportProp = function(prop) {
            return !!_style2.default.styleProp(prop)
        };
        var isNativeScrollingSupported = function() {
            var _devices$real = _devices2.default.real(),
                platform = _devices$real.platform,
                version = _devices$real.version,
                isMac = _devices$real.mac;
            var isObsoleteAndroid = version && version[0] < 4 && "android" === platform;
            var isNativeScrollDevice = !isObsoleteAndroid && (0, _array.inArray)(platform, ["ios", "android"]) > -1 || isMac;
            return isNativeScrollDevice
        };
        var inputType = function(type) {
            if ("text" === type) {
                return true
            }
            var input = (0, _dom_adapter.createElement)("input");
            try {
                input.setAttribute("type", type);
                input.value = "wrongValue";
                return !input.value
            } catch (e) {
                return false
            }
        };
        var detectTouchEvents = function(hasWindowProperty, maxTouchPoints) {
            return (hasWindowProperty("ontouchstart") || !!maxTouchPoints) && !hasWindowProperty("callPhantom")
        };
        var detectPointerEvent = function(hasWindowProperty, pointerEnabled) {
            var isPointerEnabled = (0, _common.ensureDefined)(pointerEnabled, true);
            var canUsePointerEvent = (0, _common.ensureDefined)(pointerEnabled, false);
            return hasWindowProperty("PointerEvent") && isPointerEnabled || canUsePointerEvent
        };
        var touchEvents = detectTouchEvents(hasProperty, maxTouchPoints);
        var pointerEvents = detectPointerEvent(hasProperty, pointerEnabled);
        var touchPointersPresent = !!maxTouchPoints || !!msMaxTouchPoints;
        exports.detectTouchEvents = detectTouchEvents;
        exports.detectPointerEvent = detectPointerEvent;
        exports.touchEvents = touchEvents;
        exports.pointerEvents = pointerEvents;
        exports.touch = touchEvents || pointerEvents && touchPointersPresent;
        exports.transition = (0, _call_once2.default)(function() {
            return supportProp("transition")
        });
        exports.transitionEndEventName = (0, _call_once2.default)(function() {
            return transitionEndEventNames[_style2.default.styleProp("transition")]
        });
        exports.animation = (0, _call_once2.default)(function() {
            return supportProp("animation")
        });
        exports.nativeScrolling = isNativeScrollingSupported();
        exports.styleProp = _style2.default.styleProp;
        exports.stylePropPrefix = _style2.default.stylePropPrefix;
        exports.supportProp = supportProp;
        exports.inputType = inputType
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/utils/object.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var typeUtils = __webpack_require__( /*! ./type */ 1);
        var variableWrapper = __webpack_require__( /*! ./variable_wrapper */ 94);
        var clone = function() {
            function Clone() {}
            return function(obj) {
                Clone.prototype = obj;
                return new Clone
            }
        }();
        var orderEach = function(map, func) {
            var keys = [];
            var key;
            var i;
            for (key in map) {
                if (Object.prototype.hasOwnProperty.call(map, key)) {
                    keys.push(key)
                }
            }
            keys.sort(function(x, y) {
                var isNumberX = typeUtils.isNumeric(x);
                var isNumberY = typeUtils.isNumeric(y);
                if (isNumberX && isNumberY) {
                    return x - y
                }
                if (isNumberX && !isNumberY) {
                    return -1
                }
                if (!isNumberX && isNumberY) {
                    return 1
                }
                if (x < y) {
                    return -1
                }
                if (x > y) {
                    return 1
                }
                return 0
            });
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                func(key, map[key])
            }
        };
        var assignValueToProperty = function(target, property, value, assignByReference) {
            if (!assignByReference && variableWrapper.isWrapped(target[property])) {
                variableWrapper.assign(target[property], value)
            } else {
                target[property] = value
            }
        };
        var deepExtendArraySafe = function deepExtendArraySafe(target, changes, extendComplexObject, assignByReference) {
            var prevValue;
            var newValue;
            for (var name in changes) {
                prevValue = target[name];
                newValue = changes[name];
                if ("__proto__" === name || target === newValue) {
                    continue
                }
                if (typeUtils.isPlainObject(newValue)) {
                    var goDeeper = extendComplexObject ? typeUtils.isObject(prevValue) : typeUtils.isPlainObject(prevValue);
                    newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference)
                }
                if (void 0 !== newValue && prevValue !== newValue) {
                    assignValueToProperty(target, name, newValue, assignByReference)
                }
            }
            return target
        };
        exports.clone = clone;
        exports.orderEach = orderEach;
        exports.deepExtendArraySafe = deepExtendArraySafe
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/ui/editor/editor.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _element_data = __webpack_require__( /*! ../../core/element_data */ 41);
        var _element_data2 = _interopRequireDefault(_element_data);
        var _callbacks = __webpack_require__( /*! ../../core/utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);
        var _window = __webpack_require__( /*! ../../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _utils = __webpack_require__( /*! ../../events/utils */ 8);
        var _position = __webpack_require__( /*! ../../core/utils/position */ 21);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _guid = __webpack_require__( /*! ../../core/guid */ 36);
        var _guid2 = _interopRequireDefault(_guid);
        var _ui = __webpack_require__( /*! ../widget/ui.widget */ 17);
        var _ui2 = _interopRequireDefault(_ui);
        var _overlay = __webpack_require__( /*! ../overlay */ 58);
        var _overlay2 = _interopRequireDefault(_overlay);
        var _validation_engine = __webpack_require__( /*! ../validation_engine */ 92);
        var _validation_engine2 = _interopRequireDefault(_validation_engine);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _string = __webpack_require__( /*! ../../core/utils/string */ 43);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var READONLY_STATE_CLASS = "dx-state-readonly";
        var INVALID_CLASS = "dx-invalid";
        var INVALID_MESSAGE = "dx-invalid-message";
        var INVALID_MESSAGE_CONTENT = "dx-invalid-message-content";
        var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
        var INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
        var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
        var VALIDATION_TARGET = "dx-validation-target";
        var VALIDATION_MESSAGE_MIN_WIDTH = 100;
        var VALIDATION_STATUS_VALID = "valid";
        var VALIDATION_STATUS_INVALID = "invalid";
        var READONLY_NAMESPACE = "editorReadOnly";
        var getValidationErrorMessage = function(validationErrors) {
            var validationErrorMessage = "";
            if (validationErrors) {
                validationErrors.forEach(function(err) {
                    if (err.message) {
                        validationErrorMessage += (validationErrorMessage ? "<br />" : "") + (0, _string.encodeHtml)(err.message)
                    }
                })
            }
            return validationErrorMessage
        };
        var Editor = _ui2.default.inherit({
            ctor: function() {
                this.showValidationMessageTimeout = null;
                this.validationRequest = (0, _callbacks2.default)();
                this.callBase.apply(this, arguments)
            },
            _createElement: function(element) {
                this.callBase(element);
                var $element = this.$element();
                if ($element) {
                    _element_data2.default.data($element[0], VALIDATION_TARGET, this)
                }
            },
            _initOptions: function(options) {
                this.callBase.apply(this, arguments);
                this.option(_validation_engine2.default.initValidationOptions(options))
            },
            _init: function() {
                this.callBase();
                this._options.cache("validationTooltipOptions", this.option("validationTooltipOptions"));
                var $element = this.$element();
                $element.addClass(DX_INVALID_BADGE_CLASS)
            },
            _getDefaultOptions: function() {
                return (0, _extend.extend)(this.callBase(), {
                    value: null,
                    name: "",
                    onValueChanged: null,
                    readOnly: false,
                    isValid: true,
                    validationError: null,
                    validationErrors: null,
                    validationStatus: VALIDATION_STATUS_VALID,
                    validationMessageMode: "auto",
                    validationBoundary: void 0,
                    validationMessageOffset: {
                        h: 0,
                        v: 0
                    },
                    validationTooltipOptions: {}
                })
            },
            _attachKeyboardEvents: function() {
                if (!this.option("readOnly")) {
                    this.callBase()
                }
            },
            _setOptionsByReference: function() {
                this.callBase();
                (0, _extend.extend)(this._optionsByReference, {
                    validationError: true
                })
            },
            _createValueChangeAction: function() {
                this._valueChangeAction = this._createActionByOption("onValueChanged", {
                    excludeValidators: ["disabled", "readOnly"]
                })
            },
            _suppressValueChangeAction: function() {
                this._valueChangeActionSuppressed = true
            },
            _resumeValueChangeAction: function() {
                this._valueChangeActionSuppressed = false
            },
            _initMarkup: function() {
                this._toggleReadOnlyState();
                this._setSubmitElementName(this.option("name"));
                this.callBase();
                this._renderValidationState()
            },
            _raiseValueChangeAction: function(value, previousValue) {
                if (!this._valueChangeAction) {
                    this._createValueChangeAction()
                }
                this._valueChangeAction(this._valueChangeArgs(value, previousValue))
            },
            _valueChangeArgs: function(value, previousValue) {
                return {
                    value: value,
                    previousValue: previousValue,
                    event: this._valueChangeEventInstance
                }
            },
            _saveValueChangeEvent: function(e) {
                this._valueChangeEventInstance = e
            },
            _focusInHandler: function(e) {
                var _this = this;
                var isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
                if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
                    this._$validationMessage && this._$validationMessage.removeClass(INVALID_MESSAGE_AUTO);
                    clearTimeout(this.showValidationMessageTimeout);
                    this.showValidationMessageTimeout = setTimeout(function() {
                        return _this._$validationMessage && _this._$validationMessage.addClass(INVALID_MESSAGE_AUTO)
                    }, 150)
                }
                return this.callBase(e)
            },
            _canValueBeChangedByClick: function() {
                return false
            },
            _renderValidationState: function() {
                var isValid = this.option("isValid") && this.option("validationStatus") !== VALIDATION_STATUS_INVALID;
                var validationMessageMode = this.option("validationMessageMode");
                var $element = this.$element();
                var validationErrors = this.option("validationErrors");
                if (!validationErrors && this.option("validationError")) {
                    validationErrors = [this.option("validationError")]
                }
                $element.toggleClass(INVALID_CLASS, !isValid);
                this.setAria(VALIDATION_STATUS_INVALID, !isValid || void 0);
                if (!_window2.default.hasWindow()) {
                    return
                }
                if (this._$validationMessage) {
                    this._$validationMessage.remove();
                    this.setAria("describedby", null);
                    this._$validationMessage = null
                }
                var validationErrorMessage = getValidationErrorMessage(validationErrors);
                if (!isValid && validationErrorMessage) {
                    this._$validationMessage = (0, _renderer2.default)("<div>").addClass(INVALID_MESSAGE).html(validationErrorMessage).appendTo($element);
                    var validationTarget = this._getValidationMessageTarget();
                    this._validationMessage = this._createComponent(this._$validationMessage, _overlay2.default, (0, _extend.extend)({
                        integrationOptions: {},
                        templatesRenderAsynchronously: false,
                        target: validationTarget,
                        shading: false,
                        width: "auto",
                        height: "auto",
                        container: $element,
                        position: this._getValidationMessagePosition("below"),
                        closeOnOutsideClick: false,
                        closeOnTargetScroll: false,
                        animation: null,
                        visible: true,
                        propagateOutsideClick: true,
                        _checkParentVisibility: false
                    }, this._options.cache("validationTooltipOptions")));
                    this._$validationMessage.toggleClass(INVALID_MESSAGE_AUTO, "auto" === validationMessageMode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === validationMessageMode);
                    var messageId = "dx-" + new _guid2.default;
                    this._validationMessage.$content().addClass(INVALID_MESSAGE_CONTENT).attr("id", messageId);
                    this.setAria("describedby", messageId);
                    this._setValidationMessageMaxWidth();
                    this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions")
                }
            },
            _setValidationMessageMaxWidth: function() {
                if (!this._validationMessage) {
                    return
                }
                if (0 === this._getValidationMessageTarget().outerWidth()) {
                    this._validationMessage.option("maxWidth", "100%");
                    return
                }
                var validationMessageMaxWidth = Math.max(VALIDATION_MESSAGE_MIN_WIDTH, this._getValidationMessageTarget().outerWidth());
                this._validationMessage.option("maxWidth", validationMessageMaxWidth)
            },
            _getValidationMessageTarget: function() {
                return this.$element()
            },
            _getValidationMessagePosition: function(positionRequest) {
                var rtlEnabled = this.option("rtlEnabled");
                var messagePositionSide = (0, _position.getDefaultAlignment)(rtlEnabled);
                var messageOriginalOffset = this.option("validationMessageOffset");
                var messageOffset = {
                    h: messageOriginalOffset.h,
                    v: messageOriginalOffset.v
                };
                var verticalPositions = "below" === positionRequest ? [" top", " bottom"] : [" bottom", " top"];
                if (rtlEnabled) {
                    messageOffset.h = -messageOffset.h
                }
                if ("below" !== positionRequest) {
                    messageOffset.v = -messageOffset.v
                }
                return {
                    offset: messageOffset,
                    boundary: this.option("validationBoundary"),
                    my: messagePositionSide + verticalPositions[0],
                    at: messagePositionSide + verticalPositions[1],
                    collision: "none flip"
                }
            },
            _toggleReadOnlyState: function() {
                var readOnly = this.option("readOnly");
                this._toggleBackspaceHandler(readOnly);
                this.$element().toggleClass(READONLY_STATE_CLASS, !!readOnly);
                this.setAria("readonly", readOnly || void 0)
            },
            _toggleBackspaceHandler: function(isReadOnly) {
                var $eventTarget = this._keyboardEventBindingTarget();
                var eventName = (0, _utils.addNamespace)("keydown", READONLY_NAMESPACE);
                _events_engine2.default.off($eventTarget, eventName);
                if (isReadOnly) {
                    _events_engine2.default.on($eventTarget, eventName, function(e) {
                        if ("backspace" === (0, _utils.normalizeKeyName)(e)) {
                            e.preventDefault()
                        }
                    })
                }
            },
            _dispose: function() {
                var element = this.$element()[0];
                _element_data2.default.data(element, VALIDATION_TARGET, null);
                clearTimeout(this.showValidationMessageTimeout);
                this.callBase()
            },
            _setSubmitElementName: function(name) {
                var $submitElement = this._getSubmitElement();
                if (!$submitElement) {
                    return
                }
                if (name.length > 0) {
                    $submitElement.attr("name", name)
                } else {
                    $submitElement.removeAttr("name")
                }
            },
            _getSubmitElement: function() {
                return null
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case "onValueChanged":
                        this._createValueChangeAction();
                        break;
                    case "isValid":
                    case "validationError":
                        this.option(_validation_engine2.default.synchronizeValidationOptions(args, this.option()));
                        break;
                    case "validationErrors":
                    case "validationStatus":
                        this.option(_validation_engine2.default.synchronizeValidationOptions(args, this.option()));
                        this._renderValidationState();
                        break;
                    case "validationBoundary":
                    case "validationMessageMode":
                        this._renderValidationState();
                        break;
                    case "validationTooltipOptions":
                        this._innerWidgetOptionChanged(this._validationMessage, args);
                        break;
                    case "readOnly":
                        this._toggleReadOnlyState();
                        this._refreshFocusState();
                        break;
                    case "value":
                        if (args.value != args.previousValue) {
                            this.validationRequest.fire({
                                value: args.value,
                                editor: this
                            })
                        }
                        if (!this._valueChangeActionSuppressed) {
                            this._raiseValueChangeAction(args.value, args.previousValue);
                            this._saveValueChangeEvent(void 0)
                        }
                        break;
                    case "width":
                        this.callBase(args);
                        this._setValidationMessageMaxWidth();
                        break;
                    case "name":
                        this._setSubmitElementName(args.value);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            reset: function() {
                var defaultOptions = this._getDefaultOptions();
                this.option("value", defaultOptions.value)
            }
        });
        module.exports = Editor
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/localization/number.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _dependency_injector = __webpack_require__( /*! ../core/utils/dependency_injector */ 56);
        var _dependency_injector2 = _interopRequireDefault(_dependency_injector);
        var _array = __webpack_require__( /*! ../core/utils/array */ 14);
        var _common = __webpack_require__( /*! ../core/utils/common */ 3);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _number = __webpack_require__( /*! ./ldml/number */ 297);
        var _number2 = _interopRequireDefault(_number);
        var _config = __webpack_require__( /*! ../core/config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _errors = __webpack_require__( /*! ../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _utils = __webpack_require__( /*! ./utils */ 271);
        var _currency = __webpack_require__( /*! ./currency */ 131);
        var _currency2 = _interopRequireDefault(_currency);
        var _number3 = __webpack_require__( /*! ./intl/number */ 451);
        var _number4 = _interopRequireDefault(_number3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest()
        }

        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) {
                return
            }
            if ("string" === typeof o) {
                return _arrayLikeToArray(o, minLen)
            }
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if ("Object" === n && o.constructor) {
                n = o.constructor.name
            }
            if ("Map" === n || "Set" === n) {
                return Array.from(o)
            }
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return _arrayLikeToArray(o, minLen)
            }
        }

        function _arrayLikeToArray(arr, len) {
            if (null == len || len > arr.length) {
                len = arr.length
            }
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
            }
            return arr2
        }

        function _iterableToArrayLimit(arr, i) {
            if ("undefined" === typeof Symbol || !(Symbol.iterator in Object(arr))) {
                return
            }
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) {
                        break
                    }
                }
            } catch (err) {
                _d = true;
                _e = err
            } finally {
                try {
                    if (!_n && null != _i.return) {
                        _i.return()
                    }
                } finally {
                    if (_d) {
                        throw _e
                    }
                }
            }
            return _arr
        }

        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) {
                return arr
            }
        }
        var hasIntl = "undefined" !== typeof Intl;
        var MAX_LARGE_NUMBER_POWER = 4;
        var DECIMAL_BASE = 10;
        var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
        var LargeNumberFormatPostfixes = {
            1: "K",
            2: "M",
            3: "B",
            4: "T"
        };
        var LargeNumberFormatPowers = {
            largenumber: "auto",
            thousands: 1,
            millions: 2,
            billions: 3,
            trillions: 4
        };
        var numberLocalization = (0, _dependency_injector2.default)({
            engine: function() {
                return "base"
            },
            numericFormats: NUMERIC_FORMATS,
            defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
            _parseNumberFormatString: function(formatType) {
                var formatObject = {};
                if (!formatType || "string" !== typeof formatType) {
                    return
                }
                var formatList = formatType.toLowerCase().split(" ");
                (0, _iterator.each)(formatList, function(index, value) {
                    if ((0, _array.inArray)(value, NUMERIC_FORMATS) > -1) {
                        formatObject.formatType = value
                    } else {
                        if (value in LargeNumberFormatPowers) {
                            formatObject.power = LargeNumberFormatPowers[value]
                        }
                    }
                });
                if (formatObject.power && !formatObject.formatType) {
                    formatObject.formatType = "fixedpoint"
                }
                if (formatObject.formatType) {
                    return formatObject
                }
            },
            _calculateNumberPower: function(value, base, minPower, maxPower) {
                var number = Math.abs(value);
                var power = 0;
                if (number > 1) {
                    while (number && number >= base && (void 0 === maxPower || power < maxPower)) {
                        power++;
                        number /= base
                    }
                } else {
                    if (number > 0 && number < 1) {
                        while (number < 1 && (void 0 === minPower || power > minPower)) {
                            power--;
                            number *= base
                        }
                    }
                }
                return power
            },
            _getNumberByPower: function(number, power, base) {
                var result = number;
                while (power > 0) {
                    result /= base;
                    power--
                }
                while (power < 0) {
                    result *= base;
                    power++
                }
                return result
            },
            _formatNumber: function(value, formatObject, formatConfig) {
                if ("auto" === formatObject.power) {
                    formatObject.power = this._calculateNumberPower(value, 1e3, 0, MAX_LARGE_NUMBER_POWER)
                }
                if (formatObject.power) {
                    value = this._getNumberByPower(value, formatObject.power, 1e3)
                }
                var powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
                var result = this._formatNumberCore(value, formatObject.formatType, formatConfig);
                result = result.replace(/(\d|.$)(\D*)$/, "$1" + powerPostfix + "$2");
                return result
            },
            _formatNumberExponential: function(value, formatConfig) {
                var power = this._calculateNumberPower(value, DECIMAL_BASE);
                var number = this._getNumberByPower(value, power, DECIMAL_BASE);
                if (void 0 === formatConfig.precision) {
                    formatConfig.precision = 1
                }
                if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {
                    power++;
                    number /= DECIMAL_BASE
                }
                var powString = (power >= 0 ? "+" : "") + power.toString();
                return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString
            },
            _addZeroes: function(value, precision) {
                var multiplier = Math.pow(10, precision);
                var sign = value < 0 ? "-" : "";
                value = (Math.abs(value) * multiplier >>> 0) / multiplier;
                var result = value.toString();
                while (result.length < precision) {
                    result = "0" + result
                }
                return sign + result
            },
            _addGroupSeparators: function(value) {
                var parts = value.toString().split(".");
                return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, (0, _config2.default)().thousandsSeparator) + (parts[1] ? (0, _config2.default)().decimalSeparator + parts[1] : "")
            },
            _formatNumberCore: function(value, format, formatConfig) {
                if ("exponential" === format) {
                    return this._formatNumberExponential(value, formatConfig)
                }
                if ("decimal" !== format && null !== formatConfig.precision) {
                    formatConfig.precision = formatConfig.precision || 0
                }
                if ("percent" === format) {
                    value = 100 * value
                }
                if (void 0 !== formatConfig.precision) {
                    if ("decimal" === format) {
                        value = this._addZeroes(value, formatConfig.precision)
                    } else {
                        value = null === formatConfig.precision ? value.toPrecision() : (0, _utils.toFixed)(value, formatConfig.precision)
                    }
                }
                if ("decimal" !== format) {
                    value = this._addGroupSeparators(value)
                } else {
                    value = value.toString().replace(".", (0, _config2.default)().decimalSeparator)
                }
                if ("percent" === format) {
                    value += "%"
                }
                return value
            },
            _normalizeFormat: function(format) {
                if (!format) {
                    return {}
                }
                if ("function" === typeof format) {
                    return format
                }
                if (!(0, _type.isPlainObject)(format)) {
                    format = {
                        type: format
                    }
                }
                return format
            },
            _getSeparators: function() {
                return {
                    decimalSeparator: this.getDecimalSeparator(),
                    thousandsSeparator: this.getThousandsSeparator()
                }
            },
            getThousandsSeparator: function() {
                return this.format(1e4, "fixedPoint")[2]
            },
            getDecimalSeparator: function() {
                return this.format(1.2, {
                    type: "fixedPoint",
                    precision: 1
                })[1]
            },
            convertDigits: function(value, toStandard) {
                var digits = this.format(90, "decimal");
                if ("string" !== typeof value || "0" === digits[1]) {
                    return value
                }
                var fromFirstDigit = toStandard ? digits[1] : "0";
                var toFirstDigit = toStandard ? "0" : digits[1];
                var fromLastDigit = toStandard ? digits[0] : "9";
                var regExp = new RegExp("[" + fromFirstDigit + "-" + fromLastDigit + "]", "g");
                return value.replace(regExp, function(char) {
                    return String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0)))
                })
            },
            getSign: function(text, format) {
                if ("-" === text.replace(/[^0-9-]/g, "").charAt(0)) {
                    return -1
                }
                if (!format) {
                    return 1
                }
                var separators = this._getSeparators();
                var regExp = new RegExp("[0-9" + (0, _common.escapeRegExp)(separators.decimalSeparator + separators.thousandsSeparator) + "]+", "g");
                var negativeEtalon = this.format(-1, format).replace(regExp, "1");
                var cleanedText = text.replace(regExp, "1");
                return cleanedText === negativeEtalon ? -1 : 1
            },
            format: function(value, _format) {
                if ("number" !== typeof value) {
                    return value
                }
                if ("number" === typeof _format) {
                    return value
                }
                _format = _format && _format.formatter || _format;
                if ("function" === typeof _format) {
                    return _format(value)
                }
                _format = this._normalizeFormat(_format);
                if (!_format.type) {
                    _format.type = "decimal"
                }
                var numberConfig = this._parseNumberFormatString(_format.type);
                if (!numberConfig) {
                    var formatterConfig = this._getSeparators();
                    formatterConfig.unlimitedIntegerDigits = _format.unlimitedIntegerDigits;
                    return this.convertDigits(_number2.default.getFormatter(_format.type, formatterConfig)(value))
                }
                return this._formatNumber(value, numberConfig, _format)
            },
            parse: function(text, format) {
                if (!text) {
                    return
                }
                if (format && format.parser) {
                    return format.parser(text)
                }
                text = this.convertDigits(text, true);
                if (format && "string" !== typeof format) {
                    _errors2.default.log("W0011")
                }
                var decimalSeparator = this.getDecimalSeparator();
                var regExp = new RegExp("[^0-9" + (0, _common.escapeRegExp)(decimalSeparator) + "]", "g");
                var cleanedText = text.replace(regExp, "").replace(decimalSeparator, ".").replace(/\.$/g, "");
                if ("." === cleanedText || "" === cleanedText) {
                    return null
                }
                if (this._calcSignificantDigits(cleanedText) > 15) {
                    return NaN
                }
                var parsed = +cleanedText;
                return parsed * this.getSign(text, format)
            },
            _calcSignificantDigits: function(text) {
                var _text$split = text.split("."),
                    _text$split2 = _slicedToArray(_text$split, 2),
                    integer = _text$split2[0],
                    fractional = _text$split2[1];
                var calcDigitsAfterLeadingZeros = function(digits) {
                    var index = -1;
                    for (var i = 0; i < digits.length; i++) {
                        if ("0" !== digits[i]) {
                            index = i;
                            break
                        }
                    }
                    return index > -1 ? digits.length - index : 0
                };
                var result = 0;
                if (integer) {
                    result += calcDigitsAfterLeadingZeros(integer.split(""))
                }
                if (fractional) {
                    result += calcDigitsAfterLeadingZeros(fractional.split("").reverse())
                }
                return result
            }
        });
        numberLocalization.inject(_currency2.default);
        if (hasIntl) {
            numberLocalization.inject(_number4.default)
        }
        module.exports = numberLocalization
    },
    /*!********************************************!*\
      !*** ./artifacts/transpiled/viz/themes.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../core/utils/iterator */ 4).each;
        var vizUtils = __webpack_require__( /*! ./core/utils */ 13);
        var uiThemes = __webpack_require__( /*! ../ui/themes */ 32);
        var themes = {};
        var themesMapping = {};
        var themesSchemeMapping = {};
        var _extend = extend;
        var _each = each;
        var _normalizeEnum = vizUtils.normalizeEnum;
        var currentThemeName = null;
        var defaultTheme;
        var nextCacheUid = 0;
        var widgetsCache = {};

        function getTheme(themeName) {
            var name = _normalizeEnum(themeName);
            return themes[name] || themes[themesMapping[name] || currentTheme()]
        }

        function findThemeNameByName(name, scheme) {
            return themesMapping[name + "." + scheme] || themesSchemeMapping[name + "." + scheme] || themesMapping[name]
        }

        function findThemeNameByPlatform(platform, version, scheme) {
            return findThemeNameByName(platform + version, scheme) || findThemeNameByName(platform, scheme)
        }

        function currentTheme(themeName, colorScheme) {
            if (!arguments.length) {
                return currentThemeName || findThemeNameByName(uiThemes.current()) || defaultTheme
            }
            var scheme = _normalizeEnum(colorScheme);
            currentThemeName = (themeName && themeName.platform ? findThemeNameByPlatform(_normalizeEnum(themeName.platform), themeName.version, scheme) : findThemeNameByName(_normalizeEnum(themeName), scheme)) || currentThemeName;
            return this
        }

        function getThemeInfo(themeName, splitter) {
            var k = themeName.indexOf(splitter);
            return k > 0 ? {
                name: themeName.substring(0, k),
                scheme: themeName.substring(k + 1)
            } : null
        }

        function registerThemeName(themeName, targetThemeName) {
            var themeInfo = getThemeInfo(themeName, ".") || {
                name: themeName
            };
            var name = themeInfo.name;
            var scheme = themeInfo.scheme;
            if (scheme) {
                themesMapping[name] = themesMapping[name] || targetThemeName;
                themesMapping[name + "." + scheme] = targetThemeName
            } else {
                themesMapping[name] = targetThemeName
            }
        }

        function registerTheme(theme, baseThemeName) {
            var themeName = _normalizeEnum(theme && theme.name);
            if (themeName) {
                theme.isDefault && (defaultTheme = themeName);
                registerThemeName(themeName, themeName);
                themes[themeName] = _extend(true, {}, getTheme(baseThemeName), patchTheme(theme))
            }
        }

        function registerThemeAlias(alias, theme) {
            registerThemeName(_normalizeEnum(alias), _normalizeEnum(theme))
        }

        function registerThemeSchemeAlias(from, to) {
            themesSchemeMapping[from] = to
        }

        function mergeScalar(target, field, source, sourceValue) {
            var _value = source ? source[field] : sourceValue;
            if (void 0 !== _value && void 0 === target[field]) {
                target[field] = _value
            }
        }

        function mergeObject(target, field, source, sourceValue) {
            var _value = source ? source[field] : sourceValue;
            if (void 0 !== _value) {
                target[field] = _extend(true, {}, _value, target[field])
            }
        }

        function patchTheme(theme) {
            theme = _extend(true, {
                loadingIndicator: {
                    font: {}
                },
                "export": {
                    font: {}
                },
                legend: {
                    font: {},
                    border: {}
                },
                title: {
                    font: {}
                },
                tooltip: {
                    font: {}
                },
                "chart:common": {},
                "chart:common:axis": {
                    grid: {},
                    minorGrid: {},
                    tick: {},
                    minorTick: {},
                    title: {
                        font: {}
                    },
                    label: {
                        font: {}
                    }
                },
                "chart:common:annotation": {
                    font: {},
                    border: {}
                },
                chart: {
                    commonSeriesSettings: {
                        candlestick: {}
                    }
                },
                pie: {},
                polar: {},
                gauge: {
                    scale: {
                        tick: {},
                        minorTick: {},
                        label: {
                            font: {}
                        }
                    }
                },
                barGauge: {},
                funnel: {},
                sankey: {},
                map: {
                    background: {}
                },
                treeMap: {
                    tile: {
                        selectionStyle: {
                            border: {}
                        }
                    },
                    group: {
                        border: {},
                        selectionStyle: {
                            border: {}
                        },
                        label: {
                            font: {}
                        }
                    }
                },
                rangeSelector: {
                    scale: {
                        tick: {},
                        minorTick: {},
                        label: {
                            font: {}
                        }
                    },
                    chart: {}
                },
                sparkline: {},
                bullet: {}
            }, theme);
            mergeScalar(theme.loadingIndicator, "backgroundColor", theme);
            mergeScalar(theme.chart.commonSeriesSettings.candlestick, "innerColor", null, theme.backgroundColor);
            mergeScalar(theme.map.background, "color", null, theme.backgroundColor);
            mergeScalar(theme.title.font, "color", null, theme.primaryTitleColor);
            mergeObject(theme.title, "subtitle", null, theme.title);
            mergeScalar(theme.legend.font, "color", null, theme.secondaryTitleColor);
            mergeScalar(theme.legend.border, "color", null, theme.gridColor);
            patchAxes(theme);
            _each(["chart", "pie", "polar", "gauge", "barGauge", "map", "treeMap", "funnel", "rangeSelector", "sparkline", "bullet", "sankey"], function(_, section) {
                mergeScalar(theme[section], "redrawOnResize", theme);
                mergeScalar(theme[section], "containerBackgroundColor", null, theme.backgroundColor);
                mergeObject(theme[section], "tooltip", theme);
                mergeObject(theme[section], "export", theme)
            });
            _each(["chart", "pie", "polar", "gauge", "barGauge", "map", "treeMap", "funnel", "rangeSelector", "sankey"], function(_, section) {
                mergeObject(theme[section], "loadingIndicator", theme);
                mergeObject(theme[section], "legend", theme);
                mergeObject(theme[section], "title", theme)
            });
            _each(["chart", "pie", "polar"], function(_, section) {
                mergeObject(theme, section, null, theme["chart:common"])
            });
            _each(["chart", "polar"], function(_, section) {
                theme[section] = theme[section] || {};
                mergeObject(theme[section], "commonAxisSettings", null, theme["chart:common:axis"]);
                mergeObject(theme[section], "commonAnnotationSettings", null, theme["chart:common:annotation"])
            });
            mergeObject(theme.rangeSelector.chart, "commonSeriesSettings", theme.chart);
            mergeObject(theme.rangeSelector.chart, "dataPrepareSettings", theme.chart);
            mergeScalar(theme.treeMap.group.border, "color", null, theme.gridColor);
            mergeScalar(theme.treeMap.tile.selectionStyle.border, "color", null, theme.primaryTitleColor);
            mergeScalar(theme.treeMap.group.selectionStyle.border, "color", null, theme.primaryTitleColor);
            mergeScalar(theme.map.legend, "backgroundColor", theme);
            patchMapLayers(theme);
            return theme
        }

        function patchAxes(theme) {
            var commonAxisSettings = theme["chart:common:axis"];
            var colorFieldName = "color";
            _each([commonAxisSettings.grid, commonAxisSettings.minorGrid], function(_, obj) {
                mergeScalar(obj, colorFieldName, null, theme.gridColor)
            });
            _each([commonAxisSettings, commonAxisSettings.tick, commonAxisSettings.minorTick, commonAxisSettings.label.font], function(_, obj) {
                mergeScalar(obj, colorFieldName, null, theme.axisColor)
            });
            mergeScalar(commonAxisSettings.title.font, colorFieldName, null, theme.secondaryTitleColor);
            mergeScalar(theme.gauge.scale.label.font, colorFieldName, null, theme.axisColor);
            mergeScalar(theme.gauge.scale.tick, colorFieldName, null, theme.backgroundColor);
            mergeScalar(theme.gauge.scale.minorTick, colorFieldName, null, theme.backgroundColor);
            mergeScalar(theme.rangeSelector.scale.label.font, colorFieldName, null, theme.axisColor)
        }

        function patchMapLayers(theme) {
            var map = theme.map;
            _each(["area", "line", "marker"], function(_, section) {
                mergeObject(map, "layer:" + section, null, map.layer)
            });
            _each(["dot", "bubble", "pie", "image"], function(_, section) {
                mergeObject(map, "layer:marker:" + section, null, map["layer:marker"])
            })
        }

        function addCacheItem(target) {
            var cacheUid = ++nextCacheUid;
            target._cache = cacheUid;
            widgetsCache[cacheUid] = target
        }

        function removeCacheItem(target) {
            delete widgetsCache[target._cache]
        }

        function refreshTheme() {
            _each(widgetsCache, function() {
                this.refresh()
            });
            return this
        }
        _extend(exports, {
            currentTheme: currentTheme,
            registerTheme: registerTheme,
            getTheme: getTheme,
            registerThemeAlias: registerThemeAlias,
            registerThemeSchemeAlias: registerThemeSchemeAlias,
            refreshTheme: refreshTheme,
            addCacheItem: addCacheItem,
            removeCacheItem: removeCacheItem
        });
        _extend(exports, {
            themes: themes,
            themesMapping: themesMapping,
            themesSchemeMapping: themesSchemeMapping,
            widgetsCache: widgetsCache,
            resetCurrentTheme: function() {
                currentThemeName = null
            }
        })
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/core/utils/ready_callbacks.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var domAdapter = __webpack_require__( /*! ../dom_adapter */ 12);
        var injector = __webpack_require__( /*! ./dependency_injector */ 56);
        var windowUtils = __webpack_require__( /*! ./window */ 7);
        var callOnce = __webpack_require__( /*! ./call_once */ 80);
        var callbacks = [];
        var isReady = function() {
            return "complete" === domAdapter.getReadyState() || "loading" !== domAdapter.getReadyState() && !domAdapter.getDocumentElement().doScroll
        };
        var subscribeReady = callOnce(function() {
            var removeListener = domAdapter.listen(domAdapter.getDocument(), "DOMContentLoaded", function() {
                readyCallbacks.fire();
                removeListener()
            })
        });
        var readyCallbacks = {
            add: function(callback) {
                var hasWindow = windowUtils.hasWindow();
                if (hasWindow && isReady()) {
                    callback()
                } else {
                    callbacks.push(callback);
                    hasWindow && subscribeReady()
                }
            },
            fire: function() {
                callbacks.forEach(function(callback) {
                    return callback()
                });
                callbacks = []
            }
        };
        module.exports = injector(readyCallbacks)
    },
    /*!*************************************************************************!*\
      !*** ./artifacts/transpiled/ui/collection/ui.collection_widget.edit.js ***!
      \*************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _uiCollection_widget = __webpack_require__( /*! ./ui.collection_widget.base */ 495);
        var _uiCollection_widget2 = _interopRequireDefault(_uiCollection_widget);
        var _ui = __webpack_require__( /*! ../widget/ui.errors */ 18);
        var _ui2 = _interopRequireDefault(_ui);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _uiCollection_widgetEditStrategy = __webpack_require__( /*! ./ui.collection_widget.edit.strategy.plain */ 191);
        var _uiCollection_widgetEditStrategy2 = _interopRequireDefault(_uiCollection_widgetEditStrategy);
        var _data = __webpack_require__( /*! ../../core/utils/data */ 20);
        var _data_source = __webpack_require__( /*! ../../data/data_source/data_source */ 61);
        var _utils = __webpack_require__( /*! ../../data/data_source/utils */ 64);
        var _selection = __webpack_require__( /*! ../selection/selection */ 218);
        var _selection2 = _interopRequireDefault(_selection);
        var _deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _toConsumableArray(arr) {
            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
        }

        function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) {
                return
            }
            if ("string" === typeof o) {
                return _arrayLikeToArray(o, minLen)
            }
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if ("Object" === n && o.constructor) {
                n = o.constructor.name
            }
            if ("Map" === n || "Set" === n) {
                return Array.from(o)
            }
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return _arrayLikeToArray(o, minLen)
            }
        }

        function _iterableToArray(iter) {
            if ("undefined" !== typeof Symbol && Symbol.iterator in Object(iter)) {
                return Array.from(iter)
            }
        }

        function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
                return _arrayLikeToArray(arr)
            }
        }

        function _arrayLikeToArray(arr, len) {
            if (null == len || len > arr.length) {
                len = arr.length
            }
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
            }
            return arr2
        }
        var ITEM_DELETING_DATA_KEY = "dxItemDeleting";
        var NOT_EXISTING_INDEX = -1;
        var indexExists = function(index) {
            return index !== NOT_EXISTING_INDEX
        };
        var CollectionWidget = _uiCollection_widget2.default.inherit({
            _setOptionsByReference: function() {
                this.callBase();
                (0, _extend.extend)(this._optionsByReference, {
                    selectedItem: true
                })
            },
            _getDefaultOptions: function() {
                return (0, _extend.extend)(this.callBase(), {
                    selectionMode: "none",
                    selectionRequired: false,
                    selectionByClick: true,
                    selectedItems: [],
                    selectedItemKeys: [],
                    maxFilterLengthInRequest: 1500,
                    keyExpr: null,
                    selectedIndex: NOT_EXISTING_INDEX,
                    selectedItem: null,
                    onSelectionChanged: null,
                    onItemReordered: null,
                    onItemDeleting: null,
                    onItemDeleted: null
                })
            },
            ctor: function(element, options) {
                this._userOptions = options || {};
                this.callBase(element, options)
            },
            _init: function() {
                this._initEditStrategy();
                this.callBase();
                this._initKeyGetter();
                this._initSelectionModule();
                if ("multi" === this.option("selectionMode")) {
                    this._showDeprecatedSelectionMode()
                }
            },
            _initKeyGetter: function() {
                this._keyGetter = (0, _data.compileGetter)(this.option("keyExpr"))
            },
            _getKeysByItems: function(selectedItems) {
                return this._editStrategy.getKeysByItems(selectedItems)
            },
            _getItemsByKeys: function(selectedItemKeys, selectedItems) {
                return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems)
            },
            _getKeyByIndex: function(index) {
                return this._editStrategy.getKeyByIndex(index)
            },
            _getIndexByKey: function(key) {
                return this._editStrategy.getIndexByKey(key)
            },
            _getIndexByItemData: function(itemData) {
                return this._editStrategy.getIndexByItemData(itemData)
            },
            _isKeySpecified: function() {
                return !!(this._dataSource && this._dataSource.key())
            },
            _getCombinedFilter: function() {
                return this._dataSource && this._dataSource.filter()
            },
            key: function() {
                if (this.option("keyExpr")) {
                    return this.option("keyExpr")
                }
                return this._dataSource && this._dataSource.key()
            },
            keyOf: function(item) {
                var key = item;
                var store = this._dataSource && this._dataSource.store();
                if (this.option("keyExpr")) {
                    key = this._keyGetter(item)
                } else {
                    if (store) {
                        key = store.keyOf(item)
                    }
                }
                return key
            },
            _nullValueSelectionSupported: function() {
                return false
            },
            _initSelectionModule: function() {
                var that = this;
                var itemsGetter = that._editStrategy.itemsGetter;
                this._selection = new _selection2.default({
                    allowNullValue: this._nullValueSelectionSupported(),
                    mode: this.option("selectionMode"),
                    maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
                    equalByReference: !this._isKeySpecified(),
                    onSelectionChanged: function(args) {
                        if (args.addedItemKeys.length || args.removedItemKeys.length) {
                            that.option("selectedItems", that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
                            that._updateSelectedItems(args)
                        }
                    },
                    filter: that._getCombinedFilter.bind(that),
                    totalCount: function() {
                        var items = that.option("items");
                        var dataSource = that._dataSource;
                        return dataSource && dataSource.totalCount() >= 0 ? dataSource.totalCount() : items.length
                    },
                    key: that.key.bind(that),
                    keyOf: that.keyOf.bind(that),
                    load: function(options) {
                        if (that._dataSource) {
                            var loadOptions = that._dataSource.loadOptions();
                            options.customQueryParams = loadOptions.customQueryParams;
                            options.userData = that._dataSource._userData
                        }
                        var store = that._dataSource && that._dataSource.store();
                        if (store) {
                            return store.load(options).done(function(loadResult) {
                                if (that._disposed) {
                                    return
                                }
                                var items = (0, _utils.normalizeLoadResult)(loadResult).data;
                                that._dataSource._applyMapFunction(items)
                            })
                        } else {
                            return (new _deferred.Deferred).resolve(this.plainItems())
                        }
                    },
                    dataFields: function() {
                        return that._dataSource && that._dataSource.select()
                    },
                    plainItems: itemsGetter.bind(that._editStrategy)
                })
            },
            _initEditStrategy: function() {
                var Strategy = _uiCollection_widgetEditStrategy2.default;
                this._editStrategy = new Strategy(this)
            },
            _getSelectedItemIndices: function(keys) {
                var that = this;
                var indices = [];
                keys = keys || this._selection.getSelectedItemKeys();
                that._editStrategy.beginCache();
                (0, _iterator.each)(keys, function(_, key) {
                    var selectedIndex = that._getIndexByKey(key);
                    if (indexExists(selectedIndex)) {
                        indices.push(selectedIndex)
                    }
                });
                that._editStrategy.endCache();
                return indices
            },
            _initMarkup: function() {
                var _this = this;
                this._rendering = true;
                if (!this._dataSource || !this._dataSource.isLoading()) {
                    this._syncSelectionOptions().done(function() {
                        return _this._normalizeSelectedItems()
                    })
                }
                this.callBase()
            },
            _render: function() {
                this.callBase();
                this._rendering = false
            },
            _fireContentReadyAction: function() {
                this._rendering = false;
                this._rendered = true;
                this.callBase.apply(this, arguments)
            },
            _syncSelectionOptions: function(byOption) {
                byOption = byOption || this._chooseSelectOption();
                var selectedItem;
                var selectedIndex;
                var selectedItemKeys;
                var selectedItems;
                switch (byOption) {
                    case "selectedIndex":
                        selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
                        if ((0, _type.isDefined)(selectedItem)) {
                            this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
                            this._setOptionWithoutOptionChange("selectedItem", selectedItem);
                            this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]))
                        } else {
                            this._setOptionWithoutOptionChange("selectedItems", []);
                            this._setOptionWithoutOptionChange("selectedItemKeys", []);
                            this._setOptionWithoutOptionChange("selectedItem", null)
                        }
                        break;
                    case "selectedItems":
                        selectedItems = this.option("selectedItems") || [];
                        selectedIndex = this._editStrategy.getIndexByItemData(selectedItems[0]);
                        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
                            return this._syncSelectionOptions("selectedIndex")
                        }
                        this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
                        this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
                        this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
                        break;
                    case "selectedItem":
                        selectedItem = this.option("selectedItem");
                        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
                        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
                            return this._syncSelectionOptions("selectedIndex")
                        }
                        if ((0, _type.isDefined)(selectedItem)) {
                            this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
                            this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
                            this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]))
                        } else {
                            this._setOptionWithoutOptionChange("selectedItems", []);
                            this._setOptionWithoutOptionChange("selectedItemKeys", []);
                            this._setOptionWithoutOptionChange("selectedIndex", NOT_EXISTING_INDEX)
                        }
                        break;
                    case "selectedItemKeys":
                        selectedItemKeys = this.option("selectedItemKeys");
                        if (this.option("selectionRequired")) {
                            var selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
                            if (!indexExists(selectedItemIndex)) {
                                return this._syncSelectionOptions("selectedIndex")
                            }
                        }
                        return this._selection.setSelection(selectedItemKeys)
                }
                return (new _deferred.Deferred).resolve().promise()
            },
            _chooseSelectOption: function() {
                var optionName = "selectedIndex";
                var isOptionDefined = function(optionName) {
                    var optionValue = this.option(optionName);
                    var length = (0, _type.isDefined)(optionValue) && optionValue.length;
                    return length || optionName in this._userOptions
                }.bind(this);
                if (isOptionDefined("selectedItems")) {
                    optionName = "selectedItems"
                } else {
                    if (isOptionDefined("selectedItem")) {
                        optionName = "selectedItem"
                    } else {
                        if (isOptionDefined("selectedItemKeys")) {
                            optionName = "selectedItemKeys"
                        }
                    }
                }
                return optionName
            },
            _compareKeys: function(oldKeys, newKeys) {
                if (oldKeys.length !== newKeys.length) {
                    return false
                }
                for (var i = 0; i < newKeys.length; i++) {
                    if (oldKeys[i] !== newKeys[i]) {
                        return false
                    }
                }
                return true
            },
            _normalizeSelectedItems: function() {
                if ("none" === this.option("selectionMode")) {
                    this._setOptionWithoutOptionChange("selectedItems", []);
                    this._syncSelectionOptions("selectedItems")
                } else {
                    if ("single" === this.option("selectionMode")) {
                        var newSelection = this.option("selectedItems");
                        if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
                            var currentSelection = this._selection.getSelectedItems();
                            var normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
                            if (void 0 === normalizedSelection) {
                                normalizedSelection = this._editStrategy.itemsGetter()[0]
                            }
                            if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
                                normalizedSelection.items = [normalizedSelection.items[0]]
                            }
                            this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
                            this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
                            return this._syncSelectionOptions("selectedItems")
                        } else {
                            this._selection.setSelection(this._getKeysByItems(newSelection))
                        }
                    } else {
                        var newKeys = this._getKeysByItems(this.option("selectedItems"));
                        var oldKeys = this._selection.getSelectedItemKeys();
                        if (!this._compareKeys(oldKeys, newKeys)) {
                            this._selection.setSelection(newKeys)
                        }
                    }
                }
                return (new _deferred.Deferred).resolve().promise()
            },
            _itemClickHandler: function(e) {
                this._createAction(function(e) {
                    this._itemSelectHandler(e.event)
                }.bind(this), {
                    validatingTargetName: "itemElement"
                })({
                    itemElement: (0, _renderer2.default)(e.currentTarget),
                    event: e
                });
                this.callBase.apply(this, arguments)
            },
            _itemSelectHandler: function(e) {
                if (!this.option("selectionByClick")) {
                    return
                }
                var $itemElement = e.currentTarget;
                if (this.isItemSelected($itemElement)) {
                    this.unselectItem(e.currentTarget)
                } else {
                    this.selectItem(e.currentTarget)
                }
            },
            _selectedItemElement: function(index) {
                return this._itemElements().eq(index)
            },
            _postprocessRenderItem: function(args) {
                if ("none" !== this.option("selectionMode")) {
                    var $itemElement = (0, _renderer2.default)(args.itemElement);
                    var normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
                    var isItemSelected = this._isItemSelected(normalizedItemIndex);
                    this._processSelectableItem($itemElement, isItemSelected)
                }
            },
            _processSelectableItem: function($itemElement, isSelected) {
                $itemElement.toggleClass(this._selectedItemClass(), isSelected);
                this._setAriaSelected($itemElement, String(isSelected))
            },
            _updateSelectedItems: function(args) {
                var that = this;
                var addedItemKeys = args.addedItemKeys;
                var removedItemKeys = args.removedItemKeys;
                if (that._rendered && (addedItemKeys.length || removedItemKeys.length)) {
                    var selectionChangePromise = that._selectionChangePromise;
                    if (!that._rendering) {
                        var addedSelection = [];
                        var normalizedIndex;
                        var removedSelection = [];
                        that._editStrategy.beginCache();
                        for (var i = 0; i < addedItemKeys.length; i++) {
                            normalizedIndex = that._getIndexByKey(addedItemKeys[i]);
                            addedSelection.push(normalizedIndex);
                            that._addSelection(normalizedIndex)
                        }
                        for (var _i = 0; _i < removedItemKeys.length; _i++) {
                            normalizedIndex = that._getIndexByKey(removedItemKeys[_i]);
                            removedSelection.push(normalizedIndex);
                            that._removeSelection(normalizedIndex)
                        }
                        that._editStrategy.endCache();
                        that._updateSelection(addedSelection, removedSelection)
                    }(0, _deferred.when)(selectionChangePromise).done(function() {
                        that._fireSelectionChangeEvent(args.addedItems, args.removedItems)
                    })
                }
            },
            _fireSelectionChangeEvent: function(addedItems, removedItems) {
                this._createActionByOption("onSelectionChanged", {
                    excludeValidators: ["disabled", "readOnly"]
                })({
                    addedItems: addedItems,
                    removedItems: removedItems
                })
            },
            _updateSelection: _common.noop,
            _setAriaSelected: function($target, value) {
                this.setAria("selected", value, $target)
            },
            _removeSelection: function(normalizedIndex) {
                var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
                if (indexExists(normalizedIndex)) {
                    this._processSelectableItem($itemElement, false);
                    _events_engine2.default.triggerHandler($itemElement, "stateChanged", false)
                }
            },
            _showDeprecatedSelectionMode: function() {
                _ui2.default.log("W0001", this.NAME, "selectionMode: 'multi'", "16.1", "Use selectionMode: 'multiple' instead");
                this.option("selectionMode", "multiple")
            },
            _addSelection: function(normalizedIndex) {
                var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
                if (indexExists(normalizedIndex)) {
                    this._processSelectableItem($itemElement, true);
                    _events_engine2.default.triggerHandler($itemElement, "stateChanged", true)
                }
            },
            _isItemSelected: function(index) {
                var key = this._getKeyByIndex(index);
                return this._selection.isItemSelected(key)
            },
            _optionChanged: function(args) {
                var _this2 = this;
                switch (args.name) {
                    case "selectionMode":
                        if ("multi" === args.value) {
                            this._showDeprecatedSelectionMode()
                        } else {
                            this._invalidate()
                        }
                        break;
                    case "dataSource":
                        if (!args.value || Array.isArray(args.value) && !args.value.length) {
                            this.option("selectedItemKeys", [])
                        }
                        this.callBase(args);
                        break;
                    case "selectedIndex":
                    case "selectedItem":
                    case "selectedItems":
                    case "selectedItemKeys":
                        this._syncSelectionOptions(args.name).done(function() {
                            return _this2._normalizeSelectedItems()
                        });
                        break;
                    case "keyExpr":
                        this._initKeyGetter();
                        break;
                    case "selectionRequired":
                        this._normalizeSelectedItems();
                        break;
                    case "selectionByClick":
                    case "onSelectionChanged":
                    case "onItemDeleting":
                    case "onItemDeleted":
                    case "onItemReordered":
                    case "maxFilterLengthInRequest":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _clearSelectedItems: function() {
                this._setOptionWithoutOptionChange("selectedItems", []);
                this._syncSelectionOptions("selectedItems")
            },
            _waitDeletingPrepare: function($itemElement) {
                if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
                    return (new _deferred.Deferred).resolve().promise()
                }
                $itemElement.data(ITEM_DELETING_DATA_KEY, true);
                var deferred = new _deferred.Deferred;
                var deletingActionArgs = {
                    cancel: false
                };
                var deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
                    excludeValidators: ["disabled", "readOnly"]
                });
                (0, _deferred.when)(deletePromise).always(function(value) {
                    var deletePromiseExists = !deletePromise;
                    var deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state();
                    var argumentsSpecified = !!arguments.length;
                    var shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
                    (0, _deferred.when)((0, _deferred.fromPromise)(deletingActionArgs.cancel)).always(function() {
                        $itemElement.data(ITEM_DELETING_DATA_KEY, false)
                    }).done(function(cancel) {
                        shouldDelete && !cancel ? deferred.resolve() : deferred.reject()
                    }).fail(deferred.reject)
                }.bind(this));
                return deferred.promise()
            },
            _deleteItemFromDS: function($item) {
                if (!this._dataSource) {
                    return (new _deferred.Deferred).resolve().promise()
                }
                var deferred = new _deferred.Deferred;
                var disabledState = this.option("disabled");
                var dataStore = this._dataSource.store();
                this.option("disabled", true);
                if (!dataStore.remove) {
                    throw _ui2.default.Error("E1011")
                }
                dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
                    if (void 0 !== key) {
                        deferred.resolve()
                    } else {
                        deferred.reject()
                    }
                }).fail(function() {
                    deferred.reject()
                });
                deferred.always(function() {
                    this.option("disabled", disabledState)
                }.bind(this));
                return deferred
            },
            _tryRefreshLastPage: function() {
                var deferred = new _deferred.Deferred;
                if (this._isLastPage() || this.option("grouped")) {
                    deferred.resolve()
                } else {
                    this._refreshLastPage().done(function() {
                        deferred.resolve()
                    })
                }
                return deferred.promise()
            },
            _refreshLastPage: function() {
                this._expectLastItemLoading();
                return this._dataSource.load()
            },
            _updateSelectionAfterDelete: function(index) {
                var key = this._getKeyByIndex(index);
                this._selection.deselect([key])
            },
            _updateIndicesAfterIndex: function(index) {
                var itemElements = this._itemElements();
                for (var i = index + 1; i < itemElements.length; i++) {
                    (0, _renderer2.default)(itemElements[i]).data(this._itemIndexKey(), i - 1)
                }
            },
            _simulateOptionChange: function(optionName) {
                var optionValue = this.option(optionName);
                if (optionValue instanceof _data_source.DataSource) {
                    return
                }
                this._optionChangedAction({
                    name: optionName,
                    fullName: optionName,
                    value: optionValue
                })
            },
            isItemSelected: function(itemElement) {
                return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement))
            },
            selectItem: function(itemElement) {
                if ("none" === this.option("selectionMode")) {
                    return
                }
                var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                if (!indexExists(itemIndex)) {
                    return
                }
                var key = this._getKeyByIndex(itemIndex);
                if (this._selection.isItemSelected(key)) {
                    return
                }
                if ("single" === this.option("selectionMode")) {
                    this._selection.setSelection([key])
                } else {
                    var selectedItemKeys = this.option("selectedItemKeys") || [];
                    this._selection.setSelection([].concat(_toConsumableArray(selectedItemKeys), [key]))
                }
            },
            unselectItem: function(itemElement) {
                var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                if (!indexExists(itemIndex)) {
                    return
                }
                var selectedItemKeys = this._selection.getSelectedItemKeys();
                if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
                    return
                }
                var key = this._getKeyByIndex(itemIndex);
                if (!this._selection.isItemSelected(key)) {
                    return
                }
                this._selection.deselect([key])
            },
            _deleteItemElementByIndex: function(index) {
                this._updateSelectionAfterDelete(index);
                this._updateIndicesAfterIndex(index);
                this._editStrategy.deleteItemAtIndex(index)
            },
            _afterItemElementDeleted: function($item, deletedActionArgs) {
                var changingOption = this._dataSource ? "dataSource" : "items";
                this._simulateOptionChange(changingOption);
                this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
                    beforeExecute: function() {
                        $item.remove()
                    },
                    excludeValidators: ["disabled", "readOnly"]
                });
                this._renderEmptyMessage()
            },
            deleteItem: function(itemElement) {
                var that = this;
                var deferred = new _deferred.Deferred;
                var $item = this._editStrategy.getItemElement(itemElement);
                var index = this._editStrategy.getNormalizedIndex(itemElement);
                var itemResponseWaitClass = this._itemResponseWaitClass();
                if (indexExists(index)) {
                    this._waitDeletingPrepare($item).done(function() {
                        $item.addClass(itemResponseWaitClass);
                        var deletedActionArgs = that._extendActionArgs($item);
                        that._deleteItemFromDS($item).done(function() {
                            that._deleteItemElementByIndex(index);
                            that._afterItemElementDeleted($item, deletedActionArgs);
                            that._tryRefreshLastPage().done(function() {
                                deferred.resolveWith(that)
                            })
                        }).fail(function() {
                            $item.removeClass(itemResponseWaitClass);
                            deferred.rejectWith(that)
                        })
                    }).fail(function() {
                        deferred.rejectWith(that)
                    })
                } else {
                    deferred.rejectWith(that)
                }
                return deferred.promise()
            },
            reorderItem: function(itemElement, toItemElement) {
                var deferred = new _deferred.Deferred;
                var that = this;
                var strategy = this._editStrategy;
                var $movingItem = strategy.getItemElement(itemElement);
                var $destinationItem = strategy.getItemElement(toItemElement);
                var movingIndex = strategy.getNormalizedIndex(itemElement);
                var destinationIndex = strategy.getNormalizedIndex(toItemElement);
                var changingOption = this._dataSource ? "dataSource" : "items";
                var canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
                if (canMoveItems) {
                    deferred.resolveWith(this)
                } else {
                    deferred.rejectWith(this)
                }
                return deferred.promise().done(function() {
                    $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
                    strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
                    this._updateIndicesAfterIndex(movingIndex);
                    that.option("selectedItems", that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));
                    if ("items" === changingOption) {
                        that._simulateOptionChange(changingOption)
                    }
                    that._itemEventHandler($movingItem, "onItemReordered", {
                        fromIndex: strategy.getIndex(movingIndex),
                        toIndex: strategy.getIndex(destinationIndex)
                    }, {
                        excludeValidators: ["disabled", "readOnly"]
                    })
                })
            }
        });
        module.exports = CollectionWidget
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/core/utils/icon.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var ICON_CLASS = "dx-icon";
        var SVG_ICON_CLASS = "dx-svg-icon";
        var getImageSourceType = function(source) {
            if (!source || "string" !== typeof source) {
                return false
            }
            if (/^\s*<svg[^>]*>(.|\r\n|\r|\n)*?<\/svg>\s*$/i.test(source)) {
                return "svg"
            }
            if (/data:.*base64|\.|[^<\s]\//.test(source)) {
                return "image"
            }
            if (/^[\w-_]+$/.test(source)) {
                return "dxIcon"
            }
            if (/^\s?([\w-_]\s?)+$/.test(source)) {
                return "fontIcon"
            }
            return false
        };
        var getImageContainer = function(source) {
            switch (getImageSourceType(source)) {
                case "image":
                    return (0, _renderer2.default)("<img>").attr("src", source).addClass(ICON_CLASS);
                case "fontIcon":
                    return (0, _renderer2.default)("<i>").addClass("".concat(ICON_CLASS, " ").concat(source));
                case "dxIcon":
                    return (0, _renderer2.default)("<i>").addClass("".concat(ICON_CLASS, " ").concat(ICON_CLASS, "-").concat(source));
                case "svg":
                    return (0, _renderer2.default)("<i>").addClass("".concat(ICON_CLASS, " ").concat(SVG_ICON_CLASS)).append(source);
                default:
                    return null
            }
        };
        exports.getImageSourceType = getImageSourceType;
        exports.getImageContainer = getImageContainer
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/core/utils/date_serialization.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var config = __webpack_require__( /*! ../config */ 30);
        var getLDMLFormatter = __webpack_require__( /*! ../../localization/ldml/date.formatter */ 273).getFormatter;
        var defaultDateNames = __webpack_require__( /*! ../../localization/default_date_names */ 274);
        var typeUtils = __webpack_require__( /*! ./type */ 1);
        var isString = typeUtils.isString;
        var isDate = typeUtils.isDate;
        var isNumber = typeUtils.isNumeric;
        var NUMBER_SERIALIZATION_FORMAT = "number";
        var DATE_SERIALIZATION_FORMAT = "yyyy/MM/dd";
        var DATETIME_SERIALIZATION_FORMAT = "yyyy/MM/dd HH:mm:ss";
        var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
        var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
        var ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];
        var MILLISECOND_LENGHT = 3;
        var dateParser = function(text, skipISO8601Parsing) {
            var result;
            var parsedValue;
            if (isString(text) && !skipISO8601Parsing) {
                result = parseISO8601String(text)
            }
            if (!result) {
                parsedValue = !isDate(text) && Date.parse(text);
                result = isNumber(parsedValue) ? new Date(parsedValue) : text
            }
            return result
        };

        function parseISO8601String(text) {
            var parts = text.match(ISO8601_PATTERN);
            var timePart = function(part) {
                return +part || 0
            };
            if (!parts) {
                parts = text.match(ISO8601_TIME_PATTERN);
                if (parts) {
                    return new Date(0, 0, 0, timePart(parts[1]), timePart(parts[2]), timePart(parts[4]))
                }
                return
            }
            var year = parts[1];
            var month = --parts[3];
            var day = parts[5];
            var timeZoneHour = 0;
            var timeZoneMinute = 0;
            timeZoneHour = timePart(parts[14]);
            timeZoneMinute = timePart(parts[16]);
            if ("-" === parts[13]) {
                timeZoneHour = -timeZoneHour;
                timeZoneMinute = -timeZoneMinute
            }
            var hour = timePart(parts[6]) - timeZoneHour;
            var minute = timePart(parts[8]) - timeZoneMinute;
            var second = timePart(parts[10]);
            var parseMilliseconds = function(part) {
                part = part || "";
                return timePart(part) * Math.pow(10, MILLISECOND_LENGHT - part.length)
            };
            var millisecond = parseMilliseconds(parts[11]);
            if (parts[12]) {
                return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond))
            }
            return new Date(year, month, day, hour, minute, second, millisecond)
        }
        var getIso8601Format = function(text, useUtc) {
            var parts = text.match(ISO8601_PATTERN);
            var result = "";
            if (!parts) {
                parts = text.match(ISO8601_TIME_PATTERN);
                if (parts) {
                    return parts[3] ? "HH:mm:ss" : "HH:mm"
                }
                return
            }
            for (var i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
                if (parts[i]) {
                    result += ISO8601_PATTERN_PARTS[i] || parts[i]
                }
            }
            if ("Z" === parts[12]) {
                result += "'Z'"
            }
            if (parts[14]) {
                if (parts[15]) {
                    result += "xxx"
                } else {
                    if (parts[16]) {
                        result += "xx"
                    } else {
                        result += "x"
                    }
                }
            }
            return result
        };
        var deserializeDate = function(value) {
            if ("number" === typeof value) {
                return new Date(value)
            }
            return dateParser(value, !config().forceIsoDateParsing)
        };
        var serializeDate = function(value, serializationFormat) {
            if (!serializationFormat) {
                return value
            }
            if (!isDate(value)) {
                return null
            }
            if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
                return value && value.valueOf ? value.valueOf() : null
            }
            return getLDMLFormatter(serializationFormat, defaultDateNames)(value)
        };
        var getDateSerializationFormat = function(value) {
            if ("number" === typeof value) {
                return NUMBER_SERIALIZATION_FORMAT
            } else {
                if (isString(value)) {
                    var format;
                    if (config().forceIsoDateParsing) {
                        format = getIso8601Format(value)
                    }
                    if (format) {
                        return format
                    } else {
                        if (value.indexOf(":") >= 0) {
                            return DATETIME_SERIALIZATION_FORMAT
                        } else {
                            return DATE_SERIALIZATION_FORMAT
                        }
                    }
                } else {
                    if (value) {
                        return null
                    }
                }
            }
        };
        module.exports = {
            dateParser: dateParser,
            deserializeDate: deserializeDate,
            serializeDate: serializeDate,
            getDateSerializationFormat: getDateSerializationFormat
        }
    }, ,
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/core/utils/dependency_injector.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = function(object) {
            var extend = __webpack_require__( /*! ./extend */ 0).extend;
            var isFunction = __webpack_require__( /*! ./type */ 1).isFunction;
            var each = __webpack_require__( /*! ./iterator */ 4).each;
            var Class = __webpack_require__( /*! ../class */ 16);
            var BaseClass = Class.inherit(object);
            var InjectedClass = BaseClass;
            var instance = new InjectedClass(object);
            var initialFields = {};
            var injectFields = function(injectionObject, initial) {
                each(injectionObject, function(key) {
                    if (isFunction(instance[key])) {
                        if (initial || !object[key]) {
                            object[key] = function() {
                                return instance[key].apply(object, arguments)
                            }
                        }
                    } else {
                        if (initial) {
                            initialFields[key] = object[key]
                        }
                        object[key] = instance[key]
                    }
                })
            };
            injectFields(object, true);
            object.inject = function(injectionObject) {
                InjectedClass = InjectedClass.inherit(injectionObject);
                instance = new InjectedClass;
                injectFields(injectionObject)
            };
            object.resetInjection = function() {
                extend(object, initialFields);
                InjectedClass = BaseClass;
                instance = new BaseClass
            };
            return object
        }
    },
    /*!********************************!*\
      !*** external "window.jQuery" ***!
      \********************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports) {
        module.exports = window.jQuery
    },
    /*!********************************************!*\
      !*** ./artifacts/transpiled/ui/overlay.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./overlay/ui.overlay */ 301)
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/core/templates/bindable_template.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.BindableTemplate = void 0;
        var _renderer = __webpack_require__( /*! ../renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _template_base = __webpack_require__( /*! ./template_base */ 78);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _remove_event = __webpack_require__( /*! ../remove_event */ 140);
        var _remove_event2 = _interopRequireDefault(_remove_event);
        var _type = __webpack_require__( /*! ../utils/type */ 1);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }

        function _inherits(subClass, superClass) {
            if ("function" !== typeof superClass && null !== superClass) {
                throw new TypeError("Super expression must either be null or a function")
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) {
                _setPrototypeOf(subClass, superClass)
            }
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o
            };
            return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                    result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (call && ("object" === _typeof(call) || "function" === typeof call)) {
                return call
            }
            return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
            if (void 0 === self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return self
        }

        function _isNativeReflectConstruct() {
            if ("undefined" === typeof Reflect || !Reflect.construct) {
                return false
            }
            if (Reflect.construct.sham) {
                return false
            }
            if ("function" === typeof Proxy) {
                return true
            }
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                return true
            } catch (e) {
                return false
            }
        }

        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
            };
            return _getPrototypeOf(o)
        }
        var watchChanges = function() {
            var globalWatch = function(data, watchMethod, callback) {
                return watchMethod(function() {
                    return data
                }, callback)
            };
            var fieldsWatch = function(data, watchMethod, fields, fieldsMap, callback) {
                var resolvedData = {};
                var missedFields = fields.slice();
                var watchHandlers = fields.map(function(name) {
                    var fieldGetter = fieldsMap[name];
                    return watchMethod(fieldGetter ? function() {
                        return fieldGetter(data)
                    } : function() {
                        return data[name]
                    }, function(value) {
                        resolvedData[name] = value;
                        if (missedFields.length) {
                            var index = missedFields.indexOf(name);
                            if (index >= 0) {
                                missedFields.splice(index, 1)
                            }
                        }
                        if (!missedFields.length) {
                            callback(resolvedData)
                        }
                    })
                });
                return function() {
                    watchHandlers.forEach(function(dispose) {
                        return dispose()
                    })
                }
            };
            return function(rawData, watchMethod, fields, fieldsMap, callback) {
                var fieldsDispose;
                var globalDispose = globalWatch(rawData, watchMethod, function(dataWithRawFields) {
                    fieldsDispose && fieldsDispose();
                    if ((0, _type.isPrimitive)(dataWithRawFields)) {
                        callback(dataWithRawFields);
                        return
                    }
                    fieldsDispose = fieldsWatch(dataWithRawFields, watchMethod, fields, fieldsMap, callback)
                });
                return function() {
                    fieldsDispose && fieldsDispose();
                    globalDispose && globalDispose()
                }
            }
        }();
        exports.BindableTemplate = function(_TemplateBase) {
            _inherits(BindableTemplate, _TemplateBase);
            var _super = _createSuper(BindableTemplate);

            function BindableTemplate(render, fields, watchMethod, fieldsMap) {
                var _this;
                _classCallCheck(this, BindableTemplate);
                _this = _super.call(this);
                _this._render = render;
                _this._fields = fields;
                _this._fieldsMap = fieldsMap || {};
                _this._watchMethod = watchMethod;
                return _this
            }
            _createClass(BindableTemplate, [{
                key: "_renderCore",
                value: function(options) {
                    var _this2 = this;
                    var $container = (0, _renderer2.default)(options.container);
                    var dispose = watchChanges(options.model, this._watchMethod, this._fields, this._fieldsMap, function(data) {
                        $container.empty();
                        _this2._render($container, data, options.model)
                    });
                    (0, _events_engine.on)($container, _remove_event2.default, dispose);
                    return $container.contents()
                }
            }]);
            return BindableTemplate
        }(_template_base.TemplateBase)
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/utils/version.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        exports.compare = function(x, y, maxLevel) {
            function normalizeArg(value) {
                if ("string" === typeof value) {
                    return value.split(".")
                }
                if ("number" === typeof value) {
                    return [value]
                }
                return value
            }
            x = normalizeArg(x);
            y = normalizeArg(y);
            var length = Math.max(x.length, y.length);
            if (isFinite(maxLevel)) {
                length = Math.min(length, maxLevel)
            }
            for (var i = 0; i < length; i++) {
                var xItem = parseInt(x[i] || 0, 10);
                var yItem = parseInt(y[i] || 0, 10);
                if (xItem < yItem) {
                    return -1
                }
                if (xItem > yItem) {
                    return 1
                }
            }
            return 0
        }
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/data/data_source/data_source.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.DataSource = void 0;
        var _class = __webpack_require__( /*! ../../core/class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _common2 = _interopRequireDefault(_common);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _utils = __webpack_require__( /*! ../utils */ 42);
        var _array_utils = __webpack_require__( /*! ../array_utils */ 142);
        var _array_utils2 = _interopRequireDefault(_array_utils);
        var _custom_store = __webpack_require__( /*! ../custom_store */ 118);
        var _custom_store2 = _interopRequireDefault(_custom_store);
        var _events_strategy = __webpack_require__( /*! ../../core/events_strategy */ 100);
        var _errors = __webpack_require__( /*! ../errors */ 38);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _array2 = _interopRequireDefault(_array);
        var _queue = __webpack_require__( /*! ../../core/utils/queue */ 280);
        var _queue2 = _interopRequireDefault(_queue);
        var _deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var _operation_manager = __webpack_require__( /*! ./operation_manager */ 496);
        var _operation_manager2 = _interopRequireDefault(_operation_manager);
        var _utils2 = __webpack_require__( /*! ./utils */ 64);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        exports.DataSource = _class2.default.inherit({
            ctor: function(options) {
                var _options$reshapeOnPus, _this = this;
                options = (0, _utils2.normalizeDataSourceOptions)(options);
                this._eventsStrategy = new _events_strategy.EventsStrategy(this);
                var onPushHandler = 0 !== options.pushAggregationTimeout ? (0, _utils.throttleChanges)(this._onPush, function() {
                    return void 0 === options.pushAggregationTimeout ? 5 * _this._changedTime : options.pushAggregationTimeout
                }) : this._onPush;
                this._changedTime = 0;
                this._onPushHandler = function(changes) {
                    _this._aggregationTimeoutId = onPushHandler.call(_this, changes)
                };
                this._store = options.store;
                this._store.on("push", this._onPushHandler);
                this._storeLoadOptions = this._extractLoadOptions(options);
                this._mapFunc = options.map;
                this._postProcessFunc = options.postProcess;
                this._pageIndex = void 0 !== options.pageIndex ? options.pageIndex : 0;
                this._pageSize = void 0 !== options.pageSize ? options.pageSize : 20;
                this._loadingCount = 0;
                this._loadQueue = this._createLoadQueue();
                this._searchValue = "searchValue" in options ? options.searchValue : null;
                this._searchOperation = options.searchOperation || "contains";
                this._searchExpr = options.searchExpr;
                this._paginate = options.paginate;
                this._reshapeOnPush = null !== (_options$reshapeOnPus = options.reshapeOnPush) && void 0 !== _options$reshapeOnPus ? _options$reshapeOnPus : false;
                (0, _iterator.each)(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], function(_, optionName) {
                    if (optionName in options) {
                        _this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName])
                    }
                });
                this._operationManager = new _operation_manager2.default;
                this._init()
            },
            _init: function() {
                this._items = [];
                this._userData = {};
                this._totalCount = -1;
                this._isLoaded = false;
                if (!(0, _type.isDefined)(this._paginate)) {
                    this._paginate = !this.group()
                }
                this._isLastPage = !this._paginate
            },
            dispose: function() {
                var _this$_delayedLoadTas;
                this._store.off("push", this._onPushHandler);
                this._eventsStrategy.dispose();
                clearTimeout(this._aggregationTimeoutId);
                delete this._store;
                null === (_this$_delayedLoadTas = this._delayedLoadTask) || void 0 === _this$_delayedLoadTas ? void 0 : _this$_delayedLoadTas.abort();
                this._operationManager.cancelAll();
                this._disposed = true
            },
            _extractLoadOptions: function(options) {
                var result = {};
                var names = ["sort", "filter", "select", "group", "requireTotalCount"];
                var customNames = this._store._customLoadOptions();
                if (customNames) {
                    names = names.concat(customNames)
                }(0, _iterator.each)(names, function() {
                    result[this] = options[this]
                });
                return result
            },
            loadOptions: function() {
                return this._storeLoadOptions
            },
            items: function() {
                return this._items
            },
            pageIndex: function(newIndex) {
                if (!(0, _type.isNumeric)(newIndex)) {
                    return this._pageIndex
                }
                this._pageIndex = newIndex;
                this._isLastPage = !this._paginate
            },
            paginate: function(value) {
                if (!(0, _type.isBoolean)(value)) {
                    return this._paginate
                }
                if (this._paginate !== value) {
                    this._paginate = value;
                    this.pageIndex(0)
                }
            },
            pageSize: function(value) {
                if (!(0, _type.isNumeric)(value)) {
                    return this._pageSize
                }
                this._pageSize = value
            },
            isLastPage: function() {
                return this._isLastPage
            },
            generateStoreLoadOptionAccessor: function(optionName) {
                var _this2 = this;
                return function(args) {
                    var normalizedArgs = (0, _utils2.normalizeStoreLoadOptionAccessorArguments)(args);
                    if (void 0 === normalizedArgs) {
                        return _this2._storeLoadOptions[optionName]
                    }
                    _this2._storeLoadOptions[optionName] = normalizedArgs
                }
            },
            sort: function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key]
                }
                return this.generateStoreLoadOptionAccessor("sort")(args)
            },
            filter: function() {
                var newFilter = (0, _utils2.normalizeStoreLoadOptionAccessorArguments)(arguments);
                if (void 0 === newFilter) {
                    return this._storeLoadOptions.filter
                }
                this._storeLoadOptions.filter = newFilter;
                this.pageIndex(0)
            },
            group: function() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2]
                }
                return this.generateStoreLoadOptionAccessor("group")(args)
            },
            select: function() {
                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    args[_key3] = arguments[_key3]
                }
                return this.generateStoreLoadOptionAccessor("select")(args)
            },
            requireTotalCount: function(value) {
                if (!(0, _type.isBoolean)(value)) {
                    return this._storeLoadOptions.requireTotalCount
                }
                this._storeLoadOptions.requireTotalCount = value
            },
            searchValue: function(value) {
                if (arguments.length < 1) {
                    return this._searchValue
                }
                this._searchValue = value;
                this.pageIndex(0)
            },
            searchOperation: function(op) {
                if (!(0, _type.isString)(op)) {
                    return this._searchOperation
                }
                this._searchOperation = op;
                this.pageIndex(0)
            },
            searchExpr: function(expr) {
                var argc = arguments.length;
                if (0 === argc) {
                    return this._searchExpr
                }
                if (argc > 1) {
                    expr = [].slice.call(arguments)
                }
                this._searchExpr = expr;
                this.pageIndex(0)
            },
            store: function() {
                return this._store
            },
            key: function() {
                var _this$_store;
                return null === (_this$_store = this._store) || void 0 === _this$_store ? void 0 : _this$_store.key()
            },
            totalCount: function() {
                return this._totalCount
            },
            isLoaded: function() {
                return this._isLoaded
            },
            isLoading: function() {
                return this._loadingCount > 0
            },
            beginLoading: function() {
                this._changeLoadingCount(1)
            },
            endLoading: function() {
                this._changeLoadingCount(-1)
            },
            _createLoadQueue: function() {
                return _queue2.default.create()
            },
            _changeLoadingCount: function(increment) {
                var oldLoading = this.isLoading();
                this._loadingCount += increment;
                var newLoading = this.isLoading();
                if (oldLoading ^ newLoading) {
                    this._eventsStrategy.fireEvent("loadingChanged", [newLoading])
                }
            },
            _scheduleLoadCallbacks: function(deferred) {
                var _this3 = this;
                this.beginLoading();
                deferred.always(function() {
                    _this3.endLoading()
                })
            },
            _scheduleFailCallbacks: function(deferred) {
                var _this4 = this;
                deferred.fail(function() {
                    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                        args[_key4] = arguments[_key4]
                    }
                    if (args[0] === _utils2.CANCELED_TOKEN) {
                        return
                    }
                    _this4._eventsStrategy.fireEvent("loadError", args)
                })
            },
            _fireChanged: function(args) {
                var date = new Date;
                this._eventsStrategy.fireEvent("changed", args);
                this._changedTime = new Date - date
            },
            _scheduleChangedCallbacks: function(deferred) {
                var _this5 = this;
                deferred.done(function() {
                    return _this5._fireChanged()
                })
            },
            loadSingle: function(propName, propValue) {
                var _this6 = this;
                var d = new _deferred.Deferred;
                var key = this.key();
                var store = this._store;
                var options = this._createStoreLoadOptions();
                var handleDone = function(data) {
                    if (!(0, _type.isDefined)(data) || _array2.default.isEmpty(data)) {
                        d.reject(new _errors.errors.Error("E4009"))
                    } else {
                        if (!Array.isArray(data)) {
                            data = [data]
                        }
                        d.resolve(_this6._applyMapFunction(data)[0])
                    }
                };
                this._scheduleFailCallbacks(d);
                if (arguments.length < 2) {
                    propValue = propName;
                    propName = key
                }
                delete options.skip;
                delete options.group;
                delete options.refresh;
                delete options.pageIndex;
                delete options.searchString;
                var shouldForceByKey = function() {
                    return store instanceof _custom_store2.default && !store._byKeyViaLoad()
                };
                (function() {
                    if (propName === key || shouldForceByKey()) {
                        return store.byKey(propValue, options)
                    }
                    options.take = 1;
                    options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
                    return store.load(options)
                })().fail(d.reject).done(handleDone);
                return d.promise()
            },
            load: function() {
                var _this7 = this;
                var d = new _deferred.Deferred;
                var loadTask = function() {
                    if (_this7._disposed) {
                        return
                    }
                    if (!(0, _utils2.isPending)(d)) {
                        return
                    }
                    return _this7._loadFromStore(loadOperation, d)
                };
                this._scheduleLoadCallbacks(d);
                this._scheduleFailCallbacks(d);
                this._scheduleChangedCallbacks(d);
                var loadOperation = this._createLoadOperation(d);
                this._eventsStrategy.fireEvent("customizeStoreLoadOptions", [loadOperation]);
                this._loadQueue.add(function() {
                    if ("number" === typeof loadOperation.delay) {
                        _this7._delayedLoadTask = _common2.default.executeAsync(loadTask, loadOperation.delay)
                    } else {
                        loadTask()
                    }
                    return d.promise()
                });
                return d.promise({
                    operationId: loadOperation.operationId
                })
            },
            _onPush: function(changes) {
                var _this8 = this;
                if (this._reshapeOnPush) {
                    this.load()
                } else {
                    this._eventsStrategy.fireEvent("changing", [{
                        changes: changes
                    }]);
                    var group = this.group();
                    var items = this.items();
                    var groupLevel = 0;
                    var dataSourceChanges = this.paginate() || group ? changes.filter(function(item) {
                        return "update" === item.type
                    }) : changes;
                    if (group) {
                        groupLevel = Array.isArray(group) ? group.length : 1
                    }
                    if (this._mapFunc) {
                        dataSourceChanges.forEach(function(item) {
                            if ("insert" === item.type) {
                                item.data = _this8._mapFunc(item.data)
                            }
                        })
                    }
                    _array_utils2.default.applyBatch(this.store(), items, dataSourceChanges, groupLevel, true);
                    this._fireChanged([{
                        changes: changes
                    }])
                }
            },
            _createLoadOperation: function(deferred) {
                var _this9 = this;
                var operationId = this._operationManager.add(deferred);
                var storeLoadOptions = this._createStoreLoadOptions();
                deferred.always(function() {
                    return _this9._operationManager.remove(operationId)
                });
                return {
                    operationId: operationId,
                    storeLoadOptions: storeLoadOptions
                }
            },
            reload: function() {
                var store = this.store();
                if (store instanceof _custom_store2.default) {
                    store.clearRawDataCache()
                }
                this._init();
                return this.load()
            },
            cancel: function(operationId) {
                return this._operationManager.cancel(operationId)
            },
            cancelAll: function() {
                return this._operationManager.cancelAll()
            },
            _addSearchOptions: function(storeLoadOptions) {
                if (this._disposed) {
                    return
                }
                if (this.store()._useDefaultSearch) {
                    this._addSearchFilter(storeLoadOptions)
                } else {
                    storeLoadOptions.searchOperation = this._searchOperation;
                    storeLoadOptions.searchValue = this._searchValue;
                    storeLoadOptions.searchExpr = this._searchExpr
                }
            },
            _createStoreLoadOptions: function() {
                var result = (0, _extend.extend)({}, this._storeLoadOptions);
                this._addSearchOptions(result);
                if (this._paginate) {
                    if (this._pageSize) {
                        result.skip = this._pageIndex * this._pageSize;
                        result.take = this._pageSize
                    }
                }
                result.userData = this._userData;
                return result
            },
            _addSearchFilter: function(storeLoadOptions) {
                var value = this._searchValue;
                var op = this._searchOperation;
                var selector = this._searchExpr;
                var searchFilter = [];
                if (!value) {
                    return
                }
                if (!selector) {
                    selector = "this"
                }
                if (!Array.isArray(selector)) {
                    selector = [selector]
                }(0, _iterator.each)(selector, function(i, item) {
                    if (searchFilter.length) {
                        searchFilter.push("or")
                    }
                    searchFilter.push([item, op, value])
                });
                if (storeLoadOptions.filter) {
                    storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter]
                } else {
                    storeLoadOptions.filter = searchFilter
                }
            },
            _loadFromStore: function(loadOptions, pendingDeferred) {
                var _this10 = this;
                var handleSuccess = function(data, extra) {
                    if (_this10._disposed) {
                        return
                    }
                    if (!(0, _utils2.isPending)(pendingDeferred)) {
                        return
                    }
                    var loadResult = (0, _extend.extend)((0, _utils2.normalizeLoadResult)(data, extra), loadOptions);
                    _this10._eventsStrategy.fireEvent("customizeLoadResult", [loadResult]);
                    (0, _deferred.when)(loadResult.data).done(function(data) {
                        loadResult.data = data;
                        _this10._processStoreLoadResult(loadResult, pendingDeferred)
                    }).fail(pendingDeferred.reject)
                };
                if (loadOptions.data) {
                    return (new _deferred.Deferred).resolve(loadOptions.data).done(handleSuccess)
                }
                return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject)
            },
            _processStoreLoadResult: function(loadResult, pendingDeferred) {
                var _this11 = this;
                var data = loadResult.data;
                var extra = loadResult.extra;
                var storeLoadOptions = loadResult.storeLoadOptions;
                var resolvePendingDeferred = function() {
                    _this11._isLoaded = true;
                    _this11._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
                    return pendingDeferred.resolve(data, extra)
                };
                var proceedLoadingTotalCount = function() {
                    _this11.store().totalCount(storeLoadOptions).done(function(count) {
                        extra.totalCount = count;
                        resolvePendingDeferred()
                    }).fail(pendingDeferred.reject)
                };
                if (this._disposed) {
                    return
                }
                data = this._applyPostProcessFunction(this._applyMapFunction(data));
                if (!(0, _type.isPlainObject)(extra)) {
                    extra = {}
                }
                this._items = data;
                if (!data.length || !this._paginate || this._pageSize && data.length < this._pageSize) {
                    this._isLastPage = true
                }
                if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
                    proceedLoadingTotalCount()
                } else {
                    resolvePendingDeferred()
                }
            },
            _applyMapFunction: function(data) {
                if (this._mapFunc) {
                    return (0, _utils2.mapDataRespectingGrouping)(data, this._mapFunc, this.group())
                }
                return data
            },
            _applyPostProcessFunction: function(data) {
                if (this._postProcessFunc) {
                    return this._postProcessFunc(data)
                }
                return data
            },
            on: function(eventName, eventHandler) {
                this._eventsStrategy.on(eventName, eventHandler);
                return this
            },
            off: function(eventName, eventHandler) {
                this._eventsStrategy.off(eventName, eventHandler);
                return this
            }
        })
    },
    /*!****************************!*\
      !*** external "window.ko" ***!
      \****************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports) {
        module.exports = window.ko
    },
    /*!***********************************************!*\
      !*** ./artifacts/transpiled/format_helper.js ***!
      \***********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var typeUtils = __webpack_require__( /*! ./core/utils/type */ 1);
        var dateUtils = __webpack_require__( /*! ./core/utils/date */ 24);
        var numberLocalization = __webpack_require__( /*! ./localization/number */ 49);
        var dateLocalization = __webpack_require__( /*! ./localization/date */ 35);
        var dependencyInjector = __webpack_require__( /*! ./core/utils/dependency_injector */ 56);
        __webpack_require__( /*! ./localization/currency */ 131);
        module.exports = dependencyInjector({
            format: function(value, _format) {
                var formatIsValid = typeUtils.isString(_format) && "" !== _format || typeUtils.isPlainObject(_format) || typeUtils.isFunction(_format);
                var valueIsValid = typeUtils.isNumeric(value) || typeUtils.isDate(value);
                if (!formatIsValid || !valueIsValid) {
                    return typeUtils.isDefined(value) ? value.toString() : ""
                }
                if (typeUtils.isFunction(_format)) {
                    return _format(value)
                }
                if (typeUtils.isString(_format)) {
                    _format = {
                        type: _format
                    }
                }
                if (typeUtils.isNumeric(value)) {
                    return numberLocalization.format(value, _format)
                }
                if (typeUtils.isDate(value)) {
                    return dateLocalization.format(value, _format)
                }
            },
            getTimeFormat: function(showSecond) {
                return showSecond ? "longtime" : "shorttime"
            },
            _normalizeFormat: function(format) {
                if (!Array.isArray(format)) {
                    return format
                }
                if (1 === format.length) {
                    return format[0]
                }
                return function(date) {
                    return format.map(function(formatPart) {
                        return dateLocalization.format(date, formatPart)
                    }).join(" ")
                }
            },
            getDateFormatByDifferences: function(dateDifferences, intervalFormat) {
                var resultFormat = [];
                var needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);
                if (needSpecialSecondFormatter) {
                    var secondFormatter = function(date) {
                        return date.getSeconds() + date.getMilliseconds() / 1e3 + "s"
                    };
                    resultFormat.push(secondFormatter)
                } else {
                    if (dateDifferences.millisecond) {
                        resultFormat.push("millisecond")
                    }
                }
                if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
                    resultFormat.unshift(this.getTimeFormat(dateDifferences.second))
                }
                if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
                    if (intervalFormat && "month" === intervalFormat) {
                        return "monthandyear"
                    } else {
                        resultFormat.unshift("shortdate");
                        return this._normalizeFormat(resultFormat)
                    }
                }
                if (dateDifferences.year && dateDifferences.month) {
                    return "monthandyear"
                }
                if (dateDifferences.year && dateDifferences.quarter) {
                    return "quarterandyear"
                }
                if (dateDifferences.year) {
                    return "year"
                }
                if (dateDifferences.quarter) {
                    return "quarter"
                }
                if (dateDifferences.month && dateDifferences.day) {
                    if (intervalFormat) {
                        var monthDayFormatter = function(date) {
                            return dateLocalization.getMonthNames("abbreviated")[date.getMonth()] + " " + dateLocalization.format(date, "day")
                        };
                        resultFormat.unshift(monthDayFormatter)
                    } else {
                        resultFormat.unshift("monthandday")
                    }
                    return this._normalizeFormat(resultFormat)
                }
                if (dateDifferences.month) {
                    return "month"
                }
                if (dateDifferences.day) {
                    if (intervalFormat) {
                        resultFormat.unshift("day")
                    } else {
                        var dayFormatter = function(date) {
                            return dateLocalization.format(date, "dayofweek") + ", " + dateLocalization.format(date, "day")
                        };
                        resultFormat.unshift(dayFormatter)
                    }
                    return this._normalizeFormat(resultFormat)
                }
                return this._normalizeFormat(resultFormat)
            },
            getDateFormatByTicks: function(ticks) {
                var maxDiff;
                var currentDiff;
                var i;
                if (ticks.length > 1) {
                    maxDiff = dateUtils.getDatesDifferences(ticks[0], ticks[1]);
                    for (i = 1; i < ticks.length - 1; i++) {
                        currentDiff = dateUtils.getDatesDifferences(ticks[i], ticks[i + 1]);
                        if (maxDiff.count < currentDiff.count) {
                            maxDiff = currentDiff
                        }
                    }
                } else {
                    maxDiff = {
                        year: true,
                        month: true,
                        day: true,
                        hour: ticks[0].getHours() > 0,
                        minute: ticks[0].getMinutes() > 0,
                        second: ticks[0].getSeconds() > 0,
                        millisecond: ticks[0].getMilliseconds() > 0
                    }
                }
                var resultFormat = this.getDateFormatByDifferences(maxDiff);
                return resultFormat
            },
            getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
                var dateUnitInterval;
                var dateDifferencesConverter = {
                    week: "day"
                };
                var correctDateDifferences = function(dateDifferences, tickInterval, value) {
                    switch (tickInterval) {
                        case "year":
                        case "quarter":
                            dateDifferences.month = value;
                        case "month":
                            dateDifferences.day = value;
                        case "week":
                        case "day":
                            dateDifferences.hour = value;
                        case "hour":
                            dateDifferences.minute = value;
                        case "minute":
                            dateDifferences.second = value;
                        case "second":
                            dateDifferences.millisecond = value
                    }
                };
                var correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
                    if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
                        if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                            differences.millisecond = true;
                            differences.second = false
                        }
                    } else {
                        if (!maxDate.getSeconds() && maxDate.getMinutes()) {
                            if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                                differences.second = true;
                                differences.minute = false
                            }
                        } else {
                            if (!maxDate.getMinutes() && maxDate.getHours()) {
                                if (maxDate.getHours() - minDate.getHours() === 1) {
                                    differences.minute = true;
                                    differences.hour = false
                                }
                            } else {
                                if (!maxDate.getHours() && maxDate.getDate() > 1) {
                                    if (maxDate.getDate() - minDate.getDate() === 1) {
                                        differences.hour = true;
                                        differences.day = false
                                    }
                                } else {
                                    if (1 === maxDate.getDate() && maxDate.getMonth()) {
                                        if (maxDate.getMonth() - minDate.getMonth() === 1) {
                                            differences.day = true;
                                            differences.month = false
                                        }
                                    } else {
                                        if (!maxDate.getMonth() && maxDate.getFullYear()) {
                                            if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                                                differences.month = true;
                                                differences.year = false
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                tickInterval = typeUtils.isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
                var dateDifferences = dateUtils.getDatesDifferences(startValue, endValue);
                if (startValue !== endValue) {
                    correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue)
                }
                dateUnitInterval = dateUtils.getDateUnitInterval(dateDifferences);
                correctDateDifferences(dateDifferences, dateUnitInterval, true);
                dateUnitInterval = dateUtils.getDateUnitInterval(tickInterval || "second");
                correctDateDifferences(dateDifferences, dateUnitInterval, false);
                dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
                var resultFormat = this.getDateFormatByDifferences(dateDifferences);
                return resultFormat
            }
        })
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/data/data_source/utils.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.normalizeDataSourceOptions = exports.normalizeLoadResult = exports.mapDataRespectingGrouping = exports.normalizeStoreLoadOptionAccessorArguments = exports.isPending = exports.CANCELED_TOKEN = void 0;
        var _ajax = __webpack_require__( /*! ../../core/utils/ajax */ 75);
        var _abstract_store = __webpack_require__( /*! ../abstract_store */ 103);
        var _abstract_store2 = _interopRequireDefault(_abstract_store);
        var _array_store = __webpack_require__( /*! ../array_store */ 70);
        var _array_store2 = _interopRequireDefault(_array_store);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _custom_store = __webpack_require__( /*! ../custom_store */ 118);
        var _custom_store2 = _interopRequireDefault(_custom_store);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _utils = __webpack_require__( /*! ../utils */ 42);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        exports.CANCELED_TOKEN = "canceled";
        exports.isPending = function(deferred) {
            return "pending" === deferred.state()
        };
        exports.normalizeStoreLoadOptionAccessorArguments = function(originalArguments) {
            switch (originalArguments.length) {
                case 0:
                    return;
                case 1:
                    return originalArguments[0]
            }
            return [].slice.call(originalArguments)
        };
        var mapGroup = function(group, level, mapper) {
            return (0, _iterator.map)(group, function(item) {
                var result = {
                    key: item.key,
                    items: mapRecursive(item.items, level - 1, mapper)
                };
                if ("aggregates" in item) {
                    result.aggregates = item.aggregates
                }
                return result
            })
        };
        var mapRecursive = function(items, level, mapper) {
            if (!Array.isArray(items)) {
                return items
            }
            return level ? mapGroup(items, level, mapper) : (0, _iterator.map)(items, mapper)
        };
        exports.mapDataRespectingGrouping = function(items, mapper, groupInfo) {
            var level = groupInfo ? (0, _utils.normalizeSortingInfo)(groupInfo).length : 0;
            return mapRecursive(items, level, mapper)
        };
        exports.normalizeLoadResult = function(data, extra) {
            var _data;
            if (null === (_data = data) || void 0 === _data ? void 0 : _data.data) {
                extra = data;
                data = data.data
            }
            if (!Array.isArray(data)) {
                data = [data]
            }
            return {
                data: data,
                extra: extra
            }
        };
        var createCustomStoreFromLoadFunc = function(options) {
            var storeConfig = {};
            (0, _iterator.each)(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
                storeConfig[this] = options[this];
                delete options[this]
            });
            return new _custom_store2.default(storeConfig)
        };
        var createStoreFromConfig = function(storeConfig) {
            var alias = storeConfig.type;
            delete storeConfig.type;
            return _abstract_store2.default.create(alias, storeConfig)
        };
        var createCustomStoreFromUrl = function(url, normalizationOptions) {
            return new _custom_store2.default({
                load: function() {
                    return (0, _ajax.sendRequest)({
                        url: url,
                        dataType: "json"
                    })
                },
                loadMode: null === normalizationOptions || void 0 === normalizationOptions ? void 0 : normalizationOptions.fromUrlLoadMode
            })
        };
        exports.normalizeDataSourceOptions = function(options, normalizationOptions) {
            var store;
            if ("string" === typeof options) {
                options = {
                    paginate: false,
                    store: createCustomStoreFromUrl(options, normalizationOptions)
                }
            }
            if (void 0 === options) {
                options = []
            }
            if (Array.isArray(options) || options instanceof _abstract_store2.default) {
                options = {
                    store: options
                }
            } else {
                options = (0, _extend.extend)({}, options)
            }
            if (void 0 === options.store) {
                options.store = []
            }
            store = options.store;
            if ("load" in options) {
                store = createCustomStoreFromLoadFunc(options)
            } else {
                if (Array.isArray(store)) {
                    store = new _array_store2.default(store)
                } else {
                    if ((0, _type.isPlainObject)(store)) {
                        store = createStoreFromConfig((0, _extend.extend)({}, store))
                    }
                }
            }
            options.store = store;
            return options
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/utils/console.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var isFunction = __webpack_require__( /*! ./type */ 1).isFunction;
        var noop = function() {};
        var getConsoleMethod = function(method) {
            if ("undefined" === typeof console || !isFunction(console[method])) {
                return noop
            }
            return console[method].bind(console)
        };
        var logger = {
            info: getConsoleMethod("info"),
            warn: getConsoleMethod("warn"),
            error: getConsoleMethod("error")
        };
        var debug = function() {
            function assert(condition, message) {
                if (!condition) {
                    throw new Error(message)
                }
            }

            function assertParam(parameter, message) {
                assert(null !== parameter && void 0 !== parameter, message)
            }
            return {
                assert: assert,
                assertParam: assertParam
            }
        }();
        exports.logger = logger;
        exports.debug = debug
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/ui/widget/selectors.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _focusable = function(element, tabIndex) {
            if (!visible(element)) {
                return false
            }
            var nodeName = element.nodeName.toLowerCase();
            var isTabIndexNotNaN = !isNaN(tabIndex);
            var isDisabled = element.disabled;
            var isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
            var isHyperlink = "a" === nodeName;
            var isFocusable = true;
            var isContentEditable = element.isContentEditable;
            if (isDefaultFocus || isContentEditable) {
                isFocusable = !isDisabled
            } else {
                if (isHyperlink) {
                    isFocusable = element.href || isTabIndexNotNaN
                } else {
                    isFocusable = isTabIndexNotNaN
                }
            }
            return isFocusable
        };

        function visible(element) {
            var $element = $(element);
            return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility")
        }
        module.exports = {
            focusable: function(index, element) {
                return _focusable(element, $(element).attr("tabIndex"))
            },
            tabbable: function(index, element) {
                var tabIndex = $(element).attr("tabIndex");
                return (isNaN(tabIndex) || tabIndex >= 0) && _focusable(element, tabIndex)
            },
            focused: function($element) {
                var element = $($element).get(0);
                return domAdapter.getActiveElement() === element
            }
        }
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/core/polyfills/promise.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var deferredUtils = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var windowUtils = __webpack_require__( /*! ../../core/utils/window */ 7);
        var Deferred = deferredUtils.Deferred;
        var when = deferredUtils.when;
        var promise = windowUtils.hasWindow() ? windowUtils.getWindow().Promise : Promise;
        if (!promise) {
            promise = function(resolver) {
                var d = new Deferred;
                resolver(d.resolve.bind(this), d.reject.bind(this));
                return d.promise()
            };
            promise.resolve = function(val) {
                return (new Deferred).resolve(val).promise()
            };
            promise.reject = function(val) {
                return (new Deferred).reject(val).promise()
            };
            promise.all = function(promises) {
                return when.apply(this, promises).then(function() {
                    return [].slice.call(arguments)
                })
            }
        }
        module.exports = promise
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/dom_component.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _config = __webpack_require__( /*! ./config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _errors = __webpack_require__( /*! ./errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _resize_callbacks = __webpack_require__( /*! ../core/utils/resize_callbacks */ 114);
        var _resize_callbacks2 = _interopRequireDefault(_resize_callbacks);
        var _component = __webpack_require__( /*! ./component */ 115);
        var _component2 = _interopRequireDefault(_component);
        var _template_manager = __webpack_require__( /*! ./template_manager */ 471);
        var _template_manager2 = _interopRequireDefault(_template_manager);
        var _public_component = __webpack_require__( /*! ./utils/public_component */ 139);
        var _element_data = __webpack_require__( /*! ./element_data */ 41);
        var _iterator = __webpack_require__( /*! ./utils/iterator */ 4);
        var _extend = __webpack_require__( /*! ./utils/extend */ 0);
        var _dom = __webpack_require__( /*! ../core/utils/dom */ 11);
        var _common = __webpack_require__( /*! ./utils/common */ 3);
        var _array = __webpack_require__( /*! ./utils/array */ 14);
        var _type = __webpack_require__( /*! ./utils/type */ 1);
        var _window = __webpack_require__( /*! ../core/utils/window */ 7);
        var _short = __webpack_require__( /*! ../events/short */ 116);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var abstract = _component2.default.abstract;
        var DOMComponent = _component2.default.inherit({
            _getDefaultOptions: function() {
                return (0, _extend.extend)(this.callBase(), {
                    width: void 0,
                    height: void 0,
                    rtlEnabled: (0, _config2.default)().rtlEnabled,
                    elementAttr: {},
                    disabled: false,
                    integrationOptions: {}
                }, this._useTemplates() ? _template_manager2.default.createDefaultOptions() : {})
            },
            ctor: function(element, options) {
                this._createElement(element);
                (0, _public_component.attachInstanceToElement)(this._$element, this, this._dispose);
                this.callBase(options)
            },
            _createElement: function(element) {
                this._$element = (0, _renderer2.default)(element)
            },
            _getSynchronizableOptionsForCreateComponent: function() {
                return ["rtlEnabled", "disabled", "templatesRenderAsynchronously"]
            },
            _visibilityChanged: abstract,
            _dimensionChanged: abstract,
            _init: function() {
                this.callBase();
                this._attachWindowResizeCallback();
                this._initTemplateManager()
            },
            _setOptionsByDevice: function(instanceCustomRules) {
                this.callBase([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []))
            },
            _isInitialOptionValue: function(name) {
                var isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name);
                return !isCustomOption && this.callBase(name)
            },
            _attachWindowResizeCallback: function() {
                if (this._isDimensionChangeSupported()) {
                    var windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
                    _resize_callbacks2.default.add(windowResizeCallBack)
                }
            },
            _isDimensionChangeSupported: function() {
                return this._dimensionChanged !== abstract
            },
            _renderComponent: function() {
                this._initMarkup();
                (0, _window.hasWindow)() && this._render()
            },
            _initMarkup: function() {
                var _ref = this.option() || {},
                    rtlEnabled = _ref.rtlEnabled;
                this._renderElementAttributes();
                this._toggleRTLDirection(rtlEnabled);
                this._renderVisibilityChange();
                this._renderDimensions()
            },
            _render: function() {
                this._attachVisibilityChangeHandlers()
            },
            _renderElementAttributes: function() {
                var _ref2 = this.option() || {},
                    elementAttr = _ref2.elementAttr;
                var attributes = (0, _extend.extend)({}, elementAttr);
                var classNames = attributes.class;
                delete attributes.class;
                this.$element().attr(attributes).addClass(classNames)
            },
            _renderVisibilityChange: function() {
                if (this._isDimensionChangeSupported()) {
                    this._attachDimensionChangeHandlers()
                }
                if (this._isVisibilityChangeSupported()) {
                    var $element = this.$element();
                    $element.addClass("dx-visibility-change-handler")
                }
            },
            _renderDimensions: function() {
                var $element = this.$element();
                var element = $element.get(0);
                var width = this._getOptionValue("width", element);
                var height = this._getOptionValue("height", element);
                if (this._isCssUpdateRequired(element, height, width)) {
                    $element.css({
                        width: null === width ? "" : width,
                        height: null === height ? "" : height
                    })
                }
            },
            _isCssUpdateRequired: function(element, height, width) {
                return !!((0, _type.isDefined)(width) || (0, _type.isDefined)(height) || element.style.width || element.style.height)
            },
            _attachDimensionChangeHandlers: function() {
                var _this = this;
                var $el = this.$element();
                var namespace = "".concat(this.NAME, "VisibilityChange");
                _short.resize.off($el, {
                    namespace: namespace
                });
                _short.resize.on($el, function() {
                    return _this._dimensionChanged()
                }, {
                    namespace: namespace
                })
            },
            _attachVisibilityChangeHandlers: function() {
                var _this2 = this;
                if (this._isVisibilityChangeSupported()) {
                    var $el = this.$element();
                    var namespace = "".concat(this.NAME, "VisibilityChange");
                    this._isHidden = !this._isVisible();
                    _short.visibility.off($el, {
                        namespace: namespace
                    });
                    _short.visibility.on($el, function() {
                        return _this2._checkVisibilityChanged("shown")
                    }, function() {
                        return _this2._checkVisibilityChanged("hiding")
                    }, {
                        namespace: namespace
                    })
                }
            },
            _isVisible: function() {
                var $element = this.$element();
                return $element.is(":visible")
            },
            _checkVisibilityChanged: function(action) {
                var isVisible = this._isVisible();
                if (isVisible) {
                    if ("hiding" === action && !this._isHidden) {
                        this._visibilityChanged(false);
                        this._isHidden = true
                    } else {
                        if ("shown" === action && this._isHidden) {
                            this._isHidden = false;
                            this._visibilityChanged(true)
                        }
                    }
                }
            },
            _isVisibilityChangeSupported: function() {
                return this._visibilityChanged !== abstract && (0, _window.hasWindow)()
            },
            _clean: _common.noop,
            _modelByElement: function() {
                var _this$option = this.option(),
                    modelByElement = _this$option.modelByElement;
                var $element = this.$element();
                return modelByElement ? modelByElement($element) : void 0
            },
            _invalidate: function() {
                if (this._isUpdateAllowed()) {
                    throw _errors2.default.Error("E0007")
                }
                this._requireRefresh = true
            },
            _refresh: function() {
                this._clean();
                this._renderComponent()
            },
            _dispose: function() {
                this._templateManager && this._templateManager.dispose();
                this.callBase();
                this._clean();
                this._detachWindowResizeCallback()
            },
            _detachWindowResizeCallback: function() {
                if (this._isDimensionChangeSupported()) {
                    _resize_callbacks2.default.remove(this._windowResizeCallBack)
                }
            },
            _toggleRTLDirection: function(rtl) {
                var $element = this.$element();
                $element.toggleClass("dx-rtl", rtl)
            },
            _createComponent: function(element, component) {
                var _this3 = this;
                var config = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                var synchronizableOptions = (0, _common.grep)(this._getSynchronizableOptionsForCreateComponent(), function(value) {
                    return !(value in config)
                });
                var _this$option2 = this.option(),
                    integrationOptions = _this$option2.integrationOptions;
                var _this$option3 = this.option(),
                    nestedComponentOptions = _this$option3.nestedComponentOptions;
                nestedComponentOptions = nestedComponentOptions || _common.noop;
                var nestedComponentConfig = (0, _extend.extend)({
                    integrationOptions: integrationOptions
                }, nestedComponentOptions(this));
                synchronizableOptions.forEach(function(optionName) {
                    return nestedComponentConfig[optionName] = _this3.option(optionName)
                });
                this._extendConfig(config, nestedComponentConfig);
                var instance = void 0;
                if ((0, _type.isString)(component)) {
                    var $element = (0, _renderer2.default)(element)[component](config);
                    instance = $element[component]("instance")
                } else {
                    if (element) {
                        instance = component.getInstance(element);
                        if (instance) {
                            instance.option(config)
                        } else {
                            instance = new component(element, config)
                        }
                    }
                }
                if (instance) {
                    var optionChangedHandler = function(_ref3) {
                        var name = _ref3.name,
                            value = _ref3.value;
                        if ((0, _array.inArray)(name, synchronizableOptions) >= 0) {
                            instance.option(name, value)
                        }
                    };
                    this.on("optionChanged", optionChangedHandler);
                    instance.on("disposing", function() {
                        return _this3.off("optionChanged", optionChangedHandler)
                    })
                }
                return instance
            },
            _extendConfig: function(config, extendConfig) {
                (0, _iterator.each)(extendConfig, function(key, value) {
                    !Object.prototype.hasOwnProperty.call(config, key) && (config[key] = value)
                })
            },
            _defaultActionConfig: function() {
                var $element = this.$element();
                var context = this._modelByElement($element);
                return (0, _extend.extend)(this.callBase(), {
                    context: context
                })
            },
            _defaultActionArgs: function() {
                var $element = this.$element();
                var model = this._modelByElement($element);
                var element = this.element();
                return (0, _extend.extend)(this.callBase(), {
                    element: element,
                    model: model
                })
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case "width":
                    case "height":
                        this._renderDimensions();
                        break;
                    case "rtlEnabled":
                        this._invalidate();
                        break;
                    case "elementAttr":
                        this._renderElementAttributes();
                        break;
                    case "disabled":
                    case "integrationOptions":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _removeAttributes: function(element) {
                var attrs = element.attributes;
                for (var i = attrs.length - 1; i >= 0; i--) {
                    var attr = attrs[i];
                    if (attr) {
                        var name = attr.name;
                        if (!name.indexOf("aria-") || name.indexOf("dx-") !== -1 || "role" === name || "style" === name || "tabindex" === name) {
                            element.removeAttribute(name)
                        }
                    }
                }
            },
            _removeClasses: function(element) {
                element.className = element.className.split(" ").filter(function(cssClass) {
                    return 0 !== cssClass.lastIndexOf("dx-", 0)
                }).join(" ")
            },
            _updateDOMComponent: function(renderRequired) {
                if (renderRequired) {
                    this._renderComponent()
                } else {
                    if (this._requireRefresh) {
                        this._requireRefresh = false;
                        this._refresh()
                    }
                }
            },
            endUpdate: function() {
                var renderRequired = this._isInitializingRequired();
                this.callBase();
                this._isUpdateAllowed() && this._updateDOMComponent(renderRequired)
            },
            $element: function() {
                return this._$element
            },
            element: function() {
                var $element = this.$element();
                return (0, _dom.getPublicElement)($element)
            },
            dispose: function() {
                var element = this.$element().get(0);
                (0, _element_data.cleanDataRecursive)(element, true);
                element.textContent = "";
                this._removeAttributes(element);
                this._removeClasses(element)
            },
            resetOption: function(optionName) {
                this.callBase(optionName);
                if ("width" === optionName || "height" === optionName) {
                    var initialOption = this.initialOption(optionName);
                    !(0, _type.isDefined)(initialOption) && this.$element().css(optionName, "")
                }
            },
            _getAnonymousTemplateName: function() {
                return
            },
            _initTemplateManager: function() {
                if (this._templateManager || !this._useTemplates()) {
                    return
                }
                var _this$option4 = this.option(),
                    _this$option4$integra = _this$option4.integrationOptions,
                    integrationOptions = void 0 === _this$option4$integra ? {} : _this$option4$integra;
                var createTemplate = integrationOptions.createTemplate;
                this._templateManager = new _template_manager2.default(createTemplate, this._getAnonymousTemplateName());
                this._initTemplates()
            },
            _initTemplates: function() {
                var _this4 = this;
                var _this$_templateManage = this._templateManager.extractTemplates(this.$element()),
                    templates = _this$_templateManage.templates,
                    anonymousTemplateMeta = _this$_templateManage.anonymousTemplateMeta;
                var anonymousTemplate = this.option("integrationOptions.templates.".concat(anonymousTemplateMeta.name));
                templates.forEach(function(_ref4) {
                    var name = _ref4.name,
                        template = _ref4.template;
                    _this4._options.silent("integrationOptions.templates.".concat(name), template)
                });
                if (anonymousTemplateMeta.name && !anonymousTemplate) {
                    this._options.silent("integrationOptions.templates.".concat(anonymousTemplateMeta.name), anonymousTemplateMeta.template)
                }
            },
            _getTemplateByOption: function(optionName) {
                return this._getTemplate(this.option(optionName))
            },
            _getTemplate: function(templateSource) {
                var templates = this.option("integrationOptions.templates");
                var isAsyncTemplate = this.option("templatesRenderAsynchronously");
                var skipTemplates = this.option("integrationOptions.skipTemplates");
                return this._templateManager.getTemplate(templateSource, templates, {
                    isAsyncTemplate: isAsyncTemplate,
                    skipTemplates: skipTemplates
                }, this)
            },
            _saveTemplate: function(name, template) {
                this._setOptionWithoutOptionChange("integrationOptions.templates." + name, this._templateManager._createTemplate(template))
            },
            _useTemplates: function() {
                return true
            }
        });
        DOMComponent.getInstance = function(element) {
            return (0, _public_component.getInstanceByElement)((0, _renderer2.default)(element), this)
        };
        DOMComponent.defaultOptions = function(rule) {
            this._classCustomRules = this._classCustomRules || [];
            this._classCustomRules.push(rule)
        };
        module.exports = DOMComponent
    },
    /*!*********************************************!*\
      !*** ./artifacts/transpiled/events/drag.js ***!
      \*********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../core/renderer */ 2);
        var dataUtils = __webpack_require__( /*! ../core/element_data */ 41);
        var wrapToArray = __webpack_require__( /*! ../core/utils/array */ 14).wrapToArray;
        var inArray = __webpack_require__( /*! ../core/utils/array */ 14).inArray;
        var iteratorUtils = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var contains = __webpack_require__( /*! ../core/utils/dom */ 11).contains;
        var registerEvent = __webpack_require__( /*! ./core/event_registrator */ 77);
        var eventUtils = __webpack_require__( /*! ./utils */ 8);
        var GestureEmitter = __webpack_require__( /*! ./gesture/emitter.gesture */ 166);
        var registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 101);
        var DRAG_START_EVENT = "dxdragstart";
        var DRAG_EVENT = "dxdrag";
        var DRAG_END_EVENT = "dxdragend";
        var DRAG_ENTER_EVENT = "dxdragenter";
        var DRAG_LEAVE_EVENT = "dxdragleave";
        var DROP_EVENT = "dxdrop";
        var DX_DRAG_EVENTS_COUNT_KEY = "dxDragEventsCount";
        var knownDropTargets = [];
        var knownDropTargetSelectors = [];
        var knownDropTargetConfigs = [];
        var dropTargetRegistration = {
            setup: function(element, data) {
                var knownDropTarget = inArray(element, knownDropTargets) !== -1;
                if (!knownDropTarget) {
                    knownDropTargets.push(element);
                    knownDropTargetSelectors.push([]);
                    knownDropTargetConfigs.push(data || {})
                }
            },
            add: function(element, handleObj) {
                var index = inArray(element, knownDropTargets);
                this.updateEventsCounter(element, handleObj.type, 1);
                var selector = handleObj.selector;
                if (inArray(selector, knownDropTargetSelectors[index]) === -1) {
                    knownDropTargetSelectors[index].push(selector)
                }
            },
            updateEventsCounter: function(element, event, value) {
                if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {
                    var eventsCount = dataUtils.data(element, DX_DRAG_EVENTS_COUNT_KEY) || 0;
                    dataUtils.data(element, DX_DRAG_EVENTS_COUNT_KEY, Math.max(0, eventsCount + value))
                }
            },
            remove: function(element, handleObj) {
                this.updateEventsCounter(element, handleObj.type, -1)
            },
            teardown: function(element) {
                var handlersCount = dataUtils.data(element, DX_DRAG_EVENTS_COUNT_KEY);
                if (!handlersCount) {
                    var index = inArray(element, knownDropTargets);
                    knownDropTargets.splice(index, 1);
                    knownDropTargetSelectors.splice(index, 1);
                    knownDropTargetConfigs.splice(index, 1);
                    dataUtils.removeData(element, DX_DRAG_EVENTS_COUNT_KEY)
                }
            }
        };
        registerEvent(DRAG_ENTER_EVENT, dropTargetRegistration);
        registerEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);
        registerEvent(DROP_EVENT, dropTargetRegistration);
        var getItemDelegatedTargets = function($element) {
            var dropTargetIndex = inArray($element.get(0), knownDropTargets);
            var dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter(function(selector) {
                return selector
            });
            var $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
            if (inArray(void 0, knownDropTargetSelectors[dropTargetIndex]) !== -1) {
                $delegatedTargets = $delegatedTargets.add($element)
            }
            return $delegatedTargets
        };
        var getItemConfig = function($element) {
            var dropTargetIndex = inArray($element.get(0), knownDropTargets);
            return knownDropTargetConfigs[dropTargetIndex]
        };
        var getItemPosition = function(dropTargetConfig, $element) {
            if (dropTargetConfig.itemPositionFunc) {
                return dropTargetConfig.itemPositionFunc($element)
            } else {
                return $element.offset()
            }
        };
        var getItemSize = function(dropTargetConfig, $element) {
            if (dropTargetConfig.itemSizeFunc) {
                return dropTargetConfig.itemSizeFunc($element)
            }
            return {
                width: $element.get(0).getBoundingClientRect().width,
                height: $element.get(0).getBoundingClientRect().height
            }
        };
        var DragEmitter = GestureEmitter.inherit({
            ctor: function(element) {
                this.callBase(element);
                this.direction = "both"
            },
            _init: function(e) {
                this._initEvent = e
            },
            _start: function(e) {
                e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
                this._maxLeftOffset = e.maxLeftOffset;
                this._maxRightOffset = e.maxRightOffset;
                this._maxTopOffset = e.maxTopOffset;
                this._maxBottomOffset = e.maxBottomOffset;
                var dropTargets = wrapToArray(e.targetElements || (null === e.targetElements ? [] : knownDropTargets));
                this._dropTargets = iteratorUtils.map(dropTargets, function(element) {
                    return $(element).get(0)
                })
            },
            _move: function(e) {
                var eventData = eventUtils.eventData(e);
                var dragOffset = this._calculateOffset(eventData);
                e = this._fireEvent(DRAG_EVENT, e, {
                    offset: dragOffset
                });
                this._processDropTargets(e);
                if (!e._cancelPreventDefault) {
                    e.preventDefault()
                }
            },
            _calculateOffset: function(eventData) {
                return {
                    x: this._calculateXOffset(eventData),
                    y: this._calculateYOffset(eventData)
                }
            },
            _calculateXOffset: function(eventData) {
                if ("vertical" !== this.direction) {
                    var offset = eventData.x - this._startEventData.x;
                    return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset)
                }
                return 0
            },
            _calculateYOffset: function(eventData) {
                if ("horizontal" !== this.direction) {
                    var offset = eventData.y - this._startEventData.y;
                    return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset)
                }
                return 0
            },
            _fitOffset: function(offset, minOffset, maxOffset) {
                if (null != minOffset) {
                    offset = Math.max(offset, -minOffset)
                }
                if (null != maxOffset) {
                    offset = Math.min(offset, maxOffset)
                }
                return offset
            },
            _processDropTargets: function(e) {
                var target = this._findDropTarget(e);
                var sameTarget = target === this._currentDropTarget;
                if (!sameTarget) {
                    this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
                    this._currentDropTarget = target;
                    this._fireDropTargetEvent(e, DRAG_ENTER_EVENT)
                }
            },
            _fireDropTargetEvent: function(event, eventName) {
                if (!this._currentDropTarget) {
                    return
                }
                var eventData = {
                    type: eventName,
                    originalEvent: event,
                    draggingElement: this._$element.get(0),
                    target: this._currentDropTarget
                };
                eventUtils.fireEvent(eventData)
            },
            _findDropTarget: function(e) {
                var that = this;
                var result;
                iteratorUtils.each(knownDropTargets, function(_, target) {
                    if (!that._checkDropTargetActive(target)) {
                        return
                    }
                    var $target = $(target);
                    iteratorUtils.each(getItemDelegatedTargets($target), function(_, delegatedTarget) {
                        var $delegatedTarget = $(delegatedTarget);
                        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, e)) {
                            result = delegatedTarget
                        }
                    })
                });
                return result
            },
            _checkDropTargetActive: function(target) {
                var active = false;
                iteratorUtils.each(this._dropTargets, function(_, activeTarget) {
                    active = active || activeTarget === target || contains(activeTarget, target);
                    return !active
                });
                return active
            },
            _checkDropTarget: function(config, $target, e) {
                var isDraggingElement = $target.get(0) === $(e.target).get(0);
                if (isDraggingElement) {
                    return false
                }
                var targetPosition = getItemPosition(config, $target);
                if (e.pageX < targetPosition.left) {
                    return false
                }
                if (e.pageY < targetPosition.top) {
                    return false
                }
                var targetSize = getItemSize(config, $target);
                if (e.pageX > targetPosition.left + targetSize.width) {
                    return false
                }
                if (e.pageY > targetPosition.top + targetSize.height) {
                    return false
                }
                if (config.checkDropTarget && !config.checkDropTarget($target, e)) {
                    return false
                }
                return $target
            },
            _end: function(e) {
                var eventData = eventUtils.eventData(e);
                this._fireEvent(DRAG_END_EVENT, e, {
                    offset: this._calculateOffset(eventData)
                });
                this._fireDropTargetEvent(e, DROP_EVENT);
                delete this._currentDropTarget
            }
        });
        registerEmitter({
            emitter: DragEmitter,
            events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
        });
        exports.dropTargets = knownDropTargets;
        exports.move = DRAG_EVENT;
        exports.start = DRAG_START_EVENT;
        exports.end = DRAG_END_EVENT;
        exports.enter = DRAG_ENTER_EVENT;
        exports.leave = DRAG_LEAVE_EVENT;
        exports.drop = DROP_EVENT
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/data/array_store.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ./utils */ 42);
        var _query = __webpack_require__( /*! ./query */ 45);
        var _query2 = _interopRequireDefault(_query);
        var _errors = __webpack_require__( /*! ./errors */ 38);
        var _abstract_store = __webpack_require__( /*! ./abstract_store */ 103);
        var _abstract_store2 = _interopRequireDefault(_abstract_store);
        var _array_utils = __webpack_require__( /*! ./array_utils */ 142);
        var _array_utils2 = _interopRequireDefault(_array_utils);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var ArrayStore = _abstract_store2.default.inherit({
            ctor: function(options) {
                if (Array.isArray(options)) {
                    options = {
                        data: options
                    }
                } else {
                    options = options || {}
                }
                this.callBase(options);
                var initialArray = options.data;
                if (initialArray && !Array.isArray(initialArray)) {
                    throw _errors.errors.Error("E4006")
                }
                this._array = initialArray || []
            },
            createQuery: function() {
                return (0, _query2.default)(this._array, {
                    errorHandler: this._errorHandler
                })
            },
            _byKeyImpl: function(key) {
                var index = _array_utils2.default.indexByKey(this, this._array, key);
                if (index === -1) {
                    return (0, _utils.rejectedPromise)(_errors.errors.Error("E4009"))
                }
                return (0, _utils.trivialPromise)(this._array[index])
            },
            _insertImpl: function(values) {
                return _array_utils2.default.insert(this, this._array, values)
            },
            _pushImpl: function(changes) {
                _array_utils2.default.applyBatch(this, this._array, changes)
            },
            _updateImpl: function(key, values) {
                return _array_utils2.default.update(this, this._array, key, values)
            },
            _removeImpl: function(key) {
                return _array_utils2.default.remove(this, this._array, key)
            },
            clear: function() {
                this._eventsStrategy.fireEvent("modifying");
                this._array = [];
                this._eventsStrategy.fireEvent("modified")
            }
        }, "array");
        module.exports = ArrayStore
    }, , ,
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tree_map.base.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _common = __webpack_require__( /*! ./common */ 266);
        var _node = __webpack_require__( /*! ./node */ 175);
        var _node2 = _interopRequireDefault(_node);
        var _tiling = __webpack_require__( /*! ./tiling */ 128);
        var _colorizing = __webpack_require__( /*! ./colorizing */ 129);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _common2 = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend2 = __webpack_require__( /*! ../../core/utils/extend */ 0);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _max = Math.max;
        var directions = {
            lefttoprightbottom: [1, 1],
            leftbottomrighttop: [1, -1],
            righttopleftbottom: [-1, 1],
            rightbottomlefttop: [-1, -1]
        };
        __webpack_require__( /*! ./tiling.squarified */ 437);
        __webpack_require__( /*! ./tiling */ 128).setDefaultAlgorithm("squarified");
        __webpack_require__( /*! ./colorizing.discrete */ 439);
        __webpack_require__( /*! ./colorizing */ 129).setDefaultColorizer("discrete");

        function pickPositiveInteger(val) {
            return val > 0 ? Math.round(val) : 0
        }
        var dxTreeMap = __webpack_require__( /*! ../core/base_widget */ 102).inherit({
            _handlers: {
                beginBuildNodes: _common2.noop,
                buildNode: _common2.noop,
                endBuildNodes: _common2.noop,
                setTrackerData: _common2.noop,
                calculateState: function(options) {
                    return (0, _common.buildRectAppearance)(options)
                }
            },
            _rootClass: "dxtm-tree-map",
            _rootClassPrefix: "dxtm",
            _getDefaultSize: function() {
                return {
                    width: 400,
                    height: 400
                }
            },
            _setDeprecatedOptions: function() {
                this.callBase.apply(this, arguments);
                (0, _extend2.extend)(this._deprecatedOptions, {
                    resolveLabelOverflow: {
                        since: "19.1",
                        message: "Use the 'tile.label.overflow' and 'group.label.textOverflow' option instead"
                    }
                })
            },
            _themeSection: "treeMap",
            _fontFields: ["tile.label.font", "group.label.font"],
            _init: function() {
                var that = this;
                that._rectOffsets = {};
                that._handlers = Object.create(that._handlers);
                that._context = {
                    suspend: function() {
                        if (!that._applyingChanges) {
                            that._suspendChanges()
                        }
                    },
                    resume: function() {
                        if (!that._applyingChanges) {
                            that._resumeChanges()
                        }
                    },
                    change: function(codes) {
                        that._change(codes)
                    },
                    settings: [{}, {}],
                    calculateState: that._handlers.calculateState,
                    calculateLabelState: _common.buildTextAppearance
                };
                that._root = that._topNode = {
                    nodes: []
                };
                that.callBase.apply(that, arguments)
            },
            _initialChanges: ["DATA_SOURCE"],
            _initCore: function() {
                var that = this;
                var renderer = that._renderer;
                that._createProxyType();
                that._tilesGroup = renderer.g().linkOn(renderer.root, "tiles").linkAppend();
                that._labelsGroup = renderer.g().linkOn(renderer.root, "labels").linkAppend()
            },
            _createProxyType: _common2.noop,
            _disposeCore: function() {
                var that = this;
                that._filter && that._filter.dispose();
                that._labelsGroup.linkOff();
                that._tilesGroup.linkOff()
            },
            _applySize: function(rect) {
                this._tilingRect = rect.slice();
                this._change(["TILING"])
            },
            _optionChangesMap: {
                dataSource: "DATA_SOURCE",
                valueField: "NODES_CREATE",
                childrenField: "NODES_CREATE",
                colorField: "TILES",
                colorizer: "TILES",
                labelField: "LABELS",
                tile: "TILE_SETTINGS",
                group: "GROUP_SETTINGS",
                maxDepth: "MAX_DEPTH",
                layoutAlgorithm: "TILING",
                layoutDirection: "TILING",
                resolveLabelOverflow: "LABEL_OVERFLOW"
            },
            _themeDependentChanges: ["TILE_SETTINGS", "GROUP_SETTINGS", "MAX_DEPTH"],
            _changeDataSource: function() {
                var that = this;
                that._isDataExpected = that._isSyncData = true;
                that._updateDataSource();
                that._isSyncData = false;
                if (that._isDataExpected) {
                    that._suspendChanges()
                }
            },
            _dataSourceChangedHandler: function() {
                var that = this;
                if (that._isDataExpected) {
                    that._isDataExpected = false;
                    that._change(["NODES_CREATE"]);
                    if (!that._isSyncData) {
                        that._resumeChanges()
                    }
                } else {
                    that._requestChange(["NODES_CREATE"])
                }
            },
            _optionChangesOrder: ["DATA_SOURCE", "TILE_SETTINGS", "GROUP_SETTINGS", "MAX_DEPTH", "LABEL_OVERFLOW"],
            _change_DATA_SOURCE: function() {
                this._changeDataSource()
            },
            _change_TILE_SETTINGS: function() {
                this._changeTileSettings()
            },
            _change_GROUP_SETTINGS: function() {
                this._changeGroupSettings()
            },
            _change_LABEL_OVERFLOW: function() {
                this._changeTileSettings();
                this._changeGroupSettings()
            },
            _change_MAX_DEPTH: function() {
                this._changeMaxDepth()
            },
            _customChangesOrder: ["NODES_CREATE", "NODES_RESET", "TILES", "LABELS", "TILING", "LABELS_LAYOUT"],
            _change_NODES_CREATE: function() {
                this._buildNodes()
            },
            _change_NODES_RESET: function() {
                this._resetNodes()
            },
            _change_TILES: function() {
                this._applyTilesAppearance()
            },
            _change_LABELS: function() {
                this._applyLabelsAppearance()
            },
            _change_TILING: function() {
                this._performTiling()
            },
            _change_LABELS_LAYOUT: function() {
                this._performLabelsLayout()
            },
            _applyChanges: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                if (!that._isDataExpected) {
                    that._drawn()
                }
                that._context.forceReset = false
            },
            _buildNodes: function() {
                var that = this;
                var root = that._root = that._topNode = new _node2.default;
                root._id = 0;
                root.parent = {};
                root.data = {};
                root.level = root.index = -1;
                root.ctx = that._context;
                root.label = null;
                that._nodes = [root];
                that._handlers.beginBuildNodes();
                var processedData = that._processDataSourceItems(that._dataSourceItems() || []);
                traverseDataItems(root, processedData.items, 0, {
                    itemsField: !processedData.isPlain && that._getOption("childrenField", true) || "items",
                    valueField: that._getOption("valueField", true) || "value",
                    buildNode: that._handlers.buildNode,
                    ctx: that._context,
                    nodes: that._nodes
                });
                that._onNodesCreated();
                that._handlers.endBuildNodes();
                that._change(["NODES_RESET"])
            },
            _onNodesCreated: _common2.noop,
            _processDataSourceItems: function(items) {
                return {
                    items: items,
                    isPlain: false
                }
            },
            _changeTileSettings: function() {
                var that = this;
                var options = that._getOption("tile");
                var offsets = that._rectOffsets;
                var borderWidth = pickPositiveInteger(options.border.width);
                var edgeOffset = borderWidth / 2;
                var innerOffset = 1 & borderWidth ? .5 : 0;
                var labelOptions = options.label;
                var settings = that._context.settings[0];
                that._change(["TILES", "LABELS"]);
                settings.state = that._handlers.calculateState(options);
                that._filter = that._filter || that._renderer.shadowFilter("-50%", "-50%", "200%", "200%");
                that._filter.attr(labelOptions.shadow);
                that._calculateLabelSettings(settings, labelOptions, that._filter.id);
                if (offsets.tileEdge !== edgeOffset || offsets.tileInner !== innerOffset) {
                    offsets.tileEdge = edgeOffset;
                    offsets.tileInner = innerOffset;
                    that._change(["TILING"])
                }
            },
            _changeGroupSettings: function() {
                var that = this;
                var options = that._getOption("group");
                var labelOptions = options.label;
                var offsets = that._rectOffsets;
                var borderWidth = pickPositiveInteger(options.border.width);
                var edgeOffset = borderWidth / 2;
                var innerOffset = 1 & borderWidth ? .5 : 0;
                var headerHeight = 0;
                var groupPadding = pickPositiveInteger(options.padding);
                var settings = that._context.settings[1];
                that._change(["TILES", "LABELS"]);
                settings.state = that._handlers.calculateState(options);
                that._calculateLabelSettings(settings, labelOptions);
                if (options.headerHeight >= 0) {
                    headerHeight = pickPositiveInteger(options.headerHeight)
                } else {
                    headerHeight = settings.labelParams.height + 2 * pickPositiveInteger(labelOptions.paddingTopBottom)
                }
                if (that._headerHeight !== headerHeight) {
                    that._headerHeight = headerHeight;
                    that._change(["TILING"])
                }
                if (that._groupPadding !== groupPadding) {
                    that._groupPadding = groupPadding;
                    that._change(["TILING"])
                }
                if (offsets.headerEdge !== edgeOffset || offsets.headerInner !== innerOffset) {
                    offsets.headerEdge = edgeOffset;
                    offsets.headerInner = innerOffset;
                    that._change(["TILING"])
                }
            },
            _calculateLabelSettings: function(settings, options, filter) {
                var bBox = this._getTextBBox(options.font);
                var paddingLeftRight = pickPositiveInteger(options.paddingLeftRight);
                var paddingTopBottom = pickPositiveInteger(options.paddingTopBottom);
                var tileLabelOptions = this._getOption("tile.label");
                var groupLabelOptions = this._getOption("group.label");
                settings.labelState = (0, _common.buildTextAppearance)(options, filter);
                settings.labelState.visible = !("visible" in options) || !!options.visible;
                settings.labelParams = {
                    height: bBox.height,
                    rtlEnabled: this._getOption("rtlEnabled", true),
                    paddingTopBottom: paddingTopBottom,
                    paddingLeftRight: paddingLeftRight,
                    resolveLabelOverflow: this._options.silent("resolveLabelOverflow"),
                    tileLabelWordWrap: tileLabelOptions.wordWrap,
                    tileLabelOverflow: tileLabelOptions.textOverflow,
                    groupLabelOverflow: groupLabelOptions.textOverflow
                }
            },
            _changeMaxDepth: function() {
                var maxDepth = this._getOption("maxDepth", true);
                maxDepth = maxDepth >= 1 ? Math.round(maxDepth) : 1 / 0;
                if (this._maxDepth !== maxDepth) {
                    this._maxDepth = maxDepth;
                    this._change(["NODES_RESET"])
                }
            },
            _resetNodes: function() {
                var that = this;
                that._tilesGroup.clear();
                that._renderer.initHatching();
                that._context.forceReset = true;
                that._context.minLevel = that._topNode.level + 1;
                that._context.maxLevel = that._context.minLevel + that._maxDepth - 1;
                that._change(["TILES", "LABELS", "TILING"])
            },
            _processNodes: function(context, process) {
                processNodes(context, this._topNode, process)
            },
            _applyTilesAppearance: function() {
                var that = this;
                var colorizer = (0, _colorizing.getColorizer)(that._getOption("colorizer"), that._themeManager, that._topNode);
                that._processNodes({
                    renderer: that._renderer,
                    group: that._tilesGroup,
                    setTrackerData: that._handlers.setTrackerData,
                    colorField: that._getOption("colorField", true) || "color",
                    getColor: colorizer
                }, processTileAppearance)
            },
            _applyLabelsAppearance: function() {
                var that = this;
                that._labelsGroup.clear();
                that._processNodes({
                    renderer: that._renderer,
                    group: that._labelsGroup,
                    setTrackerData: that._handlers.setTrackerData,
                    labelField: that._getOption("labelField", true) || "name"
                }, processLabelAppearance);
                that._change(["LABELS_LAYOUT"])
            },
            _performTiling: function() {
                var that = this;
                var context = {
                    algorithm: (0, _tiling.getAlgorithm)(that._getOption("layoutAlgorithm", true)),
                    directions: directions[String(that._getOption("layoutDirection", true)).toLowerCase()] || directions.lefttoprightbottom,
                    headerHeight: that._headerHeight,
                    groupPadding: that._groupPadding,
                    rectOffsets: that._rectOffsets
                };
                that._topNode.innerRect = that._tilingRect;
                calculateRects(context, that._topNode);
                that._processNodes(context, processTiling);
                that._change(["LABELS_LAYOUT"]);
                that._onTilingPerformed()
            },
            _onTilingPerformed: _common2.noop,
            _performLabelsLayout: function() {
                this._processNodes(null, processLabelsLayout)
            },
            _getTextBBox: function(fontOptions) {
                var renderer = this._renderer;
                var text = this._textForCalculations || renderer.text("0", 0, 0);
                this._textForCalculations = text;
                text.css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);
                var bBox = text.getBBox();
                text.remove();
                return bBox
            }
        });

        function traverseDataItems(root, dataItems, level, params) {
            var nodes = [];
            var allNodes = params.nodes;
            var node;
            var i;
            var ii = dataItems.length;
            var dataItem;
            var totalValue = 0;
            var items;
            for (i = 0; i < ii; ++i) {
                var _items;
                dataItem = dataItems[i];
                node = new _node2.default;
                node._id = allNodes.length;
                node.ctx = params.ctx;
                node.parent = root;
                node.level = level;
                node.index = nodes.length;
                node.data = dataItem;
                params.buildNode(node);
                allNodes.push(node);
                nodes.push(node);
                items = dataItem[params.itemsField];
                if (null === (_items = items) || void 0 === _items ? void 0 : _items.length) {
                    traverseDataItems(node, items, level + 1, params)
                }
                if (dataItem[params.valueField] > 0) {
                    node.value = Number(dataItem[params.valueField])
                }
                totalValue += node.value
            }
            root.nodes = nodes;
            root.value = totalValue
        }

        function processNodes(context, root, process) {
            var nodes = root.nodes;
            var node;
            var i;
            var ii = nodes.length;
            for (i = 0; i < ii; ++i) {
                node = nodes[i];
                process(context, node);
                if (node.isNode()) {
                    processNodes(context, node, process)
                }
            }
        }
        var createTile = [createLeaf, createGroup];

        function processTileAppearance(context, node) {
            node.color = node.data[context.colorField] || context.getColor(node) || node.parent.color;
            node.updateStyles();
            node.tile = !node.ctx.forceReset && node.tile || createTile[Number(node.isNode())](context, node);
            node.applyState()
        }

        function createLeaf(context, node) {
            var tile = context.renderer.simpleRect().append(context.group);
            context.setTrackerData(node, tile);
            return tile
        }

        function createGroup(context, node) {
            var outer = context.renderer.simpleRect().append(context.group);
            var inner = context.renderer.simpleRect().append(context.group);
            context.setTrackerData(node, inner);
            return {
                outer: outer,
                inner: inner
            }
        }

        function processLabelAppearance(context, node) {
            node.updateLabelStyle();
            if (node.labelState.visible) {
                createLabel(context, node, node.labelState, node.labelParams)
            }
        }

        function createLabel(context, currentNode, settings, params) {
            var textData = currentNode.data[context.labelField];
            currentNode.label = textData ? String(textData) : null;
            textData = currentNode.customLabel || currentNode.label;
            if (textData) {
                currentNode.text = context.renderer.text(textData).attr(settings.attr).css(settings.css).append(context.group);
                context.setTrackerData(currentNode, currentNode.text)
            }
        }
        var emptyRect = [0, 0, 0, 0];

        function calculateRects(context, root) {
            var nodes = root.nodes;
            var items = [];
            var rects = [];
            var sum = 0;
            var i;
            var ii = items.length = rects.length = nodes.length;
            for (i = 0; i < ii; ++i) {
                sum += nodes[i].value;
                items[i] = {
                    value: nodes[i].value,
                    i: i
                }
            }
            if (sum > 0) {
                context.algorithm({
                    items: items.slice(),
                    sum: sum,
                    rect: root.innerRect.slice(),
                    isRotated: 1 & nodes[0].level,
                    directions: context.directions
                })
            }
            for (i = 0; i < ii; ++i) {
                rects[i] = items[i].rect || emptyRect
            }
            root.rects = rects
        }

        function processTiling(context, node) {
            var rect = node.parent.rects[node.index];
            var rectOffsets = context.rectOffsets;
            var headerHeight;
            if (node.isNode()) {
                setRectAttrs(node.tile.outer, buildTileRect(rect, node.parent.innerRect, rectOffsets.headerEdge, rectOffsets.headerInner));
                rect = marginateRect(rect, context.groupPadding);
                headerHeight = Math.min(context.headerHeight, rect[3] - rect[1]);
                node.rect = [rect[0], rect[1], rect[2], rect[1] + headerHeight];
                setRectAttrs(node.tile.inner, marginateRect(node.rect, rectOffsets.headerEdge));
                rect[1] += headerHeight;
                node.innerRect = rect;
                calculateRects(context, node)
            } else {
                node.rect = rect;
                setRectAttrs(node.tile, buildTileRect(rect, node.parent.innerRect, rectOffsets.tileEdge, rectOffsets.tileInner))
            }
        }

        function marginateRect(rect, margin) {
            return [rect[0] + margin, rect[1] + margin, rect[2] - margin, rect[3] - margin]
        }

        function buildTileRect(rect, outer, edgeOffset, innerOffset) {
            return [rect[0] + (rect[0] === outer[0] ? edgeOffset : +innerOffset), rect[1] + (rect[1] === outer[1] ? edgeOffset : +innerOffset), rect[2] - (rect[2] === outer[2] ? edgeOffset : -innerOffset), rect[3] - (rect[3] === outer[3] ? edgeOffset : -innerOffset)]
        }

        function setRectAttrs(element, rect) {
            element.attr({
                x: rect[0],
                y: rect[1],
                width: _max(rect[2] - rect[0], 0),
                height: _max(rect[3] - rect[1], 0)
            })
        }

        function processLabelsLayout(context, node) {
            if (node.text && node.labelState.visible) {
                layoutTextNode(node, node.labelParams)
            }
        }

        function layoutTextNode(node, params) {
            var rect = node.rect;
            var text = node.text;
            var bBox = text.getBBox();
            var paddingLeftRight = params.paddingLeftRight;
            var paddingTopBottom = params.paddingTopBottom;
            var effectiveWidth = rect[2] - rect[0] - 2 * paddingLeftRight;
            var fitByHeight = bBox.height + paddingTopBottom <= rect[3] - rect[1];
            var fitByWidth = bBox.width <= effectiveWidth;
            var resolveLabelOverflow = params.resolveLabelOverflow;
            var groupLabelOverflow = params.groupLabelOverflow;
            var tileLabelOverflow = params.tileLabelOverflow;
            var tileLabelWordWrap = params.tileLabelWordWrap;
            if ((0, _type.isDefined)(resolveLabelOverflow)) {
                if ("ellipsis" === resolveLabelOverflow && fitByHeight) {
                    text.setMaxSize(effectiveWidth, void 0, {
                        wordWrap: "none",
                        textOverflow: "ellipsis"
                    });
                    if (!fitByWidth) {
                        bBox = text.getBBox();
                        fitByWidth = bBox.width <= effectiveWidth
                    }
                }
            } else {
                fitByWidth = true;
                fitByHeight = true;
                text.setMaxSize(effectiveWidth, rect[3] - rect[1] - paddingTopBottom, node.isNode() ? {
                    textOverflow: groupLabelOverflow,
                    wordWrap: "none"
                } : {
                    textOverflow: tileLabelOverflow,
                    wordWrap: tileLabelWordWrap,
                    hideOverflowEllipsis: true
                })
            }
            text.attr({
                visibility: fitByHeight && fitByWidth ? "visible" : "hidden"
            });
            if (fitByHeight && fitByWidth) {
                text.move(params.rtlEnabled ? rect[2] - paddingLeftRight - bBox.x - bBox.width : rect[0] + paddingLeftRight - bBox.x, rect[1] + paddingTopBottom - bBox.y)
            }
        }
        __webpack_require__( /*! ../../core/component_registrator */ 9)("dxTreeMap", dxTreeMap);
        module.exports = dxTreeMap;
        dxTreeMap.addPlugin(__webpack_require__( /*! ../core/data_source */ 152).plugin)
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/animation/position.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../core/renderer */ 2);
        var commonUtils = __webpack_require__( /*! ../core/utils/common */ 3);
        var each = __webpack_require__( /*! ../core/utils/iterator */ 4).each;
        var windowUtils = __webpack_require__( /*! ../core/utils/window */ 7);
        var window = windowUtils.getWindow();
        var domAdapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var isWindow = __webpack_require__( /*! ../core/utils/type */ 1).isWindow;
        var extend = __webpack_require__( /*! ../core/utils/extend */ 0).extend;
        var getBoundingRect = __webpack_require__( /*! ../core/utils/position */ 21).getBoundingRect;
        var browser = __webpack_require__( /*! ../core/utils/browser */ 26);
        var translator = __webpack_require__( /*! ./translator */ 28);
        var support = __webpack_require__( /*! ../core/utils/support */ 46);
        var horzRe = /left|right/;
        var vertRe = /top|bottom/;
        var collisionRe = /fit|flip|none/;
        var IS_SAFARI = browser.safari;
        var normalizeAlign = function(raw) {
            var result = {
                h: "center",
                v: "center"
            };
            var pair = commonUtils.splitPair(raw);
            if (pair) {
                each(pair, function() {
                    var w = String(this).toLowerCase();
                    if (horzRe.test(w)) {
                        result.h = w
                    } else {
                        if (vertRe.test(w)) {
                            result.v = w
                        }
                    }
                })
            }
            return result
        };
        var normalizeOffset = function(raw) {
            return commonUtils.pairToObject(raw)
        };
        var normalizeCollision = function(raw) {
            var pair = commonUtils.splitPair(raw);
            var h = String(pair && pair[0]).toLowerCase();
            var v = String(pair && pair[1]).toLowerCase();
            if (!collisionRe.test(h)) {
                h = "none"
            }
            if (!collisionRe.test(v)) {
                v = h
            }
            return {
                h: h,
                v: v
            }
        };
        var getAlignFactor = function(align) {
            switch (align) {
                case "center":
                    return .5;
                case "right":
                case "bottom":
                    return 1;
                default:
                    return 0
            }
        };
        var inverseAlign = function(align) {
            switch (align) {
                case "left":
                    return "right";
                case "right":
                    return "left";
                case "top":
                    return "bottom";
                case "bottom":
                    return "top";
                default:
                    return align
            }
        };
        var calculateOversize = function(data, bounds) {
            var oversize = 0;
            if (data.myLocation < bounds.min) {
                oversize += bounds.min - data.myLocation
            }
            if (data.myLocation > bounds.max) {
                oversize += data.myLocation - bounds.max
            }
            return oversize
        };
        var collisionSide = function(direction, data, bounds) {
            if (data.myLocation < bounds.min) {
                return "h" === direction ? "left" : "top"
            }
            if (data.myLocation > bounds.max) {
                return "h" === direction ? "right" : "bottom"
            }
            return "none"
        };
        var initMyLocation = function(data) {
            data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
        };
        var collisionResolvers = {
            fit: function(data, bounds) {
                var result = false;
                if (data.myLocation > bounds.max) {
                    data.myLocation = bounds.max;
                    result = true
                }
                if (data.myLocation < bounds.min) {
                    data.myLocation = bounds.min;
                    result = true
                }
                data.fit = result
            },
            flip: function(data, bounds) {
                data.flip = false;
                if ("center" === data.myAlign && "center" === data.atAlign) {
                    return
                }
                if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
                    var inverseData = extend({}, data, {
                        myAlign: inverseAlign(data.myAlign),
                        atAlign: inverseAlign(data.atAlign),
                        offset: -data.offset
                    });
                    initMyLocation(inverseData);
                    inverseData.oversize = calculateOversize(inverseData, bounds);
                    if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
                        data.myLocation = inverseData.myLocation;
                        data.oversize = inverseData.oversize;
                        data.flip = true
                    }
                }
            },
            flipfit: function(data, bounds) {
                this.flip(data, bounds);
                this.fit(data, bounds)
            },
            none: function(data) {
                data.oversize = 0
            }
        };
        var scrollbarWidth;
        var calculateScrollbarWidth = function() {
            var $scrollDiv = $("<div>").css({
                width: 100,
                height: 100,
                overflow: "scroll",
                position: "absolute",
                top: -9999
            }).appendTo($("body"));
            var result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
            $scrollDiv.remove();
            scrollbarWidth = result
        };
        var defaultPositionResult = {
            h: {
                location: 0,
                flip: false,
                fit: false,
                oversize: 0
            },
            v: {
                location: 0,
                flip: false,
                fit: false,
                oversize: 0
            }
        };
        var calculatePosition = function(what, options) {
            var $what = $(what);
            var currentOffset = $what.offset();
            var result = extend(true, {}, defaultPositionResult, {
                h: {
                    location: currentOffset.left
                },
                v: {
                    location: currentOffset.top
                }
            });
            if (!options) {
                return result
            }
            var my = normalizeAlign(options.my);
            var at = normalizeAlign(options.at);
            var of = $(options.of).length && options.of || window;
            var offset = normalizeOffset(options.offset);
            var collision = normalizeCollision(options.collision);
            var boundary = options.boundary;
            var boundaryOffset = normalizeOffset(options.boundaryOffset);
            var h = {
                mySize: $what.outerWidth(),
                myAlign: my.h,
                atAlign: at.h,
                offset: offset.h,
                collision: collision.h,
                boundaryOffset: boundaryOffset.h
            };
            var v = {
                mySize: $what.outerHeight(),
                myAlign: my.v,
                atAlign: at.v,
                offset: offset.v,
                collision: collision.v,
                boundaryOffset: boundaryOffset.v
            };
            if ( of .preventDefault) {
                h.atLocation = of .pageX;
                v.atLocation = of .pageY;
                h.atSize = 0;
                v.atSize = 0
            } else {
                of = $( of );
                if (isWindow( of [0])) {
                    h.atLocation = of .scrollLeft();
                    v.atLocation = of .scrollTop();
                    h.atSize = of [0].innerWidth >= of [0].outerWidth ? of [0].innerWidth : of .width();
                    v.atSize = of [0].innerHeight >= of [0].outerHeight || IS_SAFARI ? of [0].innerHeight : of .height()
                } else {
                    if (9 === of [0].nodeType) {
                        h.atLocation = 0;
                        v.atLocation = 0;
                        h.atSize = of .width();
                        v.atSize = of .height()
                    } else {
                        var ofRect = getBoundingRect( of .get(0));
                        var o = of .offset();
                        h.atLocation = o.left;
                        v.atLocation = o.top;
                        h.atSize = ofRect.width;
                        v.atSize = ofRect.height
                    }
                }
            }
            initMyLocation(h);
            initMyLocation(v);
            var bounds = function() {
                var win = $(window);
                var windowWidth = win.width();
                var windowHeight = win.height();
                var left = win.scrollLeft();
                var top = win.scrollTop();
                var documentElement = domAdapter.getDocumentElement();
                var hZoomLevel = support.touch ? documentElement.clientWidth / windowWidth : 1;
                var vZoomLevel = support.touch ? documentElement.clientHeight / windowHeight : 1;
                if (void 0 === scrollbarWidth) {
                    calculateScrollbarWidth()
                }
                var boundaryWidth = windowWidth;
                var boundaryHeight = windowHeight;
                if (boundary) {
                    var $boundary = $(boundary);
                    var boundaryPosition = $boundary.offset();
                    left = boundaryPosition.left;
                    top = boundaryPosition.top;
                    boundaryWidth = $boundary.width();
                    boundaryHeight = $boundary.height()
                }
                return {
                    h: {
                        min: left + h.boundaryOffset,
                        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
                    },
                    v: {
                        min: top + v.boundaryOffset,
                        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
                    }
                }
            }();
            h.oversize = calculateOversize(h, bounds.h);
            v.oversize = calculateOversize(v, bounds.v);
            h.collisionSide = collisionSide("h", h, bounds.h);
            v.collisionSide = collisionSide("v", v, bounds.v);
            if (collisionResolvers[h.collision]) {
                collisionResolvers[h.collision](h, bounds.h)
            }
            if (collisionResolvers[v.collision]) {
                collisionResolvers[v.collision](v, bounds.v)
            }
            var preciser = function(number) {
                return options.precise ? number : Math.round(number)
            };
            extend(true, result, {
                h: {
                    location: preciser(h.myLocation),
                    oversize: preciser(h.oversize),
                    fit: h.fit,
                    flip: h.flip,
                    collisionSide: h.collisionSide
                },
                v: {
                    location: preciser(v.myLocation),
                    oversize: preciser(v.oversize),
                    fit: v.fit,
                    flip: v.flip,
                    collisionSide: v.collisionSide
                },
                precise: options.precise
            });
            return result
        };
        var position = function(what, options) {
            var $what = $(what);
            if (!options) {
                return $what.offset()
            }
            translator.resetPosition($what, true);
            var offset = $what.offset();
            var targetPosition = options.h && options.v ? options : calculatePosition($what, options);
            var preciser = function(number) {
                return options.precise ? number : Math.round(number)
            };
            translator.move($what, {
                left: targetPosition.h.location - preciser(offset.left),
                top: targetPosition.v.location - preciser(offset.top)
            });
            return targetPosition
        };
        var offset = function(element) {
            element = $(element).get(0);
            if (isWindow(element)) {
                return null
            } else {
                if (element && "pageY" in element && "pageX" in element) {
                    return {
                        top: element.pageY,
                        left: element.pageX
                    }
                }
            }
            return $(element).offset()
        };
        if (!position.inverseAlign) {
            position.inverseAlign = inverseAlign
        }
        if (!position.normalizeAlign) {
            position.normalizeAlign = normalizeAlign
        }
        module.exports = {
            calculateScrollbarWidth: calculateScrollbarWidth,
            calculate: calculatePosition,
            setup: position,
            offset: offset
        }
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/core/utils/ajax.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Deferred = __webpack_require__( /*! ./deferred */ 6).Deferred;
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var httpRequest = __webpack_require__( /*! ../../core/http_request */ 463);
        var windowUtils = __webpack_require__( /*! ../../core/utils/window */ 7);
        var window = windowUtils.getWindow();
        var extendFromObject = __webpack_require__( /*! ./extend */ 0).extendFromObject;
        var isDefined = __webpack_require__( /*! ./type */ 1).isDefined;
        var Promise = __webpack_require__( /*! ../polyfills/promise */ 67);
        var injector = __webpack_require__( /*! ./dependency_injector */ 56);
        var SUCCESS = "success";
        var ERROR = "error";
        var TIMEOUT = "timeout";
        var NO_CONTENT = "nocontent";
        var PARSER_ERROR = "parsererror";
        var isStatusSuccess = function(status) {
            return 200 <= status && status < 300
        };
        var hasContent = function(status) {
            return 204 !== status
        };
        var paramsConvert = function(params) {
            var result = [];
            for (var name in params) {
                var value = params[name];
                if (void 0 === value) {
                    continue
                }
                if (null === value) {
                    value = ""
                }
                result.push(encodeURIComponent(name) + "=" + encodeURIComponent(value))
            }
            return result.join("&")
        };
        var createScript = function(options) {
            var script = domAdapter.createElement("script");
            for (var name in options) {
                script[name] = options[name]
            }
            return script
        };
        var removeScript = function(scriptNode) {
            scriptNode.parentNode.removeChild(scriptNode)
        };
        var appendToHead = function(element) {
            return domAdapter.getHead().appendChild(element)
        };
        var evalScript = function(code) {
            var script = createScript({
                text: code
            });
            appendToHead(script);
            removeScript(script)
        };
        var evalCrossDomainScript = function(url) {
            var script = createScript({
                src: url
            });
            return new Promise(function(resolve, reject) {
                var events = {
                    load: resolve,
                    error: reject
                };
                var loadHandler = function(e) {
                    events[e.type]();
                    removeScript(script)
                };
                for (var event in events) {
                    domAdapter.listen(script, event, loadHandler)
                }
                appendToHead(script)
            })
        };
        var getAcceptHeader = function(options) {
            var dataType = options.dataType || "*";
            var scriptAccept = "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript";
            var accepts = {
                "*": "*/*",
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript",
                jsonp: scriptAccept,
                script: scriptAccept
            };
            extendFromObject(accepts, options.accepts, true);
            return accepts[dataType] ? accepts[dataType] + ("*" !== dataType ? ", */*; q=0.01" : "") : accepts["*"]
        };
        var getContentTypeHeader = function(options) {
            var defaultContentType;
            if (options.data && !options.upload && "GET" !== getMethod(options)) {
                defaultContentType = "application/x-www-form-urlencoded;charset=utf-8"
            }
            return options.contentType || defaultContentType
        };
        var getDataFromResponse = function(xhr) {
            return xhr.responseType && "text" !== xhr.responseType || "string" !== typeof xhr.responseText ? xhr.response : xhr.responseText
        };
        var postProcess = function(deferred, xhr, dataType) {
            var data = getDataFromResponse(xhr);
            switch (dataType) {
                case "jsonp":
                    evalScript(data);
                    break;
                case "script":
                    evalScript(data);
                    deferred.resolve(data, SUCCESS, xhr);
                    break;
                case "json":
                    try {
                        deferred.resolve(JSON.parse(data), SUCCESS, xhr)
                    } catch (e) {
                        deferred.reject(xhr, PARSER_ERROR, e)
                    }
                    break;
                default:
                    deferred.resolve(data, SUCCESS, xhr)
            }
        };
        var isCrossDomain = function(url) {
            if (!windowUtils.hasWindow()) {
                return true
            }
            var crossDomain = false;
            var originAnchor = domAdapter.createElement("a");
            var urlAnchor = domAdapter.createElement("a");
            originAnchor.href = window.location.href;
            try {
                urlAnchor.href = url;
                urlAnchor.href = urlAnchor.href;
                crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host
            } catch (e) {
                crossDomain = true
            }
            return crossDomain
        };
        var setHttpTimeout = function(timeout, xhr) {
            return timeout && setTimeout(function() {
                xhr.customStatus = TIMEOUT;
                xhr.abort()
            }, timeout)
        };
        var getJsonpOptions = function(options) {
            if ("jsonp" === options.dataType) {
                var random = Math.random().toString().replace(/\D/g, "");
                var callbackName = options.jsonpCallback || "dxCallback" + Date.now() + "_" + random;
                var callbackParameter = options.jsonp || "callback";
                options.data = options.data || {};
                options.data[callbackParameter] = callbackName;
                return callbackName
            }
        };
        var getRequestOptions = function(options, headers) {
            var params = options.data;
            var paramsAlreadyString = "string" === typeof params;
            var url = options.url || window.location.href;
            if (!paramsAlreadyString && !options.cache) {
                params = params || {};
                params._ = Date.now()
            }
            if (params && !options.upload) {
                if (!paramsAlreadyString) {
                    params = paramsConvert(params)
                }
                if ("GET" === getMethod(options)) {
                    if ("" !== params) {
                        url += (url.indexOf("?") > -1 ? "&" : "?") + params
                    }
                    params = null
                } else {
                    if (headers["Content-Type"] && headers["Content-Type"].indexOf("application/x-www-form-urlencoded") > -1) {
                        params = params.replace(/%20/g, "+")
                    }
                }
            }
            return {
                url: url,
                parameters: params
            }
        };

        function getMethod(options) {
            return (options.method || "GET").toUpperCase()
        }
        var getRequestHeaders = function(options) {
            var headers = options.headers || {};
            headers["Content-Type"] = headers["Content-Type"] || getContentTypeHeader(options);
            headers.Accept = headers.Accept || getAcceptHeader(options);
            if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest"
            }
            return headers
        };
        var sendRequest = function(options) {
            var xhr = httpRequest.getXhr();
            var d = new Deferred;
            var result = d.promise();
            var async = isDefined(options.async) ? options.async : true;
            var dataType = options.dataType;
            var timeout = options.timeout || 0;
            var timeoutId;
            options.crossDomain = isCrossDomain(options.url);
            var needScriptEvaluation = "jsonp" === dataType || "script" === dataType;
            if (void 0 === options.cache) {
                options.cache = !needScriptEvaluation
            }
            var callbackName = getJsonpOptions(options);
            var headers = getRequestHeaders(options);
            var requestOptions = getRequestOptions(options, headers);
            var url = requestOptions.url;
            var parameters = requestOptions.parameters;
            if (callbackName) {
                window[callbackName] = function(data) {
                    d.resolve(data, SUCCESS, xhr)
                }
            }
            if (options.crossDomain && needScriptEvaluation) {
                var reject = function() {
                    d.reject(xhr, ERROR)
                };
                var resolve = function() {
                    if ("jsonp" === dataType) {
                        return
                    }
                    d.resolve(null, SUCCESS, xhr)
                };
                evalCrossDomainScript(url).then(resolve, reject);
                return result
            }
            if (options.crossDomain && !("withCredentials" in xhr)) {
                d.reject(xhr, ERROR);
                return result
            }
            xhr.open(getMethod(options), url, async, options.username, options.password);
            if (async) {
                xhr.timeout = timeout;
                timeoutId = setHttpTimeout(timeout, xhr, d)
            }
            xhr.onreadystatechange = function(e) {
                if (4 === xhr.readyState) {
                    clearTimeout(timeoutId);
                    if (isStatusSuccess(xhr.status)) {
                        if (hasContent(xhr.status)) {
                            postProcess(d, xhr, dataType)
                        } else {
                            d.resolve(null, NO_CONTENT, xhr)
                        }
                    } else {
                        d.reject(xhr, xhr.customStatus || ERROR)
                    }
                }
            };
            if (options.upload) {
                xhr.upload.onprogress = options.upload.onprogress;
                xhr.upload.onloadstart = options.upload.onloadstart;
                xhr.upload.onabort = options.upload.onabort
            }
            if (options.xhrFields) {
                for (var field in options.xhrFields) {
                    xhr[field] = options.xhrFields[field]
                }
            }
            if ("arraybuffer" === options.responseType) {
                xhr.responseType = options.responseType
            }
            for (var name in headers) {
                if (Object.prototype.hasOwnProperty.call(headers, name) && isDefined(headers[name])) {
                    xhr.setRequestHeader(name, headers[name])
                }
            }
            if (options.beforeSend) {
                options.beforeSend(xhr)
            }
            xhr.send(parameters);
            result.abort = function() {
                xhr.abort()
            };
            return result
        };
        module.exports = injector({
            sendRequest: sendRequest
        })
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/core/utils/view_port.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../renderer */ 2);
        var readyCallbacks = __webpack_require__( /*! ./ready_callbacks */ 51);
        var ready = readyCallbacks.add;
        var changeCallback = __webpack_require__( /*! ./callbacks */ 27)();
        var $originalViewPort = $();
        var value = function() {
            var $current;
            return function(element) {
                if (!arguments.length) {
                    return $current
                }
                var $element = $(element);
                $originalViewPort = $element;
                var isNewViewportFound = !!$element.length;
                var prevViewPort = value();
                $current = isNewViewportFound ? $element : $("body");
                changeCallback.fire(isNewViewportFound ? value() : $(), prevViewPort)
            }
        }();
        ready(function() {
            value(".dx-viewport")
        });
        exports.value = value;
        exports.changeCallback = changeCallback;
        exports.originalViewPort = function() {
            return $originalViewPort
        }
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/events/core/event_registrator.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _event_registrator_callbacks = __webpack_require__( /*! ./event_registrator_callbacks */ 130);
        var _event_registrator_callbacks2 = _interopRequireDefault(_event_registrator_callbacks);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var registerEvent = function(name, eventObject) {
            var strategy = {};
            if ("noBubble" in eventObject) {
                strategy.noBubble = eventObject.noBubble
            }
            if ("bindType" in eventObject) {
                strategy.bindType = eventObject.bindType
            }
            if ("delegateType" in eventObject) {
                strategy.delegateType = eventObject.delegateType
            }(0, _iterator.each)(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_, methodName) {
                if (!eventObject[methodName]) {
                    return
                }
                strategy[methodName] = function() {
                    var args = [].slice.call(arguments);
                    args.unshift(this);
                    return eventObject[methodName].apply(eventObject, args)
                }
            });
            _event_registrator_callbacks2.default.fire(name, strategy)
        };
        registerEvent.callbacks = _event_registrator_callbacks2.default;
        module.exports = registerEvent
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/core/templates/template_base.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.TemplateBase = exports.renderedCallbacks = void 0;
        var _renderer = __webpack_require__( /*! ../renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _dom_adapter = __webpack_require__( /*! ../dom_adapter */ 12);
        var _callbacks = __webpack_require__( /*! ../utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);
        var _dom = __webpack_require__( /*! ../utils/dom */ 11);
        var _errors = __webpack_require__( /*! ../errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var renderedCallbacks = exports.renderedCallbacks = (0, _callbacks2.default)({
            syncStrategy: true
        });
        exports.TemplateBase = function() {
            function TemplateBase() {
                _classCallCheck(this, TemplateBase)
            }
            _createClass(TemplateBase, [{
                key: "render",
                value: function(options) {
                    options = options || {};
                    var onRendered = options.onRendered;
                    delete options.onRendered;
                    var $result = this._renderCore(options);
                    this._ensureResultInContainer($result, options.container);
                    renderedCallbacks.fire($result, options.container);
                    onRendered && onRendered();
                    return $result
                }
            }, {
                key: "_ensureResultInContainer",
                value: function($result, container) {
                    if (!container) {
                        return
                    }
                    var $container = (0, _renderer2.default)(container);
                    var resultInContainer = (0, _dom.contains)($container.get(0), $result.get(0));
                    $container.append($result);
                    if (resultInContainer) {
                        return
                    }
                    var resultInBody = (0, _dom_adapter.getBody)().contains($container.get(0));
                    if (!resultInBody) {
                        return
                    }(0, _dom.triggerShownEvent)($result)
                }
            }, {
                key: "_renderCore",
                value: function() {
                    throw _errors2.default.Error("E0001")
                }
            }]);
            return TemplateBase
        }()
    },
    /*!***********************************!*\
      !*** external "window.Globalize" ***!
      \***********************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports) {
        module.exports = window.Globalize
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/core/utils/call_once.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var callOnce = function(handler) {
            var result;
            var _wrappedHandler = function() {
                result = handler.apply(this, arguments);
                _wrappedHandler = function() {
                    return result
                };
                return result
            };
            return function() {
                return _wrappedHandler.apply(this, arguments)
            }
        };
        module.exports = callOnce
    }, ,
    /*!*********************************************!*\
      !*** ./artifacts/transpiled/data_helper.js ***!
      \*********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var DataSource = __webpack_require__( /*! ./data/data_source/data_source */ 61).DataSource;
        var extend = __webpack_require__( /*! ./core/utils/extend */ 0).extend;
        var normalizeDataSourceOptions = __webpack_require__( /*! ./data/data_source/utils */ 64).normalizeDataSourceOptions;
        var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions";
        var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
        var DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler";
        var DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler";
        var DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD = "_dataSourceFromUrlLoadMode";
        var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
        var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
        var DataHelperMixin = {
            postCtor: function() {
                this.on("disposing", function() {
                    this._disposeDataSource()
                }.bind(this))
            },
            _refreshDataSource: function() {
                this._initDataSource();
                this._loadDataSource()
            },
            _initDataSource: function() {
                var dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
                var widgetDataSourceOptions;
                var dataSourceType;
                this._disposeDataSource();
                if (dataSourceOptions) {
                    if (dataSourceOptions instanceof DataSource) {
                        this._isSharedDataSource = true;
                        this._dataSource = dataSourceOptions
                    } else {
                        widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
                        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
                        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
                            fromUrlLoadMode: DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD in this && this[DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD]()
                        });
                        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions))
                    }
                    if (NORMALIZE_DATA_SOURCE in this) {
                        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource)
                    }
                    this._addDataSourceHandlers()
                }
            },
            _addDataSourceHandlers: function() {
                if (DATA_SOURCE_CHANGED_METHOD in this) {
                    this._addDataSourceChangeHandler()
                }
                if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
                    this._addDataSourceLoadErrorHandler()
                }
                if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
                    this._addDataSourceLoadingChangedHandler()
                }
                this._addReadyWatcher()
            },
            _addReadyWatcher: function() {
                this._dataSource.on("loadingChanged", function(isLoading) {
                    this._ready && this._ready(!isLoading)
                }.bind(this))
            },
            _addDataSourceChangeHandler: function() {
                var dataSource = this._dataSource;
                this._proxiedDataSourceChangedHandler = function(e) {
                    this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e)
                }.bind(this);
                dataSource.on("changed", this._proxiedDataSourceChangedHandler)
            },
            _addDataSourceLoadErrorHandler: function() {
                this._proxiedDataSourceLoadErrorHandler = this[DATA_SOURCE_LOAD_ERROR_METHOD].bind(this);
                this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler)
            },
            _addDataSourceLoadingChangedHandler: function() {
                this._proxiedDataSourceLoadingChangedHandler = this[DATA_SOURCE_LOADING_CHANGED_METHOD].bind(this);
                this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
            },
            _loadDataSource: function() {
                if (this._dataSource) {
                    var dataSource = this._dataSource;
                    if (dataSource.isLoaded()) {
                        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler()
                    } else {
                        dataSource.load()
                    }
                }
            },
            _loadSingle: function(key, value) {
                key = "this" === key ? this._dataSource.key() || "this" : key;
                return this._dataSource.loadSingle(key, value)
            },
            _isLastPage: function() {
                return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize
            },
            _isDataSourceLoading: function() {
                return this._dataSource && this._dataSource.isLoading()
            },
            _disposeDataSource: function() {
                if (this._dataSource) {
                    if (this._isSharedDataSource) {
                        delete this._isSharedDataSource;
                        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
                        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
                        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
                    } else {
                        this._dataSource.dispose()
                    }
                    delete this._dataSource;
                    delete this._proxiedDataSourceChangedHandler;
                    delete this._proxiedDataSourceLoadErrorHandler;
                    delete this._proxiedDataSourceLoadingChangedHandler
                }
            },
            getDataSource: function() {
                return this._dataSource || null
            }
        };
        module.exports = DataHelperMixin
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/localization/core.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _dependency_injector = __webpack_require__( /*! ../core/utils/dependency_injector */ 56);
        var _dependency_injector2 = _interopRequireDefault(_dependency_injector);
        var _parent_locales = __webpack_require__( /*! ./cldr-data/parent_locales */ 452);
        var _parent_locales2 = _interopRequireDefault(_parent_locales);
        var _parentLocale = __webpack_require__( /*! ./parentLocale */ 453);
        var _parentLocale2 = _interopRequireDefault(_parentLocale);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var DEFAULT_LOCALE = "en";
        module.exports = (0, _dependency_injector2.default)({
            locale: function() {
                var currentLocale = DEFAULT_LOCALE;
                return function(locale) {
                    if (!locale) {
                        return currentLocale
                    }
                    currentLocale = locale
                }
            }(),
            getValueByClosestLocale: function(getter) {
                var locale = this.locale();
                var value = getter(locale);
                var isRootLocale;
                while (!value && !isRootLocale) {
                    locale = (0, _parentLocale2.default)(_parent_locales2.default, locale);
                    if (locale) {
                        value = getter(locale)
                    } else {
                        isRootLocale = true
                    }
                }
                if (void 0 === value && locale !== DEFAULT_LOCALE) {
                    return getter(DEFAULT_LOCALE)
                }
                return value
            }
        })
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.tag_helper.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var tagHelper = {
            toXml: function(tagName, attributes, content) {
                var result = ["<", tagName];
                for (var attributeName in attributes) {
                    var attributeValue = attributes[attributeName];
                    if ((0, _type.isDefined)(attributeValue)) {
                        result.push(" ", attributeName, '="', attributeValue, '"')
                    }
                }
                if ((0, _type.isDefined)(content) && "" !== content) {
                    result.push(">", content, "</", tagName, ">")
                } else {
                    result.push(" />")
                }
                return result.join("")
            }
        };
        exports.default = tagHelper
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/use_jquery.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var jQuery = __webpack_require__( /*! jquery */ 57);
        var config = __webpack_require__( /*! ../../core/config */ 30);
        var useJQuery = config().useJQuery;
        if (jQuery && false !== useJQuery) {
            config({
                useJQuery: true
            })
        }
        module.exports = function() {
            return jQuery && config().useJQuery
        }
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/data/store_helper.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var grep = __webpack_require__( /*! ../core/utils/common */ 3).grep;
        var extend = __webpack_require__( /*! ../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../core/utils/iterator */ 4).each;
        var arrayQuery = __webpack_require__( /*! ./array_query */ 161);
        var normalizeSortingInfo = __webpack_require__( /*! ./utils */ 42).normalizeSortingInfo;

        function multiLevelGroup(query, groupInfo) {
            query = query.groupBy(groupInfo[0].selector);
            if (groupInfo.length > 1) {
                query = query.select(function(g) {
                    return extend({}, g, {
                        items: multiLevelGroup(arrayQuery(g.items), groupInfo.slice(1)).toArray()
                    })
                })
            }
            return query
        }

        function arrangeSortingInfo(groupInfo, sortInfo) {
            var filteredGroup = [];
            each(groupInfo, function(_, group) {
                var collision = grep(sortInfo, function(sort) {
                    return group.selector === sort.selector
                });
                if (collision.length < 1) {
                    filteredGroup.push(group)
                }
            });
            return filteredGroup.concat(sortInfo)
        }

        function queryByOptions(query, options, isCountQuery) {
            options = options || {};
            var filter = options.filter;
            if (filter) {
                query = query.filter(filter)
            }
            if (isCountQuery) {
                return query
            }
            var sort = options.sort;
            var select = options.select;
            var group = options.group;
            var skip = options.skip;
            var take = options.take;
            if (group) {
                group = normalizeSortingInfo(group);
                group.keepInitialKeyOrder = !!options.group.keepInitialKeyOrder
            }
            if (sort || group) {
                sort = normalizeSortingInfo(sort || []);
                if (group && !group.keepInitialKeyOrder) {
                    sort = arrangeSortingInfo(group, sort)
                }
                each(sort, function(index) {
                    query = query[index ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare)
                })
            }
            if (select) {
                query = query.select(select)
            }
            if (group) {
                query = multiLevelGroup(query, group)
            }
            if (take || skip) {
                query = query.slice(skip || 0, take)
            }
            return query
        }
        module.exports = {
            multiLevelGroup: multiLevelGroup,
            arrangeSortingInfo: arrangeSortingInfo,
            queryByOptions: queryByOptions
        }
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/core/templates/empty_template.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.EmptyTemplate = void 0;
        var _renderer = __webpack_require__( /*! ../renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _template_base = __webpack_require__( /*! ./template_base */ 78);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }

        function _inherits(subClass, superClass) {
            if ("function" !== typeof superClass && null !== superClass) {
                throw new TypeError("Super expression must either be null or a function")
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) {
                _setPrototypeOf(subClass, superClass)
            }
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o
            };
            return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                    result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (call && ("object" === _typeof(call) || "function" === typeof call)) {
                return call
            }
            return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
            if (void 0 === self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return self
        }

        function _isNativeReflectConstruct() {
            if ("undefined" === typeof Reflect || !Reflect.construct) {
                return false
            }
            if (Reflect.construct.sham) {
                return false
            }
            if ("function" === typeof Proxy) {
                return true
            }
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                return true
            } catch (e) {
                return false
            }
        }

        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
            };
            return _getPrototypeOf(o)
        }
        exports.EmptyTemplate = function(_TemplateBase) {
            _inherits(EmptyTemplate, _TemplateBase);
            var _super = _createSuper(EmptyTemplate);

            function EmptyTemplate() {
                _classCallCheck(this, EmptyTemplate);
                return _super.apply(this, arguments)
            }
            _createClass(EmptyTemplate, [{
                key: "_renderCore",
                value: function() {
                    return (0, _renderer2.default)()
                }
            }]);
            return EmptyTemplate
        }(_template_base.TemplateBase)
    }, , , ,
    /*!***************************************!*\
      !*** ./artifacts/transpiled/color.js ***!
      \***************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var standardColorNames = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "00ffff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000000",
            blanchedalmond: "ffebcd",
            blue: "0000ff",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "00ffff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dodgerblue: "1e90ff",
            feldspar: "d19275",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "ff00ff",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgrey: "d3d3d3",
            lightgreen: "90ee90",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslateblue: "8470ff",
            lightslategray: "778899",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "00ff00",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "ff00ff",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370d8",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "d87093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "ff0000",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            violetred: "d02090",
            wheat: "f5deb3",
            white: "ffffff",
            whitesmoke: "f5f5f5",
            yellow: "ffff00",
            yellowgreen: "9acd32"
        };
        var standardColorTypes = [{
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            process: function(colorString) {
                return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)]
            }
        }, {
            re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
            process: function(colorString) {
                return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])]
            }
        }, {
            re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
            process: function(colorString) {
                return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)]
            }
        }, {
            re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
            process: function(colorString) {
                return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)]
            }
        }, {
            re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            process: function(colorString) {
                var h = parseInt(colorString[1], 10);
                var s = parseInt(colorString[2], 10);
                var v = parseInt(colorString[3], 10);
                var rgb = hsvToRgb(h, s, v);
                return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]]
            }
        }, {
            re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            process: function(colorString) {
                var h = parseInt(colorString[1], 10);
                var s = parseInt(colorString[2], 10);
                var l = parseInt(colorString[3], 10);
                var rgb = hslToRgb(h, s, l);
                return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]]
            }
        }];
        var _round = Math.round;

        function Color(value) {
            this.baseColor = value;
            var color;
            if (value) {
                color = String(value).toLowerCase().replace(/ /g, "");
                color = standardColorNames[color] ? "#" + standardColorNames[color] : color;
                color = parseColor(color)
            }
            if (!color) {
                this.colorIsInvalid = true
            }
            color = color || {};
            this.r = normalize(color[0]);
            this.g = normalize(color[1]);
            this.b = normalize(color[2]);
            this.a = normalize(color[3], 1, 1);
            if (color[4]) {
                this.hsv = {
                    h: color[4][0],
                    s: color[4][1],
                    v: color[4][2]
                }
            } else {
                this.hsv = toHsvFromRgb(this.r, this.g, this.b)
            }
            if (color[5]) {
                this.hsl = {
                    h: color[5][0],
                    s: color[5][1],
                    l: color[5][2]
                }
            } else {
                this.hsl = toHslFromRgb(this.r, this.g, this.b)
            }
        }

        function parseColor(color) {
            if ("transparent" === color) {
                return [0, 0, 0, 0]
            }
            var i = 0;
            var ii = standardColorTypes.length;
            var str;
            for (; i < ii; ++i) {
                str = standardColorTypes[i].re.exec(color);
                if (str) {
                    return standardColorTypes[i].process(str)
                }
            }
            return null
        }

        function normalize(colorComponent, def, max) {
            def = def || 0;
            max = max || 255;
            return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent
        }

        function toHexFromRgb(r, g, b) {
            return "#" + (16777216 | r << 16 | g << 8 | b).toString(16).slice(1)
        }

        function toHsvFromRgb(r, g, b) {
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var delta = max - min;
            var H;
            var S;
            var V = max;
            S = 0 === max ? 0 : 1 - min / max;
            if (max === min) {
                H = 0
            } else {
                switch (max) {
                    case r:
                        H = 60 * ((g - b) / delta);
                        if (g < b) {
                            H += 360
                        }
                        break;
                    case g:
                        H = 60 * ((b - r) / delta) + 120;
                        break;
                    case b:
                        H = 60 * ((r - g) / delta) + 240
                }
            }
            S *= 100;
            V *= 100 / 255;
            return {
                h: Math.round(H),
                s: Math.round(S),
                v: Math.round(V)
            }
        }

        function hsvToRgb(h, s, v) {
            var index = Math.floor(h % 360 / 60);
            var vMin = (100 - s) * v / 100;
            var a = (v - vMin) * (h % 60 / 60);
            var vInc = vMin + a;
            var vDec = v - a;
            var r;
            var g;
            var b;
            switch (index) {
                case 0:
                    r = v;
                    g = vInc;
                    b = vMin;
                    break;
                case 1:
                    r = vDec;
                    g = v;
                    b = vMin;
                    break;
                case 2:
                    r = vMin;
                    g = v;
                    b = vInc;
                    break;
                case 3:
                    r = vMin;
                    g = vDec;
                    b = v;
                    break;
                case 4:
                    r = vInc;
                    g = vMin;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = vMin;
                    b = vDec
            }
            return [Math.round(2.55 * r), Math.round(2.55 * g), Math.round(2.55 * b)]
        }

        function calculateHue(r, g, b, delta) {
            var max = Math.max(r, g, b);
            switch (max) {
                case r:
                    return (g - b) / delta + (g < b ? 6 : 0);
                case g:
                    return (b - r) / delta + 2;
                case b:
                    return (r - g) / delta + 4
            }
        }

        function toHslFromRgb(r, g, b) {
            r = convertTo01Bounds(r, 255);
            g = convertTo01Bounds(g, 255);
            b = convertTo01Bounds(b, 255);
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var maxMinSum = max + min;
            var h;
            var s;
            var l = maxMinSum / 2;
            if (max === min) {
                h = s = 0
            } else {
                var delta = max - min;
                if (l > .5) {
                    s = delta / (2 - maxMinSum)
                } else {
                    s = delta / maxMinSum
                }
                h = calculateHue(r, g, b, delta);
                h /= 6
            }
            return {
                h: _round(360 * h),
                s: _round(100 * s),
                l: _round(100 * l)
            }
        }

        function makeColorTint(colorPart, h) {
            var colorTint = h;
            if ("r" === colorPart) {
                colorTint = h + 1 / 3
            }
            if ("b" === colorPart) {
                colorTint = h - 1 / 3
            }
            return colorTint
        }

        function modifyColorTint(colorTint) {
            if (colorTint < 0) {
                colorTint += 1
            }
            if (colorTint > 1) {
                colorTint -= 1
            }
            return colorTint
        }

        function hueToRgb(p, q, colorTint) {
            colorTint = modifyColorTint(colorTint);
            if (colorTint < 1 / 6) {
                return p + 6 * (q - p) * colorTint
            }
            if (colorTint < .5) {
                return q
            }
            if (colorTint < 2 / 3) {
                return p + (q - p) * (2 / 3 - colorTint) * 6
            }
            return p
        }

        function hslToRgb(h, s, l) {
            var r;
            var g;
            var b;
            h = convertTo01Bounds(h, 360);
            s = convertTo01Bounds(s, 100);
            l = convertTo01Bounds(l, 100);
            if (0 === s) {
                r = g = b = l
            } else {
                var q = l < .5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hueToRgb(p, q, makeColorTint("r", h));
                g = hueToRgb(p, q, makeColorTint("g", h));
                b = hueToRgb(p, q, makeColorTint("b", h))
            }
            return [_round(255 * r), _round(255 * g), _round(255 * b)]
        }

        function convertTo01Bounds(n, max) {
            n = Math.min(max, Math.max(0, parseFloat(n)));
            if (Math.abs(n - max) < 1e-6) {
                return 1
            }
            return n % max / parseFloat(max)
        }

        function isIntegerBetweenMinAndMax(number, min, max) {
            min = min || 0;
            max = max || 255;
            if (number % 1 !== 0 || number < min || number > max || "number" !== typeof number || isNaN(number)) {
                return false
            }
            return true
        }
        Color.prototype = {
            constructor: Color,
            highlight: function(step) {
                step = step || 10;
                return this.alter(step).toHex()
            },
            darken: function(step) {
                step = step || 10;
                return this.alter(-step).toHex()
            },
            alter: function(step) {
                var result = new Color;
                result.r = normalize(this.r + step);
                result.g = normalize(this.g + step);
                result.b = normalize(this.b + step);
                return result
            },
            blend: function(blendColor, opacity) {
                var other = blendColor instanceof Color ? blendColor : new Color(blendColor);
                var result = new Color;
                result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
                result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
                result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
                return result
            },
            toHex: function() {
                return toHexFromRgb(this.r, this.g, this.b)
            },
            getPureColor: function() {
                var rgb = hsvToRgb(this.hsv.h, 100, 100);
                return new Color("rgb(" + rgb.join(",") + ")")
            },
            isValidHex: function(hex) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex)
            },
            isValidRGB: function(r, g, b) {
                if (!isIntegerBetweenMinAndMax(r) || !isIntegerBetweenMinAndMax(g) || !isIntegerBetweenMinAndMax(b)) {
                    return false
                }
                return true
            },
            isValidAlpha: function(a) {
                if (isNaN(a) || a < 0 || a > 1 || "number" !== typeof a) {
                    return false
                }
                return true
            },
            colorIsInvalid: false,
            fromHSL: function(hsl) {
                var color = new Color;
                var rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                color.r = rgb[0];
                color.g = rgb[1];
                color.b = rgb[2];
                return color
            }
        };
        module.exports = Color
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/ui/validation_engine.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _class = __webpack_require__( /*! ../core/class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _array = __webpack_require__( /*! ../core/utils/array */ 14);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _events_strategy = __webpack_require__( /*! ../core/events_strategy */ 100);
        var _errors = __webpack_require__( /*! ../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _common = __webpack_require__( /*! ../core/utils/common */ 3);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _type2 = _interopRequireDefault(_type);
        var _number = __webpack_require__( /*! ../localization/number */ 49);
        var _number2 = _interopRequireDefault(_number);
        var _message = __webpack_require__( /*! ../localization/message */ 10);
        var _message2 = _interopRequireDefault(_message);
        var _promise = __webpack_require__( /*! ../core/polyfills/promise */ 67);
        var _promise2 = _interopRequireDefault(_promise);
        var _deferred = __webpack_require__( /*! ../core/utils/deferred */ 6);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function _inherits(subClass, superClass) {
            if ("function" !== typeof superClass && null !== superClass) {
                throw new TypeError("Super expression must either be null or a function")
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) {
                _setPrototypeOf(subClass, superClass)
            }
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o
            };
            return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                    result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (call && ("object" === _typeof(call) || "function" === typeof call)) {
                return call
            }
            return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
            if (void 0 === self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return self
        }

        function _isNativeReflectConstruct() {
            if ("undefined" === typeof Reflect || !Reflect.construct) {
                return false
            }
            if (Reflect.construct.sham) {
                return false
            }
            if ("function" === typeof Proxy) {
                return true
            }
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                return true
            } catch (e) {
                return false
            }
        }

        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
            };
            return _getPrototypeOf(o)
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var STATUS = {
            valid: "valid",
            invalid: "invalid",
            pending: "pending"
        };
        var BaseRuleValidator = function() {
            function BaseRuleValidator() {
                _classCallCheck(this, BaseRuleValidator);
                this.NAME = "base"
            }
            _createClass(BaseRuleValidator, [{
                key: "defaultMessage",
                value: function(value) {
                    return _message2.default.getFormatter("validation-".concat(this.NAME))(value)
                }
            }, {
                key: "defaultFormattedMessage",
                value: function(value) {
                    return _message2.default.getFormatter("validation-".concat(this.NAME, "-formatted"))(value)
                }
            }, {
                key: "_isValueEmpty",
                value: function(value) {
                    return !rulesValidators.required.validate(value, {})
                }
            }, {
                key: "validate",
                value: function(value, rule) {
                    var _this = this;
                    var valueArray = Array.isArray(value) ? value : [value];
                    var result = true;
                    if (valueArray.length) {
                        valueArray.every(function(itemValue) {
                            result = _this._validate(itemValue, rule);
                            return result
                        })
                    } else {
                        result = this._validate(null, rule)
                    }
                    return result
                }
            }]);
            return BaseRuleValidator
        }();
        var RequiredRuleValidator = function(_BaseRuleValidator) {
            _inherits(RequiredRuleValidator, _BaseRuleValidator);
            var _super = _createSuper(RequiredRuleValidator);

            function RequiredRuleValidator() {
                var _this2;
                _classCallCheck(this, RequiredRuleValidator);
                _this2 = _super.call(this);
                _this2.NAME = "required";
                return _this2
            }
            _createClass(RequiredRuleValidator, [{
                key: "_validate",
                value: function(value, rule) {
                    if (!_type2.default.isDefined(value)) {
                        return false
                    }
                    if (false === value) {
                        return false
                    }
                    value = String(value);
                    if (rule.trim || !_type2.default.isDefined(rule.trim)) {
                        value = value.trim()
                    }
                    return "" !== value
                }
            }]);
            return RequiredRuleValidator
        }(BaseRuleValidator);
        var NumericRuleValidator = function(_BaseRuleValidator2) {
            _inherits(NumericRuleValidator, _BaseRuleValidator2);
            var _super2 = _createSuper(NumericRuleValidator);

            function NumericRuleValidator() {
                var _this3;
                _classCallCheck(this, NumericRuleValidator);
                _this3 = _super2.call(this);
                _this3.NAME = "numeric";
                return _this3
            }
            _createClass(NumericRuleValidator, [{
                key: "_validate",
                value: function(value, rule) {
                    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {
                        return true
                    }
                    if (rule.useCultureSettings && _type2.default.isString(value)) {
                        return !isNaN(_number2.default.parse(value))
                    } else {
                        return _type2.default.isNumeric(value)
                    }
                }
            }]);
            return NumericRuleValidator
        }(BaseRuleValidator);
        var RangeRuleValidator = function(_BaseRuleValidator3) {
            _inherits(RangeRuleValidator, _BaseRuleValidator3);
            var _super3 = _createSuper(RangeRuleValidator);

            function RangeRuleValidator() {
                var _this4;
                _classCallCheck(this, RangeRuleValidator);
                _this4 = _super3.call(this);
                _this4.NAME = "range";
                return _this4
            }
            _createClass(RangeRuleValidator, [{
                key: "_validate",
                value: function(value, rule) {
                    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {
                        return true
                    }
                    var validNumber = rulesValidators.numeric.validate(value, rule);
                    var validValue = _type2.default.isDefined(value) && "" !== value;
                    var number = validNumber ? parseFloat(value) : validValue && value.valueOf();
                    var min = rule.min;
                    var max = rule.max;
                    if (!(validNumber || _type2.default.isDate(value)) && !validValue) {
                        return false
                    }
                    if (_type2.default.isDefined(min)) {
                        if (_type2.default.isDefined(max)) {
                            return number >= min && number <= max
                        }
                        return number >= min
                    } else {
                        if (_type2.default.isDefined(max)) {
                            return number <= max
                        } else {
                            throw _errors2.default.Error("E0101")
                        }
                    }
                }
            }]);
            return RangeRuleValidator
        }(BaseRuleValidator);
        var StringLengthRuleValidator = function(_BaseRuleValidator4) {
            _inherits(StringLengthRuleValidator, _BaseRuleValidator4);
            var _super4 = _createSuper(StringLengthRuleValidator);

            function StringLengthRuleValidator() {
                var _this5;
                _classCallCheck(this, StringLengthRuleValidator);
                _this5 = _super4.call(this);
                _this5.NAME = "stringLength";
                return _this5
            }
            _createClass(StringLengthRuleValidator, [{
                key: "_validate",
                value: function(value, rule) {
                    value = _type2.default.isDefined(value) ? String(value) : "";
                    if (rule.trim || !_type2.default.isDefined(rule.trim)) {
                        value = value.trim()
                    }
                    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
                        return true
                    }
                    return rulesValidators.range.validate(value.length, (0, _extend.extend)({}, rule))
                }
            }]);
            return StringLengthRuleValidator
        }(BaseRuleValidator);
        var CustomRuleValidator = function(_BaseRuleValidator5) {
            _inherits(CustomRuleValidator, _BaseRuleValidator5);
            var _super5 = _createSuper(CustomRuleValidator);

            function CustomRuleValidator() {
                var _this6;
                _classCallCheck(this, CustomRuleValidator);
                _this6 = _super5.call(this);
                _this6.NAME = "custom";
                return _this6
            }
            _createClass(CustomRuleValidator, [{
                key: "validate",
                value: function(value, rule) {
                    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
                        return true
                    }
                    var validator = rule.validator;
                    var dataGetter = validator && _type2.default.isFunction(validator.option) && validator.option("dataGetter");
                    var extraParams = _type2.default.isFunction(dataGetter) && dataGetter();
                    var params = {
                        value: value,
                        validator: validator,
                        rule: rule
                    };
                    if (extraParams) {
                        (0, _extend.extend)(params, extraParams)
                    }
                    return rule.validationCallback(params)
                }
            }]);
            return CustomRuleValidator
        }(BaseRuleValidator);
        var AsyncRuleValidator = function(_CustomRuleValidator) {
            _inherits(AsyncRuleValidator, _CustomRuleValidator);
            var _super6 = _createSuper(AsyncRuleValidator);

            function AsyncRuleValidator() {
                var _this7;
                _classCallCheck(this, AsyncRuleValidator);
                _this7 = _super6.call(this);
                _this7.NAME = "async";
                return _this7
            }
            _createClass(AsyncRuleValidator, [{
                key: "validate",
                value: function(value, rule) {
                    if (!_type2.default.isDefined(rule.reevaluate)) {
                        (0, _extend.extend)(rule, {
                            reevaluate: true
                        })
                    }
                    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
                        return true
                    }
                    var validator = rule.validator;
                    var dataGetter = validator && _type2.default.isFunction(validator.option) && validator.option("dataGetter");
                    var extraParams = _type2.default.isFunction(dataGetter) && dataGetter();
                    var params = {
                        value: value,
                        validator: validator,
                        rule: rule
                    };
                    if (extraParams) {
                        (0, _extend.extend)(params, extraParams)
                    }
                    var callbackResult = rule.validationCallback(params);
                    if (!_type2.default.isPromise(callbackResult)) {
                        throw _errors2.default.Error("E0103")
                    }
                    return this._getWrappedPromise((0, _deferred.fromPromise)(callbackResult).promise())
                }
            }, {
                key: "_getWrappedPromise",
                value: function(promise) {
                    var deferred = new _deferred.Deferred;
                    promise.then(function(res) {
                        deferred.resolve(res)
                    }, function(err) {
                        var res = {
                            isValid: false
                        };
                        if (_type2.default.isDefined(err)) {
                            if (_type2.default.isString(err)) {
                                res.message = err
                            } else {
                                if (_type2.default.isObject(err) && _type2.default.isDefined(err.message) && _type2.default.isString(err.message)) {
                                    res.message = err.message
                                }
                            }
                        }
                        deferred.resolve(res)
                    });
                    return deferred.promise()
                }
            }]);
            return AsyncRuleValidator
        }(CustomRuleValidator);
        var CompareRuleValidator = function(_BaseRuleValidator6) {
            _inherits(CompareRuleValidator, _BaseRuleValidator6);
            var _super7 = _createSuper(CompareRuleValidator);

            function CompareRuleValidator() {
                var _this8;
                _classCallCheck(this, CompareRuleValidator);
                _this8 = _super7.call(this);
                _this8.NAME = "compare";
                return _this8
            }
            _createClass(CompareRuleValidator, [{
                key: "_validate",
                value: function(value, rule) {
                    if (!rule.comparisonTarget) {
                        throw _errors2.default.Error("E0102")
                    }
                    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
                        return true
                    }(0, _extend.extend)(rule, {
                        reevaluate: true
                    });
                    var otherValue = rule.comparisonTarget();
                    var type = rule.comparisonType || "==";
                    switch (type) {
                        case "==":
                            return value == otherValue;
                        case "!=":
                            return value != otherValue;
                        case "===":
                            return value === otherValue;
                        case "!==":
                            return value !== otherValue;
                        case ">":
                            return value > otherValue;
                        case ">=":
                            return value >= otherValue;
                        case "<":
                            return value < otherValue;
                        case "<=":
                            return value <= otherValue
                    }
                }
            }]);
            return CompareRuleValidator
        }(BaseRuleValidator);
        var PatternRuleValidator = function(_BaseRuleValidator7) {
            _inherits(PatternRuleValidator, _BaseRuleValidator7);
            var _super8 = _createSuper(PatternRuleValidator);

            function PatternRuleValidator() {
                var _this9;
                _classCallCheck(this, PatternRuleValidator);
                _this9 = _super8.call(this);
                _this9.NAME = "pattern";
                return _this9
            }
            _createClass(PatternRuleValidator, [{
                key: "_validate",
                value: function(value, rule) {
                    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {
                        return true
                    }
                    var pattern = rule.pattern;
                    if (_type2.default.isString(pattern)) {
                        pattern = new RegExp(pattern)
                    }
                    return pattern.test(value)
                }
            }]);
            return PatternRuleValidator
        }(BaseRuleValidator);
        var EmailRuleValidator = function(_BaseRuleValidator8) {
            _inherits(EmailRuleValidator, _BaseRuleValidator8);
            var _super9 = _createSuper(EmailRuleValidator);

            function EmailRuleValidator() {
                var _this10;
                _classCallCheck(this, EmailRuleValidator);
                _this10 = _super9.call(this);
                _this10.NAME = "email";
                return _this10
            }
            _createClass(EmailRuleValidator, [{
                key: "_validate",
                value: function(value, rule) {
                    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {
                        return true
                    }
                    return rulesValidators.pattern.validate(value, (0, _extend.extend)({}, rule, {
                        pattern: /^[\d\w._-]+@([\d\w._-]+\.)+[\w]+$/i
                    }))
                }
            }]);
            return EmailRuleValidator
        }(BaseRuleValidator);
        var rulesValidators = {
            required: new RequiredRuleValidator,
            numeric: new NumericRuleValidator,
            range: new RangeRuleValidator,
            stringLength: new StringLengthRuleValidator,
            custom: new CustomRuleValidator,
            async: new AsyncRuleValidator,
            compare: new CompareRuleValidator,
            pattern: new PatternRuleValidator,
            email: new EmailRuleValidator
        };
        var GroupConfig = _class2.default.inherit({
            ctor: function(group) {
                this.group = group;
                this.validators = [];
                this._pendingValidators = [];
                this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
                this._resetValidationInfo();
                this._eventsStrategy = new _events_strategy.EventsStrategy(this)
            },
            validate: function() {
                var _this11 = this;
                var result = {
                    isValid: true,
                    brokenRules: [],
                    validators: [],
                    status: STATUS.valid,
                    complete: null
                };
                this._unsubscribeFromAllChangeEvents();
                this._pendingValidators = [];
                this._resetValidationInfo();
                (0, _iterator.each)(this.validators, function(_, validator) {
                    var validatorResult = validator.validate();
                    result.isValid = result.isValid && validatorResult.isValid;
                    if (validatorResult.brokenRules) {
                        result.brokenRules = result.brokenRules.concat(validatorResult.brokenRules)
                    }
                    result.validators.push(validator);
                    if (validatorResult.status === STATUS.pending) {
                        _this11._addPendingValidator(validator)
                    }
                    _this11._subscribeToChangeEvents(validator)
                });
                if (this._pendingValidators.length) {
                    result.status = STATUS.pending
                } else {
                    result.status = result.isValid ? STATUS.valid : STATUS.invalid;
                    this._unsubscribeFromAllChangeEvents();
                    this._raiseValidatedEvent(result)
                }
                this._updateValidationInfo(result);
                return (0, _extend.extend)({}, this._validationInfo.result)
            },
            _subscribeToChangeEvents: function(validator) {
                validator.on("validating", this._onValidatorStatusChanged);
                validator.on("validated", this._onValidatorStatusChanged)
            },
            _unsubscribeFromChangeEvents: function(validator) {
                validator.off("validating", this._onValidatorStatusChanged);
                validator.off("validated", this._onValidatorStatusChanged)
            },
            _unsubscribeFromAllChangeEvents: function() {
                var _this12 = this;
                (0, _iterator.each)(this.validators, function(_, validator) {
                    _this12._unsubscribeFromChangeEvents(validator)
                })
            },
            _updateValidationInfo: function(result) {
                this._validationInfo.result = result;
                if (result.status !== STATUS.pending) {
                    return
                }
                if (!this._validationInfo.deferred) {
                    this._validationInfo.deferred = new _deferred.Deferred;
                    this._validationInfo.result.complete = this._validationInfo.deferred.promise()
                }
            },
            _addPendingValidator: function(validator) {
                var foundValidator = (0, _common.grep)(this._pendingValidators, function(val) {
                    return val === validator
                })[0];
                if (!foundValidator) {
                    this._pendingValidators.push(validator)
                }
            },
            _removePendingValidator: function(validator) {
                var index = (0, _array.inArray)(validator, this._pendingValidators);
                if (index >= 0) {
                    this._pendingValidators.splice(index, 1)
                }
            },
            _orderBrokenRules: function(brokenRules) {
                var orderedRules = [];
                (0, _iterator.each)(this.validators, function(_, validator) {
                    var foundRules = (0, _common.grep)(brokenRules, function(rule) {
                        return rule.validator === validator
                    });
                    if (foundRules.length) {
                        orderedRules = orderedRules.concat(foundRules)
                    }
                });
                return orderedRules
            },
            _updateBrokenRules: function(result) {
                if (!this._validationInfo.result) {
                    return
                }
                var brokenRules = this._validationInfo.result.brokenRules;
                var rules = (0, _common.grep)(brokenRules, function(rule) {
                    return rule.validator !== result.validator
                });
                if (result.brokenRules) {
                    brokenRules = rules.concat(result.brokenRules)
                }
                this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules)
            },
            _onValidatorStatusChanged: function(result) {
                if (result.status === STATUS.pending) {
                    this._addPendingValidator(result.validator);
                    return
                }
                this._resolveIfComplete(result)
            },
            _resolveIfComplete: function(result) {
                this._removePendingValidator(result.validator);
                this._updateBrokenRules(result);
                if (!this._pendingValidators.length) {
                    this._unsubscribeFromAllChangeEvents();
                    if (!this._validationInfo.result) {
                        return
                    }
                    this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;
                    this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
                    var res = (0, _extend.extend)({}, this._validationInfo.result, {
                        complete: null
                    });
                    var deferred = this._validationInfo.deferred;
                    this._resetValidationInfo();
                    this._raiseValidatedEvent(res);
                    deferred && setTimeout(function() {
                        deferred.resolve(res)
                    })
                }
            },
            _raiseValidatedEvent: function(result) {
                this._eventsStrategy.fireEvent("validated", [result])
            },
            _resetValidationInfo: function() {
                this._validationInfo = {
                    result: null,
                    deferred: null
                }
            },
            _synchronizeValidationInfo: function() {
                if (this._validationInfo.result) {
                    this._validationInfo.result.validators = this.validators
                }
            },
            removeRegisteredValidator: function(validator) {
                var index = (0, _array.inArray)(validator, this.validators);
                if (index > -1) {
                    this.validators.splice(index, 1);
                    this._synchronizeValidationInfo();
                    this._resolveIfComplete({
                        validator: validator
                    })
                }
            },
            registerValidator: function(validator) {
                if ((0, _array.inArray)(validator, this.validators) < 0) {
                    this.validators.push(validator);
                    this._synchronizeValidationInfo()
                }
            },
            reset: function() {
                (0, _iterator.each)(this.validators, function(_, validator) {
                    validator.reset()
                });
                this._pendingValidators = [];
                this._resetValidationInfo()
            },
            on: function(eventName, eventHandler) {
                this._eventsStrategy.on(eventName, eventHandler);
                return this
            },
            off: function(eventName, eventHandler) {
                this._eventsStrategy.off(eventName, eventHandler);
                return this
            }
        });
        var ValidationEngine = {
            groups: [],
            getGroupConfig: function(group) {
                var result = (0, _common.grep)(this.groups, function(config) {
                    return config.group === group
                });
                if (result.length) {
                    return result[0]
                }
            },
            findGroup: function($element, model) {
                var $dxGroup = $element.parents(".dx-validationgroup").first();
                if ($dxGroup.length) {
                    return $dxGroup.dxValidationGroup("instance")
                }
                return model
            },
            initGroups: function() {
                this.groups = [];
                this.addGroup()
            },
            addGroup: function(group) {
                var config = this.getGroupConfig(group);
                if (!config) {
                    config = new GroupConfig(group);
                    this.groups.push(config)
                }
                return config
            },
            removeGroup: function(group) {
                var config = this.getGroupConfig(group);
                var index = (0, _array.inArray)(config, this.groups);
                if (index > -1) {
                    this.groups.splice(index, 1)
                }
                return config
            },
            _setDefaultMessage: function(info) {
                var rule = info.rule,
                    validator = info.validator,
                    name = info.name;
                if (!_type2.default.isDefined(rule.message)) {
                    if (validator.defaultFormattedMessage && _type2.default.isDefined(name)) {
                        rule.message = validator.defaultFormattedMessage(name)
                    } else {
                        rule.message = validator.defaultMessage()
                    }
                }
            },
            _addBrokenRule: function(info) {
                var result = info.result,
                    rule = info.rule;
                if (!result.brokenRule) {
                    result.brokenRule = rule
                }
                if (!result.brokenRules) {
                    result.brokenRules = []
                }
                result.brokenRules.push(rule)
            },
            validate: function(value, rules, name) {
                var _this13 = this;
                var result = {
                    name: name,
                    value: value,
                    brokenRule: null,
                    brokenRules: null,
                    isValid: true,
                    validationRules: rules,
                    pendingRules: null,
                    status: STATUS.valid,
                    complete: null
                };
                var asyncRuleItems = [];
                (0, _iterator.each)(rules || [], function(_, rule) {
                    var ruleValidator = rulesValidators[rule.type];
                    var ruleValidationResult;
                    if (ruleValidator) {
                        if (_type2.default.isDefined(rule.isValid) && rule.value === value && !rule.reevaluate) {
                            if (!rule.isValid) {
                                result.isValid = false;
                                _this13._addBrokenRule({
                                    result: result,
                                    rule: rule
                                });
                                return false
                            }
                            return true
                        }
                        rule.value = value;
                        if ("async" === rule.type) {
                            asyncRuleItems.push({
                                rule: rule,
                                ruleValidator: ruleValidator
                            });
                            return true
                        }
                        ruleValidationResult = ruleValidator.validate(value, rule);
                        rule.isValid = ruleValidationResult;
                        if (!ruleValidationResult) {
                            result.isValid = false;
                            _this13._setDefaultMessage({
                                rule: rule,
                                validator: ruleValidator,
                                name: name
                            });
                            _this13._addBrokenRule({
                                result: result,
                                rule: rule
                            })
                        }
                        if (!rule.isValid) {
                            return false
                        }
                    } else {
                        throw _errors2.default.Error("E0100")
                    }
                });
                if (result.isValid && !result.brokenRules && asyncRuleItems.length) {
                    result = this._validateAsyncRules({
                        value: value,
                        items: asyncRuleItems,
                        result: result,
                        name: name
                    })
                }
                result.status = result.pendingRules ? STATUS.pending : result.isValid ? STATUS.valid : STATUS.invalid;
                return result
            },
            _validateAsyncRules: function(_ref) {
                var _this14 = this;
                var result = _ref.result,
                    value = _ref.value,
                    items = _ref.items,
                    name = _ref.name;
                var asyncResults = [];
                (0, _iterator.each)(items, function(_, item) {
                    var validateResult = item.ruleValidator.validate(value, item.rule);
                    if (!_type2.default.isPromise(validateResult)) {
                        _this14._updateRuleConfig({
                            rule: item.rule,
                            ruleResult: _this14._getPatchedRuleResult(validateResult),
                            validator: item.ruleValidator,
                            name: name
                        })
                    } else {
                        if (!result.pendingRules) {
                            result.pendingRules = []
                        }
                        result.pendingRules.push(item.rule);
                        var asyncResult = validateResult.then(function(res) {
                            var ruleResult = _this14._getPatchedRuleResult(res);
                            _this14._updateRuleConfig({
                                rule: item.rule,
                                ruleResult: ruleResult,
                                validator: item.ruleValidator,
                                name: name
                            });
                            return ruleResult
                        });
                        asyncResults.push(asyncResult)
                    }
                });
                if (asyncResults.length) {
                    result.complete = _promise2.default.all(asyncResults).then(function(values) {
                        return _this14._getAsyncRulesResult({
                            result: result,
                            values: values
                        })
                    })
                }
                return result
            },
            _updateRuleConfig: function(_ref2) {
                var rule = _ref2.rule,
                    ruleResult = _ref2.ruleResult,
                    validator = _ref2.validator,
                    name = _ref2.name;
                rule.isValid = ruleResult.isValid;
                if (!ruleResult.isValid) {
                    if (_type2.default.isDefined(ruleResult.message) && _type2.default.isString(ruleResult.message) && ruleResult.message.length) {
                        rule.message = ruleResult.message
                    } else {
                        this._setDefaultMessage({
                            rule: rule,
                            validator: validator,
                            name: name
                        })
                    }
                }
            },
            _getPatchedRuleResult: function(ruleResult) {
                var result;
                var isValid = true;
                if (_type2.default.isObject(ruleResult)) {
                    result = (0, _extend.extend)({}, ruleResult);
                    if (!_type2.default.isDefined(result.isValid)) {
                        result.isValid = isValid
                    }
                } else {
                    result = {
                        isValid: _type2.default.isBoolean(ruleResult) ? ruleResult : isValid
                    }
                }
                return result
            },
            _getAsyncRulesResult: function(_ref3) {
                var _this15 = this;
                var values = _ref3.values,
                    result = _ref3.result;
                (0, _iterator.each)(values, function(index, val) {
                    if (false === val.isValid) {
                        result.isValid = val.isValid;
                        var rule = result.pendingRules[index];
                        _this15._addBrokenRule({
                            result: result,
                            rule: rule
                        })
                    }
                });
                result.pendingRules = null;
                result.complete = null;
                result.status = result.isValid ? STATUS.valid : STATUS.invalid;
                return result
            },
            registerValidatorInGroup: function(group, validator) {
                var groupConfig = ValidationEngine.addGroup(group);
                groupConfig.registerValidator.call(groupConfig, validator)
            },
            _shouldRemoveGroup: function(group, validatorsInGroup) {
                var isDefaultGroup = void 0 === group;
                var isValidationGroupInstance = group && "dxValidationGroup" === group.NAME;
                return !isDefaultGroup && !isValidationGroupInstance && !validatorsInGroup.length
            },
            removeRegisteredValidator: function(group, validator) {
                var config = ValidationEngine.getGroupConfig(group);
                if (config) {
                    config.removeRegisteredValidator.call(config, validator);
                    var validatorsInGroup = config.validators;
                    if (this._shouldRemoveGroup(group, validatorsInGroup)) {
                        this.removeGroup(group)
                    }
                }
            },
            initValidationOptions: function(options) {
                var _this16 = this;
                var initedOptions = {};
                if (options) {
                    var syncOptions = ["isValid", "validationStatus", "validationError", "validationErrors"];
                    syncOptions.forEach(function(prop) {
                        if (prop in options) {
                            (0, _extend.extend)(initedOptions, _this16.synchronizeValidationOptions({
                                name: prop,
                                value: options[prop]
                            }, options))
                        }
                    })
                }
                return initedOptions
            },
            synchronizeValidationOptions: function(_ref4, options) {
                var name = _ref4.name,
                    value = _ref4.value;
                switch (name) {
                    case "validationStatus":
                        var isValid = value === STATUS.valid || value === STATUS.pending;
                        return options.isValid !== isValid ? {
                            isValid: isValid
                        } : {};
                    case "isValid":
                        var validationStatus = options.validationStatus;
                        var newStatus = validationStatus;
                        if (value && validationStatus === STATUS.invalid) {
                            newStatus = STATUS.valid
                        } else {
                            if (!value && validationStatus !== STATUS.invalid) {
                                newStatus = STATUS.invalid
                            }
                        }
                        return newStatus !== validationStatus ? {
                            validationStatus: newStatus
                        } : {};
                    case "validationErrors":
                        var validationError = !value || !value.length ? null : value[0];
                        return options.validationError !== validationError ? {
                            validationError: validationError
                        } : {};
                    case "validationError":
                        var validationErrors = options.validationErrors;
                        if (!value && validationErrors) {
                            return {
                                validationErrors: null
                            }
                        } else {
                            if (value && !validationErrors) {
                                return {
                                    validationErrors: [value]
                                }
                            } else {
                                if (value && validationErrors && value !== validationErrors[0]) {
                                    validationErrors[0] = value;
                                    return {
                                        validationErrors: validationErrors.slice()
                                    }
                                }
                            }
                        }
                }
                return {}
            },
            validateGroup: function(group) {
                var groupConfig = ValidationEngine.getGroupConfig(group);
                if (!groupConfig) {
                    throw _errors2.default.Error("E0110")
                }
                return groupConfig.validate()
            },
            resetGroup: function(group) {
                var groupConfig = ValidationEngine.getGroupConfig(group);
                if (!groupConfig) {
                    throw _errors2.default.Error("E0110")
                }
                return groupConfig.reset()
            }
        };
        ValidationEngine.initGroups();
        module.exports = ValidationEngine
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/core/utils/style.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var camelize = __webpack_require__( /*! ./inflector */ 34).camelize;
        var callOnce = __webpack_require__( /*! ./call_once */ 80);
        var typeUtils = __webpack_require__( /*! ./type */ 1);
        var domAdapter = __webpack_require__( /*! ../dom_adapter */ 12);
        var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"];
        var cssPrefixes = {
            "": "",
            Webkit: "-webkit-",
            Moz: "-moz-",
            O: "-o-",
            ms: "-ms-"
        };
        var getStyles = callOnce(function() {
            return domAdapter.createElement("dx").style
        });
        var forEachPrefixes = function(prop, callBack) {
            prop = camelize(prop, true);
            var result;
            for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
                var jsPrefix = jsPrefixes[i];
                var prefixedProp = jsPrefix + prop;
                var lowerPrefixedProp = camelize(prefixedProp);
                result = callBack(lowerPrefixedProp, jsPrefix);
                if (void 0 === result) {
                    result = callBack(prefixedProp, jsPrefix)
                }
                if (void 0 !== result) {
                    break
                }
            }
            return result || ""
        };
        var styleProp = function(name) {
            if (name in getStyles()) {
                return name
            }
            var originalName = name;
            name = name.charAt(0).toUpperCase() + name.substr(1);
            for (var i = 1; i < jsPrefixes.length; i++) {
                var prefixedProp = jsPrefixes[i].toLowerCase() + name;
                if (prefixedProp in getStyles()) {
                    return prefixedProp
                }
            }
            return originalName
        };
        var stylePropPrefix = function(prop) {
            return forEachPrefixes(prop, function(specific, jsPrefix) {
                if (specific in getStyles()) {
                    return cssPrefixes[jsPrefix]
                }
            })
        };
        var pxExceptions = ["fillOpacity", "columnCount", "flexGrow", "flexShrink", "fontWeight", "lineHeight", "opacity", "zIndex", "zoom"];
        var normalizeStyleProp = function(prop, value) {
            if (typeUtils.isNumeric(value) && pxExceptions.indexOf(prop) === -1) {
                value += "px"
            }
            return value
        };
        var setDimensionProperty = function(elements, propertyName, value) {
            if (elements) {
                value = typeUtils.isNumeric(value) ? value += "px" : value;
                for (var i = 0; i < elements.length; ++i) {
                    elements[i].style[propertyName] = value
                }
            }
        };
        var setWidth = function(elements, value) {
            setDimensionProperty(elements, "width", value)
        };
        var setHeight = function(elements, value) {
            setDimensionProperty(elements, "height", value)
        };
        exports.styleProp = styleProp;
        exports.stylePropPrefix = stylePropPrefix;
        exports.normalizeStyleProp = normalizeStyleProp;
        exports.setWidth = setWidth;
        exports.setHeight = setHeight
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/core/utils/variable_wrapper.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var logger = __webpack_require__( /*! ./console */ 65).logger;
        var dependencyInjector = __webpack_require__( /*! ./dependency_injector */ 56);
        module.exports = dependencyInjector({
            isWrapped: function() {
                return false
            },
            isWritableWrapped: function() {
                return false
            },
            wrap: function(value) {
                return value
            },
            unwrap: function(value) {
                return value
            },
            assign: function() {
                logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.")
            }
        })
    },
    /*!*********************************************!*\
      !*** ./artifacts/transpiled/events/hold.js ***!
      \*********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventUtils = __webpack_require__( /*! ./utils */ 8);
        var Emitter = __webpack_require__( /*! ./core/emitter */ 132);
        var registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 101);
        var abs = Math.abs;
        var HOLD_EVENT_NAME = "dxhold";
        var HOLD_TIMEOUT = 750;
        var TOUCH_BOUNDARY = 5;
        var HoldEmitter = Emitter.inherit({
            start: function(e) {
                this._startEventData = eventUtils.eventData(e);
                this._startTimer(e)
            },
            _startTimer: function(e) {
                var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
                this._holdTimer = setTimeout(function() {
                    this._requestAccept(e);
                    this._fireEvent(HOLD_EVENT_NAME, e, {
                        target: e.target
                    });
                    this._forgetAccept()
                }.bind(this), holdTimeout)
            },
            move: function(e) {
                if (this._touchWasMoved(e)) {
                    this._cancel(e)
                }
            },
            _touchWasMoved: function(e) {
                var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
                return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY
            },
            end: function() {
                this._stopTimer()
            },
            _stopTimer: function() {
                clearTimeout(this._holdTimer)
            },
            cancel: function() {
                this._stopTimer()
            },
            dispose: function() {
                this._stopTimer()
            }
        });
        registerEmitter({
            emitter: HoldEmitter,
            bubble: true,
            events: [HOLD_EVENT_NAME]
        });
        module.exports = {
            name: HOLD_EVENT_NAME
        }
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/data/odata/utils.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.OData__internals = exports.escapeServiceOperationParams = exports.formatFunctionInvocationUrl = exports.generateExpand = exports.generateSelect = exports.convertPrimitiveValue = exports.keyConverters = exports.serializeKey = exports.serializeValue = exports.serializePropName = exports.EdmLiteral = exports.sendRequest = void 0;
        var _class = __webpack_require__( /*! ../../core/class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _ajax = __webpack_require__( /*! ../../core/utils/ajax */ 75);
        var _ajax2 = _interopRequireDefault(_ajax);
        var _guid = __webpack_require__( /*! ../../core/guid */ 36);
        var _guid2 = _interopRequireDefault(_guid);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var _errors = __webpack_require__( /*! ../errors */ 38);
        var _utils = __webpack_require__( /*! ../utils */ 42);
        var _string = __webpack_require__( /*! ../../core/utils/string */ 43);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var GUID_REGEX = /^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/;
        var VERBOSE_DATE_REGEX = /^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/;
        var ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]{1}\d{2}(:?)(\d{2})?)?$/;
        var JSON_VERBOSE_MIME_TYPE = "application/json;odata=verbose";
        var makeArray = function(value) {
            return "string" === (0, _type.type)(value) ? value.split() : value
        };
        var hasDot = function(x) {
            return /\./.test(x)
        };
        var pad = function(text, length, right) {
            text = String(text);
            while (text.length < length) {
                text = right ? "".concat(text, "0") : "0".concat(text)
            }
            return text
        };
        var formatISO8601 = function(date, skipZeroTime, skipTimezone) {
            var bag = [];
            var isZeroTime = function() {
                return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1
            };
            var padLeft2 = function(text) {
                return pad(text, 2)
            };
            bag.push(date.getFullYear());
            bag.push("-");
            bag.push(padLeft2(date.getMonth() + 1));
            bag.push("-");
            bag.push(padLeft2(date.getDate()));
            if (!(skipZeroTime && isZeroTime())) {
                bag.push("T");
                bag.push(padLeft2(date.getHours()));
                bag.push(":");
                bag.push(padLeft2(date.getMinutes()));
                bag.push(":");
                bag.push(padLeft2(date.getSeconds()));
                if (date.getMilliseconds()) {
                    bag.push(".");
                    bag.push(pad(date.getMilliseconds(), 3))
                }
                if (!skipTimezone) {
                    bag.push("Z")
                }
            }
            return bag.join("")
        };
        var parseISO8601 = function(isoString) {
            var result = new Date(60 * new Date(0).getTimezoneOffset() * 1e3);
            var chunks = isoString.replace("Z", "").split("T");
            var date = /(\d{4})-(\d{2})-(\d{2})/.exec(chunks[0]);
            var time = /(\d{2}):(\d{2}):(\d{2})\.?(\d{0,7})?/.exec(chunks[1]);
            result.setFullYear(Number(date[1]));
            result.setMonth(Number(date[2]) - 1);
            result.setDate(Number(date[3]));
            if (Array.isArray(time) && time.length) {
                result.setHours(Number(time[1]));
                result.setMinutes(Number(time[2]));
                result.setSeconds(Number(time[3]));
                var fractional = (time[4] || "").slice(0, 3);
                fractional = pad(fractional, 3, true);
                result.setMilliseconds(Number(fractional))
            }
            return result
        };
        var isAbsoluteUrl = function(url) {
            return /^(?:[a-z]+:)?\/\//i.test(url)
        };
        var stripParams = function(url) {
            var index = url.indexOf("?");
            if (index > -1) {
                return url.substr(0, index)
            }
            return url
        };
        var toAbsoluteUrl = function(basePath, relativePath) {
            var part;
            var baseParts = stripParams(basePath).split("/");
            var relativeParts = relativePath.split("/");
            baseParts.pop();
            while (relativeParts.length) {
                part = relativeParts.shift();
                if (".." === part) {
                    baseParts.pop()
                } else {
                    baseParts.push(part)
                }
            }
            return baseParts.join("/")
        };
        var param = function(params) {
            var result = [];
            for (var name in params) {
                result.push(name + "=" + params[name])
            }
            return result.join("&")
        };
        var ajaxOptionsForRequest = function(protocolVersion, request) {
            var _options$beforeSend;
            var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            var formatPayload = function(payload) {
                return JSON.stringify(payload, function(key, value) {
                    if (!(this[key] instanceof Date)) {
                        return value
                    }
                    value = formatISO8601(this[key]);
                    switch (protocolVersion) {
                        case 2:
                            return value.substr(0, value.length - 1);
                        case 3:
                        case 4:
                            return value;
                        default:
                            throw _errors.errors.Error("E4002")
                    }
                })
            };
            request = (0, _extend.extend)({
                async: true,
                method: "get",
                url: "",
                params: {},
                payload: null,
                headers: {},
                timeout: 3e4
            }, request);
            null === (_options$beforeSend = options.beforeSend) || void 0 === _options$beforeSend ? void 0 : _options$beforeSend.call(options, request);
            var _request = request,
                async = _request.async, timeout = _request.timeout, headers = _request.headers;
            var _request2 = request,
                url = _request2.url,
                method = _request2.method;
            var jsonp = options.jsonp,
                withCredentials = options.withCredentials;
            method = (method || "get").toLowerCase();
            var isGet = "get" === method;
            var useJsonp = isGet && jsonp;
            var params = (0, _extend.extend)({}, request.params);
            var ajaxData = isGet ? params : formatPayload(request.payload);
            var qs = !isGet && param(params);
            var contentType = !isGet && JSON_VERBOSE_MIME_TYPE;
            if (qs) {
                url += (url.indexOf("?") > -1 ? "&" : "?") + qs
            }
            if (useJsonp) {
                ajaxData.$format = "json"
            }
            return {
                url: url,
                data: ajaxData,
                dataType: useJsonp ? "jsonp" : "json",
                jsonp: useJsonp && "$callback",
                method: method,
                async: async,
                timeout: timeout,
                headers: headers,
                contentType: contentType,
                accepts: {
                    json: [JSON_VERBOSE_MIME_TYPE, "text/plain"].join()
                },
                xhrFields: {
                    withCredentials: withCredentials
                }
            }
        };
        exports.sendRequest = function sendRequest(protocolVersion, request, options) {
            var deserializeDates = options.deserializeDates,
                fieldTypes = options.fieldTypes,
                countOnly = options.countOnly,
                isPaged = options.isPaged;
            var d = new _deferred.Deferred;
            var ajaxOptions = ajaxOptionsForRequest(protocolVersion, request, options);
            _ajax2.default.sendRequest(ajaxOptions).always(function(obj, textStatus) {
                var transformOptions = {
                    deserializeDates: deserializeDates,
                    fieldTypes: fieldTypes
                };
                var tuple = interpretJsonFormat(obj, textStatus, transformOptions, ajaxOptions);
                var error = tuple.error,
                    data = tuple.data,
                    count = tuple.count;
                var nextUrl = tuple.nextUrl;
                if (error) {
                    if (error.message !== _utils.XHR_ERROR_UNLOAD) {
                        d.reject(error)
                    }
                } else {
                    if (countOnly) {
                        if (isFinite(count)) {
                            d.resolve(count)
                        } else {
                            d.reject(new _errors.errors.Error("E4018"))
                        }
                    } else {
                        if (nextUrl && !isPaged) {
                            if (!isAbsoluteUrl(nextUrl)) {
                                nextUrl = toAbsoluteUrl(ajaxOptions.url, nextUrl)
                            }
                            sendRequest(protocolVersion, {
                                url: nextUrl
                            }, options).fail(d.reject).done(function(nextData) {
                                return d.resolve(data.concat(nextData))
                            })
                        } else {
                            var extra = isFinite(count) ? {
                                totalCount: count
                            } : void 0;
                            d.resolve(data, extra)
                        }
                    }
                }
            });
            return d.promise()
        };
        var formatDotNetError = function(errorObj) {
            var message;
            var currentError = errorObj;
            if ("message" in errorObj) {
                var _errorObj$message;
                message = (null === (_errorObj$message = errorObj.message) || void 0 === _errorObj$message ? void 0 : _errorObj$message.value) || errorObj.message
            }
            while (currentError = currentError.innererror || currentError.internalexception) {
                message = currentError.message;
                if (currentError.internalexception && message.indexOf("inner exception") === -1) {
                    break
                }
            }
            return message
        };
        var errorFromResponse = function(obj, textStatus, ajaxOptions) {
            var _response, _response2, _response3, _response4;
            if ("nocontent" === textStatus) {
                return null
            }
            var message = "Unknown error";
            var response = obj;
            var httpStatus = 200;
            var errorData = {
                requestOptions: ajaxOptions
            };
            if ("success" !== textStatus) {
                var status = obj.status,
                    responseText = obj.responseText;
                httpStatus = status;
                message = (0, _utils.errorMessageFromXhr)(obj, textStatus);
                try {
                    response = JSON.parse(responseText)
                } catch (x) {}
            }
            var errorObj = (null === (_response = response) || void 0 === _response ? void 0 : _response.then) || (null === (_response2 = response) || void 0 === _response2 ? void 0 : _response2.error) || (null === (_response3 = response) || void 0 === _response3 ? void 0 : _response3["odata.error"]) || (null === (_response4 = response) || void 0 === _response4 ? void 0 : _response4["@odata.error"]);
            if (errorObj) {
                message = formatDotNetError(errorObj) || message;
                errorData.errorDetails = errorObj;
                if (200 === httpStatus) {
                    httpStatus = 500
                }
                var customCode = Number(errorObj.code);
                if (isFinite(customCode) && customCode >= 400) {
                    httpStatus = customCode
                }
            }
            if (httpStatus >= 400 || 0 === httpStatus) {
                errorData.httpStatus = httpStatus;
                return (0, _extend.extend)(Error(message), errorData)
            }
            return null
        };
        var interpretJsonFormat = function(obj, textStatus, transformOptions, ajaxOptions) {
            var error = errorFromResponse(obj, textStatus, ajaxOptions);
            if (error) {
                return {
                    error: error
                }
            }
            if (!(0, _type.isPlainObject)(obj)) {
                return {
                    data: obj
                }
            }
            var value = "d" in obj && (Array.isArray(obj.d) || (0, _type.isObject)(obj.d)) ? interpretVerboseJsonFormat(obj, textStatus) : interpretLightJsonFormat(obj, textStatus);
            transformTypes(value, transformOptions);
            return value
        };
        var interpretVerboseJsonFormat = function(_ref) {
            var _data$results;
            var data = _ref.d;
            if (!(0, _type.isDefined)(data)) {
                return {
                    error: Error("Malformed or unsupported JSON response received")
                }
            }
            return {
                data: null !== (_data$results = data.results) && void 0 !== _data$results ? _data$results : data,
                nextUrl: data.__next,
                count: parseInt(data.__count, 10)
            }
        };
        var interpretLightJsonFormat = function(obj) {
            var _obj$value;
            return {
                data: null !== (_obj$value = obj.value) && void 0 !== _obj$value ? _obj$value : obj,
                nextUrl: obj["@odata.nextLink"],
                count: parseInt(obj["@odata.count"], 10)
            }
        };
        var EdmLiteral = exports.EdmLiteral = _class2.default.inherit({
            ctor: function(value) {
                this._value = value
            },
            valueOf: function() {
                return this._value
            }
        });
        var transformTypes = function transformTypes(obj) {
            var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            (0, _iterator.each)(obj, function(key, value) {
                if (null !== value && "object" === _typeof(value)) {
                    if ("results" in value) {
                        obj[key] = value.results
                    }
                    transformTypes(obj[key], options)
                } else {
                    if ("string" === typeof value) {
                        var fieldTypes = options.fieldTypes,
                            deserializeDates = options.deserializeDates;
                        var canBeGuid = !fieldTypes || "String" !== fieldTypes[key];
                        if (canBeGuid && GUID_REGEX.test(value)) {
                            obj[key] = new _guid2.default(value)
                        }
                        if (false !== deserializeDates) {
                            if (value.match(VERBOSE_DATE_REGEX)) {
                                var date = new Date(Number(RegExp.$1) + 60 * RegExp.$2 * 1e3);
                                obj[key] = new Date(date.valueOf() + 60 * date.getTimezoneOffset() * 1e3)
                            } else {
                                if (ISO8601_DATE_REGEX.test(value)) {
                                    obj[key] = new Date(parseISO8601(obj[key]).valueOf())
                                }
                            }
                        }
                    }
                }
            })
        };
        var serializeDate = function(date) {
            return "datetime'".concat(formatISO8601(date, true, true), "'")
        };
        var serializeString = function(value) {
            return "'".concat(value.replace(/'/g, "''"), "'")
        };
        var serializePropName = exports.serializePropName = function(propName) {
            return propName instanceof EdmLiteral ? propName.valueOf() : propName.replace(/\./g, "/")
        };
        var serializeValueV4 = function serializeValueV4(value) {
            if (value instanceof Date) {
                return formatISO8601(value, false, false)
            }
            if (value instanceof _guid2.default) {
                return value.valueOf()
            }
            if (Array.isArray(value)) {
                return "[".concat(value.map(function(item) {
                    return serializeValueV4(item)
                }).join(","), "]")
            }
            return serializeValueV2(value)
        };
        var serializeValueV2 = function(value) {
            if (value instanceof Date) {
                return serializeDate(value)
            }
            if (value instanceof _guid2.default) {
                return "guid'".concat(value, "'")
            }
            if (value instanceof EdmLiteral) {
                return value.valueOf()
            }
            if ("string" === typeof value) {
                return serializeString(value)
            }
            return String(value)
        };
        var serializeValue = exports.serializeValue = function(value, protocolVersion) {
            switch (protocolVersion) {
                case 2:
                case 3:
                    return serializeValueV2(value);
                case 4:
                    return serializeValueV4(value);
                default:
                    throw _errors.errors.Error("E4002")
            }
        };
        exports.serializeKey = function(key, protocolVersion) {
            if ((0, _type.isPlainObject)(key)) {
                var parts = [];
                (0, _iterator.each)(key, function(k, v) {
                    return parts.push("".concat(serializePropName(k), "=").concat(serializeValue(v, protocolVersion)))
                });
                return parts.join()
            }
            return serializeValue(key, protocolVersion)
        };
        var keyConverters = exports.keyConverters = {
            String: function(value) {
                return "".concat(value)
            },
            Int32: function(value) {
                return Math.floor(value)
            },
            Int64: function(value) {
                return value instanceof EdmLiteral ? value : new EdmLiteral("".concat(value, "L"))
            },
            Guid: function(value) {
                return value instanceof _guid2.default ? value : new _guid2.default(value)
            },
            Boolean: function(value) {
                return !!value
            },
            Single: function(value) {
                return value instanceof EdmLiteral ? value : new EdmLiteral(value + "f")
            },
            Decimal: function(value) {
                return value instanceof EdmLiteral ? value : new EdmLiteral(value + "m")
            }
        };
        exports.convertPrimitiveValue = function(type, value) {
            if (null === value) {
                return null
            }
            var converter = keyConverters[type];
            if (!converter) {
                throw _errors.errors.Error("E4014", type)
            }
            return converter(value)
        };
        exports.generateSelect = function(oDataVersion, select) {
            if (!select) {
                return
            }
            return oDataVersion < 4 ? serializePropName(select.join()) : (0, _common.grep)(select, hasDot, true).join()
        };
        var formatCore = function formatCore(hash) {
            var result = "";
            var selectValue = [];
            var expandValue = [];
            (0, _iterator.each)(hash, function(key, value) {
                if (Array.isArray(value)) {
                    [].push.apply(selectValue, value)
                }
                if ((0, _type.isPlainObject)(value)) {
                    expandValue.push("".concat(key).concat(formatCore(value)))
                }
            });
            if (selectValue.length || expandValue.length) {
                result += "(";
                if (selectValue.length) {
                    result += "$select=".concat((0, _iterator.map)(selectValue, serializePropName).join())
                }
                if (expandValue.length) {
                    if (selectValue.length) {
                        result += ";"
                    }
                    result += "$expand=".concat((0, _iterator.map)(expandValue, serializePropName).join())
                }
                result += ")"
            }
            return result
        };
        var format = function(hash) {
            var result = [];
            (0, _iterator.each)(hash, function(key, value) {
                return result.push("".concat(key).concat(formatCore(value)))
            });
            return result.join()
        };
        var parseCore = function parseCore(exprParts, root, stepper) {
            var result = stepper(root, exprParts.shift(), exprParts);
            if (false === result) {
                return
            }
            parseCore(exprParts, result, stepper)
        };
        var parseTree = function(exprs, root, stepper) {
            return (0, _iterator.each)(exprs, function(_, x) {
                return parseCore(x.split("."), root, stepper)
            })
        };
        var generatorV2 = function(expand, select) {
            var hash = {};
            if (expand) {
                (0, _iterator.each)(makeArray(expand), function() {
                    hash[serializePropName(this)] = 1
                })
            }
            if (select) {
                (0, _iterator.each)(makeArray(select), function() {
                    var path = this.split(".");
                    if (path.length < 2) {
                        return
                    }
                    path.pop();
                    hash[serializePropName(path.join("."))] = 1
                })
            }
            return (0, _iterator.map)(hash, function(_, v) {
                return v
            }).join()
        };
        var generatorV4 = function(expand, select) {
            var hash = {};
            if (expand || select) {
                if (expand) {
                    parseTree(makeArray(expand), hash, function(node, key, path) {
                        node[key] = node[key] || {};
                        return !path.length ? false : node[key]
                    })
                }
                if (select) {
                    parseTree((0, _common.grep)(makeArray(select), hasDot), hash, function(node, key, path) {
                        if (!path.length) {
                            node[key] = node[key] || [];
                            node[key].push(key);
                            return false
                        }
                        return node[key] = node[key] || {}
                    })
                }
                return format(hash)
            }
        };
        exports.generateExpand = function(oDataVersion, expand, select) {
            return oDataVersion < 4 ? generatorV2(expand, select) : generatorV4(expand, select)
        };
        exports.formatFunctionInvocationUrl = function(baseUrl, args) {
            return (0, _string.format)("{0}({1})", baseUrl, (0, _iterator.map)(args || {}, function(value, key) {
                return (0, _string.format)("{0}={1}", key, value)
            }).join(","))
        };
        exports.escapeServiceOperationParams = function(params, version) {
            if (!params) {
                return params
            }
            var result = {};
            (0, _iterator.each)(params, function(k, v) {
                result[k] = serializeValue(v, version)
            });
            return result
        };
        exports.OData__internals = {
            interpretJsonFormat: interpretJsonFormat
        }
    }, , ,
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/viz/core/export.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.plugin = exports.ExportMenu = exports.combineMarkups = exports.exportWidgets = exports.getMarkup = exports.exportFromMarkup = void 0;
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _window = __webpack_require__( /*! ../../core/utils/window */ 7);
        var _utils = __webpack_require__( /*! ./utils */ 13);
        var _exporter = __webpack_require__( /*! ../../exporter */ 179);
        var _exporter2 = _interopRequireDefault(_exporter);
        var _message = __webpack_require__( /*! ../../localization/message */ 10);
        var _message2 = _interopRequireDefault(_message);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _themes = __webpack_require__( /*! ../themes */ 50);
        var _themes2 = _interopRequireDefault(_themes);
        var _hover = __webpack_require__( /*! ../../events/hover */ 156);
        var _hover2 = _interopRequireDefault(_hover);
        var _pointer = __webpack_require__( /*! ../../events/pointer */ 23);
        var _pointer2 = _interopRequireDefault(_pointer);
        var _console = __webpack_require__( /*! ../../core/utils/console */ 65);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var imageExporter = _exporter2.default.image;
        var svgExporter = _exporter2.default.svg;
        var pdfExporter = _exporter2.default.pdf;
        var pointerActions = [_pointer2.default.down, _pointer2.default.move].join(" ");
        var BUTTON_SIZE = 35;
        var ICON_COORDS = [
            [9, 12, 26, 12, 26, 14, 9, 14],
            [9, 17, 26, 17, 26, 19, 9, 19],
            [9, 22, 26, 22, 26, 24, 9, 24]
        ];
        var LIST_PADDING_TOP = 4;
        var LIST_WIDTH = 120;
        var VERTICAL_TEXT_MARGIN = 8;
        var HORIZONTAL_TEXT_MARGIN = 15;
        var MENU_ITEM_HEIGHT = 30;
        var LIST_STROKE_WIDTH = 1;
        var MARGIN = 10;
        var SHADOW_OFFSET = 2;
        var SHADOW_BLUR = 3;
        var DEFAULT_EXPORT_FORMAT = "PNG";
        var ALLOWED_IMAGE_FORMATS = [DEFAULT_EXPORT_FORMAT, "JPEG", "GIF"];
        var ALLOWED_EXTRA_FORMATS = ["PDF", "SVG"];
        var EXPORT_CSS_CLASS = "dx-export-menu";
        var EXPORT_DATA_KEY = "export-element-type";
        var FORMAT_DATA_KEY = "export-element-format";
        var GET_COLOR_REGEX = /data-backgroundcolor="([^"]*)"/;

        function getValidFormats() {
            var imageFormats = imageExporter.testFormats(ALLOWED_IMAGE_FORMATS);
            return {
                unsupported: imageFormats.unsupported,
                supported: imageFormats.supported.concat(ALLOWED_EXTRA_FORMATS)
            }
        }

        function validateFormat(format, incidentOccurred, validFormats) {
            validFormats = validFormats || getValidFormats();
            format = String(format).toUpperCase();
            if (validFormats.supported.indexOf(format) !== -1) {
                return format
            }
            if (validFormats.unsupported.indexOf(format) !== -1) {
                incidentOccurred && incidentOccurred("W2108", [format])
            }
        }

        function getCreatorFunc(format) {
            if ("SVG" === format) {
                return svgExporter.getData
            } else {
                if ("PDF" === format) {
                    return pdfExporter.getData
                } else {
                    return imageExporter.getData
                }
            }
        }

        function _print(imageSrc, options) {
            var document = (0, _window.getWindow)().document;
            var iFrame = document.createElement("iframe");
            iFrame.onload = setPrint(imageSrc, options);
            iFrame.style.visibility = "hidden";
            iFrame.style.position = "fixed";
            iFrame.style.right = "0";
            iFrame.style.bottom = "0";
            document.body.appendChild(iFrame)
        }

        function setPrint(imageSrc, options) {
            return function() {
                var _this = this;
                var window = this.contentWindow;
                var img = window.document.createElement("img");
                window.document.body.appendChild(img);
                var origImageSrc = imageSrc;
                if (options.__test) {
                    imageSrc = options.__test.imageSrc;
                    window = options.__test.mockWindow
                }
                var removeFrame = function() {
                    options.__test && options.__test.checkAssertions();
                    _this.parentElement.removeChild(_this);
                    options.__test && options.__test.deferred.resolve(origImageSrc)
                };
                img.addEventListener("load", function() {
                    window.focus();
                    window.print();
                    removeFrame()
                });
                img.addEventListener("error", removeFrame);
                img.src = imageSrc
            }
        }

        function getItemAttributes(options, type, itemIndex) {
            var x = BUTTON_SIZE - LIST_WIDTH;
            var y = BUTTON_SIZE + LIST_PADDING_TOP + LIST_STROKE_WIDTH + itemIndex * MENU_ITEM_HEIGHT;
            var attr = {
                rect: {
                    width: LIST_WIDTH - 2 * LIST_STROKE_WIDTH,
                    height: MENU_ITEM_HEIGHT,
                    x: x + LIST_STROKE_WIDTH,
                    y: y
                },
                text: {
                    x: x + (options.rtl ? LIST_WIDTH - HORIZONTAL_TEXT_MARGIN : HORIZONTAL_TEXT_MARGIN),
                    y: y + MENU_ITEM_HEIGHT - VERTICAL_TEXT_MARGIN
                }
            };
            if ("printing" === type) {
                attr.separator = {
                    stroke: options.button.default.borderColor,
                    "stroke-width": LIST_STROKE_WIDTH,
                    cursor: "pointer",
                    sharp: "v",
                    d: "M " + x + " " + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH) + " L " + (x + LIST_WIDTH) + " " + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH)
                }
            }
            return attr
        }

        function createMenuItem(renderer, options, settings) {
            var itemData = {};
            var type = settings.type;
            var format = settings.format;
            var attr = getItemAttributes(options, type, settings.itemIndex);
            var fontStyle = (0, _utils.patchFontOptions)(options.font);
            fontStyle["pointer-events"] = "none";
            var menuItem = renderer.g().attr({
                "class": EXPORT_CSS_CLASS + "-list-item"
            });
            itemData[EXPORT_DATA_KEY] = type;
            if (format) {
                itemData[FORMAT_DATA_KEY] = format
            }
            var rect = renderer.rect();
            rect.attr(attr.rect).css({
                cursor: "pointer",
                "pointer-events": "all"
            }).data(itemData);
            rect.on(_hover2.default.start + ".export", function() {
                return rect.attr({
                    fill: options.button.hover.backgroundColor
                })
            }).on(_hover2.default.end + ".export", function() {
                return rect.attr({
                    fill: null
                })
            });
            rect.append(menuItem);
            var text = renderer.text(settings.text).css(fontStyle).attr(attr.text).append(menuItem);
            if ("printing" === type) {
                renderer.path(null, "line").attr(attr.separator).append(menuItem)
            }
            return {
                g: menuItem,
                rect: rect,
                resetState: function() {
                    return rect.attr({
                        fill: null
                    })
                },
                fixPosition: function() {
                    var textBBox = text.getBBox();
                    text.move(attr.text.x - textBBox.x - (options.rtl ? textBBox.width : 0))
                }
            }
        }

        function createMenuItems(renderer, options) {
            var items = [];
            if (options.printingEnabled) {
                items.push(createMenuItem(renderer, options, {
                    type: "printing",
                    text: _message2.default.format("vizExport-printingButtonText"),
                    itemIndex: items.length
                }))
            }
            items = options.formats.reduce(function(r, format) {
                r.push(createMenuItem(renderer, options, {
                    type: "exporting",
                    text: _message2.default.getFormatter("vizExport-exportButtonText")(format),
                    format: format,
                    itemIndex: r.length
                }));
                return r
            }, items);
            return items
        }

        function getBackgroundColorFromMarkup(markup) {
            var parsedMarkup = GET_COLOR_REGEX.exec(markup);
            return null === parsedMarkup || void 0 === parsedMarkup ? void 0 : parsedMarkup[1]
        }
        var exportFromMarkup = exports.exportFromMarkup = function(markup, options) {
            options.format = validateFormat(options.format) || DEFAULT_EXPORT_FORMAT;
            options.fileName = options.fileName || "file";
            options.exportingAction = options.onExporting;
            options.exportedAction = options.onExported;
            options.fileSavingAction = options.onFileSaving;
            options.margin = (0, _type.isDefined)(options.margin) ? options.margin : MARGIN;
            options.backgroundColor = (0, _type.isDefined)(options.backgroundColor) ? options.backgroundColor : getBackgroundColorFromMarkup(markup) || _themes2.default.getTheme().backgroundColor;
            _exporter2.default.export(markup, options, getCreatorFunc(options.format))
        };
        exports.getMarkup = function(widgets) {
            return combineMarkups(widgets).markup
        };
        exports.exportWidgets = function(widgets, options) {
            options = options || {};
            var markupInfo = exports.combineMarkups(widgets, {
                gridLayout: options.gridLayout,
                verticalAlignment: options.verticalAlignment,
                horizontalAlignment: options.horizontalAlignment
            });
            options.width = markupInfo.width;
            options.height = markupInfo.height;
            exportFromMarkup(markupInfo.markup, options)
        };
        var combineMarkups = exports.combineMarkups = function(widgets) {
            var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if (!Array.isArray(widgets)) {
                widgets = [
                    [widgets]
                ]
            } else {
                if (!Array.isArray(widgets[0])) {
                    widgets = widgets.map(function(item) {
                        return [item]
                    })
                }
            }
            var compactView = !options.gridLayout;
            var exportItems = widgets.reduce(function(r, row, rowIndex) {
                var rowInfo = row.reduce(function(r, item, colIndex) {
                    var size = item.getSize();
                    var backgroundColor = item.option("backgroundColor") || _themes2.default.getTheme(item.option("theme")).backgroundColor;
                    backgroundColor && r.backgroundColors.indexOf(backgroundColor) === -1 && r.backgroundColors.push(backgroundColor);
                    r.hOffset = r.width;
                    r.width += size.width;
                    r.height = Math.max(r.height, size.height);
                    r.itemWidth = Math.max(r.itemWidth, size.width);
                    r.items.push({
                        markup: item.svg(),
                        width: size.width,
                        height: size.height,
                        c: colIndex,
                        r: rowIndex,
                        hOffset: r.hOffset
                    });
                    return r
                }, {
                    items: [],
                    height: 0,
                    itemWidth: 0,
                    hOffset: 0,
                    width: 0,
                    backgroundColors: r.backgroundColors
                });
                r.rowOffsets.push(r.totalHeight);
                r.rowHeights.push(rowInfo.height);
                r.totalHeight += rowInfo.height;
                r.items = r.items.concat(rowInfo.items);
                r.itemWidth = Math.max(r.itemWidth, rowInfo.itemWidth);
                r.maxItemLen = Math.max(r.maxItemLen, rowInfo.items.length);
                r.totalWidth = compactView ? Math.max(r.totalWidth, rowInfo.width) : r.maxItemLen * r.itemWidth;
                return r
            }, {
                items: [],
                rowOffsets: [],
                rowHeights: [],
                itemWidth: 0,
                totalHeight: 0,
                maxItemLen: 0,
                totalWidth: 0,
                backgroundColors: []
            });
            var backgroundColor = 'data-backgroundcolor="'.concat(1 === exportItems.backgroundColors.length ? exportItems.backgroundColors[0] : "", '" ');
            var getVOffset = function(item) {
                var align = options.verticalAlignment;
                var dy = exportItems.rowHeights[item.r] - item.height;
                return exportItems.rowOffsets[item.r] + ("bottom" === align ? dy : "center" === align ? dy / 2 : 0)
            };
            var getHOffset = function(item) {
                if (compactView) {
                    return item.hOffset
                }
                var align = options.horizontalAlignment;
                var colWidth = exportItems.itemWidth;
                var dx = colWidth - item.width;
                return item.c * colWidth + ("right" === align ? dx : "center" === align ? dx / 2 : 0)
            };
            var totalHeight = exportItems.totalHeight;
            var totalWidth = exportItems.totalWidth;
            return {
                markup: "<svg " + backgroundColor + 'height="' + totalHeight + '" width="' + totalWidth + '" version="1.1" xmlns="http://www.w3.org/2000/svg">' + exportItems.items.map(function(item) {
                    return '<g transform="translate('.concat(getHOffset(item), ",").concat(getVOffset(item), ')">').concat(item.markup, "</g>")
                }).join("") + "</svg>",
                width: totalWidth,
                height: totalHeight
            }
        };
        var ExportMenu = exports.ExportMenu = function(params) {
            var renderer = this._renderer = params.renderer;
            this._incidentOccurred = params.incidentOccurred;
            this._exportTo = params.exportTo;
            this._print = params.print;
            this._shadow = renderer.shadowFilter("-50%", "-50%", "200%", "200%", SHADOW_OFFSET, 6, SHADOW_BLUR);
            this._shadow.attr({
                opacity: .8
            });
            this._group = renderer.g().attr({
                "class": EXPORT_CSS_CLASS,
                "hidden-for-export": true
            }).linkOn(renderer.root, {
                name: "export-menu",
                after: "peripheral"
            });
            this._buttonGroup = renderer.g().attr({
                "class": EXPORT_CSS_CLASS + "-button"
            }).append(this._group);
            this._listGroup = renderer.g().attr({
                "class": EXPORT_CSS_CLASS + "-list"
            }).append(this._group);
            this._overlay = renderer.rect(-LIST_WIDTH + BUTTON_SIZE, BUTTON_SIZE + LIST_PADDING_TOP, LIST_WIDTH, 0);
            this._overlay.attr({
                "stroke-width": LIST_STROKE_WIDTH,
                cursor: "pointer",
                rx: 4,
                ry: 4,
                filter: this._shadow.id
            });
            this._overlay.data({
                "export-element-type": "list"
            });
            this.validFormats = getValidFormats();
            this._subscribeEvents()
        };
        (0, _extend.extend)(ExportMenu.prototype, {
            getLayoutOptions: function() {
                if (this._hiddenDueToLayout) {
                    return {
                        width: 0,
                        height: 0,
                        cutSide: "vertical",
                        cutLayoutSide: "top"
                    }
                }
                var bBox = this._buttonGroup.getBBox();
                bBox.cutSide = "vertical";
                bBox.cutLayoutSide = "top";
                bBox.height += MARGIN;
                bBox.position = {
                    vertical: "top",
                    horizontal: "right"
                };
                bBox.verticalAlignment = "top";
                bBox.horizontalAlignment = "right";
                return bBox
            },
            probeDraw: function() {
                this._fillSpace();
                this.show()
            },
            shift: function(_, y) {
                this._group.attr({
                    translateY: this._group.attr("translateY") + y
                })
            },
            draw: function(width, height, canvas) {
                this._group.move(width - BUTTON_SIZE - SHADOW_OFFSET - SHADOW_BLUR + canvas.left, Math.floor(height / 2 - BUTTON_SIZE / 2));
                var layoutOptions = this.getLayoutOptions();
                if (layoutOptions.width > width || layoutOptions.height > height) {
                    this.freeSpace()
                }
                return this
            },
            show: function() {
                this._group.linkAppend()
            },
            hide: function() {
                this._group.linkRemove()
            },
            setOptions: function(options) {
                var _this2 = this;
                this._options = options;
                if (options.formats) {
                    options.formats = options.formats.reduce(function(r, format) {
                        format = validateFormat(format, _this2._incidentOccurred, _this2.validFormats);
                        format && r.push(format);
                        return r
                    }, [])
                } else {
                    options.formats = this.validFormats.supported.slice()
                }
                options.printingEnabled = void 0 === options.printingEnabled ? true : options.printingEnabled;
                if (options.enabled && (options.formats.length || options.printingEnabled)) {
                    this.show();
                    this._updateButton();
                    this._updateList();
                    this._hideList()
                } else {
                    this.hide()
                }
            },
            dispose: function() {
                this._unsubscribeEvents();
                this._group.linkRemove().linkOff();
                this._group.dispose();
                this._shadow.dispose()
            },
            layoutOptions: function() {
                return this._options.enabled && {
                    horizontalAlignment: "right",
                    verticalAlignment: "top",
                    weak: true
                }
            },
            measure: function() {
                this._fillSpace();
                var margin = this._options.button.margin;
                return [BUTTON_SIZE + margin.left + margin.right, BUTTON_SIZE + margin.top + margin.bottom]
            },
            move: function(rect) {
                var margin = this._options.button.margin;
                this._group.attr({
                    translateX: Math.round(rect[0]) + margin.left,
                    translateY: Math.round(rect[1]) + margin.top
                })
            },
            _fillSpace: function() {
                this._hiddenDueToLayout = false;
                this.show()
            },
            freeSpace: function() {
                this._incidentOccurred("W2107");
                this._hiddenDueToLayout = true;
                this.hide()
            },
            _hideList: function() {
                this._listGroup.remove();
                this._listShown = false;
                this._setButtonState("default");
                this._menuItems.forEach(function(item) {
                    return item.resetState()
                })
            },
            _showList: function() {
                this._listGroup.append(this._group);
                this._listShown = true;
                this._menuItems.forEach(function(item) {
                    return item.fixPosition()
                })
            },
            _setButtonState: function(state) {
                var style = this._options.button[state];
                this._button.attr({
                    stroke: style.borderColor,
                    fill: style.backgroundColor
                });
                this._icon.attr({
                    fill: style.color
                })
            },
            _subscribeEvents: function() {
                var _this3 = this;
                this._renderer.root.on(_pointer2.default.up + ".export", function(e) {
                    var elementType = e.target[EXPORT_DATA_KEY];
                    if (!elementType) {
                        if (_this3._button) {
                            _this3._hideList()
                        }
                        return
                    }
                    if ("button" === elementType) {
                        if (_this3._listShown) {
                            _this3._setButtonState("default");
                            _this3._hideList()
                        } else {
                            _this3._setButtonState("focus");
                            _this3._showList()
                        }
                    } else {
                        if ("printing" === elementType) {
                            _this3._print();
                            _this3._hideList()
                        } else {
                            if ("exporting" === elementType) {
                                _this3._exportTo(e.target[FORMAT_DATA_KEY]);
                                _this3._hideList()
                            }
                        }
                    }
                });
                this._listGroup.on(pointerActions, function(e) {
                    return e.stopPropagation()
                });
                this._buttonGroup.on(_pointer2.default.enter, function() {
                    return _this3._setButtonState("hover")
                });
                this._buttonGroup.on(_pointer2.default.leave, function() {
                    return _this3._setButtonState(_this3._listShown ? "focus" : "default")
                });
                this._buttonGroup.on(_pointer2.default.down + ".export", function() {
                    return _this3._setButtonState("active")
                })
            },
            _unsubscribeEvents: function() {
                this._renderer.root.off(".export");
                this._listGroup.off();
                this._buttonGroup.off()
            },
            _updateButton: function() {
                var renderer = this._renderer;
                var options = this._options;
                var exportData = {
                    "export-element-type": "button"
                };
                if (!this._button) {
                    this._button = renderer.rect(0, 0, BUTTON_SIZE, BUTTON_SIZE).append(this._buttonGroup);
                    this._button.attr({
                        rx: 4,
                        ry: 4,
                        fill: options.button.default.backgroundColor,
                        stroke: options.button.default.borderColor,
                        "stroke-width": 1,
                        cursor: "pointer"
                    });
                    this._button.data(exportData);
                    this._icon = renderer.path(ICON_COORDS).append(this._buttonGroup);
                    this._icon.attr({
                        fill: options.button.default.color,
                        cursor: "pointer"
                    });
                    this._icon.data(exportData);
                    this._buttonGroup.setTitle(_message2.default.format("vizExport-titleMenuText"))
                }
            },
            _updateList: function() {
                var options = this._options;
                var buttonDefault = options.button.default;
                var listGroup = this._listGroup;
                var items = createMenuItems(this._renderer, options);
                this._shadow.attr({
                    color: options.shadowColor
                });
                this._overlay.attr({
                    height: items.length * MENU_ITEM_HEIGHT + 2 * LIST_STROKE_WIDTH,
                    fill: buttonDefault.backgroundColor,
                    stroke: buttonDefault.borderColor
                });
                listGroup.clear();
                this._overlay.append(listGroup);
                items.forEach(function(item) {
                    return item.g.append(listGroup)
                });
                this._menuItems = items
            }
        });

        function getExportOptions(widget, exportOptions, fileName, format) {
            if (format || exportOptions.format) {
                format = validateFormat(format || exportOptions.format, widget._incidentOccurred)
            }
            return {
                format: format || DEFAULT_EXPORT_FORMAT,
                fileName: fileName || exportOptions.fileName || "file",
                proxyUrl: exportOptions.proxyUrl,
                backgroundColor: exportOptions.backgroundColor,
                width: widget._canvas.width,
                height: widget._canvas.height,
                margin: exportOptions.margin,
                svgToCanvas: exportOptions.svgToCanvas,
                forceProxy: exportOptions.forceProxy,
                exportingAction: widget._createActionByOption("onExporting"),
                exportedAction: widget._createActionByOption("onExported"),
                fileSavingAction: widget._createActionByOption("onFileSaving")
            }
        }
        exports.plugin = {
            name: "export",
            init: function() {
                var _this4 = this;
                this._exportMenu = new exports.ExportMenu({
                    renderer: this._renderer,
                    incidentOccurred: this._incidentOccurred,
                    print: function() {
                        return _this4.print()
                    },
                    exportTo: function(format) {
                        return _this4.exportTo(void 0, format)
                    }
                });
                this._layout.add(this._exportMenu)
            },
            dispose: function() {
                this._exportMenu.dispose()
            },
            members: {
                _getExportMenuOptions: function() {
                    return (0, _extend.extend)({}, this._getOption("export"), {
                        rtl: this._getOption("rtlEnabled", true)
                    })
                },
                _disablePointerEvents: function() {
                    var pointerEventsValue = this._renderer.root.attr("pointer-events");
                    this._renderer.root.attr({
                        "pointer-events": "none"
                    });
                    return pointerEventsValue
                },
                exportTo: function(fileName, format) {
                    var _this5 = this;
                    var menu = this._exportMenu;
                    var options = getExportOptions(this, this._getOption("export") || {}, fileName, format);
                    menu && menu.hide();
                    var pointerEventsValue = this._disablePointerEvents();
                    var promise = _exporter2.default.export(this._renderer.root.element, options, getCreatorFunc(options.format)).fail(_console.logger.error).always(function() {
                        _this5._renderer.root.attr({
                            "pointer-events": pointerEventsValue
                        })
                    });
                    menu && menu.show();
                    return promise
                },
                print: function() {
                    var _this6 = this;
                    var menu = this._exportMenu;
                    var options = getExportOptions(this, this._getOption("export") || {});
                    options.__test = this._getOption("export").__test;
                    options.exportingAction = null;
                    options.exportedAction = null;
                    options.margin = 0;
                    options.format = "PNG";
                    options.forceProxy = true;
                    options.fileSavingAction = function(eventArgs) {
                        _print("data:image/png;base64,".concat(eventArgs.data), {
                            __test: options.__test
                        });
                        eventArgs.cancel = true
                    };
                    var pointerEventsValue = this._disablePointerEvents();
                    menu && menu.hide();
                    var promise = _exporter2.default.export(this._renderer.root.element, options, getCreatorFunc(options.format)).fail(_console.logger.error).always(function() {
                        _this6._renderer.root.attr({
                            "pointer-events": pointerEventsValue
                        })
                    });
                    menu && menu.show();
                    return promise
                }
            },
            customize: function(constructor) {
                var proto = constructor.prototype;
                constructor.addChange({
                    code: "EXPORT",
                    handler: function() {
                        this._exportMenu.setOptions(this._getExportMenuOptions());
                        this._change(["LAYOUT"])
                    },
                    isThemeDependent: true,
                    isOptionChange: true,
                    option: "export"
                });
                proto._optionChangesMap.onExporting = "EXPORT";
                proto._optionChangesMap.onExported = "EXPORT";
                proto._optionChangesMap.onFileSaving = "EXPORT"
            },
            fontFields: ["export.font"]
        }
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/core/events_strategy.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.EventsStrategy = void 0;
        var _callbacks = __webpack_require__( /*! ./utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);
        var _iterator = __webpack_require__( /*! ./utils/iterator */ 4);
        var _type = __webpack_require__( /*! ./utils/type */ 1);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        exports.EventsStrategy = function() {
            function EventsStrategy(owner) {
                _classCallCheck(this, EventsStrategy);
                this._events = {};
                this._owner = owner
            }
            _createClass(EventsStrategy, [{
                key: "hasEvent",
                value: function(eventName) {
                    var callbacks = this._events[eventName];
                    return callbacks ? callbacks.has() : false
                }
            }, {
                key: "fireEvent",
                value: function(eventName, eventArgs) {
                    var callbacks = this._events[eventName];
                    if (callbacks) {
                        callbacks.fireWith(this._owner, eventArgs)
                    }
                    return this._owner
                }
            }, {
                key: "on",
                value: function(eventName, eventHandler) {
                    var _this = this;
                    if ((0, _type.isPlainObject)(eventName)) {
                        (0, _iterator.each)(eventName, function(e, h) {
                            _this.on(e, h)
                        })
                    } else {
                        var callbacks = this._events[eventName];
                        if (!callbacks) {
                            callbacks = (0, _callbacks2.default)();
                            this._events[eventName] = callbacks
                        }
                        var addFn = callbacks.originalAdd || callbacks.add;
                        addFn.call(callbacks, eventHandler)
                    }
                }
            }, {
                key: "off",
                value: function(eventName, eventHandler) {
                    var callbacks = this._events[eventName];
                    if (callbacks) {
                        if ((0, _type.isFunction)(eventHandler)) {
                            callbacks.remove(eventHandler)
                        } else {
                            callbacks.empty()
                        }
                    }
                }
            }, {
                key: "dispose",
                value: function() {
                    (0, _iterator.each)(this._events, function(eventName, event) {
                        event.empty()
                    })
                }
            }], [{
                key: "create",
                value: function(owner, strategy) {
                    if (strategy) {
                        return (0, _type.isFunction)(strategy) ? strategy(owner) : strategy
                    } else {
                        return new EventsStrategy(owner)
                    }
                }
            }]);
            return EventsStrategy
        }()
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/events/core/emitter_registrator.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var readyCallbacks = __webpack_require__( /*! ../../core/utils/ready_callbacks */ 51);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var dataUtils = __webpack_require__( /*! ../../core/element_data */ 41);
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var inArray = __webpack_require__( /*! ../../core/utils/array */ 14).inArray;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var registerEvent = __webpack_require__( /*! ./event_registrator */ 77);
        var eventUtils = __webpack_require__( /*! ../utils */ 8);
        var pointerEvents = __webpack_require__( /*! ../pointer */ 23);
        var wheelEvent = __webpack_require__( /*! ./wheel */ 133);
        var MANAGER_EVENT = "dxEventManager";
        var EMITTER_DATA = "dxEmitter";
        var EventManager = Class.inherit({
            ctor: function() {
                this._attachHandlers();
                this.reset();
                this._proxiedCancelHandler = this._cancelHandler.bind(this);
                this._proxiedAcceptHandler = this._acceptHandler.bind(this)
            },
            _attachHandlers: function() {
                readyCallbacks.add(function() {
                    var document = domAdapter.getDocument();
                    eventsEngine.subscribeGlobal(document, eventUtils.addNamespace(pointerEvents.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
                    eventsEngine.subscribeGlobal(document, eventUtils.addNamespace(pointerEvents.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
                    eventsEngine.subscribeGlobal(document, eventUtils.addNamespace([pointerEvents.up, pointerEvents.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this));
                    eventsEngine.subscribeGlobal(document, eventUtils.addNamespace(wheelEvent.name, MANAGER_EVENT), this._mouseWheelHandler.bind(this))
                }.bind(this))
            },
            _eachEmitter: function(callback) {
                var activeEmitters = this._activeEmitters || [];
                var i = 0;
                while (activeEmitters.length > i) {
                    var emitter = activeEmitters[i];
                    if (false === callback(emitter)) {
                        break
                    }
                    if (activeEmitters[i] === emitter) {
                        i++
                    }
                }
            },
            _applyToEmitters: function(method, arg) {
                this._eachEmitter(function(emitter) {
                    emitter[method].call(emitter, arg)
                })
            },
            reset: function() {
                this._eachEmitter(this._proxiedCancelHandler);
                this._activeEmitters = []
            },
            resetEmitter: function(emitter) {
                this._proxiedCancelHandler(emitter)
            },
            _pointerDownHandler: function(e) {
                if (eventUtils.isMouseEvent(e) && e.which > 1) {
                    return
                }
                this._updateEmitters(e)
            },
            _updateEmitters: function(e) {
                if (!this._isSetChanged(e)) {
                    return
                }
                this._cleanEmitters(e);
                this._fetchEmitters(e)
            },
            _isSetChanged: function(e) {
                var currentSet = this._closestEmitter(e);
                var previousSet = this._emittersSet || [];
                var setChanged = currentSet.length !== previousSet.length;
                each(currentSet, function(index, emitter) {
                    setChanged = setChanged || previousSet[index] !== emitter;
                    return !setChanged
                });
                this._emittersSet = currentSet;
                return setChanged
            },
            _closestEmitter: function(e) {
                var that = this;
                var result = [];
                var $element = $(e.target);

                function handleEmitter(_, emitter) {
                    if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
                        emitter.addCancelCallback(that._proxiedCancelHandler);
                        emitter.addAcceptCallback(that._proxiedAcceptHandler);
                        result.push(emitter)
                    }
                }
                while ($element.length) {
                    var emitters = dataUtils.data($element.get(0), EMITTER_DATA) || [];
                    each(emitters, handleEmitter);
                    $element = $element.parent()
                }
                return result
            },
            _acceptHandler: function(acceptedEmitter, e) {
                var that = this;
                this._eachEmitter(function(emitter) {
                    if (emitter !== acceptedEmitter) {
                        that._cancelEmitter(emitter, e)
                    }
                })
            },
            _cancelHandler: function(canceledEmitter, e) {
                this._cancelEmitter(canceledEmitter, e)
            },
            _cancelEmitter: function(emitter, e) {
                var activeEmitters = this._activeEmitters;
                if (e) {
                    emitter.cancel(e)
                } else {
                    emitter.reset()
                }
                emitter.removeCancelCallback();
                emitter.removeAcceptCallback();
                var emitterIndex = inArray(emitter, activeEmitters);
                if (emitterIndex > -1) {
                    activeEmitters.splice(emitterIndex, 1)
                }
            },
            _cleanEmitters: function(e) {
                this._applyToEmitters("end", e);
                this.reset(e)
            },
            _fetchEmitters: function(e) {
                this._activeEmitters = this._emittersSet.slice();
                this._applyToEmitters("start", e)
            },
            _pointerMoveHandler: function(e) {
                this._applyToEmitters("move", e)
            },
            _pointerUpHandler: function(e) {
                this._updateEmitters(e)
            },
            _mouseWheelHandler: function(e) {
                if (!this._allowInterruptionByMouseWheel()) {
                    return
                }
                e.pointers = [null];
                this._pointerDownHandler(e);
                this._adjustWheelEvent(e);
                this._pointerMoveHandler(e);
                e.pointers = [];
                this._pointerUpHandler(e)
            },
            _allowInterruptionByMouseWheel: function() {
                var allowInterruption = true;
                this._eachEmitter(function(emitter) {
                    allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
                    return allowInterruption
                });
                return allowInterruption
            },
            _adjustWheelEvent: function(e) {
                var closestGestureEmitter = null;
                this._eachEmitter(function(emitter) {
                    if (!emitter.gesture) {
                        return
                    }
                    var direction = emitter.getDirection(e);
                    if ("horizontal" !== direction && !e.shiftKey || "vertical" !== direction && e.shiftKey) {
                        closestGestureEmitter = emitter;
                        return false
                    }
                });
                if (!closestGestureEmitter) {
                    return
                }
                var direction = closestGestureEmitter.getDirection(e);
                var verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction;
                var prop = verticalGestureDirection ? "pageY" : "pageX";
                e[prop] += e.delta
            },
            isActive: function(element) {
                var result = false;
                this._eachEmitter(function(emitter) {
                    result = result || emitter.getElement().is(element)
                });
                return result
            }
        });
        var eventManager = new EventManager;
        var EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
        var registerEmitter = function(emitterConfig) {
            var emitterClass = emitterConfig.emitter;
            var emitterName = emitterConfig.events[0];
            var emitterEvents = emitterConfig.events;
            each(emitterEvents, function(_, eventName) {
                registerEvent(eventName, {
                    noBubble: !emitterConfig.bubble,
                    setup: function(element) {
                        var subscriptions = dataUtils.data(element, EMITTER_SUBSCRIPTION_DATA) || {};
                        var emitters = dataUtils.data(element, EMITTER_DATA) || {};
                        var emitter = emitters[emitterName] || new emitterClass(element);
                        subscriptions[eventName] = true;
                        emitters[emitterName] = emitter;
                        dataUtils.data(element, EMITTER_DATA, emitters);
                        dataUtils.data(element, EMITTER_SUBSCRIPTION_DATA, subscriptions)
                    },
                    add: function(element, handleObj) {
                        var emitters = dataUtils.data(element, EMITTER_DATA);
                        var emitter = emitters[emitterName];
                        emitter.configure(extend({
                            delegateSelector: handleObj.selector
                        }, handleObj.data), handleObj.type)
                    },
                    teardown: function(element) {
                        var subscriptions = dataUtils.data(element, EMITTER_SUBSCRIPTION_DATA);
                        var emitters = dataUtils.data(element, EMITTER_DATA);
                        var emitter = emitters[emitterName];
                        delete subscriptions[eventName];
                        var disposeEmitter = true;
                        each(emitterEvents, function(_, eventName) {
                            disposeEmitter = disposeEmitter && !subscriptions[eventName];
                            return disposeEmitter
                        });
                        if (disposeEmitter) {
                            if (eventManager.isActive(element)) {
                                eventManager.resetEmitter(emitter)
                            }
                            emitter && emitter.dispose();
                            delete emitters[emitterName]
                        }
                    }
                })
            })
        };
        module.exports = registerEmitter
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/core/base_widget.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _window = __webpack_require__( /*! ../../core/utils/window */ 7);
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _version = __webpack_require__( /*! ../../core/version */ 164);
        var _version2 = _interopRequireDefault(_version);
        var _resize_callbacks = __webpack_require__( /*! ../../core/utils/resize_callbacks */ 114);
        var _resize_callbacks2 = _interopRequireDefault(_resize_callbacks);
        var _string = __webpack_require__( /*! ../../core/utils/string */ 43);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _base_theme_manager = __webpack_require__( /*! ../core/base_theme_manager */ 257);
        var _base_theme_manager2 = _interopRequireDefault(_base_theme_manager);
        var _dom_component = __webpack_require__( /*! ../../core/dom_component */ 68);
        var _dom_component2 = _interopRequireDefault(_dom_component);
        var _helpers = __webpack_require__( /*! ./helpers */ 150);
        var _helpers2 = _interopRequireDefault(_helpers);
        var _utils = __webpack_require__( /*! ./utils */ 13);
        var _errors_warnings = __webpack_require__( /*! ./errors_warnings */ 814);
        var _renderer3 = __webpack_require__( /*! ./renderers/renderer */ 163);
        var _renderer4 = _interopRequireDefault(_renderer3);
        var _layout = __webpack_require__( /*! ./layout */ 816);
        var _layout2 = _interopRequireDefault(_layout);
        var _devices = __webpack_require__( /*! ../../core/devices */ 15);
        var _devices2 = _interopRequireDefault(_devices);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _floor = Math.floor;
        var OPTION_RTL_ENABLED = "rtlEnabled";
        var SIZED_ELEMENT_CLASS = "dx-sized-element";
        var _option = _dom_component2.default.prototype.option;

        function getTrue() {
            return true
        }

        function getFalse() {
            return false
        }

        function areCanvasesDifferent(canvas1, canvas2) {
            return !(canvas1.width === canvas2.width && canvas1.height === canvas2.height && canvas1.left === canvas2.left && canvas1.top === canvas2.top && canvas1.right === canvas2.right && canvas1.bottom === canvas2.bottom)
        }

        function createResizeHandler(callback) {
            var timeout;
            var handler = function() {
                clearTimeout(timeout);
                timeout = setTimeout(callback, 100)
            };
            handler.dispose = function() {
                clearTimeout(timeout);
                return this
            };
            return handler
        }

        function defaultOnIncidentOccurred(e) {
            if (!e.component._eventsStrategy.hasEvent("incidentOccurred")) {
                _errors_warnings.log.apply(null, [e.target.id].concat(e.target.args || []))
            }
        }
        var createIncidentOccurred = function(widgetName, eventTrigger) {
            return function(id, args) {
                eventTrigger("incidentOccurred", {
                    target: {
                        id: id,
                        type: "E" === id[0] ? "error" : "warning",
                        args: args,
                        text: _string.format.apply(null, [_errors_warnings.ERROR_MESSAGES[id]].concat(args || [])),
                        widget: widgetName,
                        version: _version2.default
                    }
                })
            }
        };

        function pickPositiveValue(values) {
            return values.reduce(function(result, value) {
                return value > 0 && !result ? value : result
            }, 0)
        }
        var getEmptyComponent = function() {
            var emptyComponentConfig = {
                _initTemplates: function() {},
                ctor: function(element, options) {
                    this.callBase(element, options);
                    var sizedElement = _dom_adapter2.default.createElement("div");
                    var width = options && (0, _type.isNumeric)(options.width) ? options.width + "px" : "100%";
                    var height = options && (0, _type.isNumeric)(options.height) ? options.height + "px" : this._getDefaultSize().height + "px";
                    _dom_adapter2.default.setStyle(sizedElement, "width", width);
                    _dom_adapter2.default.setStyle(sizedElement, "height", height);
                    _dom_adapter2.default.setClass(sizedElement, SIZED_ELEMENT_CLASS);
                    _dom_adapter2.default.insertElement(element, sizedElement)
                }
            };
            var EmptyComponent = _dom_component2.default.inherit(emptyComponentConfig);
            var originalInherit = EmptyComponent.inherit;
            EmptyComponent.inherit = function(config) {
                for (var field in config) {
                    if ((0, _type.isFunction)(config[field]) && "_" !== field.substr(0, 1) && "option" !== field || "_dispose" === field || "_optionChanged" === field) {
                        config[field] = _common.noop
                    }
                }
                return originalInherit.call(this, config)
            };
            return EmptyComponent
        };
        var isServerSide = !(0, _window.hasWindow)();

        function sizeIsValid(value) {
            return (0, _type.isDefined)(value) && value > 0
        }
        module.exports = isServerSide ? getEmptyComponent() : _dom_component2.default.inherit({
            _eventsMap: {
                onIncidentOccurred: {
                    name: "incidentOccurred"
                },
                onDrawn: {
                    name: "drawn"
                }
            },
            _getDefaultOptions: function() {
                return (0, _extend.extend)(this.callBase(), {
                    onIncidentOccurred: defaultOnIncidentOccurred
                })
            },
            _useLinks: true,
            _init: function() {
                var that = this;
                that._$element.children("." + SIZED_ELEMENT_CLASS).remove();
                that.callBase.apply(that, arguments);
                that._changesLocker = 0;
                that._optionChangedLocker = 0;
                that._changes = _helpers2.default.changes();
                that._suspendChanges();
                that._themeManager = that._createThemeManager();
                that._themeManager.setCallback(function() {
                    that._requestChange(that._themeDependentChanges)
                });
                that._renderElementAttributes();
                that._initRenderer();
                var linkTarget = that._useLinks && that._renderer.root;
                linkTarget && linkTarget.enableLinks().virtualLink("core").virtualLink("peripheral");
                that._renderVisibilityChange();
                that._attachVisibilityChangeHandlers();
                that._toggleParentsScrollSubscription(this._isVisible());
                that._initEventTrigger();
                that._incidentOccurred = createIncidentOccurred(that.NAME, that._eventTrigger);
                that._layout = new _layout2.default;
                linkTarget && linkTarget.linkAfter("core");
                that._initPlugins();
                that._initCore();
                linkTarget && linkTarget.linkAfter();
                that._change(that._initialChanges)
            },
            _createThemeManager: function() {
                return new _base_theme_manager2.default.BaseThemeManager(this._getThemeManagerOptions())
            },
            _getThemeManagerOptions: function() {
                return {
                    themeSection: this._themeSection,
                    fontFields: this._fontFields
                }
            },
            _initialChanges: ["LAYOUT", "RESIZE_HANDLER", "THEME", "DISABLED"],
            _initPlugins: function() {
                var that = this;
                (0, _iterator.each)(that._plugins, function(_, plugin) {
                    plugin.init.call(that)
                })
            },
            _disposePlugins: function() {
                var that = this;
                (0, _iterator.each)(that._plugins.slice().reverse(), function(_, plugin) {
                    plugin.dispose.call(that)
                })
            },
            _change: function(codes) {
                this._changes.add(codes)
            },
            _suspendChanges: function() {
                ++this._changesLocker
            },
            _resumeChanges: function() {
                var that = this;
                if (0 === --that._changesLocker && that._changes.count() > 0 && !that._applyingChanges) {
                    that._renderer.lock();
                    that._applyingChanges = true;
                    that._applyChanges();
                    that._changes.reset();
                    that._applyingChanges = false;
                    that._renderer.unlock();
                    if (that._optionsQueue) {
                        that._applyQueuedOptions()
                    }
                    that._optionChangedLocker++;
                    that._notify();
                    that._optionChangedLocker--
                }
            },
            _applyQueuedOptions: function() {
                var that = this;
                var queue = that._optionsQueue;
                that._optionsQueue = null;
                that.beginUpdate();
                (0, _iterator.each)(queue, function(_, action) {
                    action()
                });
                that.endUpdate()
            },
            _requestChange: function(codes) {
                this._suspendChanges();
                this._change(codes);
                this._resumeChanges()
            },
            _applyChanges: function() {
                var that = this;
                var changes = that._changes;
                var order = that._totalChangesOrder;
                var i;
                var ii = order.length;
                for (i = 0; i < ii; ++i) {
                    if (changes.has(order[i])) {
                        that["_change_" + order[i]]()
                    }
                }
            },
            _optionChangesOrder: ["EVENTS", "THEME", "RENDERER", "RESIZE_HANDLER"],
            _layoutChangesOrder: ["ELEMENT_ATTR", "CONTAINER_SIZE", "LAYOUT"],
            _customChangesOrder: ["DISABLED"],
            _change_EVENTS: function() {
                this._eventTrigger.applyChanges()
            },
            _change_THEME: function() {
                this._setThemeAndRtl()
            },
            _change_RENDERER: function() {
                this._setRendererOptions()
            },
            _change_RESIZE_HANDLER: function() {
                this._setupResizeHandler()
            },
            _change_ELEMENT_ATTR: function() {
                this._renderElementAttributes();
                this._change(["CONTAINER_SIZE"])
            },
            _change_CONTAINER_SIZE: function() {
                this._updateSize()
            },
            _change_LAYOUT: function() {
                this._setContentSize()
            },
            _change_DISABLED: function() {
                var renderer = this._renderer;
                var root = renderer.root;
                if (this.option("disabled")) {
                    this._initDisabledState = root.attr("pointer-events");
                    root.attr({
                        "pointer-events": "none",
                        filter: renderer.getGrayScaleFilter().id
                    })
                } else {
                    if ("none" === root.attr("pointer-events")) {
                        root.attr({
                            "pointer-events": (0, _type.isDefined)(this._initDisabledState) ? this._initDisabledState : null,
                            filter: null
                        })
                    }
                }
            },
            _themeDependentChanges: ["RENDERER"],
            _initRenderer: function() {
                var that = this;
                that._canvas = that._calculateCanvas();
                that._renderer = new _renderer4.default.Renderer({
                    cssClass: that._rootClassPrefix + " " + that._rootClass,
                    pathModified: that.option("pathModified"),
                    container: that._$element[0]
                });
                that._renderer.resize(that._canvas.width, that._canvas.height)
            },
            _disposeRenderer: function() {
                this._useLinks && this._renderer.root.checkLinks();
                this._renderer.dispose()
            },
            _getAnimationOptions: _common.noop,
            render: function() {
                this._requestChange(["CONTAINER_SIZE"]);
                var visible = this._isVisible();
                this._toggleParentsScrollSubscription(visible);
                !visible && this._stopCurrentHandling()
            },
            _toggleParentsScrollSubscription: function(subscribe) {
                var $parents = (0, _renderer2.default)(this._renderer.root.element).parents();
                var scrollEvents = "scroll.viz_widgets";
                if ("generic" === _devices2.default.real().platform) {
                    $parents = $parents.add((0, _window.getWindow)())
                }
                this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function() {
                    this._stopCurrentHandling()
                }.bind(this);
                _events_engine2.default.off((0, _renderer2.default)().add(this._$prevRootParents), scrollEvents, this._proxiedTargetParentsScrollHandler);
                if (subscribe) {
                    _events_engine2.default.on($parents, scrollEvents, this._proxiedTargetParentsScrollHandler);
                    this._$prevRootParents = $parents
                }
            },
            _stopCurrentHandling: _common.noop,
            _dispose: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                that._toggleParentsScrollSubscription(false);
                that._removeResizeHandler();
                that._layout.dispose();
                that._eventTrigger.dispose();
                that._disposeCore();
                that._disposePlugins();
                that._disposeRenderer();
                that._themeManager.dispose();
                that._themeManager = that._renderer = that._eventTrigger = null
            },
            _initEventTrigger: function() {
                var that = this;
                that._eventTrigger = createEventTrigger(that._eventsMap, function(name) {
                    return that._createActionByOption(name)
                })
            },
            _calculateCanvas: function() {
                var that = this;
                var size = that.option("size") || {};
                var margin = that.option("margin") || {};
                var defaultCanvas = that._getDefaultSize() || {};
                var elementWidth = !sizeIsValid(size.width) && (0, _window.hasWindow)() ? that._$element.width() : 0;
                var elementHeight = !sizeIsValid(size.height) && (0, _window.hasWindow)() ? that._$element.height() : 0;
                var canvas = {
                    width: size.width <= 0 ? 0 : _floor(pickPositiveValue([size.width, elementWidth, defaultCanvas.width])),
                    height: size.height <= 0 ? 0 : _floor(pickPositiveValue([size.height, elementHeight, defaultCanvas.height])),
                    left: pickPositiveValue([margin.left, defaultCanvas.left]),
                    top: pickPositiveValue([margin.top, defaultCanvas.top]),
                    right: pickPositiveValue([margin.right, defaultCanvas.right]),
                    bottom: pickPositiveValue([margin.bottom, defaultCanvas.bottom])
                };
                if (canvas.width - canvas.left - canvas.right <= 0 || canvas.height - canvas.top - canvas.bottom <= 0) {
                    canvas = {
                        width: 0,
                        height: 0
                    }
                }
                return canvas
            },
            _updateSize: function() {
                var that = this;
                var canvas = that._calculateCanvas();
                that._renderer.fixPlacement();
                if (areCanvasesDifferent(that._canvas, canvas) || that.__forceRender) {
                    that._canvas = canvas;
                    that._recreateSizeDependentObjects(true);
                    that._renderer.resize(canvas.width, canvas.height);
                    that._change(["LAYOUT"])
                }
            },
            _recreateSizeDependentObjects: _common.noop,
            _getMinSize: function() {
                return [0, 0]
            },
            _getAlignmentRect: _common.noop,
            _setContentSize: function() {
                var canvas = this._canvas;
                var layout = this._layout;
                var rect = canvas.width > 0 && canvas.height > 0 ? [canvas.left, canvas.top, canvas.width - canvas.right, canvas.height - canvas.bottom] : [0, 0, 0, 0];
                rect = layout.forward(rect, this._getMinSize());
                var nextRect = this._applySize(rect) || rect;
                layout.backward(nextRect, this._getAlignmentRect() || nextRect)
            },
            DEBUG_getCanvas: function() {
                return this._canvas
            },
            DEBUG_getEventTrigger: function() {
                return this._eventTrigger
            },
            _getOption: function(name, isScalar) {
                var theme = this._themeManager.theme(name);
                var option = this.option(name);
                return isScalar ? void 0 !== option ? option : theme : (0, _extend.extend)(true, {}, theme, option)
            },
            _setupResizeHandler: function() {
                var that = this;
                var redrawOnResize = (0, _utils.parseScalar)(this._getOption("redrawOnResize", true), true);
                if (that._resizeHandler) {
                    that._removeResizeHandler()
                }
                that._resizeHandler = createResizeHandler(function() {
                    if (redrawOnResize) {
                        that._requestChange(["CONTAINER_SIZE"])
                    } else {
                        that._renderer.fixPlacement()
                    }
                });
                _resize_callbacks2.default.add(that._resizeHandler)
            },
            _removeResizeHandler: function() {
                if (this._resizeHandler) {
                    _resize_callbacks2.default.remove(this._resizeHandler);
                    this._resizeHandler.dispose();
                    this._resizeHandler = null
                }
            },
            _onBeginUpdate: _common.noop,
            beginUpdate: function() {
                var that = this;
                if (that._initialized && that._isUpdateAllowed()) {
                    that._onBeginUpdate();
                    that._suspendChanges()
                }
                that.callBase.apply(that, arguments);
                return that
            },
            endUpdate: function() {
                this.callBase();
                this._isUpdateAllowed() && this._resumeChanges();
                return this
            },
            option: function(name) {
                var that = this;
                if (that._initialized && that._applyingChanges && (arguments.length > 1 || (0, _type.isObject)(name))) {
                    that._optionsQueue = that._optionsQueue || [];
                    that._optionsQueue.push(that._getActionForUpdating(arguments))
                } else {
                    return _option.apply(that, arguments)
                }
            },
            _getActionForUpdating: function(args) {
                var that = this;
                return function() {
                    _option.apply(that, args)
                }
            },
            _clean: _common.noop,
            _render: _common.noop,
            _optionChanged: function(arg) {
                var that = this;
                if (that._optionChangedLocker) {
                    return
                }
                var partialChanges = that.getPartialChangeOptionsName(arg);
                var changes = [];
                if (partialChanges.length > 0) {
                    partialChanges.forEach(function(pc) {
                        return changes.push(that._partialOptionChangesMap[pc])
                    })
                } else {
                    changes.push(that._optionChangesMap[arg.name])
                }
                changes = changes.filter(function(c) {
                    return !!c
                });
                if (that._eventTrigger.change(arg.name)) {
                    that._change(["EVENTS"])
                } else {
                    if (changes.length > 0) {
                        that._change(changes)
                    } else {
                        that.callBase.apply(that, arguments)
                    }
                }
            },
            _notify: _common.noop,
            _optionChangesMap: {
                size: "CONTAINER_SIZE",
                margin: "CONTAINER_SIZE",
                redrawOnResize: "RESIZE_HANDLER",
                theme: "THEME",
                rtlEnabled: "THEME",
                encodeHtml: "THEME",
                elementAttr: "ELEMENT_ATTR",
                disabled: "DISABLED"
            },
            _partialOptionChangesMap: {},
            _partialOptionChangesPath: {},
            getPartialChangeOptionsName: function(changedOption) {
                var that = this;
                var fullName = changedOption.fullName;
                var sections = fullName.split(/[.]/);
                var name = changedOption.name;
                var value = changedOption.value;
                var options = this._partialOptionChangesPath[name];
                var partialChangeOptionsName = [];
                if (options) {
                    if (true === options) {
                        partialChangeOptionsName.push(name)
                    } else {
                        options.forEach(function(op) {
                            fullName.indexOf(op) >= 0 && partialChangeOptionsName.push(op)
                        });
                        if (1 === sections.length) {
                            if ("object" === (0, _type.type)(value)) {
                                that._addOptionsNameForPartialUpdate(value, options, partialChangeOptionsName)
                            } else {
                                if ("array" === (0, _type.type)(value)) {
                                    if (value.length > 0 && value.every(function(item) {
                                            return that._checkOptionsForPartialUpdate(item, options)
                                        })) {
                                        value.forEach(function(item) {
                                            return that._addOptionsNameForPartialUpdate(item, options, partialChangeOptionsName)
                                        })
                                    }
                                }
                            }
                        }
                    }
                }
                return partialChangeOptionsName.filter(function(value, index, self) {
                    return self.indexOf(value) === index
                })
            },
            _checkOptionsForPartialUpdate: function(optionObject, options) {
                return !Object.keys(optionObject).some(function(key) {
                    return options.indexOf(key) === -1
                })
            },
            _addOptionsNameForPartialUpdate: function(optionObject, options, partialChangeOptionsName) {
                var optionKeys = Object.keys(optionObject);
                if (this._checkOptionsForPartialUpdate(optionObject, options)) {
                    optionKeys.forEach(function(key) {
                        return options.indexOf(key) > -1 && partialChangeOptionsName.push(key)
                    })
                }
            },
            _visibilityChanged: function() {
                this.render()
            },
            _setThemeAndRtl: function() {
                this._themeManager.setTheme(this.option("theme"), this.option(OPTION_RTL_ENABLED))
            },
            _getRendererOptions: function() {
                return {
                    rtl: this.option(OPTION_RTL_ENABLED),
                    encodeHtml: this.option("encodeHtml"),
                    animation: this._getAnimationOptions()
                }
            },
            _setRendererOptions: function() {
                this._renderer.setOptions(this._getRendererOptions())
            },
            svg: function() {
                return this._renderer.svg()
            },
            getSize: function() {
                var canvas = this._canvas || {};
                return {
                    width: canvas.width,
                    height: canvas.height
                }
            },
            isReady: getFalse,
            _dataIsReady: getTrue,
            _resetIsReady: function() {
                this.isReady = getFalse
            },
            _drawn: function() {
                var that = this;
                that.isReady = getFalse;
                if (that._dataIsReady()) {
                    that._renderer.onEndAnimation(function() {
                        that.isReady = getTrue
                    })
                }
                that._eventTrigger("drawn", {})
            }
        });
        _helpers2.default.replaceInherit(module.exports);

        function createEventTrigger(eventsMap, callbackGetter) {
            var triggers = {};
            (0, _iterator.each)(eventsMap, function(name, info) {
                if (info.name) {
                    createEvent(name)
                }
            });
            var changes;
            triggerEvent.change = function(name) {
                var eventInfo = eventsMap[name];
                if (eventInfo) {
                    (changes = changes || {})[name] = eventInfo
                }
                return !!eventInfo
            };
            triggerEvent.applyChanges = function() {
                if (changes) {
                    (0, _iterator.each)(changes, function(name, eventInfo) {
                        createEvent(eventInfo.newName || name)
                    });
                    changes = null
                }
            };
            triggerEvent.dispose = function() {
                eventsMap = callbackGetter = triggers = null
            };
            return triggerEvent;

            function createEvent(name) {
                var eventInfo = eventsMap[name];
                triggers[eventInfo.name] = callbackGetter(name)
            }

            function triggerEvent(name, arg, complete) {
                triggers[name](arg);
                complete && complete()
            }
        }
        module.exports.DEBUG_createEventTrigger = createEventTrigger;
        module.exports.DEBUG_createIncidentOccurred = createIncidentOccurred;
        module.exports.DEBUG_stub_createIncidentOccurred = function(stub) {
            createIncidentOccurred = stub
        };
        module.exports.DEBUG_restore_createIncidentOccurred = function() {
            createIncidentOccurred = module.exports.DEBUG_createIncidentOccurred
        };
        module.exports.DEBUG_createResizeHandler = createResizeHandler
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/data/abstract_store.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Class = __webpack_require__( /*! ../core/class */ 16);
        var abstract = Class.abstract;
        var EventsStrategy = __webpack_require__( /*! ../core/events_strategy */ 100).EventsStrategy;
        var each = __webpack_require__( /*! ../core/utils/iterator */ 4).each;
        var errorsModule = __webpack_require__( /*! ./errors */ 38);
        var dataUtils = __webpack_require__( /*! ./utils */ 42);
        var compileGetter = __webpack_require__( /*! ../core/utils/data */ 20).compileGetter;
        var storeHelper = __webpack_require__( /*! ./store_helper */ 86);
        var queryByOptions = storeHelper.queryByOptions;
        var Deferred = __webpack_require__( /*! ../core/utils/deferred */ 6).Deferred;
        var noop = __webpack_require__( /*! ../core/utils/common */ 3).noop;
        var storeImpl = {};
        var Store = Class.inherit({
            ctor: function(options) {
                var that = this;
                options = options || {};
                this._eventsStrategy = new EventsStrategy(this);
                each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onPush", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_, optionName) {
                    if (optionName in options) {
                        that.on(optionName.slice(2).toLowerCase(), options[optionName])
                    }
                });
                this._key = options.key;
                this._errorHandler = options.errorHandler;
                this._useDefaultSearch = true
            },
            _customLoadOptions: function() {
                return null
            },
            key: function() {
                return this._key
            },
            keyOf: function(obj) {
                if (!this._keyGetter) {
                    this._keyGetter = compileGetter(this.key())
                }
                return this._keyGetter(obj)
            },
            _requireKey: function() {
                if (!this.key()) {
                    throw errorsModule.errors.Error("E4005")
                }
            },
            load: function(options) {
                var that = this;
                options = options || {};
                this._eventsStrategy.fireEvent("loading", [options]);
                return this._withLock(this._loadImpl(options)).done(function(result) {
                    that._eventsStrategy.fireEvent("loaded", [result, options])
                })
            },
            _loadImpl: function(options) {
                return queryByOptions(this.createQuery(options), options).enumerate()
            },
            _withLock: function(task) {
                var result = new Deferred;
                task.done(function() {
                    var that = this;
                    var args = arguments;
                    dataUtils.processRequestResultLock.promise().done(function() {
                        result.resolveWith(that, args)
                    })
                }).fail(function() {
                    result.rejectWith(this, arguments)
                });
                return result
            },
            createQuery: abstract,
            totalCount: function(options) {
                return this._totalCountImpl(options)
            },
            _totalCountImpl: function(options) {
                return queryByOptions(this.createQuery(options), options, true).count()
            },
            byKey: function(key, extraOptions) {
                return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)))
            },
            _byKeyImpl: abstract,
            insert: function(values) {
                var that = this;
                that._eventsStrategy.fireEvent("modifying");
                that._eventsStrategy.fireEvent("inserting", [values]);
                return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
                    that._eventsStrategy.fireEvent("inserted", [callbackValues, callbackKey]);
                    that._eventsStrategy.fireEvent("modified")
                }))
            },
            _insertImpl: abstract,
            update: function(key, values) {
                var that = this;
                that._eventsStrategy.fireEvent("modifying");
                that._eventsStrategy.fireEvent("updating", [key, values]);
                return that._addFailHandlers(that._updateImpl(key, values).done(function() {
                    that._eventsStrategy.fireEvent("updated", [key, values]);
                    that._eventsStrategy.fireEvent("modified")
                }))
            },
            _updateImpl: abstract,
            push: function(changes) {
                this._pushImpl(changes);
                this._eventsStrategy.fireEvent("push", [changes])
            },
            _pushImpl: noop,
            remove: function(key) {
                var that = this;
                that._eventsStrategy.fireEvent("modifying");
                that._eventsStrategy.fireEvent("removing", [key]);
                return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
                    that._eventsStrategy.fireEvent("removed", [callbackKey]);
                    that._eventsStrategy.fireEvent("modified")
                }))
            },
            _removeImpl: abstract,
            _addFailHandlers: function(deferred) {
                return deferred.fail(this._errorHandler).fail(errorsModule._errorHandler)
            },
            on: function(eventName, eventHandler) {
                this._eventsStrategy.on(eventName, eventHandler);
                return this
            },
            off: function(eventName, eventHandler) {
                this._eventsStrategy.off(eventName, eventHandler);
                return this
            }
        });
        Store.create = function(alias, options) {
            if (!(alias in storeImpl)) {
                throw errorsModule.errors.Error("E4020", alias)
            }
            return new storeImpl[alias](options)
        };
        Store.registerClass = function(type, alias) {
            if (alias) {
                storeImpl[alias] = type
            }
            return type
        };
        Store.inherit = function(inheritor) {
            return function(members, alias) {
                var type = inheritor.apply(this, [members]);
                Store.registerClass(type, alias);
                return type
            }
        }(Store.inherit);
        module.exports = Store
    }, ,
    /*!*********************************************!*\
      !*** ./artifacts/transpiled/core/action.js ***!
      \*********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _renderer = __webpack_require__( /*! ./renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _config = __webpack_require__( /*! ./config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _window = __webpack_require__( /*! ./utils/window */ 7);
        var _type = __webpack_require__( /*! ./utils/type */ 1);
        var _iterator = __webpack_require__( /*! ./utils/iterator */ 4);
        var _errors = __webpack_require__( /*! ./errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var Action = function() {
            function Action(action, config) {
                _classCallCheck(this, Action);
                config = config || {};
                this._action = action;
                this._context = config.context || (0, _window.getWindow)();
                this._beforeExecute = config.beforeExecute;
                this._afterExecute = config.afterExecute;
                this._component = config.component;
                this._validatingTargetName = config.validatingTargetName;
                var excludeValidators = this._excludeValidators = {};
                if (config.excludeValidators) {
                    for (var i = 0; i < config.excludeValidators.length; i++) {
                        excludeValidators[config.excludeValidators[i]] = true
                    }
                }
            }
            _createClass(Action, [{
                key: "execute",
                value: function() {
                    var e = {
                        action: this._action,
                        args: Array.prototype.slice.call(arguments),
                        context: this._context,
                        component: this._component,
                        validatingTargetName: this._validatingTargetName,
                        cancel: false,
                        handled: false
                    };
                    var beforeExecute = this._beforeExecute;
                    var afterExecute = this._afterExecute;
                    var argsBag = e.args[0] || {};
                    if ("jQueryEvent" in argsBag && !argsBag.event) {
                        throw "The jQueryEvent field is deprecated. Please, use the `event` field instead"
                    }
                    if (!("jQueryEvent" in argsBag) && argsBag.event && (0, _config2.default)().useJQuery) {
                        Object.defineProperty(argsBag, "jQueryEvent", {
                            get: function() {
                                _errors2.default.log("W0003", "Handler argument", "jQueryEvent", "17.2", "Use the 'event' field instead");
                                return argsBag.event
                            },
                            set: function(value) {
                                _errors2.default.log("W0003", "Handler argument", "jQueryEvent", "17.2", "Use the 'event' field instead");
                                argsBag.event = value
                            }
                        })
                    }
                    if (!this._validateAction(e)) {
                        return
                    }
                    null === beforeExecute || void 0 === beforeExecute ? void 0 : beforeExecute.call(this._context, e);
                    if (e.cancel) {
                        return
                    }
                    var result = this._executeAction(e);
                    if (argsBag.cancel) {
                        return
                    }
                    null === afterExecute || void 0 === afterExecute ? void 0 : afterExecute.call(this._context, e);
                    return result
                }
            }, {
                key: "_validateAction",
                value: function(e) {
                    var excludeValidators = this._excludeValidators;
                    var executors = Action.executors;
                    for (var name in executors) {
                        if (!excludeValidators[name]) {
                            var _executor$validate;
                            var executor = executors[name];
                            null === (_executor$validate = executor.validate) || void 0 === _executor$validate ? void 0 : _executor$validate.call(executor, e);
                            if (e.cancel) {
                                return false
                            }
                        }
                    }
                    return true
                }
            }, {
                key: "_executeAction",
                value: function(e) {
                    var result;
                    var executors = Action.executors;
                    for (var name in executors) {
                        var _executor$execute;
                        var executor = executors[name];
                        null === (_executor$execute = executor.execute) || void 0 === _executor$execute ? void 0 : _executor$execute.call(executor, e);
                        if (e.handled) {
                            result = e.result;
                            break
                        }
                    }
                    return result
                }
            }], [{
                key: "registerExecutor",
                value: function(name, executor) {
                    if ((0, _type.isPlainObject)(name)) {
                        (0, _iterator.each)(name, Action.registerExecutor);
                        return
                    }
                    Action.executors[name] = executor
                }
            }, {
                key: "unregisterExecutor",
                value: function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key]
                    }(0, _iterator.each)(args, function() {
                        delete Action.executors[this]
                    })
                }
            }]);
            return Action
        }();
        exports.default = Action;
        Action.executors = {};
        var createValidatorByTargetElement = function(condition) {
            return function(e) {
                if (!e.args.length) {
                    return
                }
                var args = e.args[0];
                var element = args[e.validatingTargetName] || args.element;
                if (element && condition((0, _renderer2.default)(element))) {
                    e.cancel = true
                }
            }
        };
        Action.registerExecutor({
            disabled: {
                validate: createValidatorByTargetElement(function($target) {
                    return $target.is(".dx-state-disabled, .dx-state-disabled *")
                })
            },
            readOnly: {
                validate: createValidatorByTargetElement(function($target) {
                    return $target.is(".dx-state-readonly, .dx-state-readonly *")
                })
            },
            undefined: {
                execute: function(e) {
                    if (!e.action) {
                        e.result = void 0;
                        e.handled = true
                    }
                }
            },
            func: {
                execute: function(e) {
                    if ((0, _type.isFunction)(e.action)) {
                        e.result = e.action.call(e.context, e.args[0]);
                        e.handled = true
                    }
                }
            }
        })
    }, , , ,
    /*!************************************************!*\
      !*** ./artifacts/transpiled/viz/core/title.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _utils = __webpack_require__( /*! ./utils */ 13);
        var _Number = Number;
        var parseHorizontalAlignment = (0, _utils.enumParser)(["left", "center", "right"]);
        var parseVerticalAlignment = (0, _utils.enumParser)(["top", "bottom"]);
        var DEFAULT_MARGIN = 10;

        function hasText(text) {
            return !!(text && String(text).length > 0)
        }

        function processTitleLength(elem, text, width, options, placeholderSize) {
            if (elem.attr({
                    text: text
                }).setMaxSize(width, placeholderSize, options).textChanged) {
                elem.setTitle(text)
            }
        }

        function pickMarginValue(value) {
            return value >= 0 ? _Number(value) : DEFAULT_MARGIN
        }

        function validateMargin(margin) {
            var result;
            if (margin >= 0) {
                result = {
                    left: _Number(margin),
                    top: _Number(margin),
                    right: _Number(margin),
                    bottom: _Number(margin)
                }
            } else {
                margin = margin || {};
                result = {
                    left: pickMarginValue(margin.left),
                    top: pickMarginValue(margin.top),
                    right: pickMarginValue(margin.right),
                    bottom: pickMarginValue(margin.bottom)
                }
            }
            return result
        }

        function checkRect(rect, boundingRect) {
            return rect[2] - rect[0] < boundingRect.width || rect[3] - rect[1] < boundingRect.height
        }

        function Title(params) {
            this._params = params;
            this._group = params.renderer.g().attr({
                "class": params.cssClass
            }).linkOn(params.root || params.renderer.root, "title");
            this._hasText = false
        }(0, _extend.extend)(Title.prototype, __webpack_require__( /*! ./layout_element */ 258).LayoutElement.prototype, {
            dispose: function() {
                var that = this;
                that._group.linkRemove();
                that._group.linkOff();
                if (that._titleElement) {
                    that._clipRect.dispose();
                    that._titleElement = that._subtitleElement = that._clipRect = null
                }
                that._params = that._group = that._options = null
            },
            _updateOptions: function(options) {
                this._options = options;
                this._options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, "center");
                this._options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, "top");
                this._options.margin = validateMargin(options.margin)
            },
            _updateStructure: function() {
                var that = this;
                var renderer = that._params.renderer;
                var group = that._group;
                var options = that._options;
                var align = options.horizontalAlignment;
                if (!that._titleElement) {
                    that._titleElement = renderer.text().append(group);
                    that._subtitleElement = renderer.text();
                    that._clipRect = renderer.clipRect();
                    group.attr({
                        "clip-path": that._clipRect.id
                    })
                }
                that._titleElement.attr({
                    align: align,
                    "class": options.cssClass
                });
                that._subtitleElement.attr({
                    align: align,
                    "class": options.subtitle.cssClass
                });
                group.linkAppend();
                hasText(options.subtitle.text) ? that._subtitleElement.append(group) : that._subtitleElement.remove()
            },
            _updateTexts: function() {
                var that = this;
                var options = that._options;
                var subtitleOptions = options.subtitle;
                var titleElement = that._titleElement;
                var subtitleElement = that._subtitleElement;
                var testText = "A";
                var titleBox;
                titleElement.attr({
                    text: testText,
                    y: 0
                }).css((0, _utils.patchFontOptions)(options.font));
                titleBox = titleElement.getBBox();
                that._baseLineCorrection = titleBox.height + titleBox.y;
                titleElement.attr({
                    text: options.text
                });
                titleBox = titleElement.getBBox();
                var y = -titleBox.y;
                titleElement.attr({
                    y: y
                });
                if (hasText(subtitleOptions.text)) {
                    subtitleElement.attr({
                        text: subtitleOptions.text,
                        y: 0
                    }).css((0, _utils.patchFontOptions)(subtitleOptions.font))
                }
            },
            _shiftSubtitle: function() {
                var that = this;
                var titleBox = that._titleElement.getBBox();
                var element = that._subtitleElement;
                var offset = that._options.subtitle.offset;
                element.move(0, titleBox.y + titleBox.height - element.getBBox().y - offset)
            },
            _updateBoundingRectAlignment: function() {
                var boundingRect = this._boundingRect;
                var options = this._options;
                boundingRect.verticalAlignment = options.verticalAlignment;
                boundingRect.horizontalAlignment = options.horizontalAlignment;
                boundingRect.cutLayoutSide = options.verticalAlignment;
                boundingRect.cutSide = "vertical";
                boundingRect.position = {
                    horizontal: options.horizontalAlignment,
                    vertical: options.verticalAlignment
                }
            },
            hasText: function() {
                return this._hasText
            },
            update: function(themeOptions, userOptions) {
                var that = this;
                var options = (0, _extend.extend)(true, {}, themeOptions, processTitleOptions(userOptions));
                var _hasText = hasText(options.text);
                var isLayoutChanged = _hasText || _hasText !== that._hasText;
                that._baseLineCorrection = 0;
                that._updateOptions(options);
                that._boundingRect = {};
                if (_hasText) {
                    that._updateStructure();
                    that._updateTexts()
                } else {
                    that._group.linkRemove()
                }
                that._updateBoundingRect();
                that._updateBoundingRectAlignment();
                that._hasText = _hasText;
                return isLayoutChanged
            },
            draw: function(width, height) {
                var that = this;
                if (that._hasText) {
                    that._group.linkAppend();
                    that._correctTitleLength(width);
                    if (that._group.getBBox().height > height) {
                        this.freeSpace()
                    }
                }
                return that
            },
            probeDraw: function(width, height) {
                this.draw(width, height);
                return this
            },
            _correctTitleLength: function(width) {
                var that = this;
                var options = that._options;
                var margin = options.margin;
                var maxWidth = width - margin.left - margin.right;
                var placeholderSize = options.placeholderSize;
                processTitleLength(that._titleElement, options.text, maxWidth, options, placeholderSize);
                if (that._subtitleElement) {
                    if (_Number(placeholderSize) > 0) {
                        placeholderSize -= that._titleElement.getBBox().height
                    }
                    processTitleLength(that._subtitleElement, options.subtitle.text, maxWidth, options.subtitle, placeholderSize);
                    that._shiftSubtitle()
                }
                that._updateBoundingRect();
                var _this$getCorrectedLay = this.getCorrectedLayoutOptions(),
                    x = _this$getCorrectedLay.x,
                    y = _this$getCorrectedLay.y,
                    height = _this$getCorrectedLay.height;
                this._clipRect.attr({
                    x: x,
                    y: y,
                    width: width,
                    height: height
                })
            },
            getLayoutOptions: function() {
                return this._boundingRect || null
            },
            shift: function(x, y) {
                var that = this;
                var box = that.getLayoutOptions();
                that._group.move(x - box.x, y - box.y);
                return that
            },
            _updateBoundingRect: function() {
                var that = this;
                var options = that._options;
                var margin = options.margin;
                var boundingRect = that._boundingRect;
                var box = that._hasText ? that._group.getBBox() : {
                    width: 0,
                    height: 0,
                    x: 0,
                    y: 0,
                    isEmpty: true
                };
                if (!box.isEmpty) {
                    box.height += margin.top + margin.bottom - that._baseLineCorrection;
                    box.width += margin.left + margin.right;
                    box.x -= margin.left;
                    box.y += that._baseLineCorrection - margin.top
                }
                if (options.placeholderSize > 0) {
                    box.height = options.placeholderSize
                }
                boundingRect.height = box.height;
                boundingRect.width = box.width;
                boundingRect.x = box.x;
                boundingRect.y = box.y
            },
            getCorrectedLayoutOptions: function() {
                var srcBox = this.getLayoutOptions();
                var correction = this._baseLineCorrection;
                return (0, _extend.extend)({}, srcBox, {
                    y: srcBox.y - correction,
                    height: srcBox.height + correction
                })
            },
            layoutOptions: function() {
                if (!this._hasText) {
                    return null
                }
                return {
                    horizontalAlignment: this._boundingRect.horizontalAlignment,
                    verticalAlignment: this._boundingRect.verticalAlignment,
                    priority: 0
                }
            },
            measure: function(size) {
                this.draw(size[0], size[1]);
                return [this._boundingRect.width, this._boundingRect.height]
            },
            move: function(rect, fitRect) {
                var boundingRect = this._boundingRect;
                if (checkRect(rect, boundingRect)) {
                    this.shift(fitRect[0], fitRect[1])
                } else {
                    this.shift(Math.round(rect[0]), Math.round(rect[1]))
                }
            },
            freeSpace: function() {
                var that = this;
                that._params.incidentOccurred("W2103");
                that._group.linkRemove();
                that._boundingRect.width = that._boundingRect.height = 0
            },
            getOptions: function() {
                return this._options
            },
            changeLink: function(root) {
                this._group.linkRemove();
                this._group.linkOn(root, "title")
            }
        });
        exports.Title = Title;
        Title.prototype.DEBUG_getOptions = function() {
            return this._options
        };

        function processTitleOptions(options) {
            var newOptions = (0, _type.isString)(options) ? {
                text: options
            } : options || {};
            newOptions.subtitle = (0, _type.isString)(newOptions.subtitle) ? {
                text: newOptions.subtitle
            } : newOptions.subtitle || {};
            return newOptions
        }
        exports.plugin = {
            name: "title",
            init: function() {
                var that = this;
                that._title = new exports.Title({
                    renderer: that._renderer,
                    cssClass: that._rootClassPrefix + "-title",
                    incidentOccurred: that._incidentOccurred
                });
                that._layout.add(that._title)
            },
            dispose: function() {
                this._title.dispose();
                this._title = null
            },
            customize: function(constructor) {
                constructor.addChange({
                    code: "TITLE",
                    handler: function() {
                        if (this._title.update(this._themeManager.theme("title"), this.option("title"))) {
                            this._change(["LAYOUT"])
                        }
                    },
                    isThemeDependent: true,
                    option: "title",
                    isOptionChange: true
                })
            },
            fontFields: ["title.font", "title.subtitle.font"]
        }
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/series/scatter_series.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var inArray = __webpack_require__( /*! ../../core/utils/array */ 14).inArray;
        var _each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var rangeCalculator = __webpack_require__( /*! ./helpers/range_data_calculator */ 209);
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var _noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var _isDefined = typeUtils.isDefined;
        var _isString = typeUtils.isString;
        var _map = vizUtils.map;
        var _normalizeEnum = vizUtils.normalizeEnum;
        var math = Math;
        var _abs = math.abs;
        var _sqrt = math.sqrt;
        var _max = math.max;
        var DEFAULT_TRACKER_WIDTH = 12;
        var DEFAULT_DURATION = 400;
        var HIGH_ERROR = "highError";
        var LOW_ERROR = "lowError";
        var VARIANCE = "variance";
        var STANDARD_DEVIATION = "stddeviation";
        var STANDARD_ERROR = "stderror";
        var PERCENT = "percent";
        var FIXED = "fixed";
        var UNDEFINED = "undefined";
        var DISCRETE = "discrete";
        var LOGARITHMIC = "logarithmic";
        var DATETIME = "datetime";
        exports.chart = {};
        exports.polar = {};

        function sum(array) {
            var result = 0;
            _each(array, function(_, value) {
                result += value
            });
            return result
        }

        function isErrorBarTypeCorrect(type) {
            return inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR]) !== -1
        }

        function variance(array, expectedValue) {
            return sum(_map(array, function(value) {
                return (value - expectedValue) * (value - expectedValue)
            })) / array.length
        }

        function calculateAvgErrorBars(result, data, series) {
            var errorBarsOptions = series.getOptions().valueErrorBar;
            var valueField = series.getValueFields()[0];
            var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
            var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
            if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {
                var fusionData = data.reduce(function(result, item) {
                    if (_isDefined(item[lowValueField])) {
                        result[0] += item[valueField] - item[lowValueField];
                        result[1]++
                    }
                    if (_isDefined(item[highValueField])) {
                        result[2] += item[highValueField] - item[valueField];
                        result[3]++
                    }
                    return result
                }, [0, 0, 0, 0]);
                if (fusionData[1]) {
                    result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1]
                }
                if (fusionData[2]) {
                    result[highValueField] = result[valueField] + fusionData[2] / fusionData[3]
                }
            }
            return result
        }

        function calculateSumErrorBars(result, data, series) {
            var errorBarsOptions = series.getOptions().valueErrorBar;
            var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
            var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
            if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {
                result[lowValueField] = 0;
                result[highValueField] = 0;
                result = data.reduce(function(result, item) {
                    result[lowValueField] += item[lowValueField];
                    result[highValueField] += item[highValueField];
                    return result
                }, result)
            }
            return result
        }

        function getMinMaxAggregator(compare) {
            return function(_ref, series) {
                var intervalStart = _ref.intervalStart,
                    data = _ref.data;
                var valueField = series.getValueFields()[0];
                var targetData = data[0];
                targetData = data.reduce(function(result, item) {
                    var value = item[valueField];
                    if (null === result[valueField]) {
                        result = item
                    }
                    if (null !== value && compare(value, result[valueField])) {
                        return item
                    }
                    return result
                }, targetData);
                return _extend({}, targetData, _defineProperty({}, series.getArgumentField(), intervalStart))
            }
        }

        function checkFields(data, fieldsToCheck, skippedFields) {
            var allFieldsIsValid = true;
            for (var field in fieldsToCheck) {
                var isArgument = "argument" === field;
                if (isArgument || "size" === field ? !_isDefined(data[field]) : void 0 === data[field]) {
                    var selector = fieldsToCheck[field];
                    if (!isArgument) {
                        skippedFields[selector] = (skippedFields[selector] || 0) + 1
                    }
                    allFieldsIsValid = false
                }
            }
            return allFieldsIsValid
        }
        var baseScatterMethods = {
            _defaultDuration: DEFAULT_DURATION,
            _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,
            _applyStyle: _noop,
            _updateOptions: _noop,
            _parseStyle: _noop,
            _prepareSegment: _noop,
            _drawSegment: _noop,
            _appendInGroup: function() {
                this._group.append(this._extGroups.seriesGroup)
            },
            _createLegendState: function(styleOptions, defaultColor) {
                return {
                    fill: styleOptions.color || defaultColor,
                    hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {
                        direction: "right"
                    }) : void 0
                }
            },
            _applyElementsClipRect: function(settings) {
                settings["clip-path"] = this._paneClipRectID
            },
            _applyMarkerClipRect: function(settings) {
                settings["clip-path"] = this._forceClipping ? this._paneClipRectID : null
            },
            _createGroup: function(groupName, parent, target, settings) {
                var group = parent[groupName] = parent[groupName] || this._renderer.g();
                target && group.append(target);
                settings && group.attr(settings)
            },
            _applyClearingSettings: function(settings) {
                settings.opacity = null;
                settings.scale = null;
                if (this._options.rotated) {
                    settings.translateX = null
                } else {
                    settings.translateY = null
                }
            },
            _createGroups: function() {
                var that = this;
                that._createGroup("_markersGroup", that, that._group);
                that._createGroup("_labelsGroup", that)
            },
            _setMarkerGroupSettings: function() {
                var that = this;
                var settings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
                settings.class = "dxc-markers";
                settings.opacity = 1;
                that._applyMarkerClipRect(settings);
                that._markersGroup.attr(settings)
            },
            getVisibleArea: function() {
                return this._visibleArea
            },
            areErrorBarsVisible: function() {
                var errorBarOptions = this._options.valueErrorBar;
                return errorBarOptions && this._errorBarsEnabled() && "none" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField))
            },
            groupPointsByCoords: function(rotated) {
                var cat = [];
                _each(this.getVisiblePoints(), function(_, p) {
                    var pointCoord = parseInt(rotated ? p.vy : p.vx);
                    if (!cat[pointCoord]) {
                        cat[pointCoord] = p
                    } else {
                        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p]
                    }
                });
                return cat
            },
            _createErrorBarGroup: function(animationEnabled) {
                var that = this;
                var errorBarOptions = that._options.valueErrorBar;
                var settings;
                if (that.areErrorBarsVisible()) {
                    settings = {
                        "class": "dxc-error-bars",
                        stroke: errorBarOptions.color,
                        "stroke-width": errorBarOptions.lineWidth,
                        opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,
                        "stroke-linecap": "square",
                        sharp: true,
                        "clip-path": that._forceClipping ? that._paneClipRectID : that._widePaneClipRectID
                    };
                    that._createGroup("_errorBarGroup", that, that._group, settings)
                }
            },
            _setGroupsSettings: function(animationEnabled) {
                var that = this;
                that._setMarkerGroupSettings();
                that._setLabelGroupSettings(animationEnabled);
                that._createErrorBarGroup(animationEnabled)
            },
            _getCreatingPointOptions: function() {
                var that = this;
                var defaultPointOptions;
                var creatingPointOptions = that._predefinedPointOptions;
                var normalStyle;
                if (!creatingPointOptions) {
                    defaultPointOptions = that._getPointOptions();
                    that._predefinedPointOptions = creatingPointOptions = _extend(true, {
                        styles: {}
                    }, defaultPointOptions);
                    normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};
                    creatingPointOptions.styles = creatingPointOptions.styles || {};
                    creatingPointOptions.styles.normal = {
                        "stroke-width": normalStyle["stroke-width"],
                        r: normalStyle.r,
                        opacity: normalStyle.opacity
                    }
                }
                return creatingPointOptions
            },
            _getPointOptions: function() {
                return this._parsePointOptions(this._preparePointOptions(), this._options.label)
            },
            _getOptionsForPoint: function() {
                return this._options.point
            },
            _parsePointStyle: function(style, defaultColor, defaultBorderColor, defaultSize) {
                var border = style.border || {};
                var sizeValue = void 0 !== style.size ? style.size : defaultSize;
                return {
                    fill: style.color || defaultColor,
                    stroke: border.color || defaultBorderColor,
                    "stroke-width": border.visible ? border.width : 0,
                    r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)
                }
            },
            _createPointStyles: function(pointOptions) {
                var that = this;
                var mainPointColor = pointOptions.color || that._options.mainSeriesColor;
                var containerColor = that._options.containerBackgroundColor;
                var normalStyle = that._parsePointStyle(pointOptions, mainPointColor, mainPointColor);
                normalStyle.visibility = pointOptions.visible ? "visible" : "hidden";
                return {
                    normal: normalStyle,
                    hover: that._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),
                    selection: that._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)
                }
            },
            _checkData: function(data, skippedFields, fieldsToCheck) {
                fieldsToCheck = fieldsToCheck || {
                    value: this.getValueFields()[0]
                };
                fieldsToCheck.argument = this.getArgumentField();
                return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value
            },
            getValueRangeInitialValue: function() {
                return
            },
            _getRangeData: function() {
                return rangeCalculator.getRangeData(this)
            },
            _getPointDataSelector: function() {
                var _this = this;
                var valueField = this.getValueFields()[0];
                var argumentField = this.getArgumentField();
                var tagField = this.getTagField();
                var areErrorBarsVisible = this.areErrorBarsVisible();
                var lowValueField;
                var highValueField;
                if (areErrorBarsVisible) {
                    var errorBarOptions = this._options.valueErrorBar;
                    lowValueField = errorBarOptions.lowValueField || LOW_ERROR;
                    highValueField = errorBarOptions.highValueField || HIGH_ERROR
                }
                return function(data) {
                    var pointData = {
                        value: _this._processEmptyValue(data[valueField]),
                        argument: data[argumentField],
                        tag: data[tagField],
                        data: data
                    };
                    if (areErrorBarsVisible) {
                        pointData.lowError = data[lowValueField];
                        pointData.highError = data[highValueField]
                    }
                    return pointData
                }
            },
            _errorBarsEnabled: function() {
                return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME
            },
            _drawPoint: function(options) {
                var point = options.point;
                if (point.isInVisibleArea()) {
                    point.clearVisibility();
                    point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);
                    this._drawnPoints.push(point)
                } else {
                    point.setInvisibility()
                }
            },
            _animateComplete: function() {
                var that = this;
                var animationSettings = {
                    duration: that._defaultDuration
                };
                that._labelsGroup && that._labelsGroup.animate({
                    opacity: 1
                }, animationSettings);
                that._errorBarGroup && that._errorBarGroup.animate({
                    opacity: that._options.valueErrorBar.opacity || 1
                }, animationSettings)
            },
            _animate: function() {
                var that = this;
                var lastPointIndex = that._drawnPoints.length - 1;
                _each(that._drawnPoints || [], function(i, p) {
                    p.animate(i === lastPointIndex ? function() {
                        that._animateComplete()
                    } : void 0, {
                        translateX: p.x,
                        translateY: p.y
                    })
                })
            },
            _defaultAggregator: "avg",
            _aggregators: {
                avg: function(_ref2, series) {
                    var _calculateAvgErrorBar;
                    var data = _ref2.data,
                        intervalStart = _ref2.intervalStart;
                    if (!data.length) {
                        return
                    }
                    var valueField = series.getValueFields()[0];
                    var aggregationResult = data.reduce(function(result, item) {
                        var value = item[valueField];
                        if (_isDefined(value)) {
                            result[0] += value;
                            result[1]++
                        } else {
                            if (null === value) {
                                result[2]++
                            }
                        }
                        return result
                    }, [0, 0, 0]);
                    return calculateAvgErrorBars((_calculateAvgErrorBar = {}, _defineProperty(_calculateAvgErrorBar, valueField, aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1]), _defineProperty(_calculateAvgErrorBar, series.getArgumentField(), intervalStart), _calculateAvgErrorBar), data, series)
                },
                sum: function(_ref3, series) {
                    var _calculateSumErrorBar;
                    var intervalStart = _ref3.intervalStart,
                        data = _ref3.data;
                    if (!data.length) {
                        return
                    }
                    var valueField = series.getValueFields()[0];
                    var aggregationResult = data.reduce(function(result, item) {
                        var value = item[valueField];
                        if (void 0 !== value) {
                            result[0] += value
                        }
                        if (null === value) {
                            result[1]++
                        } else {
                            if (void 0 === value) {
                                result[2]++
                            }
                        }
                        return result
                    }, [0, 0, 0]);
                    var value = aggregationResult[0];
                    if (aggregationResult[1] === data.length) {
                        value = null
                    }
                    if (aggregationResult[2] === data.length) {
                        return
                    }
                    return calculateSumErrorBars((_calculateSumErrorBar = {}, _defineProperty(_calculateSumErrorBar, valueField, value), _defineProperty(_calculateSumErrorBar, series.getArgumentField(), intervalStart), _calculateSumErrorBar), data, series)
                },
                count: function(_ref4, series) {
                    var _ref5;
                    var data = _ref4.data,
                        intervalStart = _ref4.intervalStart;
                    var valueField = series.getValueFields()[0];
                    return _ref5 = {}, _defineProperty(_ref5, series.getArgumentField(), intervalStart), _defineProperty(_ref5, valueField, data.filter(function(i) {
                        return void 0 !== i[valueField]
                    }).length), _ref5
                },
                min: getMinMaxAggregator(function(a, b) {
                    return a < b
                }),
                max: getMinMaxAggregator(function(a, b) {
                    return a > b
                })
            },
            _endUpdateData: function() {
                delete this._predefinedPointOptions
            },
            getArgumentField: function() {
                return this._options.argumentField || "arg"
            },
            getValueFields: function() {
                var options = this._options;
                var errorBarsOptions = options.valueErrorBar;
                var valueFields = [options.valueField || "val"];
                var lowValueField;
                var highValueField;
                if (errorBarsOptions) {
                    lowValueField = errorBarsOptions.lowValueField;
                    highValueField = errorBarsOptions.highValueField;
                    _isString(lowValueField) && valueFields.push(lowValueField);
                    _isString(highValueField) && valueFields.push(highValueField)
                }
                return valueFields
            },
            _calculateErrorBars: function(data) {
                if (!this.areErrorBarsVisible()) {
                    return
                }
                var that = this;
                var options = that._options;
                var errorBarsOptions = options.valueErrorBar;
                var errorBarType = _normalizeEnum(errorBarsOptions.type);
                var floatErrorValue = parseFloat(errorBarsOptions.value);
                var valueField = that.getValueFields()[0];
                var value;
                var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
                var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
                var valueArray;
                var valueArrayLength;
                var meanValue;
                var processDataItem;
                var addSubError = function(_i, item) {
                    value = item.value;
                    item.lowError = value - floatErrorValue;
                    item.highError = value + floatErrorValue
                };
                switch (errorBarType) {
                    case FIXED:
                        processDataItem = addSubError;
                        break;
                    case PERCENT:
                        processDataItem = function(_, item) {
                            value = item.value;
                            var error = value * floatErrorValue / 100;
                            item.lowError = value - error;
                            item.highError = value + error
                        };
                        break;
                    case UNDEFINED:
                        processDataItem = function(_, item) {
                            item.lowError = item.data[lowValueField];
                            item.highError = item.data[highValueField]
                        };
                        break;
                    default:
                        valueArray = _map(data, function(item) {
                            return _isDefined(item.data[valueField]) ? item.data[valueField] : null
                        });
                        valueArrayLength = valueArray.length;
                        floatErrorValue = floatErrorValue || 1;
                        switch (errorBarType) {
                            case VARIANCE:
                                floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;
                                processDataItem = addSubError;
                                break;
                            case STANDARD_DEVIATION:
                                meanValue = sum(valueArray) / valueArrayLength;
                                floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;
                                processDataItem = function(_, item) {
                                    item.lowError = meanValue - floatErrorValue;
                                    item.highError = meanValue + floatErrorValue
                                };
                                break;
                            case STANDARD_ERROR:
                                floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;
                                processDataItem = addSubError
                        }
                }
                processDataItem && _each(data, processDataItem)
            },
            _patchMarginOptions: function(options) {
                var pointOptions = this._getCreatingPointOptions();
                var styles = pointOptions.styles;
                var maxSize = [styles.normal, styles.hover, styles.selection].reduce(function(max, style) {
                    return _max(max, 2 * style.r + style["stroke-width"])
                }, 0);
                options.size = pointOptions.visible ? maxSize : 0;
                options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal["stroke-width"] : 2;
                return options
            },
            usePointsToDefineAutoHiding: function() {
                return true
            }
        };
        exports.chart = _extend({}, baseScatterMethods, {
            drawTrackers: function() {
                var that = this;
                var trackers;
                var trackersGroup;
                var segments = that._segments || [];
                var rotated = that._options.rotated;
                if (!that.isVisible()) {
                    return
                }
                if (segments.length) {
                    trackers = that._trackers = that._trackers || [];
                    trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({
                        fill: "gray",
                        opacity: .001,
                        stroke: "gray",
                        "class": "dxc-trackers"
                    })).attr({
                        "clip-path": this._paneClipRectID || null
                    }).append(that._group);
                    _each(segments, function(i, segment) {
                        if (!trackers[i]) {
                            trackers[i] = that._drawTrackerElement(segment).data({
                                "chart-data-series": that
                            }).append(trackersGroup)
                        } else {
                            that._updateTrackerElement(segment, trackers[i])
                        }
                    })
                }
                that._trackersTranslator = that.groupPointsByCoords(rotated)
            },
            _checkAxisVisibleAreaCoord: function(isArgument, coord) {
                var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();
                var visibleArea = axis.getVisibleArea();
                return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord
            },
            checkSeriesViewportCoord: function(axis, coord) {
                return true
            },
            getSeriesPairCoord: function(coord, isArgument) {
                var oppositeCoord = null;
                var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;
                var coordName = !isOpposite ? "vx" : "vy";
                var oppositeCoordName = !isOpposite ? "vy" : "vx";
                var points = this.getVisiblePoints();
                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;
                    if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
                        oppositeCoord = tmpCoord;
                        break
                    }
                }
                return oppositeCoord
            },
            _getNearestPoints: function(point, nextPoint) {
                return [point, nextPoint]
            },
            _getBezierPoints: function() {
                return []
            },
            _getNearestPointsByCoord: function(coord, isArgument) {
                var that = this;
                var rotated = that.getOptions().rotated;
                var isOpposite = !isArgument && !rotated || isArgument && rotated;
                var coordName = isOpposite ? "vy" : "vx";
                var allPoints = that.getPoints();
                var bezierPoints = that._getBezierPoints();
                var nearestPoints = [];
                if (allPoints.length > 1) {
                    allPoints.forEach(function(point, i) {
                        var nextPoint = allPoints[i + 1];
                        if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {
                            nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints))
                        }
                    })
                } else {
                    nearestPoints.push([allPoints[0], allPoints[0]])
                }
                return nearestPoints
            },
            getNeighborPoint: function(x, y) {
                var pCoord = this._options.rotated ? y : x;
                var nCoord = pCoord;
                var cat = this._trackersTranslator;
                var point = null;
                var minDistance;
                var oppositeCoord = this._options.rotated ? x : y;
                var oppositeCoordName = this._options.rotated ? "vx" : "vy";
                if (this.isVisible() && cat) {
                    point = cat[pCoord];
                    do {
                        point = cat[nCoord] || cat[pCoord];
                        pCoord--;
                        nCoord++
                    } while ((pCoord >= 0 || nCoord < cat.length) && !point);
                    if (Array.isArray(point)) {
                        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);
                        _each(point, function(i, p) {
                            var distance = _abs(p[oppositeCoordName] - oppositeCoord);
                            if (minDistance >= distance) {
                                minDistance = distance;
                                point = p
                            }
                        })
                    }
                }
                return point
            },
            _applyVisibleArea: function() {
                var that = this;
                var rotated = that._options.rotated;
                var visibleX = (rotated ? that.getValueAxis() : that.getArgumentAxis()).getVisibleArea();
                var visibleY = (rotated ? that.getArgumentAxis() : that.getValueAxis()).getVisibleArea();
                that._visibleArea = {
                    minX: visibleX[0],
                    maxX: visibleX[1],
                    minY: visibleY[0],
                    maxY: visibleY[1]
                }
            },
            getPointCenterByArg: function(arg) {
                var point = this.getPointsByArg(arg)[0];
                return point ? point.getCenterCoord() : void 0
            }
        });
        exports.polar = _extend({}, baseScatterMethods, {
            drawTrackers: function() {
                exports.chart.drawTrackers.call(this);
                var cat = this._trackersTranslator;
                var index;
                if (!this.isVisible()) {
                    return
                }
                _each(cat, function(i, category) {
                    if (category) {
                        index = i;
                        return false
                    }
                });
                cat[index + 360] = cat[index]
            },
            getNeighborPoint: function(x, y) {
                var pos = vizUtils.convertXYToPolar(this.getValueAxis().getCenter(), x, y);
                return exports.chart.getNeighborPoint.call(this, pos.phi, pos.r)
            },
            _applyVisibleArea: function() {
                var that = this;
                var canvas = that.getValueAxis().getCanvas();
                that._visibleArea = {
                    minX: canvas.left,
                    maxX: canvas.width - canvas.right,
                    minY: canvas.top,
                    maxY: canvas.height - canvas.bottom
                }
            },
            getSeriesPairCoord: function(params, isArgument) {
                var coords = null;
                var paramName = isArgument ? "argument" : "radius";
                var points = this.getVisiblePoints();
                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {
                        x: p.x,
                        y: p.y
                    } : void 0;
                    if (_isDefined(tmpPoint)) {
                        coords = tmpPoint;
                        break
                    }
                }
                return coords
            }
        })
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/viz/core/tooltip.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _window = __webpack_require__( /*! ../../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _inflector = __webpack_require__( /*! ../../core/utils/inflector */ 34);
        var _inflector2 = _interopRequireDefault(_inflector);
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _renderer3 = __webpack_require__( /*! ./renderers/renderer */ 163);
        var _renderer4 = _interopRequireDefault(_renderer3);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _type2 = _interopRequireDefault(_type);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _utils = __webpack_require__( /*! ./utils */ 13);
        var _utils2 = _interopRequireDefault(_utils);
        var _format_helper = __webpack_require__( /*! ../../format_helper */ 63);
        var _plaque = __webpack_require__( /*! ./plaque */ 422);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var mathCeil = Math.ceil;
        var mathMax = Math.max;
        var mathMin = Math.min;
        var window = _window2.default.getWindow();
        var DEFAULT_HTML_GROUP_WIDTH = 3e3;

        function hideElement($element) {
            $element.css({
                left: "-9999px"
            }).detach()
        }

        function getSpecialFormatOptions(options, specialFormat) {
            var result = options;
            switch (specialFormat) {
                case "argument":
                    result = {
                        format: options.argumentFormat
                    };
                    break;
                case "percent":
                    result = {
                        format: {
                            type: "percent",
                            precision: options.format && options.format.percentPrecision
                        }
                    }
            }
            return result
        }

        function Tooltip(params) {
            var that = this;
            var renderer;
            that._eventTrigger = params.eventTrigger;
            that._widgetRoot = params.widgetRoot;
            that._widget = params.widget;
            that._wrapper = (0, _renderer2.default)("<div>").css({
                position: "absolute",
                overflow: "hidden",
                pointerEvents: "none"
            }).addClass(params.cssClass);
            that._renderer = renderer = new _renderer4.default.Renderer({
                pathModified: params.pathModified,
                container: that._wrapper[0]
            });
            var root = renderer.root;
            root.attr({
                "pointer-events": "none"
            });
            that._text = renderer.text(void 0, 0, 0);
            that._textGroupHtml = (0, _renderer2.default)("<div>").css({
                position: "absolute",
                padding: 0,
                margin: 0,
                border: "0px solid transparent"
            }).appendTo(that._wrapper);
            that._textHtml = (0, _renderer2.default)("<div>").css({
                position: "relative",
                display: "inline-block",
                padding: 0,
                margin: 0,
                border: "0px solid transparent"
            }).appendTo(that._textGroupHtml)
        }
        Tooltip.prototype = {
            constructor: Tooltip,
            dispose: function() {
                this._wrapper.remove();
                this._renderer.dispose();
                this._options = this._widgetRoot = null
            },
            _getContainer: function() {
                var options = this._options;
                var container = (0, _renderer2.default)(this._widgetRoot).closest(options.container);
                if (0 === container.length) {
                    container = (0, _renderer2.default)(options.container)
                }
                return (container.length ? container : (0, _renderer2.default)("body")).get(0)
            },
            setTemplate: function(contentTemplate) {
                var that = this;
                that._template = contentTemplate ? that._widget._getTemplate(contentTemplate) : null
            },
            setOptions: function(options) {
                var _this = this;
                options = options || {};
                var that = this;
                that._options = options;
                that._textFontStyles = _utils2.default.patchFontOptions(options.font);
                that._textFontStyles.color = that._textFontStyles.fill;
                that._wrapper.css({
                    zIndex: options.zIndex
                });
                that._customizeTooltip = options.customizeTooltip;
                var textGroupHtml = that._textGroupHtml;
                var textHtml = that._textHtml;
                if (this.plaque) {
                    this.plaque.clear()
                }
                this.setTemplate(options.contentTemplate);
                var pointerEvents = options.interactive ? "auto" : "none";
                if (options.interactive) {
                    this._renderer.root.css({
                        "-ms-user-select": "auto",
                        "-moz-user-select": "auto",
                        "-webkit-user-select": "auto"
                    })
                }
                var drawTooltip = function(tooltip, group) {
                    var state = tooltip._state;
                    var template = tooltip._template;
                    var useTemplate = template && !state.formatObject.skipTemplate;
                    if (state.html || useTemplate) {
                        if (!state.isRendered) {
                            if (useTemplate) {
                                template.render({
                                    model: state.formatObject,
                                    container: textHtml
                                });
                                state.html = textHtml.html();
                                if (!state.html) {
                                    _this.plaque.clear();
                                    return
                                }
                            } else {
                                that._text.attr({
                                    text: ""
                                });
                                textHtml.html(state.html)
                            }
                            textGroupHtml.css({
                                color: state.textColor,
                                width: DEFAULT_HTML_GROUP_WIDTH,
                                pointerEvents: pointerEvents
                            });
                            state.isRendered = true
                        }
                    } else {
                        that._text.css({
                            fill: state.textColor
                        }).attr({
                            text: state.text,
                            "class": options.cssClass,
                            "pointer-events": pointerEvents
                        }).append(group.attr({
                            align: options.textAlignment
                        }))
                    }
                    tooltip.plaque.customizeCloud({
                        fill: state.color,
                        stroke: state.borderColor,
                        "pointer-events": pointerEvents
                    })
                };
                this.plaque = new _plaque.Plaque({
                    opacity: that._options.opacity,
                    color: that._options.color,
                    border: that._options.border,
                    paddingLeftRight: that._options.paddingLeftRight,
                    paddingTopBottom: that._options.paddingTopBottom,
                    arrowLength: that._options.arrowLength,
                    arrowWidth: 20,
                    shadow: that._options.shadow,
                    cornerRadius: that._options.cornerRadius
                }, that, that._renderer.root, drawTooltip, true, function(tooltip, g) {
                    var state = tooltip._state;
                    if (state.html) {
                        var bBox;
                        var getComputedStyle = window.getComputedStyle;
                        if (getComputedStyle) {
                            bBox = getComputedStyle(textHtml.get(0));
                            bBox = {
                                x: 0,
                                y: 0,
                                width: mathCeil(parseFloat(bBox.width)),
                                height: mathCeil(parseFloat(bBox.height))
                            }
                        } else {
                            bBox = textHtml.get(0).getBoundingClientRect();
                            bBox = {
                                x: 0,
                                y: 0,
                                width: mathCeil(bBox.width ? bBox.width : bBox.right - bBox.left),
                                height: mathCeil(bBox.height ? bBox.height : bBox.bottom - bBox.top)
                            }
                        }
                        return bBox
                    }
                    return g.getBBox()
                }, function(tooltip, g, x, y) {
                    var state = tooltip._state;
                    if (state.html) {
                        that._textGroupHtml.css({
                            left: x,
                            top: y
                        })
                    } else {
                        g.move(x, y)
                    }
                });
                return that
            },
            setRendererOptions: function(options) {
                this._renderer.setOptions(options);
                this._textGroupHtml.css({
                    direction: options.rtl ? "rtl" : "ltr"
                });
                return this
            },
            render: function() {
                var that = this;
                hideElement(that._wrapper);
                var normalizedCSS = {};
                for (var name in that._textFontStyles) {
                    normalizedCSS[_inflector2.default.camelize(name)] = that._textFontStyles[name]
                }
                that._textGroupHtml.css(normalizedCSS);
                that._text.css(that._textFontStyles);
                that._eventData = null;
                return that
            },
            update: function(options) {
                return this.setOptions(options).render()
            },
            _prepare: function(formatObject, state) {
                var customizeTooltip = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this._customizeTooltip;
                var options = this._options;
                var customize = {};
                if (_type2.default.isFunction(customizeTooltip)) {
                    customize = customizeTooltip.call(formatObject, formatObject);
                    customize = _type2.default.isPlainObject(customize) ? customize : {};
                    if ("text" in customize) {
                        state.text = _type2.default.isDefined(customize.text) ? String(customize.text) : ""
                    }
                    if ("html" in customize) {
                        state.html = _type2.default.isDefined(customize.html) ? String(customize.html) : ""
                    }
                }
                if (!("text" in state) && !("html" in state)) {
                    state.text = formatObject.valueText || formatObject.description || ""
                }
                state.color = customize.color || options.color;
                state.borderColor = customize.borderColor || (options.border || {}).color;
                state.textColor = customize.fontColor || (this._textFontStyles || {}).color;
                return !!state.text || !!state.html || !!this._template
            },
            show: function(formatObject, params, eventData, customizeTooltip) {
                var that = this;
                var state = {
                    formatObject: formatObject
                };
                if (!that._prepare(formatObject, state, customizeTooltip)) {
                    return false
                }
                that._state = state;
                that._wrapper.appendTo(that._getContainer());
                that._clear();
                this.plaque.clear().draw((0, _extend.extend)({}, that._options, {
                    canvas: that._getCanvas()
                }, state, {
                    x: params.x,
                    y: params.y,
                    offset: params.offset
                }));
                that.moveWrapper();
                that._eventData && that._eventTrigger("tooltipHidden", that._eventData);
                that._eventData = eventData;
                that._eventTrigger("tooltipShown", that._eventData);
                return true
            },
            hide: function() {
                var that = this;
                hideElement(that._wrapper);
                if (that._eventData) {
                    that._eventTrigger("tooltipHidden", that._eventData);
                    that._clear();
                    that._eventData = null
                }
            },
            _clear: function() {
                this._textHtml.empty()
            },
            move: function(x, y, offset) {
                this.plaque.draw({
                    x: x,
                    y: y,
                    offset: offset,
                    canvas: this._getCanvas()
                });
                this.moveWrapper()
            },
            moveWrapper: function() {
                var that = this;
                var plaqueBBox = this.plaque.getBBox();
                that._renderer.resize(plaqueBBox.width, plaqueBBox.height);
                var offset = that._wrapper.css({
                    left: 0,
                    top: 0
                }).offset();
                var left = plaqueBBox.x;
                var top = plaqueBBox.y;
                that._wrapper.css({
                    left: left - offset.left,
                    top: top - offset.top
                });
                this.plaque.moveRoot(-left, -top);
                if (this._state.html) {
                    that._textHtml.css({
                        left: -left,
                        top: -top
                    });
                    that._textGroupHtml.css({
                        width: plaqueBBox.width
                    })
                }
            },
            formatValue: function(value, _specialFormat) {
                var options = _specialFormat ? getSpecialFormatOptions(this._options, _specialFormat) : this._options;
                return (0, _format_helper.format)(value, options.format)
            },
            getLocation: function() {
                return _utils2.default.normalizeEnum(this._options.location)
            },
            isEnabled: function() {
                return !!this._options.enabled
            },
            isShared: function() {
                return !!this._options.shared
            },
            _getCanvas: function() {
                var container = this._getContainer();
                var containerBox = container.getBoundingClientRect();
                var html = _dom_adapter2.default.getDocumentElement();
                var document = _dom_adapter2.default.getDocument();
                var left = window.pageXOffset || html.scrollLeft || 0;
                var top = window.pageYOffset || html.scrollTop || 0;
                var box = {
                    left: left,
                    top: top,
                    width: html.clientWidth + left || 0,
                    height: mathMax(document.body.scrollHeight, html.scrollHeight, document.body.offsetHeight, html.offsetHeight, document.body.clientHeight, html.clientHeight) || 0,
                    right: 0,
                    bottom: 0
                };
                if (container !== _dom_adapter2.default.getBody()) {
                    left = mathMax(box.left, box.left + containerBox.left);
                    top = mathMax(box.top, box.top + containerBox.top);
                    box.width = mathMin(containerBox.width, box.width) + left + box.left;
                    box.height = mathMin(containerBox.height, box.height) + top + box.top;
                    box.left = left;
                    box.top = top
                }
                return box
            }
        };
        exports.Tooltip = Tooltip;
        exports.plugin = {
            name: "tooltip",
            init: function() {
                this._initTooltip()
            },
            dispose: function() {
                this._disposeTooltip()
            },
            members: {
                _initTooltip: function() {
                    this._tooltip = new exports.Tooltip({
                        cssClass: this._rootClassPrefix + "-tooltip",
                        eventTrigger: this._eventTrigger,
                        pathModified: this.option("pathModified"),
                        widgetRoot: this.element(),
                        widget: this
                    })
                },
                _disposeTooltip: function() {
                    this._tooltip.dispose();
                    this._tooltip = null
                },
                _setTooltipRendererOptions: function() {
                    this._tooltip.setRendererOptions(this._getRendererOptions())
                },
                _setTooltipOptions: function() {
                    this._tooltip.update(this._getOption("tooltip"))
                }
            },
            extenders: {
                _stopCurrentHandling: function() {
                    this._tooltip && this._tooltip.hide()
                }
            },
            customize: function(constructor) {
                var proto = constructor.prototype;
                proto._eventsMap.onTooltipShown = {
                    name: "tooltipShown"
                };
                proto._eventsMap.onTooltipHidden = {
                    name: "tooltipHidden"
                };
                constructor.addChange({
                    code: "TOOLTIP_RENDERER",
                    handler: function() {
                        this._setTooltipRendererOptions()
                    },
                    isThemeDependent: true,
                    isOptionChange: true
                });
                constructor.addChange({
                    code: "TOOLTIP",
                    handler: function() {
                        this._setTooltipOptions()
                    },
                    isThemeDependent: true,
                    isOptionChange: true,
                    option: "tooltip"
                })
            },
            fontFields: ["tooltip.font"]
        }
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/translators/range.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var _isDefined = typeUtils.isDefined;
        var _isDate = typeUtils.isDate;
        var _isFunction = typeUtils.isFunction;
        var unique = __webpack_require__( /*! ../core/utils */ 13).unique;
        var minSelector = "min";
        var maxSelector = "max";
        var minVisibleSelector = "minVisible";
        var maxVisibleSelector = "maxVisible";
        var baseSelector = "base";
        var axisTypeSelector = "axisType";

        function otherLessThan(thisValue, otherValue) {
            return otherValue < thisValue
        }

        function otherGreaterThan(thisValue, otherValue) {
            return otherValue > thisValue
        }

        function compareAndReplace(thisValue, otherValue, setValue, compare) {
            var otherValueDefined = _isDefined(otherValue);
            if (_isDefined(thisValue)) {
                if (otherValueDefined && compare(thisValue, otherValue)) {
                    setValue(otherValue)
                }
            } else {
                if (otherValueDefined) {
                    setValue(otherValue)
                }
            }
        }
        var _Range = exports.Range = function(range) {
            range && extend(this, range)
        };
        _Range.prototype = {
            constructor: _Range,
            addRange: function(otherRange) {
                var that = this;
                var categories = that.categories;
                var otherCategories = otherRange.categories;
                var isDiscrete = "discrete" === that[axisTypeSelector];
                var compareAndReplaceByField = function(field, compare) {
                    compareAndReplace(that[field], otherRange[field], function(value) {
                        that[field] = value
                    }, compare)
                };
                var controlValuesByVisibleBounds = function(valueField, visibleValueField, compare) {
                    compareAndReplace(that[valueField], that[visibleValueField], function(value) {
                        _isDefined(that[valueField]) && (that[valueField] = value)
                    }, compare)
                };
                var checkField = function(field) {
                    that[field] = that[field] || otherRange[field]
                };
                checkField("invert");
                checkField(axisTypeSelector);
                checkField("dataType");
                checkField("isSpacedMargin");
                if ("logarithmic" === that[axisTypeSelector]) {
                    checkField(baseSelector)
                } else {
                    that[baseSelector] = void 0
                }
                compareAndReplaceByField(minSelector, otherLessThan);
                compareAndReplaceByField(maxSelector, otherGreaterThan);
                if (isDiscrete) {
                    checkField(minVisibleSelector);
                    checkField(maxVisibleSelector)
                } else {
                    compareAndReplaceByField(minVisibleSelector, otherLessThan);
                    compareAndReplaceByField(maxVisibleSelector, otherGreaterThan)
                }
                compareAndReplaceByField("interval", otherLessThan);
                if (!isDiscrete) {
                    controlValuesByVisibleBounds(minSelector, minVisibleSelector, otherLessThan);
                    controlValuesByVisibleBounds(minSelector, maxVisibleSelector, otherLessThan);
                    controlValuesByVisibleBounds(maxSelector, maxVisibleSelector, otherGreaterThan);
                    controlValuesByVisibleBounds(maxSelector, minVisibleSelector, otherGreaterThan)
                }
                if (void 0 === categories) {
                    that.categories = otherCategories
                } else {
                    that.categories = otherCategories ? unique(categories.concat(otherCategories)) : categories
                }
                if ("logarithmic" === that[axisTypeSelector]) {
                    checkField("allowNegatives");
                    compareAndReplaceByField("linearThreshold", otherLessThan)
                }
                return that
            },
            isEmpty: function() {
                return (!_isDefined(this[minSelector]) || !_isDefined(this[maxSelector])) && (!this.categories || 0 === this.categories.length)
            },
            correctValueZeroLevel: function() {
                var that = this;
                if ("logarithmic" === that[axisTypeSelector] || _isDate(that[maxSelector]) || _isDate(that[minSelector])) {
                    return that
                }

                function setZeroLevel(min, max) {
                    that[min] < 0 && that[max] < 0 && (that[max] = 0);
                    that[min] > 0 && that[max] > 0 && (that[min] = 0)
                }
                setZeroLevel(minSelector, maxSelector);
                setZeroLevel(minVisibleSelector, maxVisibleSelector);
                return that
            },
            sortCategories: function(sort) {
                if (false === sort || !this.categories) {
                    return
                }
                if (Array.isArray(sort)) {
                    var sortValues = sort.map(function(item) {
                        return item.valueOf()
                    });
                    var filteredSeriesCategories = this.categories.filter(function(item) {
                        return sortValues.indexOf(item.valueOf()) === -1
                    });
                    this.categories = sort.concat(filteredSeriesCategories)
                } else {
                    var notAFunction = !_isFunction(sort);
                    if (notAFunction && "string" !== this.dataType) {
                        sort = function(a, b) {
                            return a.valueOf() - b.valueOf()
                        }
                    } else {
                        if (notAFunction) {
                            sort = false
                        }
                    }
                    sort && this.categories.sort(sort)
                }
            }
        }
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/core/templates/function_template.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.FunctionTemplate = void 0;
        var _template_base = __webpack_require__( /*! ./template_base */ 78);
        var _dom = __webpack_require__( /*! ../utils/dom */ 11);

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }

        function _inherits(subClass, superClass) {
            if ("function" !== typeof superClass && null !== superClass) {
                throw new TypeError("Super expression must either be null or a function")
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) {
                _setPrototypeOf(subClass, superClass)
            }
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o
            };
            return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                    result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (call && ("object" === _typeof(call) || "function" === typeof call)) {
                return call
            }
            return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
            if (void 0 === self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return self
        }

        function _isNativeReflectConstruct() {
            if ("undefined" === typeof Reflect || !Reflect.construct) {
                return false
            }
            if (Reflect.construct.sham) {
                return false
            }
            if ("function" === typeof Proxy) {
                return true
            }
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                return true
            } catch (e) {
                return false
            }
        }

        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
            };
            return _getPrototypeOf(o)
        }
        exports.FunctionTemplate = function(_TemplateBase) {
            _inherits(FunctionTemplate, _TemplateBase);
            var _super = _createSuper(FunctionTemplate);

            function FunctionTemplate(render) {
                var _this;
                _classCallCheck(this, FunctionTemplate);
                _this = _super.call(this);
                _this._render = render;
                return _this
            }
            _createClass(FunctionTemplate, [{
                key: "_renderCore",
                value: function(options) {
                    return (0, _dom.normalizeTemplateElement)(this._render(options))
                }
            }]);
            return FunctionTemplate
        }(_template_base.TemplateBase)
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/core/utils/resize_callbacks.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var windowUtils = __webpack_require__( /*! ./window */ 7);
        var domAdapter = __webpack_require__( /*! ../dom_adapter */ 12);
        var Callbacks = __webpack_require__( /*! ./callbacks */ 27);
        var readyCallbacks = __webpack_require__( /*! ./ready_callbacks */ 51);
        var callOnce = __webpack_require__( /*! ./call_once */ 80);
        var resizeCallbacks = function() {
            var prevSize;
            var callbacks = Callbacks();
            var originalCallbacksAdd = callbacks.add;
            var originalCallbacksRemove = callbacks.remove;
            if (!windowUtils.hasWindow()) {
                return callbacks
            }
            var formatSize = function() {
                var window = windowUtils.getWindow();
                return {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            };
            var handleResize = function() {
                var now = formatSize();
                if (now.width === prevSize.width && now.height === prevSize.height) {
                    return
                }
                var changedDimension;
                if (now.width === prevSize.width) {
                    changedDimension = "height"
                }
                if (now.height === prevSize.height) {
                    changedDimension = "width"
                }
                prevSize = now;
                callbacks.fire(changedDimension)
            };
            var setPrevSize = callOnce(function() {
                prevSize = formatSize()
            });
            var removeListener;
            callbacks.add = function() {
                var result = originalCallbacksAdd.apply(callbacks, arguments);
                setPrevSize();
                readyCallbacks.add(function() {
                    if (!removeListener && callbacks.has()) {
                        removeListener = domAdapter.listen(windowUtils.getWindow(), "resize", handleResize)
                    }
                });
                return result
            };
            callbacks.remove = function() {
                var result = originalCallbacksRemove.apply(callbacks, arguments);
                if (!callbacks.has() && removeListener) {
                    removeListener();
                    removeListener = void 0
                }
                return result
            };
            return callbacks
        }();
        module.exports = resizeCallbacks
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/core/component.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _config = __webpack_require__( /*! ./config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _extend = __webpack_require__( /*! ./utils/extend */ 0);
        var _index = __webpack_require__( /*! ./options/index */ 468);
        var _utils = __webpack_require__( /*! ./options/utils */ 187);
        var _class = __webpack_require__( /*! ./class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _action = __webpack_require__( /*! ./action */ 105);
        var _action2 = _interopRequireDefault(_action);
        var _errors = __webpack_require__( /*! ./errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _callbacks = __webpack_require__( /*! ./utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);
        var _events_strategy = __webpack_require__( /*! ./events_strategy */ 100);
        var _public_component = __webpack_require__( /*! ./utils/public_component */ 139);
        var _public_component2 = _interopRequireDefault(_public_component);
        var _postponed_operations = __webpack_require__( /*! ./postponed_operations */ 470);
        var _type = __webpack_require__( /*! ./utils/type */ 1);
        var _common = __webpack_require__( /*! ./utils/common */ 3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var getEventName = function(actionName) {
            return actionName.charAt(2).toLowerCase() + actionName.substr(3)
        };
        var Component = _class2.default.inherit({
            _setDeprecatedOptions: function() {
                this._deprecatedOptions = {}
            },
            _getDeprecatedOptions: function() {
                return this._deprecatedOptions
            },
            _getDefaultOptions: function() {
                return {
                    onInitialized: null,
                    onOptionChanged: null,
                    onDisposing: null,
                    defaultOptionsRules: null
                }
            },
            _defaultOptionsRules: function() {
                return []
            },
            _setOptionsByDevice: function(rules) {
                this._options.applyRules(rules)
            },
            _convertRulesToOptions: function(rules) {
                return (0, _utils.convertRulesToOptions)(rules)
            },
            _isInitialOptionValue: function(name) {
                return this._options.isInitial(name)
            },
            _setOptionsByReference: function() {
                this._optionsByReference = {}
            },
            _getOptionsByReference: function() {
                return this._optionsByReference
            },
            ctor: function() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                var _optionChangedCallbacks = options._optionChangedCallbacks,
                    _disposingCallbacks = options._disposingCallbacks;
                this.NAME = _public_component2.default.name(this.constructor);
                this._eventsStrategy = _events_strategy.EventsStrategy.create(this, options.eventsStrategy);
                this._updateLockCount = 0;
                this._optionChangedCallbacks = _optionChangedCallbacks || (0, _callbacks2.default)();
                this._disposingCallbacks = _disposingCallbacks || (0, _callbacks2.default)();
                this.postponedOperations = new _postponed_operations.PostponedOperations;
                this._createOptions(options)
            },
            _createOptions: function(options) {
                var _this = this;
                this.beginUpdate();
                try {
                    this._setOptionsByReference();
                    this._setDeprecatedOptions();
                    this._options = new _index.Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
                    this._options.onChanging(function(name, previousValue, value) {
                        return _this._initialized && _this._optionChanging(name, previousValue, value)
                    });
                    this._options.onDeprecated(function(option, info) {
                        return _this._logDeprecatedOptionWarning(option, info)
                    });
                    this._options.onChanged(function(name, value, previousValue) {
                        return _this._notifyOptionChanged(name, value, previousValue)
                    });
                    this._options.onStartChange(function() {
                        return _this.beginUpdate()
                    });
                    this._options.onEndChange(function() {
                        return _this.endUpdate()
                    });
                    this._options.addRules(this._defaultOptionsRules());
                    if (options && options.onInitializing) {
                        options.onInitializing.apply(this, [options])
                    }
                    this._setOptionsByDevice(options.defaultOptionsRules);
                    this._initOptions(options)
                } finally {
                    this.endUpdate()
                }
            },
            _initOptions: function(options) {
                this.option(options)
            },
            _init: function() {
                var _this2 = this;
                this._createOptionChangedAction();
                this.on("disposing", function(args) {
                    _this2._disposingCallbacks.fireWith(_this2, [args])
                })
            },
            _logDeprecatedOptionWarning: function(option, info) {
                var message = info.message || "Use the '".concat(info.alias, "' option instead");
                _errors2.default.log("W0001", this.NAME, option, info.since, message)
            },
            _logDeprecatedComponentWarning: function(since, alias) {
                _errors2.default.log("W0000", this.NAME, since, "Use the '".concat(alias, "' widget instead"))
            },
            _createOptionChangedAction: function() {
                this._optionChangedAction = this._createActionByOption("onOptionChanged", {
                    excludeValidators: ["disabled", "readOnly"]
                })
            },
            _createDisposingAction: function() {
                this._disposingAction = this._createActionByOption("onDisposing", {
                    excludeValidators: ["disabled", "readOnly"]
                })
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case "onDisposing":
                    case "onInitialized":
                        break;
                    case "onOptionChanged":
                        this._createOptionChangedAction();
                        break;
                    case "defaultOptionsRules":
                }
            },
            _dispose: function() {
                this._optionChangedCallbacks.empty();
                this._createDisposingAction();
                this._disposingAction();
                this._eventsStrategy.dispose();
                this._options.dispose();
                this._disposed = true
            },
            _lockUpdate: function() {
                this._updateLockCount++
            },
            _unlockUpdate: function() {
                this._updateLockCount = Math.max(this._updateLockCount - 1, 0)
            },
            _isUpdateAllowed: function() {
                return 0 === this._updateLockCount
            },
            _isInitializingRequired: function() {
                return !this._initializing && !this._initialized
            },
            _commitUpdate: function() {
                this.postponedOperations.callPostponedOperations();
                this._isInitializingRequired() && this._initializeComponent()
            },
            _initializeComponent: function() {
                this._initializing = true;
                try {
                    this._init()
                } finally {
                    this._initializing = false;
                    this._lockUpdate();
                    this._createActionByOption("onInitialized", {
                        excludeValidators: ["disabled", "readOnly"]
                    })();
                    this._unlockUpdate();
                    this._initialized = true
                }
            },
            instance: function() {
                return this
            },
            beginUpdate: function() {
                this._lockUpdate()
            },
            endUpdate: function() {
                this._unlockUpdate();
                this._isUpdateAllowed() && this._commitUpdate()
            },
            _optionChanging: _common.noop,
            _notifyOptionChanged: function(option, value, previousValue) {
                if (this._initialized) {
                    var optionNames = [option].concat(this._options.getAliasesByName(option));
                    for (var i = 0; i < optionNames.length; i++) {
                        var name = optionNames[i];
                        var args = {
                            name: name.split(/[.[]/)[0],
                            fullName: name,
                            value: value,
                            previousValue: previousValue
                        };
                        this._optionChangedCallbacks.fireWith(this, [(0, _extend.extend)(this._defaultActionArgs(), args)]);
                        this._optionChangedAction((0, _extend.extend)({}, args));
                        if (!this._disposed && this._cancelOptionChange !== args.name) {
                            this._optionChanged(args)
                        }
                    }
                }
            },
            initialOption: function(name) {
                return this._options.initial(name)
            },
            _defaultActionConfig: function() {
                return {
                    context: this,
                    component: this
                }
            },
            _defaultActionArgs: function() {
                return {
                    component: this
                }
            },
            _createAction: function(actionSource, config) {
                var _this3 = this;
                var action;
                return function(e) {
                    if (!(0, _type.isDefined)(e)) {
                        e = {}
                    }
                    if (!(0, _type.isPlainObject)(e)) {
                        e = {
                            actionValue: e
                        }
                    }
                    action = action || new _action2.default(actionSource, (0, _extend.extend)(config, _this3._defaultActionConfig()));
                    return action.execute.call(action, (0, _extend.extend)(e, _this3._defaultActionArgs()))
                }
            },
            _createActionByOption: function(optionName, config) {
                var _this4 = this;
                var action;
                var eventName;
                var actionFunc;
                var result = function() {
                    if (!eventName) {
                        config = config || {};
                        if ("string" !== typeof optionName) {
                            throw _errors2.default.Error("E0008")
                        }
                        if (0 === optionName.indexOf("on")) {
                            eventName = getEventName(optionName)
                        }
                        if (0 !== optionName.indexOf("on")) {
                            throw Error("The '".concat(optionName, "' option name should start with 'on' prefix"))
                        }
                        actionFunc = _this4.option(optionName)
                    }
                    if (!action && !actionFunc && !config.beforeExecute && !config.afterExecute && !_this4._eventsStrategy.hasEvent(eventName)) {
                        return
                    }
                    if (!action) {
                        var beforeExecute = config.beforeExecute;
                        config.beforeExecute = function() {
                            for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                props[_key2] = arguments[_key2]
                            }
                            beforeExecute && beforeExecute.apply(_this4, props);
                            _this4._eventsStrategy.fireEvent(eventName, props[0].args)
                        };
                        action = _this4._createAction(actionFunc, config)
                    }
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key]
                    }
                    if ((0, _config2.default)().wrapActionsBeforeExecute) {
                        var beforeActionExecute = _this4.option("beforeActionExecute") || _common.noop;
                        var wrappedAction = beforeActionExecute(_this4, action, config) || action;
                        return wrappedAction.apply(_this4, args)
                    }
                    return action.apply(_this4, args)
                };
                if ((0, _config2.default)().wrapActionsBeforeExecute) {
                    return result
                }
                var onActionCreated = this.option("onActionCreated") || _common.noop;
                return onActionCreated(this, result, config) || result
            },
            on: function(eventName, eventHandler) {
                this._eventsStrategy.on(eventName, eventHandler);
                return this
            },
            off: function(eventName, eventHandler) {
                this._eventsStrategy.off(eventName, eventHandler);
                return this
            },
            hasActionSubscription: function(actionName) {
                return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName))
            },
            isOptionDeprecated: function(name) {
                return this._options.isDeprecated(name)
            },
            _setOptionWithoutOptionChange: function(name, value) {
                this._cancelOptionChange = name;
                this.option(name, value);
                this._cancelOptionChange = false
            },
            _getOptionValue: function(name, context) {
                var value = this.option(name);
                if ((0, _type.isFunction)(value)) {
                    return value.bind(context)()
                }
                return value
            },
            option: function() {
                var _this$_options;
                return (_this$_options = this._options).option.apply(_this$_options, arguments)
            },
            resetOption: function(name) {
                this.beginUpdate();
                this._options.reset(name);
                this.endUpdate()
            }
        });
        module.exports = Component
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/events/short.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.keyboard = exports.click = exports.dxClick = exports.focus = exports.visibility = exports.hover = exports.resize = exports.active = void 0;
        var _dom_adapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _events_engine = __webpack_require__( /*! ./core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _keyboard_processor = __webpack_require__( /*! ./core/keyboard_processor */ 475);
        var _keyboard_processor2 = _interopRequireDefault(_keyboard_processor);
        var _utils = __webpack_require__( /*! ./utils */ 8);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function addNamespace(event, namespace) {
            return namespace ? (0, _utils.addNamespace)(event, namespace) : event
        }
        exports.active = {
            on: function($el, active, inactive, opts) {
                var selector = opts.selector,
                    showTimeout = opts.showTimeout,
                    hideTimeout = opts.hideTimeout,
                    namespace = opts.namespace;
                _events_engine2.default.on($el, addNamespace("dxactive", namespace), selector, {
                    timeout: showTimeout
                }, function(event) {
                    return active.execute({
                        event: event,
                        element: event.currentTarget
                    })
                });
                _events_engine2.default.on($el, addNamespace("dxinactive", namespace), selector, {
                    timeout: hideTimeout
                }, function(event) {
                    return inactive.execute({
                        event: event,
                        element: event.currentTarget
                    })
                })
            },
            off: function($el, _ref) {
                var namespace = _ref.namespace,
                    selector = _ref.selector;
                _events_engine2.default.off($el, addNamespace("dxactive", namespace), selector);
                _events_engine2.default.off($el, addNamespace("dxinactive", namespace), selector)
            }
        };
        exports.resize = {
            on: function($el, resize) {
                var _ref2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    namespace = _ref2.namespace;
                _events_engine2.default.on($el, addNamespace("dxresize", namespace), resize)
            },
            off: function($el) {
                var _ref3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    namespace = _ref3.namespace;
                _events_engine2.default.off($el, addNamespace("dxresize", namespace))
            }
        };
        exports.hover = {
            on: function($el, start, end, _ref4) {
                var selector = _ref4.selector,
                    namespace = _ref4.namespace;
                _events_engine2.default.on($el, addNamespace("dxhoverend", namespace), selector, function(event) {
                    return end(event)
                });
                _events_engine2.default.on($el, addNamespace("dxhoverstart", namespace), selector, function(event) {
                    start.execute({
                        element: event.target,
                        event: event
                    })
                })
            },
            off: function($el, _ref5) {
                var selector = _ref5.selector,
                    namespace = _ref5.namespace;
                _events_engine2.default.off($el, addNamespace("dxhoverstart", namespace), selector);
                _events_engine2.default.off($el, addNamespace("dxhoverend", namespace), selector)
            }
        };
        exports.visibility = {
            on: function($el, shown, hiding, _ref6) {
                var namespace = _ref6.namespace;
                _events_engine2.default.on($el, addNamespace("dxhiding", namespace), hiding);
                _events_engine2.default.on($el, addNamespace("dxshown", namespace), shown)
            },
            off: function($el, _ref7) {
                var namespace = _ref7.namespace;
                _events_engine2.default.off($el, addNamespace("dxhiding", namespace));
                _events_engine2.default.off($el, addNamespace("dxshown", namespace))
            }
        };
        exports.focus = {
            on: function($el, focusIn, focusOut, _ref8) {
                var namespace = _ref8.namespace,
                    isFocusable = _ref8.isFocusable;
                _events_engine2.default.on($el, addNamespace("focusin", namespace), focusIn);
                _events_engine2.default.on($el, addNamespace("focusout", namespace), focusOut);
                if (_dom_adapter2.default.hasDocumentProperty("onbeforeactivate")) {
                    _events_engine2.default.on($el, addNamespace("beforeactivate", namespace), function(e) {
                        return isFocusable(e.target) || e.preventDefault()
                    })
                }
            },
            off: function($el, _ref9) {
                var namespace = _ref9.namespace;
                _events_engine2.default.off($el, addNamespace("focusin", namespace));
                _events_engine2.default.off($el, addNamespace("focusout", namespace));
                if (_dom_adapter2.default.hasDocumentProperty("onbeforeactivate")) {
                    _events_engine2.default.off($el, addNamespace("beforeactivate", namespace))
                }
            },
            trigger: function($el) {
                return _events_engine2.default.trigger($el, "focus")
            }
        };
        exports.dxClick = {
            on: function($el, click) {
                var _ref10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    namespace = _ref10.namespace;
                _events_engine2.default.on($el, addNamespace("dxclick", namespace), click)
            },
            off: function($el) {
                var _ref11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    namespace = _ref11.namespace;
                _events_engine2.default.off($el, addNamespace("dxclick", namespace))
            }
        };
        exports.click = {
            on: function($el, click) {
                var _ref12 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    namespace = _ref12.namespace;
                _events_engine2.default.on($el, addNamespace("click", namespace), click)
            },
            off: function($el) {
                var _ref13 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    namespace = _ref13.namespace;
                _events_engine2.default.off($el, addNamespace("click", namespace))
            }
        };
        var index = 0;
        var keyboardProcessors = {};
        var generateListenerId = function() {
            return "keyboardProcessorId".concat(index++)
        };
        exports.keyboard = {
            on: function(element, focusTarget, handler) {
                var listenerId = generateListenerId();
                keyboardProcessors[listenerId] = new _keyboard_processor2.default({
                    element: element,
                    focusTarget: focusTarget,
                    handler: handler
                });
                return listenerId
            },
            off: function(listenerId) {
                if (listenerId && keyboardProcessors[listenerId]) {
                    keyboardProcessors[listenerId].dispose();
                    delete keyboardProcessors[listenerId]
                }
            },
            _getProcessor: function(listenerId) {
                return keyboardProcessors[listenerId]
            }
        }
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/animation/frame.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var windowUtils = __webpack_require__( /*! ../core/utils/window */ 7);
        var window = windowUtils.hasWindow() ? windowUtils.getWindow() : {};
        var callOnce = __webpack_require__( /*! ../core/utils/call_once */ 80);
        var FRAME_ANIMATION_STEP_TIME = 1e3 / 60;
        var request = function(callback) {
            return setTimeout(callback, FRAME_ANIMATION_STEP_TIME)
        };
        var cancel = function(requestID) {
            clearTimeout(requestID)
        };
        var setAnimationFrameMethods = callOnce(function() {
            var nativeRequest = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
            var nativeCancel = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
            if (nativeRequest && nativeCancel) {
                request = nativeRequest;
                cancel = nativeCancel
            }
            if (nativeRequest && !nativeCancel) {
                var canceledRequests = {};
                request = function(callback) {
                    var requestId = nativeRequest.call(window, function() {
                        try {
                            if (requestId in canceledRequests) {
                                return
                            }
                            callback.apply(this, arguments)
                        } finally {
                            delete canceledRequests[requestId]
                        }
                    });
                    return requestId
                };
                cancel = function(requestId) {
                    canceledRequests[requestId] = true
                }
            }
        });
        exports.requestAnimationFrame = function() {
            setAnimationFrameMethods();
            return request.apply(window, arguments)
        };
        exports.cancelAnimationFrame = function() {
            setAnimationFrameMethods();
            cancel.apply(window, arguments)
        }
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/data/custom_store.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../core/renderer */ 2);
        var dataUtils = __webpack_require__( /*! ./utils */ 42);
        var arrayUtils = __webpack_require__( /*! ./array_utils */ 142);
        var isFunction = __webpack_require__( /*! ../core/utils/type */ 1).isFunction;
        var config = __webpack_require__( /*! ../core/config */ 30);
        var errors = __webpack_require__( /*! ./errors */ 38).errors;
        var Store = __webpack_require__( /*! ./abstract_store */ 103);
        var arrayQuery = __webpack_require__( /*! ./array_query */ 161);
        var queryByOptions = __webpack_require__( /*! ./store_helper */ 86).queryByOptions;
        var deferredUtils = __webpack_require__( /*! ../core/utils/deferred */ 6);
        var Deferred = deferredUtils.Deferred;
        var when = deferredUtils.when;
        var fromPromise = deferredUtils.fromPromise;
        var TOTAL_COUNT = "totalCount";
        var LOAD = "load";
        var BY_KEY = "byKey";
        var INSERT = "insert";
        var UPDATE = "update";
        var REMOVE = "remove";

        function isPromise(obj) {
            return obj && isFunction(obj.then)
        }

        function trivialPromise(value) {
            return (new Deferred).resolve(value).promise()
        }

        function ensureRequiredFuncOption(name, obj) {
            if (!isFunction(obj)) {
                throw errors.Error("E4011", name)
            }
        }

        function throwInvalidUserFuncResult(name) {
            throw errors.Error("E4012", name)
        }

        function createUserFuncFailureHandler(pendingDeferred) {
            function errorMessageFromXhr(promiseArguments) {
                var xhr = promiseArguments[0];
                var textStatus = promiseArguments[1];
                if (!xhr || !xhr.getResponseHeader) {
                    return null
                }
                return dataUtils.errorMessageFromXhr(xhr, textStatus)
            }
            return function(arg) {
                var error;
                if (arg instanceof Error) {
                    error = arg
                } else {
                    error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || "Unknown error")
                }
                if (error.message !== dataUtils.XHR_ERROR_UNLOAD) {
                    pendingDeferred.reject(error)
                }
            }
        }

        function invokeUserLoad(store, options) {
            var userFunc = store._loadFunc;
            var userResult;
            ensureRequiredFuncOption(LOAD, userFunc);
            userResult = userFunc.apply(store, [options]);
            if (Array.isArray(userResult)) {
                userResult = trivialPromise(userResult)
            } else {
                if (null === userResult || void 0 === userResult) {
                    userResult = trivialPromise([])
                } else {
                    if (!isPromise(userResult)) {
                        throwInvalidUserFuncResult(LOAD)
                    }
                }
            }
            return fromPromise(userResult)
        }

        function invokeUserTotalCountFunc(store, options) {
            var userFunc = store._totalCountFunc;
            var userResult;
            if (!isFunction(userFunc)) {
                throw errors.Error("E4021")
            }
            userResult = userFunc.apply(store, [options]);
            if (!isPromise(userResult)) {
                userResult = Number(userResult);
                if (!isFinite(userResult)) {
                    throwInvalidUserFuncResult(TOTAL_COUNT)
                }
                userResult = trivialPromise(userResult)
            }
            return fromPromise(userResult)
        }

        function invokeUserByKeyFunc(store, key, extraOptions) {
            var userFunc = store._byKeyFunc;
            var userResult;
            ensureRequiredFuncOption(BY_KEY, userFunc);
            userResult = userFunc.apply(store, [key, extraOptions]);
            if (!isPromise(userResult)) {
                userResult = trivialPromise(userResult)
            }
            return fromPromise(userResult)
        }

        function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
            if (store.__rawData) {
                continuation(store.__rawData)
            } else {
                var loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
                if (store._cacheRawData) {
                    store.__rawDataPromise = loadPromise
                }
                loadPromise.always(function() {
                    delete store.__rawDataPromise
                }).done(function(rawData) {
                    if (store._cacheRawData) {
                        store.__rawData = rawData
                    }
                    continuation(rawData)
                }).fail(createUserFuncFailureHandler(pendingDeferred))
            }
        }

        function runRawLoadWithQuery(pendingDeferred, store, options, countOnly) {
            options = options || {};
            var userFuncOptions = {};
            if ("userData" in options) {
                userFuncOptions.userData = options.userData
            }
            runRawLoad(pendingDeferred, store, userFuncOptions, function(rawData) {
                var rawDataQuery = arrayQuery(rawData, {
                    errorHandler: store._errorHandler
                });
                var itemsQuery;
                var totalCountQuery;
                var waitList = [];
                var items;
                var totalCount;
                if (!countOnly) {
                    itemsQuery = queryByOptions(rawDataQuery, options);
                    if (itemsQuery === rawDataQuery) {
                        items = rawData.slice(0)
                    } else {
                        waitList.push(itemsQuery.enumerate().done(function(asyncResult) {
                            items = asyncResult
                        }))
                    }
                }
                if (options.requireTotalCount || countOnly) {
                    totalCountQuery = queryByOptions(rawDataQuery, options, true);
                    if (totalCountQuery === rawDataQuery) {
                        totalCount = rawData.length
                    } else {
                        waitList.push(totalCountQuery.count().done(function(asyncResult) {
                            totalCount = asyncResult
                        }))
                    }
                }
                when.apply($, waitList).done(function() {
                    if (countOnly) {
                        pendingDeferred.resolve(totalCount)
                    } else {
                        if (options.requireTotalCount) {
                            pendingDeferred.resolve(items, {
                                totalCount: totalCount
                            })
                        } else {
                            pendingDeferred.resolve(items)
                        }
                    }
                }).fail(function(x) {
                    pendingDeferred.reject(x)
                })
            })
        }

        function runRawLoadWithKey(pendingDeferred, store, key) {
            runRawLoad(pendingDeferred, store, {}, function(rawData) {
                var keyExpr = store.key();
                var item;
                for (var i = 0, len = rawData.length; i < len; i++) {
                    item = rawData[i];
                    if (dataUtils.keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
                        pendingDeferred.resolve(item);
                        return
                    }
                }
                pendingDeferred.reject(errors.Error("E4009"))
            })
        }
        var CustomStore = Store.inherit({
            ctor: function(options) {
                options = options || {};
                this.callBase(options);
                this._useDefaultSearch = !!options.useDefaultSearch || "raw" === options.loadMode;
                this._loadMode = options.loadMode;
                this._cacheRawData = false !== options.cacheRawData;
                this._loadFunc = options[LOAD];
                this._totalCountFunc = options[TOTAL_COUNT];
                this._byKeyFunc = options[BY_KEY];
                this._insertFunc = options[INSERT];
                this._updateFunc = options[UPDATE];
                this._removeFunc = options[REMOVE]
            },
            createQuery: function() {
                throw errors.Error("E4010")
            },
            clearRawDataCache: function() {
                delete this.__rawData
            },
            _totalCountImpl: function(options) {
                var d = new Deferred;
                if ("raw" === this._loadMode && !this._totalCountFunc) {
                    runRawLoadWithQuery(d, this, options, true)
                } else {
                    invokeUserTotalCountFunc(this, options).done(function(count) {
                        d.resolve(Number(count))
                    }).fail(createUserFuncFailureHandler(d));
                    d = this._addFailHandlers(d)
                }
                return d.promise()
            },
            _pushImpl: function(changes) {
                if (this.__rawData) {
                    arrayUtils.applyBatch(this, this.__rawData, changes)
                }
            },
            _loadImpl: function(options) {
                var d = new Deferred;
                if ("raw" === this._loadMode) {
                    runRawLoadWithQuery(d, this, options, false)
                } else {
                    invokeUserLoad(this, options).done(function(data, extra) {
                        d.resolve(data, extra)
                    }).fail(createUserFuncFailureHandler(d));
                    d = this._addFailHandlers(d)
                }
                return d.promise()
            },
            _byKeyImpl: function(key, extraOptions) {
                var d = new Deferred;
                if (this._byKeyViaLoad()) {
                    this._requireKey();
                    runRawLoadWithKey(d, this, key)
                } else {
                    invokeUserByKeyFunc(this, key, extraOptions).done(function(obj) {
                        d.resolve(obj)
                    }).fail(createUserFuncFailureHandler(d))
                }
                return d.promise()
            },
            _byKeyViaLoad: function() {
                return "raw" === this._loadMode && !this._byKeyFunc
            },
            _insertImpl: function(values) {
                var that = this;
                var userFunc = that._insertFunc;
                var userResult;
                var d = new Deferred;
                ensureRequiredFuncOption(INSERT, userFunc);
                userResult = userFunc.apply(that, [values]);
                if (!isPromise(userResult)) {
                    userResult = trivialPromise(userResult)
                }
                fromPromise(userResult).done(function(serverResponse) {
                    if (config().useLegacyStoreResult) {
                        d.resolve(values, serverResponse)
                    } else {
                        d.resolve(serverResponse || values, that.keyOf(serverResponse))
                    }
                }).fail(createUserFuncFailureHandler(d));
                return d.promise()
            },
            _updateImpl: function(key, values) {
                var userFunc = this._updateFunc;
                var userResult;
                var d = new Deferred;
                ensureRequiredFuncOption(UPDATE, userFunc);
                userResult = userFunc.apply(this, [key, values]);
                if (!isPromise(userResult)) {
                    userResult = trivialPromise(userResult)
                }
                fromPromise(userResult).done(function(serverResponse) {
                    if (config().useLegacyStoreResult) {
                        d.resolve(key, values)
                    } else {
                        d.resolve(serverResponse || values, key)
                    }
                }).fail(createUserFuncFailureHandler(d));
                return d.promise()
            },
            _removeImpl: function(key) {
                var userFunc = this._removeFunc;
                var userResult;
                var d = new Deferred;
                ensureRequiredFuncOption(REMOVE, userFunc);
                userResult = userFunc.apply(this, [key]);
                if (!isPromise(userResult)) {
                    userResult = trivialPromise()
                }
                fromPromise(userResult).done(function() {
                    d.resolve(key)
                }).fail(createUserFuncFailureHandler(d));
                return d.promise()
            }
        });
        module.exports = CustomStore
    }, , , , , , ,
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/components/consts.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = {
            events: {
                mouseover: "mouseover",
                mouseout: "mouseout",
                mousemove: "mousemove",
                touchstart: "touchstart",
                touchmove: "touchmove",
                touchend: "touchend",
                mousedown: "mousedown",
                mouseup: "mouseup",
                click: "click",
                selectSeries: "selectseries",
                deselectSeries: "deselectseries",
                selectPoint: "selectpoint",
                deselectPoint: "deselectpoint",
                showPointTooltip: "showpointtooltip",
                hidePointTooltip: "hidepointtooltip"
            },
            states: {
                hover: "hover",
                normal: "normal",
                selection: "selection",
                normalMark: 0,
                hoverMark: 1,
                selectedMark: 2,
                applyHover: "applyHover",
                applySelected: "applySelected",
                resetItem: "resetItem"
            },
            radialLabelIndent: 30,
            pieLabelSpacing: 10,
            pieSeriesSpacing: 4
        }
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/symbol_point.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../../../core/utils/iterator */ 4).each;
        var noop = __webpack_require__( /*! ../../../core/utils/common */ 3).noop;
        var windowUtils = __webpack_require__( /*! ../../../core/utils/window */ 7);
        var window = windowUtils.getWindow();
        var labelModule = __webpack_require__( /*! ./label */ 262);
        var _extend = extend;
        var _isDefined = __webpack_require__( /*! ../../../core/utils/type */ 1).isDefined;
        var _normalizeEnum = __webpack_require__( /*! ../../core/utils */ 13).normalizeEnum;
        var _math = Math;
        var _round = _math.round;
        var _floor = _math.floor;
        var _ceil = _math.ceil;
        var DEFAULT_IMAGE_WIDTH = 20;
        var DEFAULT_IMAGE_HEIGHT = 20;
        var LABEL_OFFSET = 10;
        var CANVAS_POSITION_DEFAULT = "canvas_position_default";

        function getSquareMarkerCoords(radius) {
            return [-radius, -radius, radius, -radius, radius, radius, -radius, radius, -radius, -radius]
        }

        function getPolygonMarkerCoords(radius) {
            var r = _ceil(radius);
            return [-r, 0, 0, -r, r, 0, 0, r, -r, 0]
        }

        function getCrossMarkerCoords(radius) {
            var r = _ceil(radius);
            var floorHalfRadius = _floor(r / 2);
            var ceilHalfRadius = _ceil(r / 2);
            return [-r, -floorHalfRadius, -floorHalfRadius, -r, 0, -ceilHalfRadius, floorHalfRadius, -r, r, -floorHalfRadius, ceilHalfRadius, 0, r, floorHalfRadius, floorHalfRadius, r, 0, ceilHalfRadius, -floorHalfRadius, r, -r, floorHalfRadius, -ceilHalfRadius, 0]
        }

        function getTriangleDownMarkerCoords(radius) {
            return [-radius, -radius, radius, -radius, 0, radius, -radius, -radius]
        }

        function getTriangleUpMarkerCoords(radius) {
            return [-radius, radius, radius, radius, 0, -radius, -radius, radius]
        }
        module.exports = {
            deleteLabel: function() {
                this._label.dispose();
                this._label = null
            },
            _hasGraphic: function() {
                return this.graphic
            },
            clearVisibility: function() {
                var that = this;
                var graphic = that.graphic;
                if (graphic && graphic.attr("visibility")) {
                    graphic.attr({
                        visibility: null
                    })
                }
            },
            isVisible: function() {
                return this.inVisibleArea && this.series.isVisible()
            },
            setInvisibility: function() {
                var that = this;
                var graphic = that.graphic;
                if (graphic && "hidden" !== graphic.attr("visibility")) {
                    graphic.attr({
                        visibility: "hidden"
                    })
                }
                that._errorBar && that._errorBar.attr({
                    visibility: "hidden"
                });
                that._label.draw(false)
            },
            clearMarker: function() {
                var graphic = this.graphic;
                graphic && graphic.attr(this._emptySettings)
            },
            _createLabel: function() {
                this._label = new labelModule.Label({
                    renderer: this.series._renderer,
                    labelsGroup: this.series._labelsGroup,
                    point: this
                })
            },
            _updateLabelData: function() {
                this._label.setData(this._getLabelFormatObject())
            },
            _updateLabelOptions: function() {
                !this._label && this._createLabel();
                this._label.setOptions(this._options.label)
            },
            _checkImage: function(image) {
                return _isDefined(image) && ("string" === typeof image || _isDefined(image.url))
            },
            _fillStyle: function() {
                this._styles = this._options.styles
            },
            _checkSymbol: function(oldOptions, newOptions) {
                var oldSymbol = oldOptions.symbol;
                var newSymbol = newOptions.symbol;
                var symbolChanged = "circle" === oldSymbol && "circle" !== newSymbol || "circle" !== oldSymbol && "circle" === newSymbol;
                var imageChanged = this._checkImage(oldOptions.image) !== this._checkImage(newOptions.image);
                return !!(symbolChanged || imageChanged)
            },
            _populatePointShape: function(symbol, radius) {
                switch (symbol) {
                    case "square":
                        return getSquareMarkerCoords(radius);
                    case "polygon":
                        return getPolygonMarkerCoords(radius);
                    case "triangle":
                    case "triangleDown":
                        return getTriangleDownMarkerCoords(radius);
                    case "triangleUp":
                        return getTriangleUpMarkerCoords(radius);
                    case "cross":
                        return getCrossMarkerCoords(radius)
                }
            },
            hasCoords: function() {
                return null !== this.x && null !== this.y
            },
            correctValue: function(correction) {
                var that = this;
                var axis = that.series.getValueAxis();
                if (that.hasValue()) {
                    that.value = that.properValue = axis.validateUnit(that.initialValue.valueOf() + correction.valueOf());
                    that.minValue = axis.validateUnit(correction)
                }
            },
            resetCorrection: function() {
                this.value = this.properValue = this.initialValue;
                this.minValue = CANVAS_POSITION_DEFAULT
            },
            resetValue: function() {
                var that = this;
                if (that.hasValue()) {
                    that.value = that.properValue = that.initialValue = 0;
                    that.minValue = 0;
                    that._label.setDataField("value", that.value)
                }
            },
            _getTranslates: function(animationEnabled) {
                var translateX = this.x;
                var translateY = this.y;
                if (animationEnabled) {
                    if (this._options.rotated) {
                        translateX = this.defaultX
                    } else {
                        translateY = this.defaultY
                    }
                }
                return {
                    x: translateX,
                    y: translateY
                }
            },
            _createImageMarker: function(renderer, settings, options) {
                var width = options.width || DEFAULT_IMAGE_WIDTH;
                var height = options.height || DEFAULT_IMAGE_HEIGHT;
                return renderer.image(-_round(.5 * width), -_round(.5 * height), width, height, options.url ? options.url.toString() : options.toString(), "center").attr({
                    translateX: settings.translateX,
                    translateY: settings.translateY,
                    visibility: settings.visibility
                })
            },
            _createSymbolMarker: function(renderer, pointSettings) {
                var marker;
                var symbol = this._options.symbol;
                if ("circle" === symbol) {
                    delete pointSettings.points;
                    marker = renderer.circle().attr(pointSettings)
                } else {
                    if ("square" === symbol || "polygon" === symbol || "triangle" === symbol || "triangleDown" === symbol || "triangleUp" === symbol || "cross" === symbol) {
                        marker = renderer.path([], "area").attr(pointSettings).sharp()
                    }
                }
                return marker
            },
            _createMarker: function(renderer, group, image, settings) {
                var that = this;
                var marker = that._checkImage(image) ? that._createImageMarker(renderer, settings, image) : that._createSymbolMarker(renderer, settings);
                if (marker) {
                    marker.data({
                        "chart-data-point": that
                    }).append(group)
                }
                return marker
            },
            _getSymbolBBox: function(x, y, r) {
                return {
                    x: x - r,
                    y: y - r,
                    width: 2 * r,
                    height: 2 * r
                }
            },
            _getImageBBox: function(x, y) {
                var image = this._options.image;
                var width = image.width || DEFAULT_IMAGE_WIDTH;
                var height = image.height || DEFAULT_IMAGE_HEIGHT;
                return {
                    x: x - _round(width / 2),
                    y: y - _round(height / 2),
                    width: width,
                    height: height
                }
            },
            _getGraphicBBox: function() {
                var that = this;
                var options = that._options;
                var x = that.x;
                var y = that.y;
                var bBox;
                if (options.visible) {
                    bBox = that._checkImage(options.image) ? that._getImageBBox(x, y) : that._getSymbolBBox(x, y, options.styles.normal.r)
                } else {
                    bBox = {
                        x: x,
                        y: y,
                        width: 0,
                        height: 0
                    }
                }
                return bBox
            },
            hideInsideLabel: noop,
            _getShiftLabelCoords: function(label) {
                var coord = this._addLabelAlignmentAndOffset(label, this._getLabelCoords(label));
                return this._checkLabelPosition(label, coord)
            },
            _drawLabel: function() {
                var that = this;
                var customVisibility = that._getCustomLabelVisibility();
                var label = that._label;
                var isVisible = that._showForZeroValues() && that.hasValue() && false !== customVisibility && (that.series.getLabelVisibility() || customVisibility);
                label.draw(!!isVisible)
            },
            correctLabelPosition: function(label) {
                var that = this;
                var coord = that._getShiftLabelCoords(label);
                if (!that.hideInsideLabel(label, coord)) {
                    label.setFigureToDrawConnector(that._getLabelConnector(label.pointPosition));
                    label.shift(_round(coord.x), _round(coord.y))
                }
            },
            _showForZeroValues: function() {
                return true
            },
            _getLabelConnector: function(pointPosition) {
                var bBox = this._getGraphicBBox(pointPosition);
                var w2 = bBox.width / 2;
                var h2 = bBox.height / 2;
                return {
                    x: bBox.x + w2,
                    y: bBox.y + h2,
                    r: this._options.visible ? Math.max(w2, h2) : 0
                }
            },
            _getPositionFromLocation: function() {
                return {
                    x: this.x,
                    y: this.y
                }
            },
            _isPointInVisibleArea: function(visibleArea, graphicBBox) {
                return visibleArea.minX <= graphicBBox.x + graphicBBox.width && visibleArea.maxX >= graphicBBox.x && visibleArea.minY <= graphicBBox.y + graphicBBox.height && visibleArea.maxY >= graphicBBox.y
            },
            _checkLabelPosition: function(label, coord) {
                var that = this;
                var visibleArea = that._getVisibleArea();
                var labelBBox = label.getBoundingRect();
                var graphicBBox = that._getGraphicBBox(label.pointPosition);
                var fullGraphicBBox = that._getGraphicBBox();
                var isInside = "inside" === label.getLayoutOptions().position;
                var offset = LABEL_OFFSET;
                if (that._isPointInVisibleArea(visibleArea, fullGraphicBBox)) {
                    if (!that._options.rotated) {
                        if (visibleArea.minX > coord.x) {
                            coord.x = visibleArea.minX
                        }
                        if (visibleArea.maxX < coord.x + labelBBox.width) {
                            coord.x = visibleArea.maxX - labelBBox.width
                        }
                        if (visibleArea.minY > coord.y) {
                            coord.y = isInside ? visibleArea.minY : graphicBBox.y + graphicBBox.height + offset
                        }
                        if (visibleArea.maxY < coord.y + labelBBox.height) {
                            coord.y = isInside ? visibleArea.maxY - labelBBox.height : graphicBBox.y - labelBBox.height - offset
                        }
                    } else {
                        if (visibleArea.minX > coord.x) {
                            coord.x = isInside ? visibleArea.minX : graphicBBox.x + graphicBBox.width + offset
                        }
                        if (visibleArea.maxX < coord.x + labelBBox.width) {
                            coord.x = isInside ? visibleArea.maxX - labelBBox.width : graphicBBox.x - offset - labelBBox.width
                        }
                        if (visibleArea.minY > coord.y) {
                            coord.y = visibleArea.minY
                        }
                        if (visibleArea.maxY < coord.y + labelBBox.height) {
                            coord.y = visibleArea.maxY - labelBBox.height
                        }
                    }
                }
                return coord
            },
            _addLabelAlignmentAndOffset: function(label, coord) {
                var labelBBox = label.getBoundingRect();
                var labelOptions = label.getLayoutOptions();
                if (!this._options.rotated) {
                    if ("left" === labelOptions.alignment) {
                        coord.x += labelBBox.width / 2
                    } else {
                        if ("right" === labelOptions.alignment) {
                            coord.x -= labelBBox.width / 2
                        }
                    }
                }
                coord.x += labelOptions.horizontalOffset;
                coord.y += labelOptions.verticalOffset;
                return coord
            },
            _getLabelCoords: function(label) {
                return this._getLabelCoordOfPosition(label, this._getLabelPosition(label.pointPosition))
            },
            _getLabelCoordOfPosition: function(label, position) {
                var that = this;
                var labelBBox = label.getBoundingRect();
                var graphicBBox = that._getGraphicBBox(label.pointPosition);
                var offset = LABEL_OFFSET;
                var centerY = graphicBBox.height / 2 - labelBBox.height / 2;
                var centerX = graphicBBox.width / 2 - labelBBox.width / 2;
                var x = graphicBBox.x;
                var y = graphicBBox.y;
                switch (position) {
                    case "left":
                        x -= labelBBox.width + offset;
                        y += centerY;
                        break;
                    case "right":
                        x += graphicBBox.width + offset;
                        y += centerY;
                        break;
                    case "top":
                        x += centerX;
                        y -= labelBBox.height + offset;
                        break;
                    case "bottom":
                        x += centerX;
                        y += graphicBBox.height + offset;
                        break;
                    case "inside":
                        x += centerX;
                        y += centerY
                }
                return {
                    x: x,
                    y: y
                }
            },
            _drawMarker: function(renderer, group, animationEnabled) {
                var that = this;
                var options = that._options;
                var translates = that._getTranslates(animationEnabled);
                var style = that._getStyle();
                that.graphic = that._createMarker(renderer, group, options.image, _extend({
                    translateX: translates.x,
                    translateY: translates.y,
                    points: that._populatePointShape(options.symbol, style.r)
                }, style))
            },
            _getErrorBarSettings: function() {
                return {
                    visibility: "visible"
                }
            },
            _getErrorBarBaseEdgeLength: function() {
                return 2 * this.getPointRadius()
            },
            _drawErrorBar: function(renderer, group) {
                if (!this._options.errorBars) {
                    return
                }
                var that = this;
                var options = that._options;
                var errorBarOptions = options.errorBars;
                var points = [];
                var settings;
                var pos = that._errorBarPos;
                var high = that._highErrorCoord;
                var low = that._lowErrorCoord;
                var displayMode = _normalizeEnum(errorBarOptions.displayMode);
                var isHighDisplayMode = "high" === displayMode;
                var isLowDisplayMode = "low" === displayMode;
                var highErrorOnly = (isHighDisplayMode || !_isDefined(low)) && _isDefined(high) && !isLowDisplayMode;
                var lowErrorOnly = (isLowDisplayMode || !_isDefined(high)) && _isDefined(low) && !isHighDisplayMode;
                var edgeLength = errorBarOptions.edgeLength;
                if (edgeLength <= 1 && edgeLength > 0) {
                    edgeLength = this._getErrorBarBaseEdgeLength() * errorBarOptions.edgeLength
                }
                edgeLength = _floor(parseInt(edgeLength) / 2);
                highErrorOnly && (low = that._baseErrorBarPos);
                lowErrorOnly && (high = that._baseErrorBarPos);
                if ("none" !== displayMode && _isDefined(high) && _isDefined(low) && _isDefined(pos)) {
                    !lowErrorOnly && points.push([pos - edgeLength, high, pos + edgeLength, high]);
                    points.push([pos, high, pos, low]);
                    !highErrorOnly && points.push([pos + edgeLength, low, pos - edgeLength, low]);
                    options.rotated && each(points, function(_, p) {
                        p.reverse()
                    });
                    settings = that._getErrorBarSettings(errorBarOptions);
                    if (!that._errorBar) {
                        that._errorBar = renderer.path(points, "line").attr(settings).append(group)
                    } else {
                        settings.points = points;
                        that._errorBar.attr(settings)
                    }
                } else {
                    that._errorBar && that._errorBar.attr({
                        visibility: "hidden"
                    })
                }
            },
            getTooltipParams: function() {
                var that = this;
                var graphic = that.graphic;
                return {
                    x: that.x,
                    y: that.y,
                    offset: graphic ? graphic.getBBox().height / 2 : 0
                }
            },
            setPercentValue: function(absTotal, total, leftHoleTotal, rightHoleTotal) {
                var that = this;
                var valuePercent = that.value / absTotal || 0;
                var minValuePercent = that.minValue / absTotal || 0;
                var percent = valuePercent - minValuePercent;
                that._label.setDataField("percent", percent);
                that._label.setDataField("total", total);
                if (that.series.isFullStackedSeries() && that.hasValue()) {
                    if (that.leftHole) {
                        that.leftHole /= absTotal - leftHoleTotal;
                        that.minLeftHole /= absTotal - leftHoleTotal
                    }
                    if (that.rightHole) {
                        that.rightHole /= absTotal - rightHoleTotal;
                        that.minRightHole /= absTotal - rightHoleTotal
                    }
                    that.value = that.properValue = valuePercent;
                    that.minValue = !minValuePercent ? that.minValue : minValuePercent
                }
            },
            _storeTrackerR: function() {
                var that = this;
                var navigator = window.navigator;
                var r = that._options.styles.normal.r;
                navigator = that.__debug_navigator || navigator;
                that.__debug_browserNavigator = navigator;
                var minTrackerSize = windowUtils.hasProperty("ontouchstart") || navigator.msPointerEnabled && navigator.msMaxTouchPoints || navigator.pointerEnabled && navigator.maxTouchPoints ? 20 : 6;
                that._options.trackerR = r < minTrackerSize ? minTrackerSize : r;
                return that._options.trackerR
            },
            _translateErrorBars: function() {
                var that = this;
                var options = that._options;
                var rotated = options.rotated;
                var errorBars = options.errorBars;
                var translator = that._getValTranslator();
                if (!errorBars) {
                    return
                }
                _isDefined(that.lowError) && (that._lowErrorCoord = translator.translate(that.lowError));
                _isDefined(that.highError) && (that._highErrorCoord = translator.translate(that.highError));
                that._errorBarPos = _floor(rotated ? that.vy : that.vx);
                that._baseErrorBarPos = "stdDeviation" === errorBars.type ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : rotated ? that.vx : that.vy
            },
            _translate: function() {
                var that = this;
                var valTranslator = that._getValTranslator();
                var argTranslator = that._getArgTranslator();
                if (that._options.rotated) {
                    that.vx = that.x = valTranslator.translate(that.value);
                    that.vy = that.y = argTranslator.translate(that.argument);
                    that.minX = valTranslator.translate(that.minValue);
                    that.defaultX = valTranslator.translate(CANVAS_POSITION_DEFAULT)
                } else {
                    that.vy = that.y = valTranslator.translate(that.value);
                    that.vx = that.x = argTranslator.translate(that.argument);
                    that.minY = valTranslator.translate(that.minValue);
                    that.defaultY = valTranslator.translate(CANVAS_POSITION_DEFAULT)
                }
                that._translateErrorBars();
                that._calculateVisibility(that.x, that.y)
            },
            _updateData: function(data) {
                var that = this;
                that.value = that.properValue = that.initialValue = that.originalValue = data.value;
                that.minValue = that.initialMinValue = that.originalMinValue = _isDefined(data.minValue) ? data.minValue : CANVAS_POSITION_DEFAULT
            },
            _getImageSettings: function(image) {
                return {
                    href: image.url || image.toString(),
                    width: image.width || DEFAULT_IMAGE_WIDTH,
                    height: image.height || DEFAULT_IMAGE_HEIGHT
                }
            },
            getCrosshairData: function() {
                var that = this;
                var r = that._options.rotated;
                var value = that.properValue;
                var argument = that.argument;
                return {
                    x: that.vx,
                    y: that.vy,
                    xValue: r ? value : argument,
                    yValue: r ? argument : value,
                    axis: that.series.axis
                }
            },
            getPointRadius: function() {
                var style = this._getStyle();
                var options = this._options;
                var r = style.r;
                var extraSpace;
                var symbol = options.symbol;
                var isSquare = "square" === symbol;
                var isTriangle = "triangle" === symbol || "triangleDown" === symbol || "triangleUp" === symbol;
                if (options.visible && !options.image && r) {
                    extraSpace = style["stroke-width"] / 2;
                    return (isSquare || isTriangle ? 1.4 * r : r) + extraSpace
                }
                return 0
            },
            _updateMarker: function(animationEnabled, style) {
                var that = this;
                var options = that._options;
                var settings;
                var image = options.image;
                var visibility = !that.isVisible() ? {
                    visibility: "hidden"
                } : {};
                if (that._checkImage(image)) {
                    settings = _extend({}, {
                        visibility: style.visibility
                    }, visibility, that._getImageSettings(image))
                } else {
                    settings = _extend({}, style, visibility, {
                        points: that._populatePointShape(options.symbol, style.r)
                    })
                }
                if (!animationEnabled) {
                    settings.translateX = that.x;
                    settings.translateY = that.y
                }
                that.graphic.attr(settings).sharp()
            },
            _getLabelFormatObject: function() {
                var that = this;
                return {
                    argument: that.initialArgument,
                    value: that.initialValue,
                    originalArgument: that.originalArgument,
                    originalValue: that.originalValue,
                    seriesName: that.series.name,
                    lowErrorValue: that.lowError,
                    highErrorValue: that.highError,
                    point: that
                }
            },
            _getLabelPosition: function() {
                var rotated = this._options.rotated;
                if (this.initialValue > 0) {
                    return rotated ? "right" : "top"
                } else {
                    return rotated ? "left" : "bottom"
                }
            },
            _getFormatObject: function(tooltip) {
                var that = this;
                var labelFormatObject = that._label.getData();
                return _extend({}, labelFormatObject, {
                    argumentText: tooltip.formatValue(that.initialArgument, "argument"),
                    valueText: tooltip.formatValue(that.initialValue)
                }, _isDefined(labelFormatObject.percent) ? {
                    percentText: tooltip.formatValue(labelFormatObject.percent, "percent")
                } : {}, _isDefined(labelFormatObject.total) ? {
                    totalText: tooltip.formatValue(labelFormatObject.total)
                } : {})
            },
            getMarkerVisibility: function() {
                return this._options.visible
            },
            coordsIn: function(x, y) {
                var trackerRadius = this._storeTrackerR();
                return x >= this.x - trackerRadius && x <= this.x + trackerRadius && y >= this.y - trackerRadius && y <= this.y + trackerRadius
            },
            getMinValue: function(noErrorBar) {
                var errorBarOptions = this._options.errorBars;
                if (errorBarOptions && !noErrorBar) {
                    var displayMode = errorBarOptions.displayMode;
                    var lowValue = "high" !== displayMode && _isDefined(this.lowError) ? this.lowError : this.value;
                    var highValue = "low" !== displayMode && _isDefined(this.highError) ? this.highError : this.value;
                    return lowValue < highValue ? lowValue : highValue
                } else {
                    return this.value
                }
            },
            getMaxValue: function(noErrorBar) {
                var errorBarOptions = this._options.errorBars;
                if (errorBarOptions && !noErrorBar) {
                    var displayMode = errorBarOptions.displayMode;
                    var lowValue = "high" !== displayMode && _isDefined(this.lowError) ? this.lowError : this.value;
                    var highValue = "low" !== displayMode && _isDefined(this.highError) ? this.highError : this.value;
                    return lowValue > highValue ? lowValue : highValue
                } else {
                    return this.value
                }
            }
        }
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/loading_indicator.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _patchFontOptions = __webpack_require__( /*! ./utils */ 13).patchFontOptions;
        var STATE_HIDDEN = 0;
        var STATE_SHOWN = 1;
        var ANIMATION_EASING = "linear";
        var ANIMATION_DURATION = 400;
        var LOADING_INDICATOR_READY = "loadingIndicatorReady";

        function LoadingIndicator(parameters) {
            var that = this;
            var renderer = parameters.renderer;
            that._group = renderer.g().attr({
                "class": "dx-loading-indicator"
            }).linkOn(renderer.root, {
                name: "loading-indicator",
                after: "peripheral"
            });
            that._rect = renderer.rect().attr({
                opacity: 0
            }).append(that._group);
            that._text = renderer.text().attr({
                align: "center"
            }).append(that._group);
            that._createStates(parameters.eventTrigger, that._group, renderer.root, parameters.notify)
        }
        LoadingIndicator.prototype = {
            constructor: LoadingIndicator,
            _createStates: function(eventTrigger, group, root, notify) {
                var that = this;
                that._states = [{
                    opacity: 0,
                    start: function() {
                        notify(false)
                    },
                    complete: function() {
                        group.linkRemove();
                        root.css({
                            "pointer-events": ""
                        });
                        eventTrigger(LOADING_INDICATOR_READY)
                    }
                }, {
                    opacity: .85,
                    start: function() {
                        group.linkAppend();
                        root.css({
                            "pointer-events": "none"
                        });
                        notify(true)
                    },
                    complete: function() {
                        eventTrigger(LOADING_INDICATOR_READY)
                    }
                }];
                that._state = STATE_HIDDEN
            },
            setSize: function(size) {
                var width = size.width;
                var height = size.height;
                this._rect.attr({
                    width: width,
                    height: height
                });
                this._text.attr({
                    x: width / 2,
                    y: height / 2
                })
            },
            setOptions: function(options) {
                this._rect.attr({
                    fill: options.backgroundColor
                });
                this._text.css(_patchFontOptions(options.font)).attr({
                    text: options.text,
                    "class": options.cssClass
                });
                this[options.show ? "show" : "hide"]()
            },
            dispose: function() {
                var that = this;
                that._group.linkRemove().linkOff();
                that._group = that._rect = that._text = that._states = null
            },
            _transit: function(stateId) {
                var that = this;
                var state;
                if (that._state !== stateId) {
                    that._state = stateId;
                    that._isHiding = false;
                    state = that._states[stateId];
                    that._rect.stopAnimation().animate({
                        opacity: state.opacity
                    }, {
                        complete: state.complete,
                        easing: ANIMATION_EASING,
                        duration: ANIMATION_DURATION,
                        unstoppable: true
                    });
                    that._noHiding = true;
                    state.start();
                    that._noHiding = false
                }
            },
            show: function() {
                this._transit(STATE_SHOWN)
            },
            hide: function() {
                this._transit(STATE_HIDDEN)
            },
            scheduleHiding: function() {
                if (!this._noHiding) {
                    this._isHiding = true
                }
            },
            fulfillHiding: function() {
                if (this._isHiding) {
                    this.hide()
                }
            }
        };
        exports.LoadingIndicator = LoadingIndicator;
        exports.plugin = {
            name: "loading_indicator",
            init: function() {
                var that = this;
                that._loadingIndicator = new exports.LoadingIndicator({
                    eventTrigger: that._eventTrigger,
                    renderer: that._renderer,
                    notify: notify
                });
                that._scheduleLoadingIndicatorHiding();

                function notify(state) {
                    that._skipLoadingIndicatorOptions = true;
                    that.option("loadingIndicator", {
                        show: state
                    });
                    that._skipLoadingIndicatorOptions = false;
                    if (state) {
                        that._stopCurrentHandling()
                    }
                }
            },
            dispose: function() {
                this._loadingIndicator.dispose();
                this._loadingIndicator = null
            },
            members: {
                _scheduleLoadingIndicatorHiding: function() {
                    this._loadingIndicator.scheduleHiding()
                },
                _fulfillLoadingIndicatorHiding: function() {
                    this._loadingIndicator.fulfillHiding()
                },
                showLoadingIndicator: function() {
                    this._loadingIndicator.show()
                },
                hideLoadingIndicator: function() {
                    this._loadingIndicator.hide()
                },
                _onBeginUpdate: function() {
                    if (!this._optionChangedLocker) {
                        this._scheduleLoadingIndicatorHiding()
                    }
                }
            },
            extenders: {
                _dataSourceLoadingChangedHandler: function(isLoading) {
                    if (isLoading && (this._options.silent("loadingIndicator") || {}).enabled) {
                        this._loadingIndicator.show()
                    }
                },
                _setContentSize: function() {
                    this._loadingIndicator.setSize(this._canvas)
                },
                endUpdate: function() {
                    if (this._initialized && this._dataIsReady()) {
                        this._fulfillLoadingIndicatorHiding()
                    }
                }
            },
            customize: function(constructor) {
                var proto = constructor.prototype;
                if (proto._dataSourceChangedHandler) {
                    var _dataSourceChangedHandler = proto._dataSourceChangedHandler;
                    proto._dataSourceChangedHandler = function() {
                        this._scheduleLoadingIndicatorHiding();
                        _dataSourceChangedHandler.apply(this, arguments)
                    }
                }
                constructor.addChange({
                    code: "LOADING_INDICATOR",
                    handler: function() {
                        if (!this._skipLoadingIndicatorOptions) {
                            this._loadingIndicator.setOptions(this._getOption("loadingIndicator"))
                        }
                        this._scheduleLoadingIndicatorHiding()
                    },
                    isThemeDependent: true,
                    option: "loadingIndicator",
                    isOptionChange: true
                });
                proto._eventsMap.onLoadingIndicatorReady = {
                    name: "loadingIndicatorReady"
                };
                var _drawn = proto._drawn;
                proto._drawn = function() {
                    _drawn.apply(this, arguments);
                    if (this._dataIsReady()) {
                        this._fulfillLoadingIndicatorHiding()
                    }
                }
            },
            fontFields: ["loadingIndicator.font"]
        }
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tiling.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _isFunction = __webpack_require__( /*! ../../core/utils/type */ 1).isFunction;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var _round = Math.round;
        var algorithms = {};
        var defaultAlgorithm;
        exports.getAlgorithm = function(value) {
            return algorithms[_normalizeEnum(value)] || _isFunction(value) && value || defaultAlgorithm
        };
        exports.addAlgorithm = function(name, callback) {
            algorithms[name] = callback
        };
        exports.setDefaultAlgorithm = function(name) {
            defaultAlgorithm = algorithms[name]
        };
        var directionToIndexOffsets = {};
        directionToIndexOffsets[-1] = [2, 0];
        directionToIndexOffsets[1] = [0, 2];
        var getStaticSideIndex = function(rect) {
            return rect[2] - rect[0] < rect[3] - rect[1] ? 0 : 1
        };
        exports.getStaticSideIndex = getStaticSideIndex;
        exports.buildSidesData = function(rect, directions, _staticSideIndex) {
            var staticSideIndex = void 0 !== _staticSideIndex ? _staticSideIndex : getStaticSideIndex(rect);
            var variedSideIndex = 1 - staticSideIndex;
            var staticSideDirection = directions[staticSideIndex];
            var variedSideDirection = directions[variedSideIndex];
            var staticSideIndexOffsets = directionToIndexOffsets[staticSideDirection];
            var variedSideIndexOffsets = directionToIndexOffsets[variedSideDirection];
            return {
                staticSide: rect[2 + staticSideIndex] - rect[staticSideIndex],
                variedSide: rect[2 + variedSideIndex] - rect[variedSideIndex],
                static1: staticSideIndex + staticSideIndexOffsets[0],
                static2: staticSideIndex + staticSideIndexOffsets[1],
                varied1: variedSideIndex + variedSideIndexOffsets[0],
                varied2: variedSideIndex + variedSideIndexOffsets[1],
                staticDir: staticSideDirection,
                variedDir: variedSideDirection
            }
        };
        exports.calculateRectangles = function(nodes, head, totalRect, sidesData, rowData) {
            var i;
            var ii;
            var variedSidePart = [0, 0, 0, 0];
            var static1 = sidesData.static1;
            var static2 = sidesData.static2;
            var position = totalRect[static1];
            var dir = sidesData.staticDir;
            var side = sidesData.staticSide;
            var sum = rowData.sum;
            var rect;
            var delta;
            variedSidePart[sidesData.varied1] = totalRect[sidesData.varied1];
            variedSidePart[sidesData.varied2] = totalRect[sidesData.varied1] + sidesData.variedDir * rowData.side;
            for (i = head, ii = head + rowData.count; i < ii; ++i) {
                rect = variedSidePart.slice();
                rect[static1] = position;
                delta = _round(side * nodes[i].value / sum) || 0;
                sum -= nodes[i].value;
                side -= delta;
                position += dir * delta;
                rect[static2] = position;
                nodes[i].rect = rect
            }
            totalRect[sidesData.varied1] = variedSidePart[sidesData.varied2]
        }
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/colorizing.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var _noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var colorizers = {};
        var defaultColorizerName;

        function wrapLeafColorGetter(getter) {
            return function(node) {
                return !node.isNode() ? getter(node) : void 0
            }
        }

        function wrapGroupColorGetter(getter) {
            return function(node) {
                var parent = !node.isNode() && node.parent;
                return parent ? parent._groupColor = parent._groupColor || getter(parent) : void 0
            }
        }
        exports.getColorizer = function(options, themeManager, root) {
            var type = _normalizeEnum(options.type || defaultColorizerName);
            var colorizer = colorizers[type] && colorizers[type](options, themeManager, root);
            return colorizer ? (options.colorizeGroups ? wrapGroupColorGetter : wrapLeafColorGetter)(colorizer) : _noop
        };
        exports.addColorizer = function(name, colorizer) {
            colorizers[name] = colorizer
        };
        exports.setDefaultColorizer = function(name) {
            defaultColorizerName = name
        };

        function getValueAsColorCode(node) {
            return node.value
        }

        function createColorCodeGetter(colorCodeField) {
            return function(node) {
                return Number(node.data[colorCodeField])
            }
        }
        exports.createColorCodeGetter = function(options) {
            return options.colorCodeField ? createColorCodeGetter(options.colorCodeField) : getValueAsColorCode
        }
    },
    /*!*************************************************************************!*\
      !*** ./artifacts/transpiled/events/core/event_registrator_callbacks.js ***!
      \*************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _memorized_callbacks = __webpack_require__( /*! ../../core/memorized_callbacks */ 185);
        var _memorized_callbacks2 = _interopRequireDefault(_memorized_callbacks);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        exports.default = new _memorized_callbacks2.default
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/localization/currency.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        module.exports = {
            _formatNumberCore: function(value, format, formatConfig) {
                if ("currency" === format) {
                    formatConfig.precision = formatConfig.precision || 0;
                    var result = this.format(value, (0, _extend.extend)({}, formatConfig, {
                        type: "fixedpoint"
                    }));
                    var currencyPart = this.getCurrencySymbol().symbol.replace("$", "$$$$");
                    result = result.replace(/^(\D*)(\d.*)/, "$1" + currencyPart + "$2");
                    return result
                }
                return this.callBase.apply(this, arguments)
            },
            getCurrencySymbol: function() {
                return {
                    symbol: "$"
                }
            },
            getOpenXmlCurrencyFormat: function() {
                return "$#,##0{0}_);\\($#,##0{0}\\)"
            }
        }
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/events/core/emitter.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var Callbacks = __webpack_require__( /*! ../../core/utils/callbacks */ 27);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var eventUtils = __webpack_require__( /*! ../utils */ 8);
        var Emitter = Class.inherit({
            ctor: function(element) {
                this._$element = $(element);
                this._cancelCallback = Callbacks();
                this._acceptCallback = Callbacks()
            },
            getElement: function() {
                return this._$element
            },
            validate: function(e) {
                return !eventUtils.isDxMouseWheelEvent(e)
            },
            validatePointers: function(e) {
                return 1 === eventUtils.hasTouches(e)
            },
            allowInterruptionByMouseWheel: function() {
                return true
            },
            configure: function(data) {
                extend(this, data)
            },
            addCancelCallback: function(callback) {
                this._cancelCallback.add(callback)
            },
            removeCancelCallback: function() {
                this._cancelCallback.empty()
            },
            _cancel: function(e) {
                this._cancelCallback.fire(this, e)
            },
            addAcceptCallback: function(callback) {
                this._acceptCallback.add(callback)
            },
            removeAcceptCallback: function() {
                this._acceptCallback.empty()
            },
            _accept: function(e) {
                this._acceptCallback.fire(this, e)
            },
            _requestAccept: function(e) {
                this._acceptRequestEvent = e
            },
            _forgetAccept: function() {
                this._accept(this._acceptRequestEvent);
                this._acceptRequestEvent = null
            },
            start: noop,
            move: noop,
            end: noop,
            cancel: noop,
            reset: function() {
                if (this._acceptRequestEvent) {
                    this._accept(this._acceptRequestEvent)
                }
            },
            _fireEvent: function(eventName, e, params) {
                var eventData = extend({
                    type: eventName,
                    originalEvent: e,
                    target: this._getEmitterTarget(e),
                    delegateTarget: this.getElement().get(0)
                }, params);
                e = eventUtils.fireEvent(eventData);
                if (e.cancel) {
                    this._cancel(e)
                }
                return e
            },
            _getEmitterTarget: function(e) {
                return (this.delegateSelector ? $(e.target).closest(this.delegateSelector) : this.getElement()).get(0)
            },
            dispose: noop
        });
        module.exports = Emitter
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/events/core/wheel.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _event_registrator = __webpack_require__( /*! ./event_registrator */ 77);
        var _event_registrator2 = _interopRequireDefault(_event_registrator);
        var _utils = __webpack_require__( /*! ../utils */ 8);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var EVENT_NAME = "dxmousewheel";
        var EVENT_NAMESPACE = "dxWheel";
        var NATIVE_EVENT_NAME = "wheel";
        var PIXEL_MODE = 0;
        var DELTA_MUTLIPLIER = 30;
        var wheel = {
            setup: function(element) {
                var $element = (0, _renderer2.default)(element);
                _events_engine2.default.on($element, (0, _utils.addNamespace)(NATIVE_EVENT_NAME, EVENT_NAMESPACE), wheel._wheelHandler.bind(wheel))
            },
            teardown: function(element) {
                _events_engine2.default.off(element, ".".concat(EVENT_NAMESPACE))
            },
            _wheelHandler: function(e) {
                var _e$originalEvent = e.originalEvent,
                    deltaMode = _e$originalEvent.deltaMode,
                    deltaY = _e$originalEvent.deltaY,
                    deltaX = _e$originalEvent.deltaX,
                    deltaZ = _e$originalEvent.deltaZ;
                (0, _utils.fireEvent)({
                    type: EVENT_NAME,
                    originalEvent: e,
                    delta: this._normalizeDelta(deltaY, deltaMode),
                    deltaX: deltaX,
                    deltaY: deltaY,
                    deltaZ: deltaZ,
                    deltaMode: deltaMode,
                    pointerType: "mouse"
                });
                e.stopPropagation()
            },
            _normalizeDelta: function(delta) {
                var deltaMode = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : PIXEL_MODE;
                if (deltaMode === PIXEL_MODE) {
                    return -delta
                } else {
                    return -DELTA_MUTLIPLIER * delta
                }
            }
        };
        (0, _event_registrator2.default)(EVENT_NAME, wheel);
        exports.name = EVENT_NAME
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/events/core/emitter.feedback.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var commonUtils = __webpack_require__( /*! ../../core/utils/common */ 3);
        var contains = __webpack_require__( /*! ../../core/utils/dom */ 11).contains;
        var devices = __webpack_require__( /*! ../../core/devices */ 15);
        var eventUtils = __webpack_require__( /*! ../utils */ 8);
        var pointerEvents = __webpack_require__( /*! ../pointer */ 23);
        var Emitter = __webpack_require__( /*! ./emitter */ 132);
        var registerEmitter = __webpack_require__( /*! ./emitter_registrator */ 101);
        var ACTIVE_EVENT_NAME = "dxactive";
        var INACTIVE_EVENT_NAME = "dxinactive";
        var ACTIVE_TIMEOUT = 30;
        var INACTIVE_TIMEOUT = 400;
        var FeedbackEvent = Class.inherit({
            ctor: function(timeout, fire) {
                this._timeout = timeout;
                this._fire = fire
            },
            start: function() {
                var that = this;
                this._schedule(function() {
                    that.force()
                })
            },
            _schedule: function(fn) {
                this.stop();
                this._timer = setTimeout(fn, this._timeout)
            },
            stop: function() {
                clearTimeout(this._timer)
            },
            force: function() {
                if (this._fired) {
                    return
                }
                this.stop();
                this._fire();
                this._fired = true
            },
            fired: function() {
                return this._fired
            }
        });
        var activeFeedback;
        var FeedbackEmitter = Emitter.inherit({
            ctor: function() {
                this.callBase.apply(this, arguments);
                this._active = new FeedbackEvent(0, commonUtils.noop);
                this._inactive = new FeedbackEvent(0, commonUtils.noop)
            },
            configure: function(data, eventName) {
                switch (eventName) {
                    case ACTIVE_EVENT_NAME:
                        data.activeTimeout = data.timeout;
                        break;
                    case INACTIVE_EVENT_NAME:
                        data.inactiveTimeout = data.timeout
                }
                this.callBase(data)
            },
            start: function(e) {
                if (activeFeedback) {
                    var activeChildExists = contains(this.getElement().get(0), activeFeedback.getElement().get(0));
                    var childJustActivated = !activeFeedback._active.fired();
                    if (activeChildExists && childJustActivated) {
                        this._cancel();
                        return
                    }
                    activeFeedback._inactive.force()
                }
                activeFeedback = this;
                this._initEvents(e);
                this._active.start()
            },
            _initEvents: function(e) {
                var that = this;
                var eventTarget = this._getEmitterTarget(e);
                var mouseEvent = eventUtils.isMouseEvent(e);
                var isSimulator = devices.isSimulator();
                var deferFeedback = isSimulator || !mouseEvent;
                var activeTimeout = commonUtils.ensureDefined(this.activeTimeout, ACTIVE_TIMEOUT);
                var inactiveTimeout = commonUtils.ensureDefined(this.inactiveTimeout, INACTIVE_TIMEOUT);
                this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
                    that._fireEvent(ACTIVE_EVENT_NAME, e, {
                        target: eventTarget
                    })
                });
                this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
                    that._fireEvent(INACTIVE_EVENT_NAME, e, {
                        target: eventTarget
                    });
                    activeFeedback = null
                })
            },
            cancel: function(e) {
                this.end(e)
            },
            end: function(e) {
                var skipTimers = e.type !== pointerEvents.up;
                if (skipTimers) {
                    this._active.stop()
                } else {
                    this._active.force()
                }
                this._inactive.start();
                if (skipTimers) {
                    this._inactive.force()
                }
            },
            dispose: function() {
                this._active.stop();
                this._inactive.stop();
                this.callBase()
            },
            lockInactive: function() {
                this._active.force();
                this._inactive.stop();
                activeFeedback = null;
                this._cancel();
                return this._inactive.force.bind(this._inactive)
            }
        });
        FeedbackEmitter.lock = function(deferred) {
            var lockInactive = activeFeedback ? activeFeedback.lockInactive() : commonUtils.noop;
            deferred.done(lockInactive)
        };
        registerEmitter({
            emitter: FeedbackEmitter,
            events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
        });
        exports.lock = FeedbackEmitter.lock;
        exports.active = ACTIVE_EVENT_NAME;
        exports.inactive = INACTIVE_EVENT_NAME
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/ui/collection/item.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var publicComponentUtils = __webpack_require__( /*! ../../core/utils/public_component */ 139);
        var INVISIBLE_STATE_CLASS = "dx-state-invisible";
        var DISABLED_STATE_CLASS = "dx-state-disabled";
        var ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
        var forcibleWatcher = function(watchMethod, fn, callback) {
            var filteredCallback = function() {
                var oldValue;
                return function(value) {
                    if (oldValue !== value) {
                        callback(value, oldValue);
                        oldValue = value
                    }
                }
            }();
            return {
                dispose: watchMethod(fn, filteredCallback),
                force: function() {
                    filteredCallback(fn())
                }
            }
        };
        var CollectionItem = Class.inherit({
            ctor: function($element, options, rawData) {
                this._$element = $element;
                this._options = options;
                this._rawData = rawData;
                publicComponentUtils.attachInstanceToElement($element, this, this._dispose);
                this._render()
            },
            _render: function() {
                var $placeholder = $("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
                this._$element.append($placeholder);
                this._watchers = [];
                this._renderWatchers()
            },
            _renderWatchers: function() {
                this._startWatcher("disabled", this._renderDisabled.bind(this));
                this._startWatcher("visible", this._renderVisible.bind(this))
            },
            _startWatcher: function(field, render) {
                var rawData = this._rawData;
                var exprGetter = this._options.fieldGetter(field);
                var watcher = forcibleWatcher(this._options.watchMethod(), function() {
                    return exprGetter(rawData)
                }, function(value, oldValue) {
                    this._dirty = true;
                    render(value, oldValue)
                }.bind(this));
                this._watchers.push(watcher)
            },
            setDataField: function() {
                this._dirty = false;
                each(this._watchers, function(_, watcher) {
                    watcher.force()
                });
                if (this._dirty) {
                    return true
                }
            },
            _renderDisabled: function(value, oldValue) {
                this._$element.toggleClass(DISABLED_STATE_CLASS, !!value);
                this._updateOwnerFocus(value)
            },
            _updateOwnerFocus: function(isDisabled) {
                var ownerComponent = this._options.owner;
                if (ownerComponent && isDisabled) {
                    ownerComponent._resetItemFocus(this._$element)
                }
            },
            _renderVisible: function(value, oldValue) {
                this._$element.toggleClass(INVISIBLE_STATE_CLASS, void 0 !== value && !value)
            },
            _dispose: function() {
                each(this._watchers, function(_, watcher) {
                    watcher.dispose()
                })
            }
        });
        CollectionItem.getInstance = function($element) {
            return publicComponentUtils.getInstanceByElement($element, this)
        };
        module.exports = CollectionItem
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/localization/globalize/core.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _globalize = __webpack_require__( /*! globalize */ 79);
        var _globalize2 = _interopRequireDefault(_globalize);
        var _core = __webpack_require__( /*! ../core */ 83);
        var _core2 = _interopRequireDefault(_core);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        if (_globalize2.default && _globalize2.default.load) {
            var likelySubtags = {
                supplemental: {
                    version: {
                        _cldrVersion: "28",
                        _unicodeVersion: "8.0.0",
                        _number: "$Revision: 11965 $"
                    },
                    likelySubtags: {
                        en: "en-Latn-US",
                        de: "de-Latn-DE",
                        ru: "ru-Cyrl-RU",
                        ja: "ja-Jpan-JP"
                    }
                }
            };
            if (!_globalize2.default.locale()) {
                _globalize2.default.load(likelySubtags);
                _globalize2.default.locale("en")
            }
            _core2.default.inject({
                locale: function(_locale) {
                    if (!_locale) {
                        return _globalize2.default.locale().locale
                    }
                    _globalize2.default.locale(_locale)
                }
            })
        }
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/events/double_click.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventsEngine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var domUtils = __webpack_require__( /*! ../core/utils/dom */ 11);
        var domAdapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var Class = __webpack_require__( /*! ../core/class */ 16);
        var registerEvent = __webpack_require__( /*! ./core/event_registrator */ 77);
        var clickEvent = __webpack_require__( /*! ./click */ 19);
        var eventUtils = __webpack_require__( /*! ./utils */ 8);
        var DBLCLICK_EVENT_NAME = "dxdblclick";
        var DBLCLICK_NAMESPACE = "dxDblClick";
        var NAMESPACED_CLICK_EVENT = eventUtils.addNamespace(clickEvent.name, DBLCLICK_NAMESPACE);
        var DBLCLICK_TIMEOUT = 300;
        var DblClick = Class.inherit({
            ctor: function() {
                this._handlerCount = 0;
                this._forgetLastClick()
            },
            _forgetLastClick: function() {
                this._firstClickTarget = null;
                this._lastClickTimeStamp = -DBLCLICK_TIMEOUT
            },
            add: function() {
                if (this._handlerCount <= 0) {
                    eventsEngine.on(domAdapter.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this))
                }
                this._handlerCount++
            },
            _clickHandler: function(e) {
                var timeStamp = e.timeStamp || Date.now();
                if (timeStamp - this._lastClickTimeStamp < DBLCLICK_TIMEOUT) {
                    eventUtils.fireEvent({
                        type: DBLCLICK_EVENT_NAME,
                        target: domUtils.closestCommonParent(this._firstClickTarget, e.target),
                        originalEvent: e
                    });
                    this._forgetLastClick()
                } else {
                    this._firstClickTarget = e.target;
                    this._lastClickTimeStamp = timeStamp
                }
            },
            remove: function() {
                this._handlerCount--;
                if (this._handlerCount <= 0) {
                    this._forgetLastClick();
                    eventsEngine.off(domAdapter.getDocument(), NAMESPACED_CLICK_EVENT)
                }
            }
        });
        registerEvent(DBLCLICK_EVENT_NAME, new DblClick);
        exports.name = DBLCLICK_EVENT_NAME
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/core/utils/error.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ./extend */ 0).extend;
        var consoleUtils = __webpack_require__( /*! ./console */ 65);
        var stringUtils = __webpack_require__( /*! ./string */ 43);
        var version = __webpack_require__( /*! ../version */ 164);
        var ERROR_URL = "http://js.devexpress.com/error/" + version.split(".").slice(0, 2).join("_") + "/";
        module.exports = function(baseErrors, errors) {
            var exports = {
                ERROR_MESSAGES: extend(errors, baseErrors),
                Error: function() {
                    return makeError([].slice.call(arguments))
                },
                log: function(id) {
                    var method = "log";
                    if (/^E\d+$/.test(id)) {
                        method = "error"
                    } else {
                        if (/^W\d+$/.test(id)) {
                            method = "warn"
                        }
                    }
                    consoleUtils.logger[method]("log" === method ? id : combineMessage([].slice.call(arguments)))
                }
            };

            function combineMessage(args) {
                var id = args[0];
                args = args.slice(1);
                return formatMessage(id, formatDetails(id, args))
            }

            function formatDetails(id, args) {
                args = [exports.ERROR_MESSAGES[id]].concat(args);
                return stringUtils.format.apply(this, args).replace(/\.*\s*?$/, "")
            }

            function formatMessage(id, details) {
                return stringUtils.format.apply(this, ["{0} - {1}. See:\n{2}", id, details, getErrorUrl(id)])
            }

            function makeError(args) {
                var id = args[0];
                args = args.slice(1);
                var details = formatDetails(id, args);
                var url = getErrorUrl(id);
                var message = formatMessage(id, details);
                return extend(new Error(message), {
                    __id: id,
                    __details: details,
                    url: url
                })
            }

            function getErrorUrl(id) {
                return ERROR_URL + id
            }
            return exports
        }
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/core/utils/public_component.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dataUtils = __webpack_require__( /*! ../../core/element_data */ 41);
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var WeakMap = __webpack_require__( /*! ../polyfills/weak_map */ 184);
        var isDefined = __webpack_require__( /*! ./type */ 1).isDefined;
        var removeEvent = __webpack_require__( /*! ../remove_event */ 140);
        var COMPONENT_NAMES_DATA_KEY = "dxComponents";
        var ANONYMOUS_COMPONENT_DATA_KEY = "dxPrivateComponent";
        var componentNames = new WeakMap;
        var nextAnonymousComponent = 0;
        var getName = exports.name = function(componentClass, newName) {
            if (isDefined(newName)) {
                componentNames.set(componentClass, newName);
                return
            }
            if (!componentNames.has(componentClass)) {
                var generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
                componentNames.set(componentClass, generatedName);
                return generatedName
            }
            return componentNames.get(componentClass)
        };
        exports.attachInstanceToElement = function($element, componentInstance, disposeFn) {
            var data = dataUtils.data($element.get(0));
            var name = getName(componentInstance.constructor);
            data[name] = componentInstance;
            if (disposeFn) {
                eventsEngine.one($element, removeEvent, function() {
                    disposeFn.call(componentInstance)
                })
            }
            if (!data[COMPONENT_NAMES_DATA_KEY]) {
                data[COMPONENT_NAMES_DATA_KEY] = []
            }
            data[COMPONENT_NAMES_DATA_KEY].push(name)
        };
        exports.getInstanceByElement = function($element, componentClass) {
            var name = getName(componentClass);
            return dataUtils.data($element.get(0), name)
        }
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/remove_event.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ./renderer */ 2);
        var beforeCleanData = __webpack_require__( /*! ./element_data */ 41).beforeCleanData;
        var eventsEngine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var registerEvent = __webpack_require__( /*! ../events/core/event_registrator */ 77);
        var eventName = "dxremove";
        var eventPropName = "dxRemoveEvent";
        beforeCleanData(function(elements) {
            elements = [].slice.call(elements);
            for (var i = 0; i < elements.length; i++) {
                var $element = $(elements[i]);
                if ($element.prop(eventPropName)) {
                    $element[0][eventPropName] = null;
                    eventsEngine.triggerHandler($element, eventName)
                }
            }
        });
        registerEvent(eventName, {
            noBubble: true,
            setup: function(element) {
                $(element).prop(eventPropName, true)
            }
        });
        module.exports = eventName
    },
    /*!***********************************************************************!*\
      !*** ./artifacts/transpiled/core/templates/child_default_template.js ***!
      \***********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.ChildDefaultTemplate = void 0;
        var _template_base = __webpack_require__( /*! ./template_base */ 78);

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _inherits(subClass, superClass) {
            if ("function" !== typeof superClass && null !== superClass) {
                throw new TypeError("Super expression must either be null or a function")
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) {
                _setPrototypeOf(subClass, superClass)
            }
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o
            };
            return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                    result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (call && ("object" === _typeof(call) || "function" === typeof call)) {
                return call
            }
            return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
            if (void 0 === self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return self
        }

        function _isNativeReflectConstruct() {
            if ("undefined" === typeof Reflect || !Reflect.construct) {
                return false
            }
            if (Reflect.construct.sham) {
                return false
            }
            if ("function" === typeof Proxy) {
                return true
            }
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                return true
            } catch (e) {
                return false
            }
        }

        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
            };
            return _getPrototypeOf(o)
        }
        exports.ChildDefaultTemplate = function(_TemplateBase) {
            _inherits(ChildDefaultTemplate, _TemplateBase);
            var _super = _createSuper(ChildDefaultTemplate);

            function ChildDefaultTemplate(name) {
                var _this;
                _classCallCheck(this, ChildDefaultTemplate);
                _this = _super.call(this);
                _this.name = name;
                return _this
            }
            return ChildDefaultTemplate
        }(_template_base.TemplateBase)
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/data/array_utils.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _config = __webpack_require__( /*! ../core/config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _guid = __webpack_require__( /*! ../core/guid */ 36);
        var _guid2 = _interopRequireDefault(_guid);
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _errors = __webpack_require__( /*! ./errors */ 38);
        var _object = __webpack_require__( /*! ../core/utils/object */ 47);
        var _object2 = _interopRequireDefault(_object);
        var _utils = __webpack_require__( /*! ./utils */ 42);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function hasKey(target, keyOrKeys) {
            var key;
            var keys = "string" === typeof keyOrKeys ? keyOrKeys.split() : keyOrKeys.slice();
            while (keys.length) {
                key = keys.shift();
                if (key in target) {
                    return true
                }
            }
            return false
        }

        function findItems(keyInfo, items, key, groupCount) {
            var childItems;
            var result;
            if (groupCount) {
                for (var i = 0; i < items.length; i++) {
                    childItems = items[i].items || items[i].collapsedItems || [];
                    result = findItems(keyInfo, childItems || [], key, groupCount - 1);
                    if (result) {
                        return result
                    }
                }
            } else {
                if (indexByKey(keyInfo, items, key) >= 0) {
                    return items
                }
            }
        }

        function getItems(keyInfo, items, key, groupCount) {
            if (groupCount) {
                return findItems(keyInfo, items, key, groupCount) || []
            }
            return items
        }

        function generateDataByKeyMap(keyInfo, array) {
            if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
                var dataByKeyMap = {};
                var arrayLength = array.length;
                for (var i = 0; i < arrayLength; i++) {
                    dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i]
                }
                array._dataByKeyMap = dataByKeyMap;
                array._dataByKeyMapLength = arrayLength
            }
        }

        function getCacheValue(array, key) {
            if (array._dataByKeyMap) {
                return array._dataByKeyMap[JSON.stringify(key)]
            }
        }

        function getHasKeyCacheValue(array, key) {
            if (array._dataByKeyMap) {
                return array._dataByKeyMap[JSON.stringify(key)]
            }
            return true
        }

        function setDataByKeyMapValue(array, key, data) {
            if (array._dataByKeyMap) {
                array._dataByKeyMap[JSON.stringify(key)] = data
            }
        }

        function applyBatch(keyInfo, array, batchData, groupCount, useInsertIndex) {
            batchData.forEach(function(item) {
                var items = "insert" === item.type ? array : getItems(keyInfo, array, item.key, groupCount);
                generateDataByKeyMap(keyInfo, items);
                switch (item.type) {
                    case "update":
                        update(keyInfo, items, item.key, item.data, true);
                        break;
                    case "insert":
                        insert(keyInfo, items, item.data, useInsertIndex && (0, _type.isDefined)(item.index) ? item.index : -1, true);
                        break;
                    case "remove":
                        remove(keyInfo, items, item.key, true)
                }
            })
        }

        function update(keyInfo, array, key, data, isBatch) {
            var target;
            var extendComplexObject = true;
            var keyExpr = keyInfo.key();
            if (keyExpr) {
                if (hasKey(data, keyExpr) && !(0, _utils.keysEqual)(keyExpr, key, keyInfo.keyOf(data))) {
                    return !isBatch && (0, _utils.rejectedPromise)(_errors.errors.Error("E4017"))
                }
                target = getCacheValue(array, key);
                if (!target) {
                    var index = indexByKey(keyInfo, array, key);
                    if (index < 0) {
                        return !isBatch && (0, _utils.rejectedPromise)(_errors.errors.Error("E4009"))
                    }
                    target = array[index]
                }
            } else {
                target = key
            }
            _object2.default.deepExtendArraySafe(target, data, extendComplexObject);
            if (!isBatch) {
                if ((0, _config2.default)().useLegacyStoreResult) {
                    return (0, _utils.trivialPromise)(key, data)
                } else {
                    return (0, _utils.trivialPromise)(target, key)
                }
            }
        }

        function insert(keyInfo, array, data, index, isBatch) {
            var keyValue;
            var keyExpr = keyInfo.key();
            var obj = (0, _type.isPlainObject)(data) ? (0, _extend.extend)({}, data) : data;
            if (keyExpr) {
                keyValue = keyInfo.keyOf(obj);
                if (void 0 === keyValue || "object" === _typeof(keyValue) && (0, _type.isEmptyObject)(keyValue)) {
                    if (Array.isArray(keyExpr)) {
                        throw _errors.errors.Error("E4007")
                    }
                    keyValue = obj[keyExpr] = String(new _guid2.default)
                } else {
                    if (void 0 !== array[indexByKey(keyInfo, array, keyValue)]) {
                        return !isBatch && (0, _utils.rejectedPromise)(_errors.errors.Error("E4008"))
                    }
                }
            } else {
                keyValue = obj
            }
            if (index >= 0) {
                array.splice(index, 0, obj)
            } else {
                array.push(obj)
            }
            setDataByKeyMapValue(array, keyValue, obj);
            if (!isBatch) {
                return (0, _utils.trivialPromise)((0, _config2.default)().useLegacyStoreResult ? data : obj, keyValue)
            }
        }

        function remove(keyInfo, array, key, isBatch) {
            var index = indexByKey(keyInfo, array, key);
            if (index > -1) {
                array.splice(index, 1)
            }
            if (!isBatch) {
                return (0, _utils.trivialPromise)(key)
            }
        }

        function indexByKey(keyInfo, array, key) {
            var keyExpr = keyInfo.key();
            if (!getHasKeyCacheValue(array, key)) {
                return -1
            }
            for (var i = 0, arrayLength = array.length; i < arrayLength; i++) {
                if ((0, _utils.keysEqual)(keyExpr, keyInfo.keyOf(array[i]), key)) {
                    return i
                }
            }
            return -1
        }
        module.exports.applyBatch = applyBatch;
        module.exports.update = update;
        module.exports.insert = insert;
        module.exports.remove = remove;
        module.exports.indexByKey = indexByKey
    }, , , , , , , ,
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/viz/core/helpers.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var windowUtils = __webpack_require__( /*! ../../core/utils/window */ 7);
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var isServerSide = !windowUtils.hasWindow();

        function Flags() {
            this.reset()
        }
        Flags.prototype = {
            constructor: Flags,
            add: function(codes) {
                var i;
                var ii = codes.length;
                var flags = this._flags;
                for (i = 0; i < ii; ++i) {
                    flags[codes[i]] = 1
                }
                this._k += ii
            },
            has: function(code) {
                return this._flags[code] > 0
            },
            count: function() {
                return this._k
            },
            reset: function() {
                this._flags = {};
                this._k = 0
            }
        };

        function combineMaps(baseMap, thisMap) {
            return baseMap !== thisMap ? _extend({}, baseMap, thisMap) : _extend({}, baseMap)
        }

        function combineLists(baseList, thisList) {
            return baseList !== thisList ? baseList.concat(thisList) : baseList.slice()
        }

        function buildTotalChanges(proto) {
            proto._totalChangesOrder = proto._optionChangesOrder.concat(proto._layoutChangesOrder, proto._customChangesOrder)
        }

        function addChange(settings) {
            var proto = this.prototype;
            var code = settings.code;
            proto["_change_" + code] = settings.handler;
            if (settings.isThemeDependent) {
                proto._themeDependentChanges.push(code)
            }
            if (settings.option) {
                proto._optionChangesMap[settings.option] = code
            }(settings.isOptionChange ? proto._optionChangesOrder : proto._customChangesOrder).push(code);
            buildTotalChanges(proto)
        }

        function createChainExecutor() {
            var executeChain = function executeChain() {
                var i;
                var ii = executeChain._chain.length;
                var result;
                for (i = 0; i < ii; ++i) {
                    result = executeChain._chain[i].apply(this, arguments)
                }
                return result
            };
            executeChain._chain = [];
            executeChain.add = function(item) {
                executeChain._chain.push(item)
            };
            executeChain.copy = function(executor) {
                executeChain._chain = executor._chain.slice()
            };
            return executeChain
        }

        function expand(target, name, expander) {
            var current = target[name];
            if (!current) {
                current = expander
            } else {
                if (!current.add) {
                    current = createChainExecutor();
                    current.add(target[name]);
                    current.add(expander)
                } else {
                    if (false === Object.prototype.hasOwnProperty.call(target, name)) {
                        current = createChainExecutor();
                        current.copy(target[name])
                    }
                    current.add(expander)
                }
            }
            target[name] = current
        }

        function addPlugin(plugin) {
            var proto = this.prototype;
            proto._plugins.push(plugin);
            plugin.fontFields && proto._fontFields.push.apply(proto._fontFields, plugin.fontFields);
            if (plugin.members) {
                _extend(this.prototype, plugin.members)
            }
            if (plugin.customize) {
                plugin.customize(this)
            }
            if (plugin.extenders) {
                Object.keys(plugin.extenders).forEach(function(key) {
                    var func = plugin.extenders[key];
                    expand(proto, key, func)
                }, this)
            }
        }
        exports.replaceInherit = isServerSide ? function(widget) {
            var _inherit = widget.inherit;
            widget.inherit = function() {
                var result = _inherit.apply(this, arguments);
                var proto = result.prototype;
                ["_plugins", "_eventsMap", "_initialChanges", "_themeDependentChanges", "_optionChangesMap", "_optionChangesOrder", "_layoutChangesOrder", "_customChangesOrder", "_totalChangesOrder"].forEach(function(key) {
                    proto[key] = {}
                });
                result.addPlugin = noop;
                return result
            };
            widget.addChange = noop;
            widget.addPlugin = noop
        } : function(widget) {
            var _inherit = widget.inherit;
            widget.inherit = function() {
                var proto = this.prototype;
                var plugins = proto._plugins;
                var fontFields = proto._fontFields;
                var eventsMap = proto._eventsMap;
                var initialChanges = proto._initialChanges;
                var themeDependentChanges = proto._themeDependentChanges;
                var optionChangesMap = proto._optionChangesMap;
                var partialOptionChangesMap = proto._partialOptionChangesMap;
                var partialOptionChangesPath = proto._partialOptionChangesPath;
                var optionChangesOrder = proto._optionChangesOrder;
                var layoutChangesOrder = proto._layoutChangesOrder;
                var customChangesOrder = proto._customChangesOrder;
                var result = _inherit.apply(this, arguments);
                proto = result.prototype;
                proto._plugins = combineLists(plugins, proto._plugins);
                proto._fontFields = combineLists(fontFields, proto._fontFields);
                proto._eventsMap = combineMaps(eventsMap, proto._eventsMap);
                proto._initialChanges = combineLists(initialChanges, proto._initialChanges);
                proto._themeDependentChanges = combineLists(themeDependentChanges, proto._themeDependentChanges);
                proto._optionChangesMap = combineMaps(optionChangesMap, proto._optionChangesMap);
                proto._partialOptionChangesMap = combineMaps(partialOptionChangesMap, proto._partialOptionChangesMap);
                proto._partialOptionChangesPath = combineMaps(partialOptionChangesPath, proto._partialOptionChangesPath);
                proto._optionChangesOrder = combineLists(optionChangesOrder, proto._optionChangesOrder);
                proto._layoutChangesOrder = combineLists(layoutChangesOrder, proto._layoutChangesOrder);
                proto._customChangesOrder = combineLists(customChangesOrder, proto._customChangesOrder);
                buildTotalChanges(proto);
                result.addPlugin = addPlugin;
                return result
            };
            widget.prototype._plugins = [];
            widget.prototype._fontFields = [];
            widget.addChange = addChange;
            widget.addPlugin = addPlugin
        };
        exports.changes = function() {
            return new Flags
        };
        exports.expand = expand
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/series/bar_series.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var scatterSeries = __webpack_require__( /*! ./scatter_series */ 110);
        var areaSeries = __webpack_require__( /*! ./area_series */ 174).chart.area;
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var chartSeries = scatterSeries.chart;
        var polarSeries = scatterSeries.polar;
        var _isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var _extend = extend;
        var _each = each;
        exports.chart = {};
        exports.polar = {};
        var baseBarSeriesMethods = {
            _createLegendState: function(styleOptions, defaultColor) {
                return {
                    fill: styleOptions.color || defaultColor,
                    hatching: styleOptions.hatching
                }
            },
            _parsePointStyle: function(style, defaultColor, defaultBorderColor) {
                var color = style.color || defaultColor;
                var base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);
                base.fill = color;
                base.hatching = style.hatching;
                base.dashStyle = style.border && style.border.dashStyle || "solid";
                delete base.r;
                return base
            },
            _applyMarkerClipRect: function(settings) {
                settings["clip-path"] = null
            },
            _setGroupsSettings: function(animationEnabled, firstDrawing) {
                var that = this;
                var settings = {};
                chartSeries._setGroupsSettings.apply(that, arguments);
                if (animationEnabled && firstDrawing) {
                    settings = this._getAffineCoordOptions()
                } else {
                    if (!animationEnabled) {
                        settings = {
                            scaleX: 1,
                            scaleY: 1,
                            translateX: 0,
                            translateY: 0
                        }
                    }
                }
                that._markersGroup.attr(settings)
            },
            _drawPoint: function(options) {
                options.hasAnimation = options.hasAnimation && !options.firstDrawing;
                options.firstDrawing = false;
                chartSeries._drawPoint.call(this, options)
            },
            _getMainColor: function() {
                return this._options.mainSeriesColor
            },
            _createPointStyles: function(pointOptions) {
                var that = this;
                var mainColor = pointOptions.color || that._getMainColor();
                return {
                    normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
                    hover: that._parsePointStyle(pointOptions.hoverStyle || {}, mainColor, mainColor),
                    selection: that._parsePointStyle(pointOptions.selectionStyle || {}, mainColor, mainColor)
                }
            },
            _updatePointsVisibility: function() {
                var visibility = this._options.visible;
                each(this._points, function(_, point) {
                    point._options.visible = visibility
                })
            },
            _getOptionsForPoint: function() {
                return this._options
            },
            _animate: function(firstDrawing) {
                var that = this;
                var complete = function() {
                    that._animateComplete()
                };
                var animateFunc = function(drawnPoints, complete) {
                    var lastPointIndex = drawnPoints.length - 1;
                    _each(drawnPoints || [], function(i, point) {
                        point.animate(i === lastPointIndex ? complete : void 0, point.getMarkerCoords())
                    })
                };
                that._animatePoints(firstDrawing, complete, animateFunc)
            },
            getValueRangeInitialValue: areaSeries.getValueRangeInitialValue,
            _patchMarginOptions: function(options) {
                options.checkInterval = true;
                return options
            },
            _defaultAggregator: "sum",
            _defineDrawingState: function() {},
            usePointsToDefineAutoHiding: function() {
                return false
            }
        };
        exports.chart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {
            _getAffineCoordOptions: function() {
                var rotated = this._options.rotated;
                var direction = rotated ? "X" : "Y";
                var settings = {
                    scaleX: rotated ? .001 : 1,
                    scaleY: rotated ? 1 : .001
                };
                settings["translate" + direction] = this.getValueAxis().getTranslator().translate("canvas_position_default");
                return settings
            },
            _animatePoints: function(firstDrawing, complete, animateFunc) {
                var that = this;
                that._markersGroup.animate({
                    scaleX: 1,
                    scaleY: 1,
                    translateY: 0,
                    translateX: 0
                }, void 0, complete);
                if (!firstDrawing) {
                    animateFunc(that._drawnPoints, complete)
                }
            },
            checkSeriesViewportCoord: function(axis, coord) {
                if (0 === this._points.length) {
                    return false
                }
                if (axis.isArgumentAxis) {
                    return true
                }
                var translator = axis.getTranslator();
                var range = this.getViewport();
                var min = translator.translate(range.categories ? range.categories[0] : range.min);
                var max = translator.translate(range.categories ? range.categories[range.categories.length - 1] : range.max);
                var rotated = this.getOptions().rotated;
                var inverted = axis.getOptions().inverted;
                return rotated && !inverted || !rotated && inverted ? coord >= min && coord <= max : coord >= max && coord <= min
            },
            getSeriesPairCoord: function(coord, isArgument) {
                var oppositeCoord = null;
                var rotated = this._options.rotated;
                var isOpposite = !isArgument && !rotated || isArgument && rotated;
                var coordName = isOpposite ? "vy" : "vx";
                var oppositeCoordName = isOpposite ? "vx" : "vy";
                var points = this.getPoints();
                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    var tmpCoord = void 0;
                    if (isArgument) {
                        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0
                    } else {
                        tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0
                    }
                    if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
                        oppositeCoord = tmpCoord;
                        break
                    }
                }
                return oppositeCoord
            }
        });
        exports.polar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {
            _animatePoints: function(firstDrawing, complete, animateFunc) {
                animateFunc(this._drawnPoints, complete)
            },
            _setGroupsSettings: chartSeries._setGroupsSettings,
            _drawPoint: function(point, groups, animationEnabled) {
                chartSeries._drawPoint.call(this, point, groups, animationEnabled)
            },
            _parsePointStyle: function(style) {
                var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);
                base.opacity = style.opacity;
                return base
            },
            _createGroups: chartSeries._createGroups,
            _setMarkerGroupSettings: function() {
                var that = this;
                var markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
                markersSettings.class = "dxc-markers";
                that._applyMarkerClipRect(markersSettings);
                var groupSettings = _extend({}, markersSettings);
                delete groupSettings.opacity;
                that._markersGroup.attr(groupSettings)
            },
            getSeriesPairCoord: function(params, isArgument) {
                var coords = null;
                var paramName = isArgument ? "argument" : "radius";
                var points = this.getVisiblePoints();
                var argAxis = this.getArgumentAxis();
                var startAngle = argAxis.getAngles()[0];
                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? vizUtils.convertPolarToXY(argAxis.getCenter(), startAngle, -argAxis.getTranslatedAngle(p.angle), p.radius) : void 0;
                    if (_isDefined(tmpPoint)) {
                        coords = tmpPoint;
                        break
                    }
                }
                return coords
            },
            _createLegendState: areaSeries._createLegendState
        })
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/core/data_source.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var DataHelperMixin = __webpack_require__( /*! ../../data_helper */ 82);
        var postCtor = DataHelperMixin.postCtor;
        var name;
        var members = {
            _dataSourceLoadErrorHandler: function() {
                this._dataSourceChangedHandler()
            },
            _dataSourceOptions: function() {
                return {
                    paginate: false
                }
            },
            _updateDataSource: function() {
                this._refreshDataSource();
                if (!this.option("dataSource")) {
                    this._dataSourceChangedHandler()
                }
            },
            _dataIsLoaded: function() {
                return !this._dataSource || this._dataSource.isLoaded()
            },
            _dataSourceItems: function() {
                return this._dataSource && this._dataSource.items()
            }
        };
        for (name in DataHelperMixin) {
            if ("postCtor" === name) {
                continue
            }
            members[name] = DataHelperMixin[name]
        }
        exports.plugin = {
            name: "data_source",
            init: function() {
                postCtor.call(this)
            },
            dispose: noop,
            members: members
        }
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/base_gauge.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _Number = Number;
        var _getAppropriateFormat = __webpack_require__( /*! ../core/utils */ 13).getAppropriateFormat;
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var translator1DModule = __webpack_require__( /*! ../translators/translator1d */ 430);
        var _extend = extend;
        var BaseWidget = __webpack_require__( /*! ../core/base_widget */ 102);
        var themeManagerModule = __webpack_require__( /*! ./theme_manager */ 844);
        var Tracker = __webpack_require__( /*! ./tracker */ 845);
        var dxBaseGauge = BaseWidget.inherit({
            _rootClassPrefix: "dxg",
            _themeSection: "gauge",
            _createThemeManager: function() {
                return new themeManagerModule.ThemeManager(this._getThemeManagerOptions())
            },
            _initCore: function() {
                var that = this;
                var root = that._renderer.root;
                that._valueChangingLocker = 0;
                that._translator = that._factory.createTranslator();
                that._tracker = that._factory.createTracker({
                    renderer: that._renderer,
                    container: root
                });
                that._setTrackerCallbacks()
            },
            _beginValueChanging: function() {
                this._resetIsReady();
                this._onBeginUpdate();
                ++this._valueChangingLocker
            },
            _endValueChanging: function() {
                if (0 === --this._valueChangingLocker) {
                    this._drawn()
                }
            },
            _setTrackerCallbacks: function() {
                var that = this;
                var renderer = that._renderer;
                var tooltip = that._tooltip;
                that._tracker.setCallbacks({
                    "tooltip-show": function(target, info) {
                        var tooltipParameters = target.getTooltipParameters();
                        var offset = renderer.getRootOffset();
                        var formatObject = _extend({
                            value: tooltipParameters.value,
                            valueText: tooltip.formatValue(tooltipParameters.value),
                            color: tooltipParameters.color
                        }, info);
                        return tooltip.show(formatObject, {
                            x: tooltipParameters.x + offset.left,
                            y: tooltipParameters.y + offset.top,
                            offset: tooltipParameters.offset
                        }, {
                            target: info
                        })
                    },
                    "tooltip-hide": function() {
                        return tooltip.hide()
                    }
                })
            },
            _dispose: function() {
                this._cleanCore();
                this.callBase.apply(this, arguments)
            },
            _disposeCore: function() {
                var that = this;
                that._themeManager.dispose();
                that._tracker.dispose();
                that._translator = that._tracker = null
            },
            _cleanCore: function() {
                var that = this;
                that._tracker.deactivate();
                that._cleanContent()
            },
            _renderCore: function() {
                var that = this;
                if (!that._isValidDomain) {
                    return
                }
                that._renderContent();
                that._tracker.setTooltipState(that._tooltip.isEnabled());
                that._tracker.activate();
                that._noAnimation = false;
                that._debug_rendered && that._debug_rendered()
            },
            _applyChanges: function() {
                this.callBase.apply(this, arguments);
                this._resizing = this._noAnimation = false
            },
            _setContentSize: function() {
                var that = this;
                that._resizing = that._noAnimation = 2 === that._changes.count();
                that.callBase.apply(that, arguments)
            },
            _applySize: function(rect) {
                var that = this;
                that._DEBUG_rootRect = rect;
                that._innerRect = {
                    left: rect[0],
                    top: rect[1],
                    right: rect[2],
                    bottom: rect[3]
                };
                var layoutCache = that._layout._cache;
                that._cleanCore();
                that._renderCore();
                that._layout._cache = that._layout._cache || layoutCache;
                return [rect[0], that._innerRect.top, rect[2], that._innerRect.bottom]
            },
            _initialChanges: ["DOMAIN"],
            _themeDependentChanges: ["DOMAIN"],
            _optionChangesMap: {
                subtitle: "MOSTLY_TOTAL",
                indicator: "MOSTLY_TOTAL",
                geometry: "MOSTLY_TOTAL",
                animation: "MOSTLY_TOTAL",
                startValue: "DOMAIN",
                endValue: "DOMAIN"
            },
            _optionChangesOrder: ["DOMAIN", "MOSTLY_TOTAL"],
            _change_DOMAIN: function() {
                this._setupDomain()
            },
            _change_MOSTLY_TOTAL: function() {
                this._applyMostlyTotalChange()
            },
            _setupDomain: function() {
                var that = this;
                that._setupDomainCore();
                that._isValidDomain = isFinite(1 / (that._translator.getDomain()[1] - that._translator.getDomain()[0]));
                if (!that._isValidDomain) {
                    that._incidentOccurred("W2301")
                }
                that._change(["MOSTLY_TOTAL"])
            },
            _applyMostlyTotalChange: function() {
                var that = this;
                that._setupCodomain();
                that._setupAnimationSettings();
                that._setupDefaultFormat();
                that._change(["LAYOUT"])
            },
            _setupAnimationSettings: function() {
                var that = this;
                var option = that.option("animation");
                that._animationSettings = null;
                if (void 0 === option || option) {
                    option = _extend({
                        enabled: true,
                        duration: 1e3,
                        easing: "easeOutCubic"
                    }, option);
                    if (option.enabled && option.duration > 0) {
                        that._animationSettings = {
                            duration: _Number(option.duration),
                            easing: option.easing
                        }
                    }
                }
                that._containerBackgroundColor = that.option("containerBackgroundColor") || that._themeManager.theme().containerBackgroundColor
            },
            _setupDefaultFormat: function() {
                var domain = this._translator.getDomain();
                this._defaultFormatOptions = _getAppropriateFormat(domain[0], domain[1], this._getApproximateScreenRange())
            },
            _setupDomainCore: null,
            _calculateSize: null,
            _cleanContent: null,
            _renderContent: null,
            _setupCodomain: null,
            _getApproximateScreenRange: null,
            _factory: {
                createTranslator: function() {
                    return new translator1DModule.Translator1D
                },
                createTracker: function(parameters) {
                    return new Tracker(parameters)
                }
            }
        });
        exports.dxBaseGauge = dxBaseGauge;
        var _format = __webpack_require__( /*! ../../format_helper */ 63).format;
        var formatValue = function(value, options, extra) {
            options = options || {};
            var text = _format(value, options.format);
            var formatObject;
            if ("function" === typeof options.customizeText) {
                formatObject = _extend({
                    value: value,
                    valueText: text
                }, extra);
                return String(options.customizeText.call(formatObject, formatObject))
            }
            return text
        };
        var getSampleText = function(translator, options) {
            var text1 = formatValue(translator.getDomainStart(), options);
            var text2 = formatValue(translator.getDomainEnd(), options);
            return text1.length >= text2.length ? text1 : text2
        };
        exports.formatValue = formatValue;
        exports.getSampleText = getSampleText;
        exports.compareArrays = function(array1, array2) {
            return array1 && array2 && array1.length === array2.length && compareArraysElements(array1, array2)
        };

        function compareArraysElements(array1, array2) {
            var i;
            var ii = array1.length;
            var array1ValueIsNaN;
            var array2ValueIsNaN;
            for (i = 0; i < ii; ++i) {
                array1ValueIsNaN = array1[i] !== array1[i];
                array2ValueIsNaN = array2[i] !== array2[i];
                if (array1ValueIsNaN && array2ValueIsNaN) {
                    continue
                }
                if (array1[i] !== array2[i]) {
                    return false
                }
            }
            return true
        }
        dxBaseGauge.addPlugin(__webpack_require__( /*! ../core/export */ 99).plugin);
        dxBaseGauge.addPlugin(__webpack_require__( /*! ../core/title */ 109).plugin);
        dxBaseGauge.addPlugin(__webpack_require__( /*! ../core/tooltip */ 111).plugin);
        dxBaseGauge.addPlugin(__webpack_require__( /*! ../core/loading_indicator */ 127).plugin);
        var _setTooltipOptions = dxBaseGauge.prototype._setTooltipOptions;
        dxBaseGauge.prototype._setTooltipOptions = function() {
            _setTooltipOptions.apply(this, arguments);
            this._tracker && this._tracker.setTooltipState(this._tooltip.isEnabled())
        }
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/api.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./tree_map.base */ 73).prototype;
        var nodeProto = __webpack_require__( /*! ./node */ 175).prototype;
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        proto._eventsMap.onNodesInitialized = {
            name: "nodesInitialized"
        };
        proto._eventsMap.onNodesRendering = {
            name: "nodesRendering"
        };
        proto._createProxyType = function() {
            var that = this;
            var nodes;
            Proxy.prototype = {
                constructor: Proxy,
                getParent: function() {
                    return nodes[this._id].parent.proxy || null
                },
                getChild: function(index) {
                    var _nodes = nodes[this._id].nodes;
                    return _nodes ? _nodes[index].proxy : null
                },
                getChildrenCount: function() {
                    var _nodes = nodes[this._id].nodes;
                    return _nodes ? _nodes.length : 0
                },
                getAllChildren: function() {
                    var _nodes = nodes[this._id].nodes;
                    var i;
                    var ii = _nodes && _nodes.length;
                    var list = [];
                    for (i = 0; i < ii; ++i) {
                        list.push(_nodes[i].proxy)
                    }
                    return list
                },
                getAllNodes: function() {
                    var list = [];
                    collectNodes(nodes[this._id], list);
                    return list
                },
                isLeaf: function() {
                    return !nodes[this._id].isNode()
                },
                isActive: function() {
                    return nodes[this._id].isActive()
                },
                value: function(arg) {
                    var node = nodes[this._id];
                    var result;
                    if (void 0 !== arg) {
                        updateValue(node, arg > 0 ? Number(arg) : 0);
                        change(node, ["TILING"]);
                        result = this
                    } else {
                        result = node.value
                    }
                    return result
                },
                label: function(arg) {
                    var node = nodes[this._id];
                    var result;
                    if (void 0 !== arg) {
                        node.customLabel = arg ? String(arg) : null;
                        change(node, ["LABELS"]);
                        result = this
                    } else {
                        result = node.customLabel || node.label
                    }
                    return result
                },
                customize: function(settings) {
                    var node = nodes[this._id];
                    if (settings) {
                        node._custom = node._custom || {};
                        _extend(true, node._custom, settings);
                        node._partialState = node._partialLabelState = null
                    }
                    change(node, ["TILES", "LABELS"]);
                    return this
                },
                resetCustomization: function() {
                    var node = nodes[this._id];
                    node._custom = node._partialState = node._partialLabelState = null;
                    change(node, ["TILES", "LABELS"]);
                    return this
                }
            };
            that._extendProxyType(Proxy.prototype);

            function Proxy(node) {
                var that = this;
                node.proxy = that;
                that._id = node._id;
                that.level = node.level;
                that.index = node.index;
                that.data = node.data
            }
            that._handlers.beginBuildNodes = function() {
                nodes = that._nodes;
                new Proxy(that._root)
            };
            that._handlers.buildNode = function(node) {
                new Proxy(node)
            };
            that._handlers.endBuildNodes = function() {
                that._eventTrigger("nodesInitialized", {
                    root: that._root.proxy
                })
            }
        };

        function change(node, codes) {
            var ctx = node.ctx;
            ctx.suspend();
            ctx.change(codes);
            ctx.resume()
        }

        function collectNodes(node, list) {
            var nodes = node.nodes;
            var i;
            var ii = nodes && nodes.length;
            for (i = 0; i < ii; ++i) {
                list.push(nodes[i].proxy);
                collectNodes(nodes[i], list)
            }
        }

        function updateValue(node, value) {
            var delta = value - node.value;
            while (node) {
                node.value += delta;
                node = node.parent
            }
        }
        proto._extendProxyType = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var _resetNodes = proto._resetNodes;
        proto._resetNodes = function() {
            _resetNodes.call(this);
            this._eventTrigger("nodesRendering", {
                node: this._topNode.proxy
            })
        };
        var _updateStyles = nodeProto.updateStyles;
        nodeProto.updateStyles = function() {
            var that = this;
            _updateStyles.call(that);
            if (that._custom) {
                that._partialState = !that.ctx.forceReset && that._partialState || that.ctx.calculateState(that._custom);
                _extend(true, that.state, that._partialState)
            }
        };
        var _updateLabelStyle = nodeProto.updateLabelStyle;
        nodeProto.updateLabelStyle = function() {
            var that = this;
            var custom = that._custom;
            _updateLabelStyle.call(that);
            if (custom && custom.label) {
                that._partialLabelState = !that.ctx.forceReset && that._partialLabelState || calculatePartialLabelState(that, custom.label);
                that.labelState = _extend(true, {}, that.labelState, that._partialLabelState)
            }
        };

        function calculatePartialLabelState(node, settings) {
            var state = node.ctx.calculateLabelState(settings);
            if ("visible" in settings) {
                state.visible = !!settings.visible
            }
            return state
        }
        proto.getRootNode = function() {
            return this._root.proxy
        };
        proto.resetNodes = function() {
            var context = this._context;
            context.suspend();
            context.change(["NODES_CREATE"]);
            context.resume();
            return this
        }
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/bundles/modules/core.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var windowUtils = __webpack_require__( /*! ../../core/utils/window */ 7);
        var window = windowUtils.getWindow();
        var DevExpress = window.DevExpress = window.DevExpress || {};
        var errors = DevExpress.errors = __webpack_require__( /*! ../../core/errors */ 22);
        if (DevExpress._DEVEXTREME_BUNDLE_INITIALIZED) {
            throw errors.Error("E0024")
        }
        DevExpress._DEVEXTREME_BUNDLE_INITIALIZED = true;
        DevExpress.clientExporter = __webpack_require__( /*! ../../exporter */ 179);
        DevExpress.excelExporter = __webpack_require__( /*! ../../excel_exporter */ 465);
        DevExpress.VERSION = __webpack_require__( /*! ../../core/version */ 164);
        DevExpress.Class = __webpack_require__( /*! ../../core/class */ 16);
        DevExpress.DOMComponent = __webpack_require__( /*! ../../core/dom_component */ 68);
        DevExpress.Component = __webpack_require__( /*! ../../core/component */ 115);
        DevExpress.registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 9);
        DevExpress.devices = __webpack_require__( /*! ../../core/devices */ 15);
        DevExpress.Color = __webpack_require__( /*! ../../color */ 91);
        var animationFrame = __webpack_require__( /*! ../../animation/frame */ 117);
        DevExpress.utils = {};
        DevExpress.utils.requestAnimationFrame = animationFrame.requestAnimationFrame;
        DevExpress.utils.cancelAnimationFrame = animationFrame.cancelAnimationFrame;
        DevExpress.utils.initMobileViewport = __webpack_require__( /*! ../../mobile/init_mobile_viewport/init_mobile_viewport */ 477).initMobileViewport;
        DevExpress.utils.extendFromObject = __webpack_require__( /*! ../../core/utils/extend */ 0).extendFromObject;
        DevExpress.utils.createComponents = __webpack_require__( /*! ../../core/utils/dom */ 11).createComponents;
        DevExpress.utils.triggerShownEvent = __webpack_require__( /*! ../../core/utils/dom */ 11).triggerShownEvent;
        DevExpress.utils.triggerHidingEvent = __webpack_require__( /*! ../../core/utils/dom */ 11).triggerHidingEvent;
        DevExpress.utils.resetActiveElement = __webpack_require__( /*! ../../core/utils/dom */ 11).resetActiveElement;
        DevExpress.utils.findBestMatches = __webpack_require__( /*! ../../core/utils/common */ 3).findBestMatches;
        DevExpress.createQueue = __webpack_require__( /*! ../../core/utils/queue */ 280).create;
        DevExpress.utils.dom = __webpack_require__( /*! ../../core/utils/dom */ 11);
        DevExpress.utils.common = __webpack_require__( /*! ../../core/utils/common */ 3);
        DevExpress.utils.date = __webpack_require__( /*! ../../core/utils/date */ 24);
        DevExpress.utils.browser = __webpack_require__( /*! ../../core/utils/browser */ 26);
        DevExpress.utils.inflector = __webpack_require__( /*! ../../core/utils/inflector */ 34);
        DevExpress.utils.iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        DevExpress.utils.readyCallbacks = __webpack_require__( /*! ../../core/utils/ready_callbacks */ 51);
        DevExpress.utils.resizeCallbacks = __webpack_require__( /*! ../../core/utils/resize_callbacks */ 114);
        DevExpress.utils.console = __webpack_require__( /*! ../../core/utils/console */ 65);
        DevExpress.utils.string = __webpack_require__( /*! ../../core/utils/string */ 43);
        DevExpress.utils.support = __webpack_require__( /*! ../../core/utils/support */ 46);
        DevExpress.utils.ajax = __webpack_require__( /*! ../../core/utils/ajax */ 75);
        DevExpress.viewPort = __webpack_require__( /*! ../../core/utils/view_port */ 76).value;
        DevExpress.hideTopOverlay = __webpack_require__( /*! ../../mobile/hide_top_overlay */ 220);
        DevExpress.formatHelper = __webpack_require__( /*! ../../format_helper */ 63);
        DevExpress.config = __webpack_require__( /*! ../../core/config */ 30);
        DevExpress.animationPresets = __webpack_require__( /*! ../../animation/presets/presets */ 188).presets;
        DevExpress.fx = __webpack_require__( /*! ../../animation/fx */ 40);
        DevExpress.TransitionExecutor = __webpack_require__( /*! ../../animation/transition_executor/transition_executor */ 300).TransitionExecutor;
        DevExpress.AnimationPresetCollection = __webpack_require__( /*! ../../animation/presets/presets */ 188).PresetCollection;
        DevExpress.events = __webpack_require__( /*! ../../events */ 478);
        DevExpress.events.click = __webpack_require__( /*! ../../events/click */ 19);
        DevExpress.events.utils = __webpack_require__( /*! ../../events/utils */ 8);
        DevExpress.events.GestureEmitter = __webpack_require__( /*! ../../events/gesture/emitter.gesture */ 166);
        DevExpress.localization = __webpack_require__( /*! ../../localization */ 481);
        DevExpress.templateRendered = __webpack_require__( /*! ../../core/templates/template_base */ 78).renderedCallbacks;
        DevExpress.setTemplateEngine = __webpack_require__( /*! ../../core/templates/template_engine_registry */ 165).setTemplateEngine;
        module.exports = DevExpress
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/events/hover.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventsEngine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var dataUtils = __webpack_require__( /*! ../core/element_data */ 41);
        var Class = __webpack_require__( /*! ../core/class */ 16);
        var devices = __webpack_require__( /*! ../core/devices */ 15);
        var registerEvent = __webpack_require__( /*! ./core/event_registrator */ 77);
        var eventUtils = __webpack_require__( /*! ./utils */ 8);
        var pointerEvents = __webpack_require__( /*! ./pointer */ 23);
        var HOVERSTART_NAMESPACE = "dxHoverStart";
        var HOVERSTART = "dxhoverstart";
        var POINTERENTER_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.enter, HOVERSTART_NAMESPACE);
        var HOVEREND_NAMESPACE = "dxHoverEnd";
        var HOVEREND = "dxhoverend";
        var POINTERLEAVE_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.leave, HOVEREND_NAMESPACE);
        var Hover = Class.inherit({
            noBubble: true,
            ctor: function() {
                this._handlerArrayKeyPath = this._eventNamespace + "_HandlerStore"
            },
            setup: function(element) {
                dataUtils.data(element, this._handlerArrayKeyPath, {})
            },
            add: function(element, handleObj) {
                var that = this;
                var handler = function(e) {
                    that._handler(e)
                };
                eventsEngine.on(element, this._originalEventName, handleObj.selector, handler);
                dataUtils.data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler
            },
            _handler: function(e) {
                if (eventUtils.isTouchEvent(e) || devices.isSimulator()) {
                    return
                }
                eventUtils.fireEvent({
                    type: this._eventName,
                    originalEvent: e,
                    delegateTarget: e.delegateTarget
                })
            },
            remove: function(element, handleObj) {
                var handler = dataUtils.data(element, this._handlerArrayKeyPath)[handleObj.guid];
                eventsEngine.off(element, this._originalEventName, handleObj.selector, handler)
            },
            teardown: function(element) {
                dataUtils.removeData(element, this._handlerArrayKeyPath)
            }
        });
        var HoverStart = Hover.inherit({
            ctor: function() {
                this._eventNamespace = HOVERSTART_NAMESPACE;
                this._eventName = HOVERSTART;
                this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
                this.callBase()
            },
            _handler: function(e) {
                var pointers = e.pointers || [];
                if (!pointers.length) {
                    this.callBase(e)
                }
            }
        });
        var HoverEnd = Hover.inherit({
            ctor: function() {
                this._eventNamespace = HOVEREND_NAMESPACE;
                this._eventName = HOVEREND;
                this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
                this.callBase()
            }
        });
        registerEvent(HOVERSTART, new HoverStart);
        registerEvent(HOVEREND, new HoverEnd);
        exports.start = HOVERSTART;
        exports.end = HOVEREND
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/ui/widget/swatch_container.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var viewPortUtils = __webpack_require__( /*! ../../core/utils/view_port */ 76);
        var SWATCH_CONTAINER_CLASS_PREFIX = "dx-swatch-";
        var getSwatchContainer = function(element) {
            var $element = $(element);
            var swatchContainer = $element.closest('[class^="'.concat(SWATCH_CONTAINER_CLASS_PREFIX, '"], [class*=" ').concat(SWATCH_CONTAINER_CLASS_PREFIX, '"]'));
            var viewport = viewPortUtils.value();
            if (!swatchContainer.length) {
                return viewport
            }
            var swatchClassRegex = new RegExp("(\\s|^)(".concat(SWATCH_CONTAINER_CLASS_PREFIX, ".*?)(\\s|$)"));
            var swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
            var viewportSwatchContainer = viewport.children("." + swatchClass);
            if (!viewportSwatchContainer.length) {
                viewportSwatchContainer = $("<div>").addClass(swatchClass).appendTo(viewport)
            }
            return viewportSwatchContainer
        };
        module.exports = {
            getSwatchContainer: getSwatchContainer
        }
    }, ,
    /*!**********************************************************************!*\
      !*** ./artifacts/transpiled/core/component_registrator_callbacks.js ***!
      \**********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _memorized_callbacks = __webpack_require__( /*! ./memorized_callbacks */ 185);
        var _memorized_callbacks2 = _interopRequireDefault(_memorized_callbacks);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        exports.default = new _memorized_callbacks2.default
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/events/pointer/base.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var browser = __webpack_require__( /*! ../../core/utils/browser */ 26);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var eventUtils = __webpack_require__( /*! ../utils */ 8);
        var POINTER_EVENTS_NAMESPACE = "dxPointerEvents";
        var BaseStrategy = Class.inherit({
            ctor: function(eventName, originalEvents) {
                this._eventName = eventName;
                this._originalEvents = eventUtils.addNamespace(originalEvents, POINTER_EVENTS_NAMESPACE);
                this._handlerCount = 0;
                this.noBubble = this._isNoBubble()
            },
            _isNoBubble: function() {
                var eventName = this._eventName;
                return "dxpointerenter" === eventName || "dxpointerleave" === eventName
            },
            _handler: function(e) {
                var delegateTarget = this._getDelegateTarget(e);
                return this._fireEvent({
                    type: this._eventName,
                    pointerType: e.pointerType || eventUtils.eventSource(e),
                    originalEvent: e,
                    delegateTarget: delegateTarget,
                    timeStamp: browser.mozilla ? (new Date).getTime() : e.timeStamp
                })
            },
            _getDelegateTarget: function(e) {
                var delegateTarget;
                if (this.noBubble) {
                    delegateTarget = e.delegateTarget
                }
                return delegateTarget
            },
            _fireEvent: function(args) {
                return eventUtils.fireEvent(args)
            },
            _setSelector: function(handleObj) {
                this._selector = this.noBubble && handleObj ? handleObj.selector : null
            },
            _getSelector: function() {
                return this._selector
            },
            setup: function() {
                return true
            },
            add: function(element, handleObj) {
                if (this._handlerCount <= 0 || this.noBubble) {
                    element = this.noBubble ? element : domAdapter.getDocument();
                    this._setSelector(handleObj);
                    var that = this;
                    eventsEngine.on(element, this._originalEvents, this._getSelector(), function(e) {
                        that._handler(e)
                    })
                }
                if (!this.noBubble) {
                    this._handlerCount++
                }
            },
            remove: function(handleObj) {
                this._setSelector(handleObj);
                if (!this.noBubble) {
                    this._handlerCount--
                }
            },
            teardown: function(element) {
                if (this._handlerCount && !this.noBubble) {
                    return
                }
                element = this.noBubble ? element : domAdapter.getDocument();
                if (this._originalEvents !== "." + POINTER_EVENTS_NAMESPACE) {
                    eventsEngine.off(element, this._originalEvents, this._getSelector())
                }
            },
            dispose: function(element) {
                element = this.noBubble ? element : domAdapter.getDocument();
                eventsEngine.off(element, this._originalEvents)
            }
        });
        module.exports = BaseStrategy
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/data/array_query.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Class = __webpack_require__( /*! ../core/class */ 16);
        var typeUtils = __webpack_require__( /*! ../core/utils/type */ 1);
        var iteratorUtils = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var compileGetter = __webpack_require__( /*! ../core/utils/data */ 20).compileGetter;
        var toComparable = __webpack_require__( /*! ../core/utils/data */ 20).toComparable;
        var Deferred = __webpack_require__( /*! ../core/utils/deferred */ 6).Deferred;
        var errorsModule = __webpack_require__( /*! ./errors */ 38);
        var dataUtils = __webpack_require__( /*! ./utils */ 42);
        var Iterator = Class.inherit({
            toArray: function() {
                var result = [];
                this.reset();
                while (this.next()) {
                    result.push(this.current())
                }
                return result
            },
            countable: function() {
                return false
            }
        });
        var ArrayIterator = Iterator.inherit({
            ctor: function(array) {
                this.array = array;
                this.index = -1
            },
            next: function() {
                if (this.index + 1 < this.array.length) {
                    this.index++;
                    return true
                }
                return false
            },
            current: function() {
                return this.array[this.index]
            },
            reset: function() {
                this.index = -1
            },
            toArray: function() {
                return this.array.slice(0)
            },
            countable: function() {
                return true
            },
            count: function() {
                return this.array.length
            }
        });
        var WrappedIterator = Iterator.inherit({
            ctor: function(iter) {
                this.iter = iter
            },
            next: function() {
                return this.iter.next()
            },
            current: function() {
                return this.iter.current()
            },
            reset: function() {
                return this.iter.reset()
            }
        });
        var MapIterator = WrappedIterator.inherit({
            ctor: function(iter, mapper) {
                this.callBase(iter);
                this.index = -1;
                this.mapper = mapper
            },
            current: function() {
                return this.mapper(this.callBase(), this.index)
            },
            next: function() {
                var hasNext = this.callBase();
                if (hasNext) {
                    this.index++
                }
                return hasNext
            }
        });
        var defaultCompare = function(xValue, yValue) {
            xValue = toComparable(xValue);
            yValue = toComparable(yValue);
            if (null === xValue && null !== yValue) {
                return -1
            }
            if (null !== xValue && null === yValue) {
                return 1
            }
            if (void 0 === xValue && void 0 !== yValue) {
                return 1
            }
            if (void 0 !== xValue && void 0 === yValue) {
                return -1
            }
            if (xValue < yValue) {
                return -1
            }
            if (xValue > yValue) {
                return 1
            }
            return 0
        };
        var SortIterator = Iterator.inherit({
            ctor: function(iter, getter, desc, compare) {
                if (!(iter instanceof MapIterator)) {
                    iter = new MapIterator(iter, this._wrap)
                }
                this.iter = iter;
                this.rules = [{
                    getter: getter,
                    desc: desc,
                    compare: compare
                }]
            },
            thenBy: function(getter, desc, compare) {
                var result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);
                if (!this.sortedIter) {
                    result.rules = this.rules.concat(result.rules)
                }
                return result
            },
            next: function() {
                this._ensureSorted();
                return this.sortedIter.next()
            },
            current: function() {
                this._ensureSorted();
                return this.sortedIter.current()
            },
            reset: function() {
                delete this.sortedIter
            },
            countable: function() {
                return this.sortedIter || this.iter.countable()
            },
            count: function() {
                if (this.sortedIter) {
                    return this.sortedIter.count()
                }
                return this.iter.count()
            },
            _ensureSorted: function() {
                var that = this;
                if (that.sortedIter) {
                    return
                }
                iteratorUtils.each(that.rules, function() {
                    this.getter = compileGetter(this.getter)
                });
                that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
                    return that._compare(x, y)
                })), that._unwrap)
            },
            _wrap: function(record, index) {
                return {
                    index: index,
                    value: record
                }
            },
            _unwrap: function(wrappedItem) {
                return wrappedItem.value
            },
            _compare: function(x, y) {
                var xIndex = x.index;
                var yIndex = y.index;
                x = x.value;
                y = y.value;
                if (x === y) {
                    return xIndex - yIndex
                }
                for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
                    var rule = this.rules[i];
                    var xValue = rule.getter(x);
                    var yValue = rule.getter(y);
                    var compare = rule.compare || defaultCompare;
                    var compareResult = compare(xValue, yValue);
                    if (compareResult) {
                        return rule.desc ? -compareResult : compareResult
                    }
                }
                return xIndex - yIndex
            }
        });
        var compileCriteria = function() {
            var compileGroup = function(crit) {
                var ops = [];
                var isConjunctiveOperator = false;
                var isConjunctiveNextOperator = false;
                iteratorUtils.each(crit, function() {
                    if (Array.isArray(this) || typeUtils.isFunction(this)) {
                        if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {
                            throw new errorsModule.errors.Error("E4019")
                        }
                        ops.push(compileCriteria(this));
                        isConjunctiveOperator = isConjunctiveNextOperator;
                        isConjunctiveNextOperator = true
                    } else {
                        isConjunctiveNextOperator = dataUtils.isConjunctiveOperator(this)
                    }
                });
                return function(d) {
                    var result = isConjunctiveOperator;
                    for (var i = 0; i < ops.length; i++) {
                        if (ops[i](d) !== isConjunctiveOperator) {
                            result = !isConjunctiveOperator;
                            break
                        }
                    }
                    return result
                }
            };
            var toString = function(value) {
                return typeUtils.isDefined(value) ? value.toString() : ""
            };
            var compileBinary = function(crit) {
                crit = dataUtils.normalizeBinaryCriterion(crit);
                var getter = compileGetter(crit[0]);
                var op = crit[1];
                var value = crit[2];
                value = toComparable(value);
                switch (op.toLowerCase()) {
                    case "=":
                        return compileEquals(getter, value);
                    case "<>":
                        return compileEquals(getter, value, true);
                    case ">":
                        return function(obj) {
                            return toComparable(getter(obj)) > value
                        };
                    case "<":
                        return function(obj) {
                            return toComparable(getter(obj)) < value
                        };
                    case ">=":
                        return function(obj) {
                            return toComparable(getter(obj)) >= value
                        };
                    case "<=":
                        return function(obj) {
                            return toComparable(getter(obj)) <= value
                        };
                    case "startswith":
                        return function(obj) {
                            return 0 === toComparable(toString(getter(obj))).indexOf(value)
                        };
                    case "endswith":
                        return function(obj) {
                            var getterValue = toComparable(toString(getter(obj)));
                            var searchValue = toString(value);
                            if (getterValue.length < searchValue.length) {
                                return false
                            }
                            return getterValue.lastIndexOf(value) === getterValue.length - value.length
                        };
                    case "contains":
                        return function(obj) {
                            return toComparable(toString(getter(obj))).indexOf(value) > -1
                        };
                    case "notcontains":
                        return function(obj) {
                            return toComparable(toString(getter(obj))).indexOf(value) === -1
                        }
                }
                throw errorsModule.errors.Error("E4003", op)
            };

            function compileEquals(getter, value, negate) {
                return function(obj) {
                    obj = toComparable(getter(obj));
                    var result = useStrictComparison(value) ? obj === value : obj == value;
                    if (negate) {
                        result = !result
                    }
                    return result
                }
            }

            function useStrictComparison(value) {
                return "" === value || 0 === value || false === value
            }

            function compileUnary(crit) {
                var op = crit[0];
                var criteria = compileCriteria(crit[1]);
                if ("!" === op) {
                    return function(obj) {
                        return !criteria(obj)
                    }
                }
                throw errorsModule.errors.Error("E4003", op)
            }
            return function(crit) {
                if (typeUtils.isFunction(crit)) {
                    return crit
                }
                if (dataUtils.isGroupCriterion(crit)) {
                    return compileGroup(crit)
                }
                if (dataUtils.isUnaryOperation(crit)) {
                    return compileUnary(crit)
                }
                return compileBinary(crit)
            }
        }();
        var FilterIterator = WrappedIterator.inherit({
            ctor: function(iter, criteria) {
                this.callBase(iter);
                this.criteria = compileCriteria(criteria)
            },
            next: function() {
                while (this.iter.next()) {
                    if (this.criteria(this.current())) {
                        return true
                    }
                }
                return false
            }
        });
        var GroupIterator = Iterator.inherit({
            ctor: function(iter, getter) {
                this.iter = iter;
                this.getter = getter
            },
            next: function() {
                this._ensureGrouped();
                return this.groupedIter.next()
            },
            current: function() {
                this._ensureGrouped();
                return this.groupedIter.current()
            },
            reset: function() {
                delete this.groupedIter
            },
            countable: function() {
                return !!this.groupedIter
            },
            count: function() {
                return this.groupedIter.count()
            },
            _ensureGrouped: function() {
                if (this.groupedIter) {
                    return
                }
                var hash = {};
                var keys = [];
                var iter = this.iter;
                var getter = compileGetter(this.getter);
                iter.reset();
                while (iter.next()) {
                    var current = iter.current();
                    var key = getter(current);
                    if (key in hash) {
                        hash[key].push(current)
                    } else {
                        hash[key] = [current];
                        keys.push(key)
                    }
                }
                this.groupedIter = new ArrayIterator(iteratorUtils.map(keys, function(key) {
                    return {
                        key: key,
                        items: hash[key]
                    }
                }))
            }
        });
        var SelectIterator = WrappedIterator.inherit({
            ctor: function(iter, getter) {
                this.callBase(iter);
                this.getter = compileGetter(getter)
            },
            current: function() {
                return this.getter(this.callBase())
            },
            countable: function() {
                return this.iter.countable()
            },
            count: function() {
                return this.iter.count()
            }
        });
        var SliceIterator = WrappedIterator.inherit({
            ctor: function(iter, skip, take) {
                this.callBase(iter);
                this.skip = Math.max(0, skip);
                this.take = Math.max(0, take);
                this.pos = 0
            },
            next: function() {
                if (this.pos >= this.skip + this.take) {
                    return false
                }
                while (this.pos < this.skip && this.iter.next()) {
                    this.pos++
                }
                this.pos++;
                return this.iter.next()
            },
            reset: function() {
                this.callBase();
                this.pos = 0
            },
            countable: function() {
                return this.iter.countable()
            },
            count: function() {
                return Math.min(this.iter.count() - this.skip, this.take)
            }
        });
        var arrayQueryImpl = function arrayQueryImpl(iter, queryOptions) {
            queryOptions = queryOptions || {};
            if (!(iter instanceof Iterator)) {
                iter = new ArrayIterator(iter)
            }
            var handleError = function(error) {
                var handler = queryOptions.errorHandler;
                if (handler) {
                    handler(error)
                }
                errorsModule._errorHandler(error)
            };
            var aggregateCore = function(aggregator) {
                var d = (new Deferred).fail(handleError);
                var seed;
                var step = aggregator.step;
                var finalize = aggregator.finalize;
                try {
                    iter.reset();
                    if ("seed" in aggregator) {
                        seed = aggregator.seed
                    } else {
                        seed = iter.next() ? iter.current() : NaN
                    }
                    var accumulator = seed;
                    while (iter.next()) {
                        accumulator = step(accumulator, iter.current())
                    }
                    d.resolve(finalize ? finalize(accumulator) : accumulator)
                } catch (x) {
                    d.reject(x)
                }
                return d.promise()
            };
            var aggregate = function(seed, step, finalize) {
                if (arguments.length < 2) {
                    return aggregateCore({
                        step: arguments[0]
                    })
                }
                return aggregateCore({
                    seed: seed,
                    step: step,
                    finalize: finalize
                })
            };
            var standardAggregate = function(name) {
                return aggregateCore(dataUtils.aggregators[name])
            };
            var select = function(getter) {
                if (!typeUtils.isFunction(getter) && !Array.isArray(getter)) {
                    getter = [].slice.call(arguments)
                }
                return chainQuery(new SelectIterator(iter, getter))
            };
            var selectProp = function(name) {
                return select(compileGetter(name))
            };

            function chainQuery(iter) {
                return arrayQueryImpl(iter, queryOptions)
            }
            return {
                toArray: function() {
                    return iter.toArray()
                },
                enumerate: function() {
                    var d = (new Deferred).fail(handleError);
                    try {
                        d.resolve(iter.toArray())
                    } catch (x) {
                        d.reject(x)
                    }
                    return d.promise()
                },
                sortBy: function(getter, desc, compare) {
                    return chainQuery(new SortIterator(iter, getter, desc, compare))
                },
                thenBy: function(getter, desc, compare) {
                    if (iter instanceof SortIterator) {
                        return chainQuery(iter.thenBy(getter, desc, compare))
                    }
                    throw errorsModule.errors.Error("E4004")
                },
                filter: function(criteria) {
                    if (!Array.isArray(criteria)) {
                        criteria = [].slice.call(arguments)
                    }
                    return chainQuery(new FilterIterator(iter, criteria))
                },
                slice: function(skip, take) {
                    if (void 0 === take) {
                        take = Number.MAX_VALUE
                    }
                    return chainQuery(new SliceIterator(iter, skip, take))
                },
                select: select,
                groupBy: function(getter) {
                    return chainQuery(new GroupIterator(iter, getter))
                },
                aggregate: aggregate,
                count: function() {
                    if (iter.countable()) {
                        var d = (new Deferred).fail(handleError);
                        try {
                            d.resolve(iter.count())
                        } catch (x) {
                            d.reject(x)
                        }
                        return d.promise()
                    }
                    return standardAggregate("count")
                },
                sum: function(getter) {
                    if (getter) {
                        return selectProp(getter).sum()
                    }
                    return standardAggregate("sum")
                },
                min: function(getter) {
                    if (getter) {
                        return selectProp(getter).min()
                    }
                    return standardAggregate("min")
                },
                max: function(getter) {
                    if (getter) {
                        return selectProp(getter).max()
                    }
                    return standardAggregate("max")
                },
                avg: function(getter) {
                    if (getter) {
                        return selectProp(getter).avg()
                    }
                    return standardAggregate("avg")
                }
            }
        };
        module.exports = arrayQueryImpl
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/data/odata/query_adapter.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.odata = void 0;
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _config = __webpack_require__( /*! ../../core/config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _query_adapters = __webpack_require__( /*! ../query_adapters */ 190);
        var _query_adapters2 = _interopRequireDefault(_query_adapters);
        var _utils = __webpack_require__( /*! ./utils */ 96);
        var _errors = __webpack_require__( /*! ../errors */ 38);
        var _utils2 = __webpack_require__( /*! ../utils */ 42);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var DEFAULT_PROTOCOL_VERSION = 2;
        var STRING_FUNCTIONS = ["contains", "notcontains", "startswith", "endswith"];
        var compileCriteria = function() {
            var protocolVersion;
            var forceLowerCase;
            var fieldTypes;
            var createBinaryOperationFormatter = function(op) {
                return function(prop, val) {
                    return "".concat(prop, " ").concat(op, " ").concat(val)
                }
            };
            var createStringFuncFormatter = function(op, reverse) {
                return function(prop, val) {
                    var bag = [op, "("];
                    if (forceLowerCase) {
                        prop = prop.indexOf("tolower(") === -1 ? "tolower(".concat(prop, ")") : prop;
                        val = val.toLowerCase()
                    }
                    if (reverse) {
                        bag.push(val, ",", prop)
                    } else {
                        bag.push(prop, ",", val)
                    }
                    bag.push(")");
                    return bag.join("")
                }
            };
            var isStringFunction = function(name) {
                return STRING_FUNCTIONS.some(function(funcName) {
                    return funcName === name
                })
            };
            var formatters = {
                "=": createBinaryOperationFormatter("eq"),
                "<>": createBinaryOperationFormatter("ne"),
                ">": createBinaryOperationFormatter("gt"),
                ">=": createBinaryOperationFormatter("ge"),
                "<": createBinaryOperationFormatter("lt"),
                "<=": createBinaryOperationFormatter("le"),
                startswith: createStringFuncFormatter("startswith"),
                endswith: createStringFuncFormatter("endswith")
            };
            var formattersV2 = (0, _extend.extend)({}, formatters, {
                contains: createStringFuncFormatter("substringof", true),
                notcontains: createStringFuncFormatter("not substringof", true)
            });
            var formattersV4 = (0, _extend.extend)({}, formatters, {
                contains: createStringFuncFormatter("contains"),
                notcontains: createStringFuncFormatter("not contains")
            });
            var compileBinary = function(criteria) {
                var _fieldTypes;
                criteria = (0, _utils2.normalizeBinaryCriterion)(criteria);
                var op = criteria[1];
                var fieldName = criteria[0];
                var fieldType = fieldTypes && fieldTypes[fieldName];
                if (fieldType && isStringFunction(op) && "String" !== fieldType) {
                    throw new _errors.errors.Error("E4024", op, fieldName, fieldType)
                }
                var formatters = 4 === protocolVersion ? formattersV4 : formattersV2;
                var formatter = formatters[op.toLowerCase()];
                if (!formatter) {
                    throw _errors.errors.Error("E4003", op)
                }
                var value = criteria[2];
                if (null === (_fieldTypes = fieldTypes) || void 0 === _fieldTypes ? void 0 : _fieldTypes[fieldName]) {
                    value = (0, _utils.convertPrimitiveValue)(fieldTypes[fieldName], value)
                }
                return formatter((0, _utils.serializePropName)(fieldName), (0, _utils.serializeValue)(value, protocolVersion))
            };
            var compileUnary = function(criteria) {
                var op = criteria[0];
                var crit = compileCore(criteria[1]);
                if ("!" === op) {
                    return "not (".concat(crit, ")")
                }
                throw _errors.errors.Error("E4003", op)
            };
            var compileGroup = function(criteria) {
                var bag = [];
                var groupOperator;
                var nextGroupOperator;
                (0, _iterator.each)(criteria, function(index, criterion) {
                    if (Array.isArray(criterion)) {
                        if (bag.length > 1 && groupOperator !== nextGroupOperator) {
                            throw new _errors.errors.Error("E4019")
                        }
                        bag.push("(".concat(compileCore(criterion), ")"));
                        groupOperator = nextGroupOperator;
                        nextGroupOperator = "and"
                    } else {
                        nextGroupOperator = (0, _utils2.isConjunctiveOperator)(this) ? "and" : "or"
                    }
                });
                return bag.join(" ".concat(groupOperator, " "))
            };
            var compileCore = function(criteria) {
                if (Array.isArray(criteria[0])) {
                    return compileGroup(criteria)
                }
                if ((0, _utils2.isUnaryOperation)(criteria)) {
                    return compileUnary(criteria)
                }
                return compileBinary(criteria)
            };
            return function(criteria, version, types, filterToLower) {
                fieldTypes = types;
                forceLowerCase = null !== filterToLower && void 0 !== filterToLower ? filterToLower : (0, _config2.default)().oDataFilterToLower;
                protocolVersion = version;
                return compileCore(criteria)
            }
        }();
        var createODataQueryAdapter = function(queryOptions) {
            var _sorting = [];
            var _criteria = [];
            var _expand = queryOptions.expand;
            var _select;
            var _skip;
            var _take;
            var _countQuery;
            var _oDataVersion = queryOptions.version || DEFAULT_PROTOCOL_VERSION;
            var hasSlice = function() {
                return _skip || void 0 !== _take
            };
            var hasFunction = function hasFunction(criterion) {
                for (var i = 0; i < criterion.length; i++) {
                    if ((0, _type.isFunction)(criterion[i])) {
                        return true
                    }
                    if (Array.isArray(criterion[i]) && hasFunction(criterion[i])) {
                        return true
                    }
                }
                return false
            };
            var requestData = function() {
                var result = {};
                if (!_countQuery) {
                    if (_sorting.length) {
                        result.$orderby = _sorting.join(",")
                    }
                    if (_skip) {
                        result.$skip = _skip
                    }
                    if (void 0 !== _take) {
                        result.$top = _take
                    }
                    result.$select = (0, _utils.generateSelect)(_oDataVersion, _select) || void 0;
                    result.$expand = (0, _utils.generateExpand)(_oDataVersion, _expand, _select) || void 0
                }
                if (_criteria.length) {
                    var criteria = _criteria.length < 2 ? _criteria[0] : _criteria;
                    var fieldTypes = null === queryOptions || void 0 === queryOptions ? void 0 : queryOptions.fieldTypes;
                    var filterToLower = null === queryOptions || void 0 === queryOptions ? void 0 : queryOptions.filterToLower;
                    result.$filter = compileCriteria(criteria, _oDataVersion, fieldTypes, filterToLower)
                }
                if (_countQuery) {
                    result.$top = 0
                }
                if (queryOptions.requireTotalCount || _countQuery) {
                    if (4 !== _oDataVersion) {
                        result.$inlinecount = "allpages"
                    } else {
                        result.$count = "true"
                    }
                }
                return result
            };
            var tryLiftSelect = function(tasks) {
                var selectIndex = -1;
                for (var i = 0; i < tasks.length; i++) {
                    if ("select" === tasks[i].name) {
                        selectIndex = i;
                        break
                    }
                }
                if (selectIndex < 0 || !(0, _type.isFunction)(tasks[selectIndex].args[0])) {
                    return
                }
                var nextTask = tasks[1 + selectIndex];
                if (!nextTask || "slice" !== nextTask.name) {
                    return
                }
                tasks[1 + selectIndex] = tasks[selectIndex];
                tasks[selectIndex] = nextTask
            };
            return {
                optimize: tryLiftSelect,
                exec: function(url) {
                    return (0, _utils.sendRequest)(_oDataVersion, {
                        url: url,
                        params: (0, _extend.extend)(requestData(), null === queryOptions || void 0 === queryOptions ? void 0 : queryOptions.params)
                    }, {
                        beforeSend: queryOptions.beforeSend,
                        jsonp: queryOptions.jsonp,
                        withCredentials: queryOptions.withCredentials,
                        countOnly: _countQuery,
                        deserializeDates: queryOptions.deserializeDates,
                        fieldTypes: queryOptions.fieldTypes,
                        isPaged: isFinite(_take)
                    })
                },
                multiSort: function(args) {
                    var rules;
                    if (hasSlice()) {
                        return false
                    }
                    for (var i = 0; i < args.length; i++) {
                        var getter = args[i][0];
                        var desc = !!args[i][1];
                        var rule = void 0;
                        if ("string" !== typeof getter) {
                            return false
                        }
                        rule = (0, _utils.serializePropName)(getter);
                        if (desc) {
                            rule += " desc"
                        }
                        rules = rules || [];
                        rules.push(rule)
                    }
                    _sorting = rules
                },
                slice: function(skipCount, takeCount) {
                    if (hasSlice()) {
                        return false
                    }
                    _skip = skipCount;
                    _take = takeCount
                },
                filter: function(criterion) {
                    if (hasSlice()) {
                        return false
                    }
                    if (!Array.isArray(criterion)) {
                        criterion = [].slice.call(arguments)
                    }
                    if (hasFunction(criterion)) {
                        return false
                    }
                    if (_criteria.length) {
                        _criteria.push("and")
                    }
                    _criteria.push(criterion)
                },
                select: function(expr) {
                    if (_select || (0, _type.isFunction)(expr)) {
                        return false
                    }
                    if (!Array.isArray(expr)) {
                        expr = [].slice.call(arguments)
                    }
                    _select = expr
                },
                count: function() {
                    return _countQuery = true
                }
            }
        };
        _query_adapters2.default.odata = createODataQueryAdapter;
        exports.odata = createODataQueryAdapter
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/renderers/renderer.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _dom_adapter = __webpack_require__( /*! ../../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _window = __webpack_require__( /*! ../../../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _call_once = __webpack_require__( /*! ../../../core/utils/call_once */ 80);
        var _call_once2 = _interopRequireDefault(_call_once);
        var _events_engine = __webpack_require__( /*! ../../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _browser = __webpack_require__( /*! ../../../core/utils/browser */ 26);
        var _browser2 = _interopRequireDefault(_browser);
        var _svg = __webpack_require__( /*! ../../../core/utils/svg */ 216);
        var _animation = __webpack_require__( /*! ./animation */ 815);
        var _animation2 = _interopRequireDefault(_animation);
        var _utils = __webpack_require__( /*! ../utils */ 13);
        var _type = __webpack_require__( /*! ../../../core/utils/type */ 1);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest()
        }

        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) {
                return
            }
            if ("string" === typeof o) {
                return _arrayLikeToArray(o, minLen)
            }
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if ("Object" === n && o.constructor) {
                n = o.constructor.name
            }
            if ("Map" === n || "Set" === n) {
                return Array.from(o)
            }
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return _arrayLikeToArray(o, minLen)
            }
        }

        function _arrayLikeToArray(arr, len) {
            if (null == len || len > arr.length) {
                len = arr.length
            }
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
            }
            return arr2
        }

        function _iterableToArrayLimit(arr, i) {
            if ("undefined" === typeof Symbol || !(Symbol.iterator in Object(arr))) {
                return
            }
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) {
                        break
                    }
                }
            } catch (err) {
                _d = true;
                _e = err
            } finally {
                try {
                    if (!_n && null != _i.return) {
                        _i.return()
                    }
                } finally {
                    if (_d) {
                        throw _e
                    }
                }
            }
            return _arr
        }

        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) {
                return arr
            }
        }
        var window = _window2.default.getWindow();
        var max = Math.max,
            min = Math.min,
            floor = Math.floor,
            round = Math.round,
            sin = Math.sin,
            cos = Math.cos,
            abs = Math.abs,
            PI = Math.PI;
        var PI_DIV_180 = PI / 180;
        var SHARPING_CORRECTION = .5;
        var ARC_COORD_PREC = 5;
        var pxAddingExceptions = {
            "column-count": true,
            "fill-opacity": true,
            "flex-grow": true,
            "flex-shrink": true,
            "font-weight": true,
            "line-height": true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            "z-index": true,
            zoom: true
        };
        var KEY_TEXT = "text";
        var KEY_STROKE = "stroke";
        var KEY_STROKE_WIDTH = "stroke-width";
        var KEY_STROKE_OPACITY = "stroke-opacity";
        var KEY_FONT_SIZE = "font-size";
        var KEY_FONT_STYLE = "font-style";
        var KEY_FONT_WEIGHT = "font-weight";
        var KEY_TEXT_DECORATION = "text-decoration";
        var KEY_TEXTS_ALIGNMENT = "textsAlignment";
        var NONE = "none";
        var DEFAULT_FONT_SIZE = 12;
        var ELLIPSIS = "...";
        var objectCreate = function() {
            if (!Object.create) {
                return function(proto) {
                    var F = function() {};
                    F.prototype = proto;
                    return new F
                }
            } else {
                return function(proto) {
                    return Object.create(proto)
                }
            }
        }();
        var DEFAULTS = {
            scaleX: 1,
            scaleY: 1,
            "pointer-events": null
        };
        var getBackup = (0, _call_once2.default)(function() {
            var backupContainer = _dom_adapter2.default.createElement("div");
            var backupCounter = 0;
            backupContainer.style.left = "-9999px";
            backupContainer.style.position = "absolute";
            return {
                backupContainer: backupContainer,
                backupCounter: backupCounter
            }
        });

        function backupRoot(root) {
            if (0 === getBackup().backupCounter) {
                _dom_adapter2.default.getBody().appendChild(getBackup().backupContainer)
            }++getBackup().backupCounter;
            root.append({
                element: getBackup().backupContainer
            })
        }

        function restoreRoot(root, container) {
            root.append({
                element: container
            });
            --getBackup().backupCounter;
            if (0 === getBackup().backupCounter) {
                _dom_adapter2.default.getBody().removeChild(getBackup().backupContainer)
            }
        }
        var getNextDefsSvgId = function() {
            var numDefsSvgElements = 1;
            return function() {
                return "DevExpress_" + numDefsSvgElements++
            }
        }();

        function isObjectArgument(value) {
            return value && "string" !== typeof value
        }

        function createElement(tagName) {
            return _dom_adapter2.default.createElementNS("http://www.w3.org/2000/svg", tagName)
        }

        function getFuncIri(id, pathModified) {
            return null !== id ? "url(" + (pathModified ? window.location.href.split("#")[0] : "") + "#" + id + ")" : id
        }
        module.exports.getFuncIri = getFuncIri;

        function extend(target, source) {
            var key;
            for (key in source) {
                target[key] = source[key]
            }
            return target
        }

        function roundValue(value, exp) {
            value = value.toString().split("e");
            value = round(+(value[0] + "e" + (value[1] ? +value[1] + exp : exp)));
            value = value.toString().split("e");
            return +(value[0] + "e" + (value[1] ? +value[1] - exp : -exp))
        }

        function getBoundingClientRect(element) {
            var box;
            try {
                box = element.getBoundingClientRect()
            } catch (e) {}
            return box || {
                left: 0,
                top: 0
            }
        }
        var preserveAspectRatioMap = {
            full: NONE,
            lefttop: "xMinYMin",
            leftcenter: "xMinYMid",
            leftbottom: "xMinYMax",
            centertop: "xMidYMin",
            center: "xMidYMid",
            centerbottom: "xMidYMax",
            righttop: "xMaxYMin",
            rightcenter: "xMaxYMid",
            rightbottom: "xMaxYMax"
        };

        function processHatchingAttrs(element, attrs) {
            if (attrs.hatching && "none" !== (0, _utils.normalizeEnum)(attrs.hatching.direction)) {
                attrs = extend({}, attrs);
                attrs.fill = element._hatching = element.renderer.lockHatching(attrs.fill, attrs.hatching, element._hatching);
                delete attrs.hatching
            } else {
                if (element._hatching) {
                    element.renderer.releaseHatching(element._hatching);
                    element._hatching = null
                }
            }
            return attrs
        }
        module.exports.processHatchingAttrs = processHatchingAttrs;

        function normalizeArcParams(x, y, innerR, outerR, startAngle, endAngle) {
            var isCircle;
            var noArc = true;
            var angleDiff = roundValue(endAngle, 3) - roundValue(startAngle, 3);
            if (angleDiff) {
                if (abs(angleDiff) % 360 === 0) {
                    startAngle = 0;
                    endAngle = 360;
                    isCircle = true;
                    endAngle -= .01
                }
                if (startAngle > 360) {
                    startAngle %= 360
                }
                if (endAngle > 360) {
                    endAngle %= 360
                }
                if (startAngle > endAngle) {
                    startAngle -= 360
                }
                noArc = false
            }
            startAngle *= PI_DIV_180;
            endAngle *= PI_DIV_180;
            return [x, y, min(outerR, innerR), max(outerR, innerR), cos(startAngle), sin(startAngle), cos(endAngle), sin(endAngle), isCircle, floor(abs(endAngle - startAngle) / PI) % 2 ? "1" : "0", noArc]
        }
        var buildArcPath = function(x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag) {
            return ["M", (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC), "A", outerR.toFixed(ARC_COORD_PREC), outerR.toFixed(ARC_COORD_PREC), 0, longFlag, 0, (x + outerR * endAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * endAngleSin).toFixed(ARC_COORD_PREC), isCircle ? "M" : "L", (x + innerR * endAngleCos).toFixed(5), (y - innerR * endAngleSin).toFixed(ARC_COORD_PREC), "A", innerR.toFixed(ARC_COORD_PREC), innerR.toFixed(ARC_COORD_PREC), 0, longFlag, 1, (x + innerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - innerR * startAngleSin).toFixed(ARC_COORD_PREC), "Z"].join(" ")
        };

        function buildPathSegments(points, type) {
            var list = [
                ["M", 0, 0]
            ];
            switch (type) {
                case "line":
                    list = buildLineSegments(points);
                    break;
                case "area":
                    list = buildLineSegments(points, true);
                    break;
                case "bezier":
                    list = buildCurveSegments(points);
                    break;
                case "bezierarea":
                    list = buildCurveSegments(points, true)
            }
            return list
        }

        function buildLineSegments(points, close) {
            return buildSegments(points, buildSimpleLineSegment, close)
        }

        function buildCurveSegments(points, close) {
            return buildSegments(points, buildSimpleCurveSegment, close)
        }

        function buildSegments(points, buildSimpleSegment, close) {
            var _points$;
            var i;
            var ii;
            var list = [];
            if (null === (_points$ = points[0]) || void 0 === _points$ ? void 0 : _points$.length) {
                for (i = 0, ii = points.length; i < ii; ++i) {
                    buildSimpleSegment(points[i], close, list)
                }
            } else {
                buildSimpleSegment(points, close, list)
            }
            return list
        }

        function buildSimpleLineSegment(points, close, list) {
            var i = 0;
            var k0 = list.length;
            var k = k0;
            var ii = (points || []).length;
            if (ii) {
                if (void 0 !== points[0].x) {
                    for (; i < ii;) {
                        list[k++] = ["L", points[i].x, points[i++].y]
                    }
                } else {
                    for (; i < ii;) {
                        list[k++] = ["L", points[i++], points[i++]]
                    }
                }
                list[k0][0] = "M"
            } else {
                list[k] = ["M", 0, 0]
            }
            close && list.push(["Z"]);
            return list
        }

        function buildSimpleCurveSegment(points, close, list) {
            var i;
            var k = list.length;
            var ii = (points || []).length;
            if (ii) {
                if (void 0 !== points[0].x) {
                    list[k++] = ["M", points[0].x, points[0].y];
                    for (i = 1; i < ii;) {
                        list[k++] = ["C", points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y]
                    }
                } else {
                    list[k++] = ["M", points[0], points[1]];
                    for (i = 2; i < ii;) {
                        list[k++] = ["C", points[i++], points[i++], points[i++], points[i++], points[i++], points[i++]]
                    }
                }
            } else {
                list[k] = ["M", 0, 0]
            }
            close && list.push(["Z"]);
            return list
        }

        function combinePathParam(segments) {
            var d = [];
            var k = 0;
            var i;
            var ii = segments.length;
            var segment;
            var j;
            var jj;
            for (i = 0; i < ii; ++i) {
                segment = segments[i];
                for (j = 0, jj = segment.length; j < jj; ++j) {
                    d[k++] = segment[j]
                }
            }
            return d.join(" ")
        }

        function compensateSegments(oldSegments, newSegments, type) {
            var oldLength = oldSegments.length;
            var newLength = newSegments.length;
            var i;
            var originalNewSegments;
            var makeEqualSegments = type.indexOf("area") !== -1 ? makeEqualAreaSegments : makeEqualLineSegments;
            if (0 === oldLength) {
                for (i = 0; i < newLength; i++) {
                    oldSegments.push(newSegments[i].slice(0))
                }
            } else {
                if (oldLength < newLength) {
                    makeEqualSegments(oldSegments, newSegments, type)
                } else {
                    if (oldLength > newLength) {
                        originalNewSegments = newSegments.slice(0);
                        makeEqualSegments(newSegments, oldSegments, type)
                    }
                }
            }
            return originalNewSegments
        }

        function prepareConstSegment(constSeg, type) {
            var x = constSeg[constSeg.length - 2];
            var y = constSeg[constSeg.length - 1];
            switch (type) {
                case "line":
                case "area":
                    constSeg[0] = "L";
                    break;
                case "bezier":
                case "bezierarea":
                    constSeg[0] = "C";
                    constSeg[1] = constSeg[3] = constSeg[5] = x;
                    constSeg[2] = constSeg[4] = constSeg[6] = y
            }
        }

        function makeEqualLineSegments(short, long, type) {
            var constSeg = short[short.length - 1].slice();
            var i = short.length;
            prepareConstSegment(constSeg, type);
            for (; i < long.length; i++) {
                short[i] = constSeg.slice(0)
            }
        }

        function makeEqualAreaSegments(short, long, type) {
            var i;
            var head;
            var shortLength = short.length;
            var longLength = long.length;
            var constsSeg1;
            var constsSeg2;
            if ((shortLength - 1) % 2 === 0 && (longLength - 1) % 2 === 0) {
                i = (shortLength - 1) / 2 - 1;
                head = short.slice(0, i + 1);
                constsSeg1 = head[head.length - 1].slice(0);
                constsSeg2 = short.slice(i + 1)[0].slice(0);
                prepareConstSegment(constsSeg1, type);
                prepareConstSegment(constsSeg2, type);
                for (var j = i; j < (longLength - 1) / 2 - 1; j++) {
                    short.splice(j + 1, 0, constsSeg1);
                    short.splice(j + 3, 0, constsSeg2)
                }
            }
        }

        function baseCss(that, styles) {
            var elemStyles = that._styles;
            var str = "";
            var key;
            var value;
            styles = styles || {};
            for (key in styles) {
                value = styles[key];
                if ((0, _type.isDefined)(value)) {
                    value += "number" === typeof value && !pxAddingExceptions[key] ? "px" : "";
                    elemStyles[key] = "" !== value ? value : null
                }
            }
            for (key in elemStyles) {
                value = elemStyles[key];
                if (value) {
                    str += key + ":" + value + ";"
                }
            }
            str && that.element.setAttribute("style", str);
            return that
        }

        function fixFuncIri(wrapper, attribute) {
            var element = wrapper.element;
            var id = wrapper.attr(attribute);
            if (id && id.indexOf("DevExpress") !== -1) {
                element.removeAttribute(attribute);
                element.setAttribute(attribute, getFuncIri(id, wrapper.renderer.pathModified))
            }
        }

        function baseAttr(that, attrs) {
            attrs = attrs || {};
            var settings = that._settings;
            var attributes = {};
            var key;
            var value;
            var elem = that.element;
            var renderer = that.renderer;
            var rtl = renderer.rtl;
            var hasTransformations;
            var recalculateDashStyle;
            var sw;
            var i;
            if (!isObjectArgument(attrs)) {
                if (attrs in settings) {
                    return settings[attrs]
                }
                if (attrs in DEFAULTS) {
                    return DEFAULTS[attrs]
                }
                return 0
            }
            extend(attributes, attrs);
            for (key in attributes) {
                value = attributes[key];
                if (void 0 === value) {
                    continue
                }
                settings[key] = value;
                if ("align" === key) {
                    key = "text-anchor";
                    value = {
                        left: rtl ? "end" : "start",
                        center: "middle",
                        right: rtl ? "start" : "end"
                    } [value] || null
                } else {
                    if ("dashStyle" === key) {
                        recalculateDashStyle = true;
                        continue
                    } else {
                        if (key === KEY_STROKE_WIDTH) {
                            recalculateDashStyle = true
                        } else {
                            if (value && ("fill" === key || "clip-path" === key || "filter" === key) && 0 === value.indexOf("DevExpress")) {
                                that._addFixIRICallback();
                                value = getFuncIri(value, renderer.pathModified)
                            } else {
                                if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y)|sharp|sharpDirection)$/i.test(key)) {
                                    hasTransformations = true;
                                    continue
                                } else {
                                    if (/^(x|y|d)$/i.test(key)) {
                                        hasTransformations = true
                                    }
                                }
                            }
                        }
                    }
                }
                if (null === value) {
                    elem.removeAttribute(key)
                } else {
                    elem.setAttribute(key, value)
                }
            }
            if (recalculateDashStyle && "dashStyle" in settings) {
                value = settings.dashStyle;
                sw = ("_originalSW" in that ? that._originalSW : settings[KEY_STROKE_WIDTH]) || 1;
                key = "stroke-dasharray";
                value = null === value ? "" : (0, _utils.normalizeEnum)(value);
                if ("" === value || "solid" === value || value === NONE) {
                    that.element.removeAttribute(key)
                } else {
                    value = value.replace(/longdash/g, "8,3,").replace(/dash/g, "4,3,").replace(/dot/g, "1,3,").replace(/,$/, "").split(",");
                    i = value.length;
                    while (i--) {
                        value[i] = parseInt(value[i]) * sw
                    }
                    that.element.setAttribute(key, value.join(","))
                }
            }
            if (hasTransformations) {
                that._applyTransformation()
            }
            return that
        }

        function pathAttr(attrs) {
            var that = this;
            var segments;
            if (isObjectArgument(attrs)) {
                attrs = extend({}, attrs);
                segments = attrs.segments;
                if ("points" in attrs) {
                    segments = buildPathSegments(attrs.points, that.type);
                    delete attrs.points
                }
                if (segments) {
                    attrs.d = combinePathParam(segments);
                    that.segments = segments;
                    delete attrs.segments
                }
            }
            return baseAttr(that, attrs)
        }

        function arcAttr(attrs) {
            var settings = this._settings;
            var x;
            var y;
            var innerRadius;
            var outerRadius;
            var startAngle;
            var endAngle;
            if (isObjectArgument(attrs)) {
                attrs = extend({}, attrs);
                if ("x" in attrs || "y" in attrs || "innerRadius" in attrs || "outerRadius" in attrs || "startAngle" in attrs || "endAngle" in attrs) {
                    settings.x = x = "x" in attrs ? attrs.x : settings.x;
                    delete attrs.x;
                    settings.y = y = "y" in attrs ? attrs.y : settings.y;
                    delete attrs.y;
                    settings.innerRadius = innerRadius = "innerRadius" in attrs ? attrs.innerRadius : settings.innerRadius;
                    delete attrs.innerRadius;
                    settings.outerRadius = outerRadius = "outerRadius" in attrs ? attrs.outerRadius : settings.outerRadius;
                    delete attrs.outerRadius;
                    settings.startAngle = startAngle = "startAngle" in attrs ? attrs.startAngle : settings.startAngle;
                    delete attrs.startAngle;
                    settings.endAngle = endAngle = "endAngle" in attrs ? attrs.endAngle : settings.endAngle;
                    delete attrs.endAngle;
                    attrs.d = buildArcPath.apply(null, normalizeArcParams(x, y, innerRadius, outerRadius, startAngle, endAngle))
                }
            }
            return baseAttr(this, attrs)
        }

        function rectAttr(attrs) {
            var that = this;
            var x;
            var y;
            var width;
            var height;
            var sw;
            var maxSW;
            var newSW;
            if (isObjectArgument(attrs)) {
                attrs = extend({}, attrs);
                if (void 0 !== attrs.x || void 0 !== attrs.y || void 0 !== attrs.width || void 0 !== attrs.height || void 0 !== attrs[KEY_STROKE_WIDTH]) {
                    void 0 !== attrs.x ? x = that._originalX = attrs.x : x = that._originalX || 0;
                    void 0 !== attrs.y ? y = that._originalY = attrs.y : y = that._originalY || 0;
                    void 0 !== attrs.width ? width = that._originalWidth = attrs.width : width = that._originalWidth || 0;
                    void 0 !== attrs.height ? height = that._originalHeight = attrs.height : height = that._originalHeight || 0;
                    void 0 !== attrs[KEY_STROKE_WIDTH] ? sw = that._originalSW = attrs[KEY_STROKE_WIDTH] : sw = that._originalSW;
                    maxSW = ~~((width < height ? width : height) / 2);
                    newSW = (sw || 0) < maxSW ? sw || 0 : maxSW;
                    attrs.x = x + newSW / 2;
                    attrs.y = y + newSW / 2;
                    attrs.width = width - newSW;
                    attrs.height = height - newSW;
                    ((sw || 0) !== newSW || !(0 === newSW && void 0 === sw)) && (attrs[KEY_STROKE_WIDTH] = newSW)
                }
                if ("sharp" in attrs) {
                    delete attrs.sharp
                }
            }
            return baseAttr(that, attrs)
        }

        function textAttr(attrs) {
            var that = this;
            var isResetRequired;
            if (!isObjectArgument(attrs)) {
                return baseAttr(that, attrs)
            }
            attrs = extend({}, attrs);
            var settings = that._settings;
            var wasStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);
            if (void 0 !== attrs[KEY_TEXT]) {
                settings[KEY_TEXT] = attrs[KEY_TEXT];
                delete attrs[KEY_TEXT];
                isResetRequired = true
            }
            if (void 0 !== attrs[KEY_STROKE]) {
                settings[KEY_STROKE] = attrs[KEY_STROKE];
                delete attrs[KEY_STROKE]
            }
            if (void 0 !== attrs[KEY_STROKE_WIDTH]) {
                settings[KEY_STROKE_WIDTH] = attrs[KEY_STROKE_WIDTH];
                delete attrs[KEY_STROKE_WIDTH]
            }
            if (void 0 !== attrs[KEY_STROKE_OPACITY]) {
                settings[KEY_STROKE_OPACITY] = attrs[KEY_STROKE_OPACITY];
                delete attrs[KEY_STROKE_OPACITY]
            }
            if (void 0 !== attrs[KEY_TEXTS_ALIGNMENT]) {
                alignTextNodes(that, attrs[KEY_TEXTS_ALIGNMENT]);
                delete attrs[KEY_TEXTS_ALIGNMENT]
            }
            var isStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);
            baseAttr(that, attrs);
            isResetRequired = isResetRequired || isStroked !== wasStroked && settings[KEY_TEXT];
            if (isResetRequired) {
                createTextNodes(that, settings.text, isStroked);
                that._hasEllipsis = false
            }
            if (isResetRequired || void 0 !== attrs.x || void 0 !== attrs.y) {
                locateTextNodes(that)
            }
            if (isStroked) {
                strokeTextNodes(that)
            }
            return that
        }

        function textCss(styles) {
            styles = styles || {};
            baseCss(this, styles);
            if (KEY_FONT_SIZE in styles) {
                locateTextNodes(this)
            }
            return this
        }

        function orderHtmlTree(list, line, node, parentStyle, parentClassName) {
            var style;
            var realStyle;
            var i;
            var ii;
            var nodes;
            if (void 0 !== node.wholeText) {
                list.push({
                    value: node.wholeText,
                    style: parentStyle,
                    className: parentClassName,
                    line: line,
                    height: parentStyle[KEY_FONT_SIZE] || 0
                })
            } else {
                if ("BR" === node.tagName) {
                    ++line
                } else {
                    if (_dom_adapter2.default.isElementNode(node)) {
                        extend(style = {}, parentStyle);
                        switch (node.tagName) {
                            case "B":
                            case "STRONG":
                                style[KEY_FONT_WEIGHT] = "bold";
                                break;
                            case "I":
                            case "EM":
                                style[KEY_FONT_STYLE] = "italic";
                                break;
                            case "U":
                                style[KEY_TEXT_DECORATION] = "underline"
                        }
                        realStyle = node.style;
                        realStyle.color && (style.fill = realStyle.color);
                        realStyle.fontSize && (style[KEY_FONT_SIZE] = realStyle.fontSize);
                        realStyle.fontStyle && (style[KEY_FONT_STYLE] = realStyle.fontStyle);
                        realStyle.fontWeight && (style[KEY_FONT_WEIGHT] = realStyle.fontWeight);
                        realStyle.textDecoration && (style[KEY_TEXT_DECORATION] = realStyle.textDecoration);
                        for (i = 0, nodes = node.childNodes, ii = nodes.length; i < ii; ++i) {
                            line = orderHtmlTree(list, line, nodes[i], style, node.className || parentClassName)
                        }
                    }
                }
            }
            return line
        }

        function adjustLineHeights(items) {
            var i;
            var ii;
            var currentItem = items[0];
            var item;
            for (i = 1, ii = items.length; i < ii; ++i) {
                item = items[i];
                if (item.line === currentItem.line) {
                    currentItem.height = maxLengthFontSize(currentItem.height, item.height);
                    currentItem.inherits = currentItem.inherits || 0 === parseFloat(item.height);
                    item.height = NaN
                } else {
                    currentItem = item
                }
            }
        }

        function removeExtraAttrs(html) {
            var findTagAttrs = /(?:(<[a-z0-9]+\s*))([\s\S]*?)(>|\/>)/gi;
            var findStyleAndClassAttrs = /(style|class)\s*=\s*(["'])(?:(?!\2).)*\2\s?/gi;
            return html.replace(findTagAttrs, function(allTagAttrs, p1, p2, p3) {
                p2 = (p2 && p2.match(findStyleAndClassAttrs) || []).map(function(str) {
                    return str
                }).join(" ");
                return p1 + p2 + p3
            })
        }

        function parseHTML(text) {
            var items = [];
            var div = _dom_adapter2.default.createElement("div");
            div.innerHTML = text.replace(/\r/g, "").replace(/\n/g, "<br/>");
            orderHtmlTree(items, 0, div, {}, "");
            adjustLineHeights(items);
            return items
        }

        function parseMultiline(text) {
            var texts = text.replace(/\r/g, "").split(/\n/g);
            var i = 0;
            var items = [];
            for (; i < texts.length; i++) {
                items.push({
                    value: texts[i].trim(),
                    height: 0,
                    line: i
                })
            }
            return items
        }

        function createTspans(items, element, fieldName) {
            var i;
            var ii;
            var item;
            for (i = 0, ii = items.length; i < ii; ++i) {
                item = items[i];
                item[fieldName] = createElement("tspan");
                item[fieldName].appendChild(_dom_adapter2.default.createTextNode(item.value));
                item.style && baseCss({
                    element: item[fieldName],
                    _styles: {}
                }, item.style);
                item.className && item[fieldName].setAttribute("class", item.className);
                element.appendChild(item[fieldName])
            }
        }

        function restoreText() {
            if (this._hasEllipsis) {
                this.attr({
                    text: this._settings.text
                })
            }
        }

        function applyEllipsis(maxWidth) {
            var that = this;
            var lines;
            var hasEllipsis = false;
            var i;
            var ii;
            var lineParts;
            var j;
            var jj;
            var text;
            restoreText.call(that);
            var ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);
            var ellipsisWidth = ellipsis.getBBox().width;
            if (that._getElementBBox().width > maxWidth) {
                if (maxWidth - ellipsisWidth < 0) {
                    maxWidth = 0
                } else {
                    maxWidth -= ellipsisWidth
                }
                lines = prepareLines(that.element, that._texts, maxWidth);
                for (i = 0, ii = lines.length; i < ii; ++i) {
                    lineParts = lines[i].parts;
                    if (1 === lines[i].commonLength) {
                        continue
                    }
                    for (j = 0, jj = lineParts.length; j < jj; ++j) {
                        text = lineParts[j];
                        if ((0, _type.isDefined)(text.endIndex)) {
                            setNewText(text, text.endIndex);
                            hasEllipsis = true
                        } else {
                            if (text.startBox > maxWidth) {
                                removeTextSpan(text)
                            }
                        }
                    }
                }
            }
            ellipsis.remove();
            that._hasEllipsis = hasEllipsis;
            return hasEllipsis
        }

        function cloneAndRemoveAttrs(node) {
            var clone;
            if (node) {
                clone = node.cloneNode();
                clone.removeAttribute("y");
                clone.removeAttribute("x")
            }
            return clone || node
        }

        function detachAndStoreTitleElements(element) {
            var titleElements = _dom_adapter2.default.querySelectorAll(element, "title");
            for (var i = 0; i < titleElements.length; i++) {
                element.removeChild(titleElements[i])
            }
            return function() {
                for (var _i = 0; _i < titleElements.length; _i++) {
                    element.appendChild(titleElements[_i])
                }
            }
        }

        function setMaxSize(maxWidth, maxHeight) {
            var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            var that = this;
            var lines = [];
            var textChanged = false;
            var textIsEmpty = false;
            var ellipsisMaxWidth = maxWidth;
            restoreText.call(that);
            var restoreTitleElement = detachAndStoreTitleElements(this.element);
            var ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);
            var ellipsisWidth = ellipsis.getBBox().width;
            var _that$_getElementBBox = that._getElementBBox(),
                width = _that$_getElementBBox.width,
                height = _that$_getElementBBox.height;
            if ((width || height) && (width > maxWidth || maxHeight && height > maxHeight)) {
                if (maxWidth - ellipsisWidth < 0) {
                    ellipsisMaxWidth = 0
                } else {
                    ellipsisMaxWidth -= ellipsisWidth
                }
                lines = applyOverflowRules(that.element, that._texts, maxWidth, ellipsisMaxWidth, options, maxHeight);
                lines = setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, parseFloat(this._getLineHeight()));
                this._texts = lines.reduce(function(texts, line) {
                    return texts.concat(line.parts)
                }, []).filter(function(t) {
                    return "" !== t.value
                }).map(function(t) {
                    t.stroke && t.tspan.parentNode.appendChild(t.stroke);
                    return t
                }).map(function(t) {
                    t.tspan.parentNode.appendChild(t.tspan);
                    return t
                });
                !this._texts.length && (this._texts = null);
                textChanged = true;
                if (this._texts) {
                    locateTextNodes(this)
                } else {
                    this.element.textContent = "";
                    textIsEmpty = true
                }
            }
            ellipsis.remove();
            that._hasEllipsis = textChanged;
            restoreTitleElement();
            return {
                rowCount: lines.length,
                textChanged: textChanged,
                textIsEmpty: textIsEmpty
            }
        }

        function getIndexForEllipsis(text, maxWidth, startBox, endBox) {
            var k;
            var kk;
            if (startBox <= maxWidth && endBox > maxWidth) {
                for (k = 1, kk = text.value.length; k <= kk; ++k) {
                    if (startBox + text.tspan.getSubStringLength(0, k) > maxWidth) {
                        return k - 1
                    }
                }
            }
        }

        function getTextWidth(text) {
            return text.value.length ? text.tspan.getSubStringLength(0, text.value.length) : 0
        }

        function prepareLines(element, texts, maxWidth) {
            var lines = [];
            var i;
            var ii;
            var text;
            var startBox;
            var endBox;
            if (texts) {
                for (i = 0, ii = texts.length; i < ii; ++i) {
                    text = texts[i];
                    if (!lines[text.line]) {
                        text.startBox = startBox = 0;
                        lines.push({
                            commonLength: text.value.length,
                            parts: [text]
                        })
                    } else {
                        text.startBox = startBox;
                        lines[text.line].parts.push(text);
                        lines[text.line].commonLength += text.value.length
                    }
                    endBox = startBox + text.tspan.getSubStringLength(0, text.value.length);
                    text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);
                    startBox = endBox
                }
            } else {
                text = {
                    value: element.textContent,
                    tspan: element
                };
                text.startBox = startBox = 0;
                endBox = startBox + getTextWidth(text);
                text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);
                lines = [{
                    commonLength: element.textContent.length,
                    parts: [text]
                }]
            }
            return lines
        }

        function getSpaceBreakIndex(text, maxWidth) {
            var initialIndices = text.startBox > 0 ? [0] : [];
            var spaceIndices = text.value.split("").reduce(function(indices, char, index) {
                if (" " === char) {
                    indices.push(index)
                }
                return indices
            }, initialIndices);
            var spaceIndex = 0;
            while (void 0 !== spaceIndices[spaceIndex + 1] && text.startBox + text.tspan.getSubStringLength(0, spaceIndices[spaceIndex + 1]) < maxWidth) {
                spaceIndex++
            }
            return spaceIndices[spaceIndex]
        }

        function getWordBreakIndex(text, maxWidth) {
            for (var i = 0; i < text.value.length - 1; i++) {
                if (text.startBox + text.tspan.getSubStringLength(0, i + 1) > maxWidth) {
                    return i
                }
            }
        }

        function getEllipsisString(ellipsisMaxWidth, _ref) {
            var hideOverflowEllipsis = _ref.hideOverflowEllipsis;
            return hideOverflowEllipsis && 0 === ellipsisMaxWidth ? "" : ELLIPSIS
        }

        function setEllipsis(text, ellipsisMaxWidth, options) {
            var ellipsis = getEllipsisString(ellipsisMaxWidth, options);
            if (text.value.length && text.tspan.parentNode) {
                for (var i = text.value.length - 1; i >= 1; i--) {
                    if (text.startBox + text.tspan.getSubStringLength(0, i) < ellipsisMaxWidth) {
                        setNewText(text, i, ellipsis);
                        break
                    } else {
                        if (1 === i) {
                            setNewText(text, 0, ellipsis)
                        }
                    }
                }
            }
        }

        function wordWrap(text, maxWidth, ellipsisMaxWidth, options) {
            var wholeText = text.value;
            var breakIndex;
            if ("none" !== options.wordWrap) {
                breakIndex = "normal" === options.wordWrap ? getSpaceBreakIndex(text, maxWidth) : getWordBreakIndex(text, maxWidth)
            }
            var restLines = [];
            var restText;
            if (isFinite(breakIndex)) {
                setNewText(text, breakIndex, "");
                var newTextOffset = " " === wholeText[breakIndex] ? 1 : 0;
                var restString = wholeText.slice(breakIndex + newTextOffset);
                if (restString.length) {
                    var restTspan = cloneAndRemoveAttrs(text.tspan);
                    restTspan.textContent = restString;
                    text.tspan.parentNode.appendChild(restTspan);
                    restText = extend(extend({}, text), {
                        value: restString,
                        startBox: 0,
                        height: 0,
                        tspan: restTspan,
                        stroke: cloneAndRemoveAttrs(text.stroke),
                        endBox: restTspan.getSubStringLength(0, restString.length)
                    });
                    restText.stroke && (restText.stroke.textContent = restString);
                    if (restText.endBox > maxWidth) {
                        restLines = wordWrap(restText, maxWidth, ellipsisMaxWidth, options);
                        if (!restLines.length) {
                            return []
                        }
                    }
                }
            }
            if (text.value.length) {
                if ("ellipsis" === options.textOverflow && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {
                    setEllipsis(text, ellipsisMaxWidth, options)
                }
                if ("hide" === options.textOverflow && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {
                    return []
                }
            } else {
                text.tspan.parentNode.removeChild(text.tspan)
            }
            var parts = [];
            if (restText) {
                parts.push(restText)
            }
            return [{
                commonLength: wholeText.length,
                parts: parts
            }].concat(restLines)
        }

        function calculateLineHeight(line, lineHeight) {
            return line.parts.reduce(function(height, text) {
                return max(height, getItemLineHeight(text, lineHeight))
            }, 0)
        }

        function setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, lineHeight) {
            var textOverflow = options.textOverflow;
            if (!isFinite(maxHeight) || 0 === Number(maxHeight) || "none" === textOverflow) {
                return lines
            }
            var result = lines.reduce(function(_ref2, l, index, arr) {
                var _ref3 = _slicedToArray(_ref2, 2),
                    lines = _ref3[0],
                    commonHeight = _ref3[1];
                var height = calculateLineHeight(l, lineHeight);
                commonHeight += height;
                if (commonHeight < maxHeight) {
                    lines.push(l)
                } else {
                    l.parts.forEach(function(item) {
                        removeTextSpan(item)
                    });
                    if ("ellipsis" === textOverflow) {
                        var prevLine = arr[index - 1];
                        if (prevLine) {
                            var text = prevLine.parts[prevLine.parts.length - 1];
                            if (!text.hasEllipsis) {
                                if (0 === ellipsisMaxWidth || text.endBox < ellipsisMaxWidth) {
                                    setNewText(text, text.value.length, getEllipsisString(ellipsisMaxWidth, options))
                                } else {
                                    setEllipsis(text, ellipsisMaxWidth, options)
                                }
                            }
                        }
                    }
                }
                return [lines, commonHeight]
            }, [
                [], 0
            ]);
            if ("hide" === textOverflow && result[1] > maxHeight) {
                result[0].forEach(function(l) {
                    l.parts.forEach(function(item) {
                        removeTextSpan(item)
                    })
                });
                return []
            }
            return result[0]
        }

        function applyOverflowRules(element, texts, maxWidth, ellipsisMaxWidth, options) {
            if (!texts) {
                var textValue = element.textContent;
                var text = {
                    value: textValue,
                    height: 0,
                    line: 0
                };
                element.textContent = "";
                createTspans([text], element, "tspan");
                texts = [text]
            }
            return texts.reduce(function(_ref4, text) {
                var _ref5 = _slicedToArray(_ref4, 5),
                    lines = _ref5[0],
                    startBox = _ref5[1],
                    endBox = _ref5[2],
                    stop = _ref5[3],
                    lineNumber = _ref5[4];
                var line = lines[lines.length - 1];
                if (stop) {
                    return [lines, startBox, endBox, stop]
                }
                if (!line || text.line !== lineNumber) {
                    text.startBox = startBox = 0;
                    lines.push({
                        commonLength: text.value.length,
                        parts: [text]
                    })
                } else {
                    text.startBox = startBox;
                    if (startBox > ellipsisMaxWidth && "none" === options.wordWrap && "ellipsis" === options.textOverflow) {
                        removeTextSpan(text);
                        return [lines, startBox, endBox, stop, lineNumber]
                    }
                    line.parts.push(text);
                    line.commonLength += text.value.length
                }
                text.endBox = endBox = startBox + getTextWidth(text);
                startBox = endBox;
                if ((0, _type.isDefined)(maxWidth) && endBox > maxWidth) {
                    var wordWrapLines = wordWrap(text, maxWidth, ellipsisMaxWidth, options);
                    if (!wordWrapLines.length) {
                        lines = [];
                        stop = true
                    } else {
                        lines = lines.concat(wordWrapLines.filter(function(l) {
                            return l.parts.length > 0
                        }))
                    }
                }
                return [lines, startBox, endBox, stop, text.line]
            }, [
                [], 0, 0, false, 0
            ])[0]
        }

        function setNewText(text, index) {
            var insertString = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ELLIPSIS;
            var newText = text.value.substr(0, index) + insertString;
            text.value = text.tspan.textContent = newText;
            text.stroke && (text.stroke.textContent = newText);
            if (insertString === ELLIPSIS) {
                text.hasEllipsis = true
            }
        }

        function removeTextSpan(text) {
            text.tspan.parentNode && text.tspan.parentNode.removeChild(text.tspan);
            text.stroke && text.stroke.parentNode && text.stroke.parentNode.removeChild(text.stroke)
        }

        function createTextNodes(wrapper, text, isStroked) {
            var items;
            var parsedHtml;
            wrapper._texts = null;
            wrapper.clear();
            if (null === text) {
                return
            }
            text = "" + text;
            if (!wrapper.renderer.encodeHtml && (/<[a-z][\s\S]*>/i.test(text) || text.indexOf("&") !== -1)) {
                parsedHtml = removeExtraAttrs(text);
                items = parseHTML(parsedHtml);
                wrapper.DEBUG_parsedHtml = parsedHtml
            } else {
                if (/\n/g.test(text)) {
                    items = parseMultiline(text)
                } else {
                    if (isStroked) {
                        items = [{
                            value: text.trim(),
                            height: 0
                        }]
                    }
                }
            }
            if (items) {
                if (items.length) {
                    wrapper._texts = items;
                    if (isStroked) {
                        createTspans(items, wrapper.element, KEY_STROKE)
                    }
                    createTspans(items, wrapper.element, "tspan")
                }
            } else {
                wrapper.element.appendChild(_dom_adapter2.default.createTextNode(text))
            }
        }

        function setTextNodeAttribute(item, name, value) {
            item.tspan.setAttribute(name, value);
            item.stroke && item.stroke.setAttribute(name, value)
        }

        function getItemLineHeight(item, defaultValue) {
            return item.inherits ? maxLengthFontSize(item.height, defaultValue) : item.height || defaultValue
        }

        function locateTextNodes(wrapper) {
            if (!wrapper._texts) {
                return
            }
            var items = wrapper._texts;
            var x = wrapper._settings.x;
            var lineHeight = wrapper._getLineHeight();
            var i;
            var ii;
            var item = items[0];
            setTextNodeAttribute(item, "x", x);
            setTextNodeAttribute(item, "y", wrapper._settings.y);
            for (i = 1, ii = items.length; i < ii; ++i) {
                item = items[i];
                if (parseFloat(item.height) >= 0) {
                    setTextNodeAttribute(item, "x", x);
                    var height = getItemLineHeight(item, lineHeight);
                    setTextNodeAttribute(item, "dy", height)
                }
            }
        }

        function alignTextNodes(wrapper, alignment) {
            if (!wrapper._texts || "center" === alignment) {
                return
            }
            var items = wrapper._texts;
            var direction = "left" === alignment ? -1 : 1;
            var maxTextWidth = Math.max.apply(Math, items.map(function(t) {
                return getTextWidth(t)
            }));
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var textWidth = getTextWidth(item);
                if (0 !== maxTextWidth && maxTextWidth !== textWidth) {
                    setTextNodeAttribute(item, "dx", direction * round((maxTextWidth - textWidth) / 2 * 10) / 10)
                }
            }
        }

        function maxLengthFontSize(fontSize1, fontSize2) {
            var parsedHeight1 = parseFloat(fontSize1);
            var parsedHeight2 = parseFloat(fontSize2);
            var height1 = parsedHeight1 || DEFAULT_FONT_SIZE;
            var height2 = parsedHeight2 || DEFAULT_FONT_SIZE;
            return height1 > height2 ? !isNaN(parsedHeight1) ? fontSize1 : height1 : !isNaN(parsedHeight2) ? fontSize2 : height2
        }

        function strokeTextNodes(wrapper) {
            if (!wrapper._texts) {
                return
            }
            var items = wrapper._texts;
            var stroke = wrapper._settings[KEY_STROKE];
            var strokeWidth = wrapper._settings[KEY_STROKE_WIDTH];
            var strokeOpacity = wrapper._settings[KEY_STROKE_OPACITY] || 1;
            var tspan;
            var i;
            var ii;
            for (i = 0, ii = items.length; i < ii; ++i) {
                tspan = items[i].stroke;
                tspan.setAttribute(KEY_STROKE, stroke);
                tspan.setAttribute(KEY_STROKE_WIDTH, strokeWidth);
                tspan.setAttribute(KEY_STROKE_OPACITY, strokeOpacity);
                tspan.setAttribute("stroke-linejoin", "round")
            }
        }

        function baseAnimate(that, params, options, complete) {
            options = options || {};
            var key;
            var value;
            var renderer = that.renderer;
            var settings = that._settings;
            var animationParams = {};
            var defaults = {
                translateX: 0,
                translateY: 0,
                scaleX: 1,
                scaleY: 1,
                rotate: 0,
                rotateX: 0,
                rotateY: 0
            };
            if (complete) {
                options.complete = complete
            }
            if (renderer.animationEnabled()) {
                for (key in params) {
                    value = params[key];
                    if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {
                        animationParams.transform = animationParams.transform || {
                            from: {},
                            to: {}
                        };
                        animationParams.transform.from[key] = key in settings ? Number(settings[key].toFixed(3)) : defaults[key];
                        animationParams.transform.to[key] = value
                    } else {
                        if ("arc" === key || "segments" === key) {
                            animationParams[key] = value
                        } else {
                            animationParams[key] = {
                                from: key in settings ? settings[key] : parseFloat(that.element.getAttribute(key) || 0),
                                to: value
                            }
                        }
                    }
                }
                renderer.animateElement(that, animationParams, extend(extend({}, renderer._animation), options))
            } else {
                options.step && options.step.call(that, 1, 1);
                options.complete && options.complete.call(that);
                that.attr(params)
            }
            return that
        }

        function pathAnimate(params, options, complete) {
            var that = this;
            var curSegments = that.segments || [];
            var newSegments;
            var endSegments;
            if (that.renderer.animationEnabled() && "points" in params) {
                newSegments = buildPathSegments(params.points, that.type);
                endSegments = compensateSegments(curSegments, newSegments, that.type);
                params.segments = {
                    from: curSegments,
                    to: newSegments,
                    end: endSegments
                };
                delete params.points
            }
            return baseAnimate(that, params, options, complete)
        }

        function arcAnimate(params, options, complete) {
            var that = this;
            var settings = that._settings;
            var arcParams = {
                from: {},
                to: {}
            };
            if (that.renderer.animationEnabled() && ("x" in params || "y" in params || "innerRadius" in params || "outerRadius" in params || "startAngle" in params || "endAngle" in params)) {
                arcParams.from.x = settings.x || 0;
                arcParams.from.y = settings.y || 0;
                arcParams.from.innerRadius = settings.innerRadius || 0;
                arcParams.from.outerRadius = settings.outerRadius || 0;
                arcParams.from.startAngle = settings.startAngle || 0;
                arcParams.from.endAngle = settings.endAngle || 0;
                arcParams.to.x = "x" in params ? params.x : settings.x;
                delete params.x;
                arcParams.to.y = "y" in params ? params.y : settings.y;
                delete params.y;
                arcParams.to.innerRadius = "innerRadius" in params ? params.innerRadius : settings.innerRadius;
                delete params.innerRadius;
                arcParams.to.outerRadius = "outerRadius" in params ? params.outerRadius : settings.outerRadius;
                delete params.outerRadius;
                arcParams.to.startAngle = "startAngle" in params ? params.startAngle : settings.startAngle;
                delete params.startAngle;
                arcParams.to.endAngle = "endAngle" in params ? params.endAngle : settings.endAngle;
                delete params.endAngle;
                params.arc = arcParams
            }
            return baseAnimate(that, params, options, complete)
        }
        exports.DEBUG_set_getNextDefsSvgId = function(newFunction) {
            getNextDefsSvgId = newFunction
        };
        exports.DEBUG_removeBackupContainer = function() {
            if (getBackup().backupCounter) {
                getBackup().backupCounter = 0;
                _dom_adapter2.default.getBody().removeChild(getBackup().backupContainer)
            }
        };

        function buildLink(target, parameters) {
            var obj = {
                is: false,
                name: parameters.name || parameters,
                after: parameters.after
            };
            if (target) {
                obj.to = target
            } else {
                obj.virtual = true
            }
            return obj
        }

        function SvgElement(renderer, tagName, type) {
            var that = this;
            that.renderer = renderer;
            that.element = createElement(tagName);
            that._settings = {};
            that._styles = {};
            if ("path" === tagName) {
                that.type = type || "line"
            }
        }

        function removeFuncIriCallback(callback) {
            fixFuncIriCallbacks.remove(callback)
        }
        exports.SvgElement = SvgElement;
        SvgElement.prototype = {
            constructor: SvgElement,
            _getJQElement: function() {
                return this._$element || (this._$element = (0, _renderer2.default)(this.element))
            },
            _addFixIRICallback: function() {
                var that = this;
                var fn = function() {
                    fixFuncIri(that, "fill");
                    fixFuncIri(that, "clip-path");
                    fixFuncIri(that, "filter")
                };
                that.element._fixFuncIri = fn;
                fn.renderer = that.renderer;
                fixFuncIriCallbacks.add(fn);
                that._addFixIRICallback = function() {}
            },
            _clearChildrenFuncIri: function() {
                var clearChildren = function clearChildren(element) {
                    var i;
                    for (i = 0; i < element.childNodes.length; i++) {
                        removeFuncIriCallback(element.childNodes[i]._fixFuncIri);
                        clearChildren(element.childNodes[i])
                    }
                };
                clearChildren(this.element)
            },
            dispose: function() {
                removeFuncIriCallback(this.element._fixFuncIri);
                this._clearChildrenFuncIri();
                this._getJQElement().remove();
                return this
            },
            append: function(parent) {
                (parent || this.renderer.root).element.appendChild(this.element);
                return this
            },
            remove: function() {
                var element = this.element;
                element.parentNode && element.parentNode.removeChild(element);
                return this
            },
            enableLinks: function() {
                this._links = [];
                return this
            },
            checkLinks: function() {
                var count = 0;
                var links = this._links;
                var i;
                var ii = links.length;
                for (i = 0; i < ii; ++i) {
                    if (!links[i]._link.virtual) {
                        ++count
                    }
                }
                if (count > 0) {
                    throw new Error("There are non disposed links!")
                }
            },
            virtualLink: function(parameters) {
                linkItem({
                    _link: buildLink(null, parameters)
                }, this);
                return this
            },
            linkAfter: function(name) {
                this._linkAfter = name;
                return this
            },
            linkOn: function(target, parameters) {
                this._link = buildLink(target, parameters);
                linkItem(this, target);
                return this
            },
            linkOff: function() {
                unlinkItem(this);
                this._link = null;
                return this
            },
            linkAppend: function() {
                var link = this._link;
                var items = link.to._links;
                var i;
                var next;
                for (i = link.i + 1;
                    (next = items[i]) && !next._link.is; ++i) {}
                this._insert(link.to, next);
                link.is = true;
                return this
            },
            _insert: function(parent, next) {
                parent.element.insertBefore(this.element, next ? next.element : null)
            },
            linkRemove: function() {
                this.remove();
                this._link.is = false;
                return this
            },
            clear: function() {
                this._clearChildrenFuncIri();
                this._getJQElement().empty();
                return this
            },
            toBackground: function() {
                var elem = this.element;
                var parent = elem.parentNode;
                parent && parent.insertBefore(elem, parent.firstChild);
                return this
            },
            toForeground: function() {
                var elem = this.element;
                var parent = elem.parentNode;
                parent && parent.appendChild(elem);
                return this
            },
            attr: function(attrs) {
                return baseAttr(this, attrs)
            },
            smartAttr: function(attrs) {
                return this.attr(processHatchingAttrs(this, attrs))
            },
            css: function(styles) {
                return baseCss(this, styles)
            },
            animate: function(params, options, complete) {
                return baseAnimate(this, params, options, complete)
            },
            sharp: function(pos, sharpDirection) {
                return this.attr({
                    sharp: pos || true,
                    sharpDirection: sharpDirection
                })
            },
            _applyTransformation: function() {
                var tr = this._settings;
                var rotateX;
                var rotateY;
                var transformations = [];
                var sharpMode = tr.sharp;
                var trDirection = tr.sharpDirection || 1;
                var strokeOdd = tr[KEY_STROKE_WIDTH] % 2;
                var correctionX = strokeOdd && ("h" === sharpMode || true === sharpMode) ? SHARPING_CORRECTION * trDirection : 0;
                var correctionY = strokeOdd && ("v" === sharpMode || true === sharpMode) ? SHARPING_CORRECTION * trDirection : 0;
                transformations.push("translate(" + ((tr.translateX || 0) + correctionX) + "," + ((tr.translateY || 0) + correctionY) + ")");
                if (tr.rotate) {
                    if ("rotateX" in tr) {
                        rotateX = tr.rotateX
                    } else {
                        rotateX = tr.x
                    }
                    if ("rotateY" in tr) {
                        rotateY = tr.rotateY
                    } else {
                        rotateY = tr.y
                    }
                    transformations.push("rotate(" + tr.rotate + "," + (rotateX || 0) + "," + (rotateY || 0) + ")")
                }
                var scaleXDefined = (0, _type.isDefined)(tr.scaleX);
                var scaleYDefined = (0, _type.isDefined)(tr.scaleY);
                if (scaleXDefined || scaleYDefined) {
                    transformations.push("scale(" + (scaleXDefined ? tr.scaleX : 1) + "," + (scaleYDefined ? tr.scaleY : 1) + ")")
                }
                if (transformations.length) {
                    this.element.setAttribute("transform", transformations.join(" "))
                }
            },
            move: function(x, y, animate, animOptions) {
                var obj = {};
                (0, _type.isDefined)(x) && (obj.translateX = x);
                (0, _type.isDefined)(y) && (obj.translateY = y);
                if (!animate) {
                    this.attr(obj)
                } else {
                    this.animate(obj, animOptions)
                }
                return this
            },
            rotate: function(angle, x, y, animate, animOptions) {
                var obj = {
                    rotate: angle || 0
                };
                (0, _type.isDefined)(x) && (obj.rotateX = x);
                (0, _type.isDefined)(y) && (obj.rotateY = y);
                if (!animate) {
                    this.attr(obj)
                } else {
                    this.animate(obj, animOptions)
                }
                return this
            },
            _getElementBBox: function() {
                var elem = this.element;
                var bBox;
                try {
                    bBox = elem.getBBox && elem.getBBox()
                } catch (e) {}
                return bBox || {
                    x: 0,
                    y: 0,
                    width: elem.offsetWidth || 0,
                    height: elem.offsetHeight || 0
                }
            },
            getBBox: function() {
                var transformation = this._settings;
                var bBox = this._getElementBBox();
                if (transformation.rotate) {
                    bBox = (0, _utils.rotateBBox)(bBox, [("rotateX" in transformation ? transformation.rotateX : transformation.x) || 0, ("rotateY" in transformation ? transformation.rotateY : transformation.y) || 0], -transformation.rotate)
                } else {
                    bBox = (0, _utils.normalizeBBox)(bBox)
                }
                return bBox
            },
            markup: function() {
                return (0, _svg.getSvgMarkup)(this.element)
            },
            getOffset: function() {
                return this._getJQElement().offset()
            },
            stopAnimation: function(disableComplete) {
                var animation = this.animation;
                animation && animation.stop(disableComplete);
                return this
            },
            setTitle: function(text) {
                var titleElem = createElement("title");
                titleElem.textContent = text || "";
                this.element.appendChild(titleElem)
            },
            data: function(obj, val) {
                var elem = this.element;
                var key;
                if (void 0 !== val) {
                    elem[obj] = val
                } else {
                    for (key in obj) {
                        elem[key] = obj[key]
                    }
                }
                return this
            },
            on: function() {
                var args = [this._getJQElement()];
                args.push.apply(args, arguments);
                _events_engine2.default.on.apply(_events_engine2.default, args);
                return this
            },
            off: function() {
                var args = [this._getJQElement()];
                args.push.apply(args, arguments);
                _events_engine2.default.off.apply(_events_engine2.default, args);
                return this
            },
            trigger: function() {
                var args = [this._getJQElement()];
                args.push.apply(args, arguments);
                _events_engine2.default.trigger.apply(_events_engine2.default, args);
                return this
            }
        };

        function PathSvgElement(renderer, type) {
            SvgElement.call(this, renderer, "path", type)
        }
        exports.PathSvgElement = PathSvgElement;
        PathSvgElement.prototype = objectCreate(SvgElement.prototype);
        extend(PathSvgElement.prototype, {
            constructor: PathSvgElement,
            attr: pathAttr,
            animate: pathAnimate
        });

        function ArcSvgElement(renderer) {
            SvgElement.call(this, renderer, "path", "arc")
        }
        exports.ArcSvgElement = ArcSvgElement;
        ArcSvgElement.prototype = objectCreate(SvgElement.prototype);
        extend(ArcSvgElement.prototype, {
            constructor: ArcSvgElement,
            attr: arcAttr,
            animate: arcAnimate
        });

        function RectSvgElement(renderer) {
            SvgElement.call(this, renderer, "rect")
        }
        exports.RectSvgElement = RectSvgElement;
        RectSvgElement.prototype = objectCreate(SvgElement.prototype);
        extend(RectSvgElement.prototype, {
            constructor: RectSvgElement,
            attr: rectAttr
        });

        function TextSvgElement(renderer) {
            SvgElement.call(this, renderer, "text");
            this.css({
                "white-space": "pre"
            })
        }
        exports.TextSvgElement = TextSvgElement;
        TextSvgElement.prototype = objectCreate(SvgElement.prototype);
        extend(TextSvgElement.prototype, {
            constructor: TextSvgElement,
            attr: textAttr,
            css: textCss,
            applyEllipsis: applyEllipsis,
            setMaxSize: setMaxSize,
            restoreText: restoreText,
            _getLineHeight: function() {
                return !isNaN(parseFloat(this._styles[KEY_FONT_SIZE])) ? this._styles[KEY_FONT_SIZE] : DEFAULT_FONT_SIZE
            }
        });

        function updateIndexes(items, k) {
            var i;
            var item;
            for (i = k; item = items[i]; ++i) {
                item._link.i = i
            }
        }

        function linkItem(target, container) {
            var items = container._links;
            var key = target._link.after = target._link.after || container._linkAfter;
            var i;
            var item;
            if (key) {
                for (i = 0;
                    (item = items[i]) && item._link.name !== key; ++i) {}
                if (item) {
                    for (++i;
                        (item = items[i]) && item._link.after === key; ++i) {}
                }
            } else {
                i = items.length
            }
            items.splice(i, 0, target);
            updateIndexes(items, i)
        }

        function unlinkItem(target) {
            var i;
            var items = target._link.to._links;
            for (i = 0; items[i] !== target; ++i) {}
            items.splice(i, 1);
            updateIndexes(items, i)
        }

        function Renderer(options) {
            var that = this;
            that.root = that._createElement("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                version: "1.1",
                fill: NONE,
                stroke: NONE,
                "stroke-width": 0
            }).attr({
                "class": options.cssClass
            }).css({
                "line-height": "normal",
                "-ms-user-select": NONE,
                "-moz-user-select": NONE,
                "-webkit-user-select": NONE,
                "-webkit-tap-highlight-color": "rgba(0, 0, 0, 0)",
                display: "block",
                overflow: "hidden"
            });
            that._init();
            that.pathModified = !!options.pathModified;
            that._$container = (0, _renderer2.default)(options.container);
            that.root.append({
                element: options.container
            });
            that.fixPlacement();
            that._locker = 0;
            that._backed = false
        }
        exports.Renderer = Renderer;
        Renderer.prototype = {
            constructor: Renderer,
            _init: function() {
                var that = this;
                that._defs = that._createElement("defs").append(that.root);
                that._animationController = new _animation2.default.AnimationController(that.root.element);
                that._animation = {
                    enabled: true,
                    duration: 1e3,
                    easing: "easeOutCubic"
                }
            },
            fixPlacement: function() {
                if (!_browser2.default.mozilla && !_browser2.default.msie) {
                    return
                }
                var box = getBoundingClientRect(this._$container.get(0));
                var dx = roundValue(box.left % 1, 2);
                var dy = roundValue(box.top % 1, 2);
                if (_browser2.default.msie) {
                    this.root.css({
                        transform: "translate(" + -dx + "px," + -dy + "px)"
                    })
                } else {
                    if (_browser2.default.mozilla) {
                        this.root.move(-dx, -dy)
                    }
                }
            },
            removePlacementFix: function() {
                if (!_browser2.default.mozilla && !_browser2.default.msie) {
                    return
                }
                if (_browser2.default.msie) {
                    this.root.css({
                        transform: ""
                    })
                } else {
                    if (_browser2.default.mozilla) {
                        this.root.attr({
                            transform: null
                        })
                    }
                }
            },
            setOptions: function(options) {
                var that = this;
                that.rtl = !!options.rtl;
                that.encodeHtml = !!options.encodeHtml;
                that.updateAnimationOptions(options.animation || {});
                that.root.attr({
                    direction: that.rtl ? "rtl" : "ltr"
                });
                return that
            },
            _createElement: function(tagName, attr, type) {
                var elem = new exports.SvgElement(this, tagName, type);
                attr && elem.attr(attr);
                return elem
            },
            lock: function() {
                var that = this;
                if (0 === that._locker) {
                    that._backed = !that._$container.is(":visible");
                    if (that._backed) {
                        backupRoot(that.root)
                    }
                }++that._locker;
                return that
            },
            unlock: function() {
                var that = this;
                --that._locker;
                if (0 === that._locker) {
                    if (that._backed) {
                        restoreRoot(that.root, that._$container[0]);
                        that.fixPlacement()
                    }
                    that._backed = false
                }
                return that
            },
            resize: function(width, height) {
                if (width >= 0 && height >= 0) {
                    this.root.attr({
                        width: width,
                        height: height
                    })
                }
                return this
            },
            dispose: function() {
                var that = this;
                var key;
                that.root.dispose();
                that._defs.dispose();
                that._animationController.dispose();
                fixFuncIriCallbacks.removeByRenderer(that);
                for (key in that) {
                    that[key] = null
                }
                return that
            },
            animationEnabled: function() {
                return !!this._animation.enabled
            },
            updateAnimationOptions: function(newOptions) {
                extend(this._animation, newOptions);
                return this
            },
            stopAllAnimations: function(lock) {
                this._animationController[lock ? "lock" : "stop"]();
                return this
            },
            animateElement: function(element, params, options) {
                this._animationController.animateElement(element, params, options);
                return this
            },
            svg: function() {
                this.removePlacementFix();
                var markup = this.root.markup();
                this.fixPlacement();
                return markup
            },
            getRootOffset: function() {
                return this.root.getOffset()
            },
            onEndAnimation: function(endAnimation) {
                this._animationController.onEndAnimation(endAnimation)
            },
            rect: function(x, y, width, height) {
                var elem = new exports.RectSvgElement(this);
                return elem.attr({
                    x: x || 0,
                    y: y || 0,
                    width: width || 0,
                    height: height || 0
                })
            },
            simpleRect: function() {
                return this._createElement("rect")
            },
            circle: function(x, y, r) {
                return this._createElement("circle", {
                    cx: x || 0,
                    cy: y || 0,
                    r: r || 0
                })
            },
            g: function() {
                return this._createElement("g")
            },
            image: function image(x, y, w, h, href, location) {
                var image = this._createElement("image", {
                    x: x || 0,
                    y: y || 0,
                    width: w || 0,
                    height: h || 0,
                    preserveAspectRatio: preserveAspectRatioMap[(0, _utils.normalizeEnum)(location)] || NONE
                });
                image.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", href || "");
                return image
            },
            path: function(points, type) {
                var elem = new exports.PathSvgElement(this, type);
                return elem.attr({
                    points: points || []
                })
            },
            arc: function(x, y, innerRadius, outerRadius, startAngle, endAngle) {
                var elem = new exports.ArcSvgElement(this);
                return elem.attr({
                    x: x || 0,
                    y: y || 0,
                    innerRadius: innerRadius || 0,
                    outerRadius: outerRadius || 0,
                    startAngle: startAngle || 0,
                    endAngle: endAngle || 0
                })
            },
            text: function(_text, x, y) {
                var elem = new exports.TextSvgElement(this);
                return elem.attr({
                    text: _text,
                    x: x || 0,
                    y: y || 0
                })
            },
            linearGradient: function(stops) {
                var id = getNextDefsSvgId();
                var that = this;
                var gradient = that._createElement("linearGradient", {
                    id: id
                }).append(that._defs);
                gradient.id = id;
                stops.forEach(function(stop) {
                    that._createElement("stop", {
                        offset: stop.offset,
                        "stop-color": stop["stop-color"]
                    }).append(gradient)
                });
                return gradient
            },
            pattern: function pattern(color, hatching, _id) {
                hatching = hatching || {};
                var that = this;
                var step = hatching.step || 6;
                var stepTo2 = step / 2;
                var stepBy15 = 1.5 * step;
                var id = _id || getNextDefsSvgId();
                var d = "right" === (0, _utils.normalizeEnum)(hatching.direction) ? "M " + stepTo2 + " " + -stepTo2 + " L " + -stepTo2 + " " + stepTo2 + " M 0 " + step + " L " + step + " 0 M " + stepBy15 + " " + stepTo2 + " L " + stepTo2 + " " + stepBy15 : "M 0 0 L " + step + " " + step + " M " + -stepTo2 + " " + stepTo2 + " L " + stepTo2 + " " + stepBy15 + " M " + stepTo2 + " " + -stepTo2 + " L " + stepBy15 + " " + stepTo2;
                var pattern = that._createElement("pattern", {
                    id: id,
                    width: step,
                    height: step,
                    patternUnits: "userSpaceOnUse"
                }).append(that._defs);
                pattern.id = id;
                var rect = that.rect(0, 0, step, step).attr({
                    fill: color,
                    opacity: hatching.opacity
                }).append(pattern);
                var path = new exports.PathSvgElement(this).attr({
                    d: d,
                    "stroke-width": hatching.width || 1,
                    stroke: color
                }).append(pattern);
                pattern.rect = rect;
                pattern.path = path;
                return pattern
            },
            _getPointsWithYOffset: function(points, offset) {
                return points.map(function(point, index) {
                    if (index % 2 !== 0) {
                        return point + offset
                    }
                    return point
                })
            },
            clipShape: function(method, methodArgs) {
                var that = this;
                var id = getNextDefsSvgId();
                var clipPath = that._createElement("clipPath", {
                    id: id
                }).append(that._defs);
                var shape = method.apply(that, methodArgs).append(clipPath);
                shape.id = id;
                shape.clipPath = clipPath;
                shape.remove = function() {
                    throw "Not implemented"
                };
                shape.dispose = function() {
                    clipPath.dispose();
                    clipPath = null;
                    return this
                };
                return shape
            },
            clipRect: function(x, y, width, height) {
                return this.clipShape(this.rect, arguments)
            },
            clipCircle: function(x, y, radius) {
                return this.clipShape(this.circle, arguments)
            },
            shadowFilter: function(x, y, width, height, offsetX, offsetY, blur, color, opacity) {
                var that = this;
                var id = getNextDefsSvgId();
                var filter = that._createElement("filter", {
                    id: id,
                    x: x || 0,
                    y: y || 0,
                    width: width || 0,
                    height: height || 0
                }).append(that._defs);
                var gaussianBlur = that._createElement("feGaussianBlur", {
                    "in": "SourceGraphic",
                    result: "gaussianBlurResult",
                    stdDeviation: blur || 0
                }).append(filter);
                var offset = that._createElement("feOffset", {
                    "in": "gaussianBlurResult",
                    result: "offsetResult",
                    dx: offsetX || 0,
                    dy: offsetY || 0
                }).append(filter);
                var flood = that._createElement("feFlood", {
                    result: "floodResult",
                    "flood-color": color || "",
                    "flood-opacity": opacity
                }).append(filter);
                var composite = that._createElement("feComposite", {
                    "in": "floodResult",
                    in2: "offsetResult",
                    operator: "in",
                    result: "compositeResult"
                }).append(filter);
                var finalComposite = that._createElement("feComposite", {
                    "in": "SourceGraphic",
                    in2: "compositeResult",
                    operator: "over"
                }).append(filter);
                filter.id = id;
                filter.gaussianBlur = gaussianBlur;
                filter.offset = offset;
                filter.flood = flood;
                filter.composite = composite;
                filter.finalComposite = finalComposite;
                filter.attr = function(attrs) {
                    var that = this;
                    var filterAttrs = {};
                    var offsetAttrs = {};
                    var floodAttrs = {};
                    "x" in attrs && (filterAttrs.x = attrs.x);
                    "y" in attrs && (filterAttrs.y = attrs.y);
                    "width" in attrs && (filterAttrs.width = attrs.width);
                    "height" in attrs && (filterAttrs.height = attrs.height);
                    baseAttr(that, filterAttrs);
                    "blur" in attrs && that.gaussianBlur.attr({
                        stdDeviation: attrs.blur
                    });
                    "offsetX" in attrs && (offsetAttrs.dx = attrs.offsetX);
                    "offsetY" in attrs && (offsetAttrs.dy = attrs.offsetY);
                    that.offset.attr(offsetAttrs);
                    "color" in attrs && (floodAttrs["flood-color"] = attrs.color);
                    "opacity" in attrs && (floodAttrs["flood-opacity"] = attrs.opacity);
                    that.flood.attr(floodAttrs);
                    return that
                };
                return filter
            },
            brightFilter: function(type, slope) {
                var that = this;
                var id = getNextDefsSvgId();
                var filter = that._createElement("filter", {
                    id: id
                }).append(that._defs);
                var componentTransferElement = that._createElement("feComponentTransfer").append(filter);
                var attrs = {
                    type: type,
                    slope: slope
                };
                filter.id = id;
                that._createElement("feFuncR", attrs).append(componentTransferElement);
                that._createElement("feFuncG", attrs).append(componentTransferElement);
                that._createElement("feFuncB", attrs).append(componentTransferElement);
                return filter
            },
            getGrayScaleFilter: function() {
                if (this._grayScaleFilter) {
                    return this._grayScaleFilter
                }
                var that = this;
                var id = getNextDefsSvgId();
                var filter = that._createElement("filter", {
                    id: id
                }).append(that._defs);
                that._createElement("feColorMatrix").attr({
                    type: "matrix",
                    values: "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 0.6 0"
                }).append(filter);
                filter.id = id;
                that._grayScaleFilter = filter;
                return filter
            },
            initHatching: function() {
                var storage = this._hatchingStorage = this._hatchingStorage || {
                    byHash: {},
                    baseId: getNextDefsSvgId()
                };
                var byHash = storage.byHash;
                var name;
                for (name in byHash) {
                    byHash[name].pattern.dispose()
                }
                storage.byHash = {};
                storage.refToHash = {};
                storage.nextId = 0
            },
            lockHatching: function(color, hatching, ref) {
                var storage = this._hatchingStorage;
                var hash = getHatchingHash(color, hatching);
                var storageItem;
                var pattern;
                if (storage.refToHash[ref] !== hash) {
                    if (ref) {
                        this.releaseHatching(ref)
                    }
                    storageItem = storage.byHash[hash];
                    if (!storageItem) {
                        pattern = this.pattern(color, hatching, storage.baseId + "-hatching-" + storage.nextId++);
                        storageItem = storage.byHash[hash] = {
                            pattern: pattern,
                            count: 0
                        };
                        storage.refToHash[pattern.id] = hash
                    }++storageItem.count;
                    ref = storageItem.pattern.id
                }
                return ref
            },
            releaseHatching: function(ref) {
                var storage = this._hatchingStorage;
                var hash = storage.refToHash[ref];
                var storageItem = storage.byHash[hash];
                if (storageItem && 0 === --storageItem.count) {
                    storageItem.pattern.dispose();
                    delete storage.byHash[hash];
                    delete storage.refToHash[ref]
                }
            }
        };

        function getHatchingHash(color, hatching) {
            return "@" + color + "::" + hatching.step + ":" + hatching.width + ":" + hatching.opacity + ":" + hatching.direction
        }
        var fixFuncIriCallbacks = function() {
            var callbacks = [];
            return {
                add: function(fn) {
                    callbacks.push(fn)
                },
                remove: function(fn) {
                    callbacks = callbacks.filter(function(el) {
                        return el !== fn
                    })
                },
                removeByRenderer: function(renderer) {
                    callbacks = callbacks.filter(function(el) {
                        return el.renderer !== renderer
                    })
                },
                fire: function() {
                    callbacks.forEach(function(fn) {
                        fn()
                    })
                }
            }
        }();
        exports.refreshPaths = function() {
            fixFuncIriCallbacks.fire()
        }
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/core/version.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = "20.1.4"
    },
    /*!*************************************************************************!*\
      !*** ./artifacts/transpiled/core/templates/template_engine_registry.js ***!
      \*************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.registerTemplateEngine = registerTemplateEngine;
        exports.setTemplateEngine = setTemplateEngine;
        exports.getCurrentTemplateEngine = getCurrentTemplateEngine;
        var _type = __webpack_require__( /*! ../utils/type */ 1);
        var _errors = __webpack_require__( /*! ../errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var templateEngines = {};
        var currentTemplateEngine;

        function registerTemplateEngine(name, templateEngine) {
            templateEngines[name] = templateEngine
        }

        function setTemplateEngine(templateEngine) {
            if ((0, _type.isString)(templateEngine)) {
                currentTemplateEngine = templateEngines[templateEngine];
                if (!currentTemplateEngine) {
                    throw _errors2.default.Error("E0020", templateEngine)
                }
            } else {
                currentTemplateEngine = templateEngine
            }
        }

        function getCurrentTemplateEngine() {
            return currentTemplateEngine
        }
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/events/gesture/emitter.gesture.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var devices = __webpack_require__( /*! ../../core/devices */ 15);
        var styleUtils = __webpack_require__( /*! ../../core/utils/style */ 93);
        var callOnce = __webpack_require__( /*! ../../core/utils/call_once */ 80);
        var domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11);
        var readyCallbacks = __webpack_require__( /*! ../../core/utils/ready_callbacks */ 51);
        var ready = readyCallbacks.add;
        var mathUtils = __webpack_require__( /*! ../../core/utils/math */ 31);
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var eventUtils = __webpack_require__( /*! ../utils */ 8);
        var Emitter = __webpack_require__( /*! ../core/emitter */ 132);
        var sign = mathUtils.sign;
        var abs = Math.abs;
        var SLEEP = 0;
        var INITED = 1;
        var STARTED = 2;
        var TOUCH_BOUNDARY = 10;
        var IMMEDIATE_TOUCH_BOUNDARY = 0;
        var IMMEDIATE_TIMEOUT = 180;
        var supportPointerEvents = function() {
            return styleUtils.styleProp("pointer-events")
        };
        var setGestureCover = callOnce(function() {
            var GESTURE_COVER_CLASS = "dx-gesture-cover";
            var isDesktop = "desktop" === devices.real().deviceType;
            if (!supportPointerEvents() || !isDesktop) {
                return noop
            }
            var $cover = $("<div>").addClass(GESTURE_COVER_CLASS).css("pointerEvents", "none");
            eventsEngine.subscribeGlobal($cover, "dxmousewheel", function(e) {
                e.preventDefault()
            });
            ready(function() {
                $cover.appendTo("body")
            });
            return function(toggle, cursor) {
                $cover.css("pointerEvents", toggle ? "all" : "none");
                toggle && $cover.css("cursor", cursor)
            }
        });
        var gestureCover = function(toggle, cursor) {
            var gestureCoverStrategy = setGestureCover();
            gestureCoverStrategy(toggle, cursor)
        };
        var GestureEmitter = Emitter.inherit({
            gesture: true,
            configure: function(data) {
                this.getElement().css("msTouchAction", data.immediate ? "pinch-zoom" : "");
                this.callBase(data)
            },
            allowInterruptionByMouseWheel: function() {
                return this._stage !== STARTED
            },
            getDirection: function() {
                return this.direction
            },
            _cancel: function() {
                this.callBase.apply(this, arguments);
                this._toggleGestureCover(false);
                this._stage = SLEEP
            },
            start: function(e) {
                if (e._needSkipEvent || eventUtils.needSkipEvent(e)) {
                    this._cancel(e);
                    return
                }
                this._startEvent = eventUtils.createEvent(e);
                this._startEventData = eventUtils.eventData(e);
                this._stage = INITED;
                this._init(e);
                this._setupImmediateTimer()
            },
            _setupImmediateTimer: function() {
                clearTimeout(this._immediateTimer);
                this._immediateAccepted = false;
                if (!this.immediate) {
                    return
                }
                this._immediateTimer = setTimeout(function() {
                    this._immediateAccepted = true
                }.bind(this), IMMEDIATE_TIMEOUT)
            },
            move: function(e) {
                if (this._stage === INITED && this._directionConfirmed(e)) {
                    this._stage = STARTED;
                    this._resetActiveElement();
                    this._toggleGestureCover(true);
                    this._clearSelection(e);
                    this._adjustStartEvent(e);
                    this._start(this._startEvent);
                    if (this._stage === SLEEP) {
                        return
                    }
                    this._requestAccept(e);
                    this._move(e);
                    this._forgetAccept()
                } else {
                    if (this._stage === STARTED) {
                        this._clearSelection(e);
                        this._move(e)
                    }
                }
            },
            _directionConfirmed: function(e) {
                var touchBoundary = this._getTouchBoundary(e);
                var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
                var deltaX = abs(delta.x);
                var deltaY = abs(delta.y);
                var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
                var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
                var direction = this.getDirection(e);
                var bothAccepted = "both" === direction && (horizontalMove || verticalMove);
                var horizontalAccepted = "horizontal" === direction && horizontalMove;
                var verticalAccepted = "vertical" === direction && verticalMove;
                return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted
            },
            _validateMove: function(touchBoundary, mainAxis, crossAxis) {
                return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)
            },
            _getTouchBoundary: function(e) {
                return this.immediate || eventUtils.isDxMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY
            },
            _adjustStartEvent: function(e) {
                var touchBoundary = this._getTouchBoundary(e);
                var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
                this._startEvent.pageX += sign(delta.x) * touchBoundary;
                this._startEvent.pageY += sign(delta.y) * touchBoundary
            },
            _resetActiveElement: function() {
                if ("ios" === devices.real().platform && this.getElement().find(":focus").length) {
                    domUtils.resetActiveElement()
                }
            },
            _toggleGestureCover: function(toggle) {
                this._toggleGestureCoverImpl(toggle)
            },
            _toggleGestureCoverImpl: function(toggle) {
                var isStarted = this._stage === STARTED;
                if (isStarted) {
                    gestureCover(toggle, this.getElement().css("cursor"))
                }
            },
            _clearSelection: function(e) {
                if (eventUtils.isDxMouseWheelEvent(e) || eventUtils.isTouchEvent(e)) {
                    return
                }
                domUtils.clearSelection()
            },
            end: function(e) {
                this._toggleGestureCover(false);
                if (this._stage === STARTED) {
                    this._end(e)
                } else {
                    if (this._stage === INITED) {
                        this._stop(e)
                    }
                }
                this._stage = SLEEP
            },
            dispose: function() {
                clearTimeout(this._immediateTimer);
                this.callBase.apply(this, arguments);
                this._toggleGestureCover(false)
            },
            _init: noop,
            _start: noop,
            _move: noop,
            _stop: noop,
            _end: noop
        });
        GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
        GestureEmitter.touchBoundary = function(newBoundary) {
            if (isDefined(newBoundary)) {
                TOUCH_BOUNDARY = newBoundary;
                return
            }
            return TOUCH_BOUNDARY
        };
        module.exports = GestureEmitter
    }, , , , , , ,
    /*!*********************************************!*\
      !*** ./artifacts/transpiled/viz/palette.js ***!
      \*********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports._DEBUG_palettes = void 0;
        var _palettes;
        exports.currentPalette = currentPalette;
        exports.generateColors = generateColors;
        exports.getPalette = getPalette;
        exports.registerPalette = registerPalette;
        exports.getAccentColor = getAccentColor;
        exports.createPalette = createPalette;
        exports.getDiscretePalette = getDiscretePalette;
        exports.getGradientPalette = getGradientPalette;
        var _utils = __webpack_require__( /*! ./core/utils */ 13);
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _errors = __webpack_require__( /*! ../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var _floor = Math.floor;
        var _ceil = Math.ceil;
        var _Color = __webpack_require__( /*! ../color */ 91);
        var _isArray = Array.isArray;
        var _isString = __webpack_require__( /*! ../core/utils/type */ 1).isString;
        var HIGHLIGHTING_STEP = 50;
        var DEFAULT_PALETTE = "material";
        var officePalette = {
            simpleSet: ["#5f8b95", "#ba4d51", "#af8a53", "#955f71", "#859666", "#7e688c"],
            indicatingSet: ["#a3b97c", "#e1b676", "#ec7f83"],
            gradientSet: ["#5f8b95", "#ba4d51"],
            accentColor: "#ba4d51"
        };
        var palettes = (_palettes = {}, _defineProperty(_palettes, DEFAULT_PALETTE, {
            simpleSet: ["#1db2f5", "#f5564a", "#97c95c", "#ffc720", "#eb3573", "#a63db8"],
            indicatingSet: ["#97c95c", "#ffc720", "#f5564a"],
            gradientSet: ["#1db2f5", "#97c95c"],
            accentColor: "#1db2f5"
        }), _defineProperty(_palettes, "default", officePalette), _defineProperty(_palettes, "office", officePalette), _defineProperty(_palettes, "harmony light", {
            simpleSet: ["#fcb65e", "#679ec5", "#ad79ce", "#7abd5c", "#e18e92", "#b6d623", "#b7abea", "#85dbd5"],
            indicatingSet: ["#b6d623", "#fcb65e", "#e18e92"],
            gradientSet: ["#7abd5c", "#fcb65e"],
            accentColor: "#679ec5"
        }), _defineProperty(_palettes, "soft pastel", {
            simpleSet: ["#60a69f", "#78b6d9", "#6682bb", "#a37182", "#eeba69", "#90ba58", "#456c68", "#7565a4"],
            indicatingSet: ["#90ba58", "#eeba69", "#a37182"],
            gradientSet: ["#78b6d9", "#eeba69"],
            accentColor: "#60a69f"
        }), _defineProperty(_palettes, "pastel", {
            simpleSet: ["#bb7862", "#70b3a1", "#bb626a", "#057d85", "#ab394b", "#dac599", "#153459", "#b1d2c6"],
            indicatingSet: ["#70b3a1", "#dac599", "#bb626a"],
            gradientSet: ["#bb7862", "#70b3a1"],
            accentColor: "#bb7862"
        }), _defineProperty(_palettes, "bright", {
            simpleSet: ["#70c92f", "#f8ca00", "#bd1550", "#e97f02", "#9d419c", "#7e4452", "#9ab57e", "#36a3a6"],
            indicatingSet: ["#70c92f", "#f8ca00", "#bd1550"],
            gradientSet: ["#e97f02", "#f8ca00"],
            accentColor: "#e97f02"
        }), _defineProperty(_palettes, "soft", {
            simpleSet: ["#cbc87b", "#9ab57e", "#e55253", "#7e4452", "#e8c267", "#565077", "#6babac", "#ad6082"],
            indicatingSet: ["#9ab57e", "#e8c267", "#e55253"],
            gradientSet: ["#9ab57e", "#e8c267"],
            accentColor: "#565077"
        }), _defineProperty(_palettes, "ocean", {
            simpleSet: ["#75c099", "#acc371", "#378a8a", "#5fa26a", "#064970", "#38c5d2", "#00a7c6", "#6f84bb"],
            indicatingSet: ["#c8e394", "#7bc59d", "#397c8b"],
            gradientSet: ["#acc371", "#38c5d2"],
            accentColor: "#378a8a"
        }), _defineProperty(_palettes, "vintage", {
            simpleSet: ["#dea484", "#efc59c", "#cb715e", "#eb9692", "#a85c4c", "#f2c0b5", "#c96374", "#dd956c"],
            indicatingSet: ["#ffe5c6", "#f4bb9d", "#e57660"],
            gradientSet: ["#efc59c", "#cb715e"],
            accentColor: "#cb715e"
        }), _defineProperty(_palettes, "violet", {
            simpleSet: ["#d1a1d1", "#eeacc5", "#7b5685", "#7e7cad", "#a13d73", "#5b41ab", "#e287e2", "#689cc1"],
            indicatingSet: ["#d8e2f6", "#d0b2da", "#d56a8a"],
            gradientSet: ["#eeacc5", "#7b5685"],
            accentColor: "#7b5685"
        }), _defineProperty(_palettes, "carmine", {
            simpleSet: ["#fb7764", "#73d47f", "#fed85e", "#d47683", "#dde392", "#757ab2"],
            indicatingSet: ["#5cb85c", "#f0ad4e", "#d9534f"],
            gradientSet: ["#fb7764", "#73d47f"],
            accentColor: "#f05b41"
        }), _defineProperty(_palettes, "dark moon", {
            simpleSet: ["#4ddac1", "#f4c99a", "#80dd9b", "#f998b3", "#4aaaa0", "#a5aef1"],
            indicatingSet: ["#59d8a4", "#f0ad4e", "#f9517e"],
            gradientSet: ["#4ddac1", "#f4c99a"],
            accentColor: "#3debd3"
        }), _defineProperty(_palettes, "soft blue", {
            simpleSet: ["#7ab8eb", "#97da97", "#facb86", "#e78683", "#839bda", "#4db7be"],
            indicatingSet: ["#5cb85c", "#f0ad4e", "#d9534f"],
            gradientSet: ["#7ab8eb", "#97da97"],
            accentColor: "#7ab8eb"
        }), _defineProperty(_palettes, "dark violet", {
            simpleSet: ["#9c63ff", "#64c064", "#eead51", "#d2504b", "#4b6bbf", "#2da7b0"],
            indicatingSet: ["#5cb85c", "#f0ad4e", "#d9534f"],
            gradientSet: ["#9c63ff", "#64c064"],
            accentColor: "#9c63ff"
        }), _defineProperty(_palettes, "green mist", {
            simpleSet: ["#3cbab2", "#8ed962", "#5b9d95", "#efcc7c", "#f1929f", "#4d8dab"],
            indicatingSet: ["#72d63c", "#ffc852", "#f74a5e"],
            gradientSet: ["#3cbab2", "#8ed962"],
            accentColor: "#3cbab2"
        }), _palettes);
        var currentPaletteName;

        function currentPalette(name) {
            if (void 0 === name) {
                return currentPaletteName || DEFAULT_PALETTE
            } else {
                name = (0, _utils.normalizeEnum)(name);
                currentPaletteName = name in palettes ? name : void 0
            }
        }

        function generateColors(palette, count) {
            var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                keepLastColorInEnd: false
            };
            options.type = options.baseColorSet;
            options.extensionMode = options.paletteExtensionMode;
            return createPalette(palette, options).generateColors(count)
        }

        function getPalette(palette, parameters) {
            parameters = parameters || {};
            palette = selectPaletteOnSeniority(palette, parameters.themeDefault);
            var result;
            var type = parameters.type;
            if (_isArray(palette)) {
                return palette.slice(0)
            } else {
                if (_isString(palette)) {
                    result = palettes[(0, _utils.normalizeEnum)(palette)]
                }
                if (!result) {
                    result = palettes[currentPalette()]
                }
            }
            return type ? result[type].slice(0) : result
        }

        function registerPalette(name, palette) {
            var item = {};
            var paletteName;
            if (_isArray(palette)) {
                item.simpleSet = palette.slice(0)
            } else {
                if (palette) {
                    item.simpleSet = _isArray(palette.simpleSet) ? palette.simpleSet.slice(0) : void 0;
                    item.indicatingSet = _isArray(palette.indicatingSet) ? palette.indicatingSet.slice(0) : void 0;
                    item.gradientSet = _isArray(palette.gradientSet) ? palette.gradientSet.slice(0) : void 0;
                    item.accentColor = palette.accentColor
                }
            }
            if (!item.accentColor) {
                item.accentColor = item.simpleSet && item.simpleSet[0]
            }
            if (item.simpleSet || item.indicatingSet || item.gradientSet) {
                paletteName = (0, _utils.normalizeEnum)(name);
                (0, _extend.extend)(palettes[paletteName] = palettes[paletteName] || {}, item)
            }
        }

        function getAccentColor(palette, themeDefault) {
            palette = getPalette(palette, {
                themeDefault: themeDefault
            });
            return palette.accentColor || palette[0]
        }

        function RingBuf(buf) {
            var ind = 0;
            this.next = function() {
                var res = buf[ind++];
                if (ind === buf.length) {
                    this.reset()
                }
                return res
            };
            this.reset = function() {
                ind = 0
            }
        }

        function getAlternateColorsStrategy(palette, parameters) {
            var stepHighlight = parameters.useHighlight ? HIGHLIGHTING_STEP : 0;
            var paletteSteps = new RingBuf([0, stepHighlight, -stepHighlight]);
            var currentPalette = [];

            function _reset() {
                var step = paletteSteps.next();
                currentPalette = step ? getAlteredPalette(palette, step) : palette.slice(0)
            }
            return {
                getColor: function(index) {
                    var color = currentPalette[index % palette.length];
                    if (index % palette.length === palette.length - 1) {
                        _reset()
                    }
                    return color
                },
                generateColors: function(count) {
                    var colors = [];
                    count = count || parameters.count;
                    for (var i = 0; i < count; i++) {
                        colors.push(this.getColor(i))
                    }
                    return colors
                },
                reset: function() {
                    paletteSteps.reset();
                    _reset()
                }
            }
        }

        function getExtrapolateColorsStrategy(palette, parameters) {
            function convertColor(color, cycleIndex, cycleCount) {
                var hsl = new _Color(color).hsl;
                var l = hsl.l / 100;
                var diapason = cycleCount - 1 / cycleCount;
                var minL = l - .5 * diapason;
                var maxL = l + .5 * diapason;
                var cycleMiddle = (cycleCount - 1) / 2;
                var cycleDiff = cycleIndex - cycleMiddle;
                if (minL < Math.min(.5, .9 * l)) {
                    minL = Math.min(.5, .9 * l)
                }
                if (maxL > Math.max(.8, l + .15 * (1 - l))) {
                    maxL = Math.max(.8, l + .15 * (1 - l))
                }
                if (cycleDiff < 0) {
                    l -= (minL - l) * cycleDiff / cycleMiddle
                } else {
                    l += (maxL - l) * (cycleDiff / cycleMiddle)
                }
                hsl.l = 100 * l;
                return _Color.prototype.fromHSL(hsl).toHex()
            }
            return {
                getColor: function(index, count) {
                    var paletteCount = palette.length;
                    var cycles = _floor((count - 1) / paletteCount + 1);
                    var color = palette[index % paletteCount];
                    if (cycles > 1) {
                        return convertColor(color, _floor(index / paletteCount), cycles)
                    }
                    return color
                },
                generateColors: function(count) {
                    var colors = [];
                    count = count || parameters.count;
                    for (var i = 0; i < count; i++) {
                        colors.push(this.getColor(i, count))
                    }
                    return colors
                },
                reset: function() {}
            }
        }

        function getColorMixer(palette, parameters) {
            var paletteCount = palette.length;
            var extendedPalette = [];

            function distributeColors(count, colorsCount, startIndex, distribution) {
                var groupSize = Math.floor(count / colorsCount);
                var extraItems = count - colorsCount * groupSize;
                var i = startIndex;
                var middleIndex;
                var size;
                while (i < startIndex + count) {
                    size = groupSize;
                    if (extraItems > 0) {
                        size += 1;
                        extraItems--
                    }
                    middleIndex = size > 2 ? Math.floor(size / 2) : 0;
                    distribution.push(i + middleIndex);
                    i += size
                }
                return distribution.sort(function(a, b) {
                    return a - b
                })
            }

            function getColorAndDistance(arr, startIndex, count) {
                startIndex = (count + startIndex) % count;
                var distance = 0;
                for (var i = startIndex; i < 2 * count; i += 1) {
                    var index = (count + i) % count;
                    if (arr[index]) {
                        return [arr[index], distance]
                    }
                    distance++
                }
            }

            function blendColors(paletteWithEmptyColors, paletteLength) {
                for (var i = 0; i < paletteLength; i++) {
                    var color = paletteWithEmptyColors[i];
                    if (!color) {
                        var color1 = paletteWithEmptyColors[i - 1];
                        if (!color1) {
                            continue
                        } else {
                            var c2 = getColorAndDistance(paletteWithEmptyColors, i, paletteLength);
                            var color2 = new _Color(c2[0]);
                            color1 = new _Color(color1);
                            for (var j = 0; j < c2[1]; j++, i++) {
                                paletteWithEmptyColors[i] = color1.blend(color2, (j + 1) / (c2[1] + 1)).toHex()
                            }
                        }
                    }
                }
                return paletteWithEmptyColors
            }

            function extendPalette(count) {
                if (count <= paletteCount) {
                    return palette
                }
                var result = [];
                var colorInGroups = paletteCount - 2;
                var currentColorIndex = 0;
                var cleanColorIndices = [];
                if (parameters.keepLastColorInEnd) {
                    cleanColorIndices = distributeColors(count - 2, colorInGroups, 1, [0, count - 1])
                } else {
                    cleanColorIndices = distributeColors(count - 1, paletteCount - 1, 1, [0])
                }
                for (var i = 0; i < count; i++) {
                    if (cleanColorIndices.indexOf(i) > -1) {
                        result[i] = palette[currentColorIndex++]
                    }
                }
                result = blendColors(result, count);
                return result
            }
            return {
                getColor: function(index, count) {
                    count = count || parameters.count || paletteCount;
                    if (extendedPalette.length !== count) {
                        extendedPalette = extendPalette(count)
                    }
                    return extendedPalette[index % count]
                },
                generateColors: function(count, repeat) {
                    count = count || parameters.count || paletteCount;
                    if (repeat && count > paletteCount) {
                        var colors = extendPalette(paletteCount);
                        for (var i = 0; i < count - paletteCount; i++) {
                            colors.push(colors[i])
                        }
                        return colors
                    } else {
                        return paletteCount > 0 ? extendPalette(count).slice(0, count) : []
                    }
                },
                reset: function() {}
            }
        }

        function createPalette(palette, parameters, themeDefaultPalette) {
            var paletteObj = {
                dispose: function() {
                    this._extensionStrategy = null
                },
                getNextColor: function(count) {
                    return this._extensionStrategy.getColor(this._currentColor++, count)
                },
                generateColors: function(count, parameters) {
                    return this._extensionStrategy.generateColors(count, (parameters || {}).repeat)
                },
                reset: function() {
                    this._currentColor = 0;
                    this._extensionStrategy.reset();
                    return this
                }
            };
            parameters = parameters || {};
            var extensionMode = (parameters.extensionMode || "").toLowerCase();
            var colors = getPalette(palette, {
                type: parameters.type || "simpleSet",
                themeDefault: themeDefaultPalette
            });
            if ("alternate" === extensionMode) {
                paletteObj._extensionStrategy = getAlternateColorsStrategy(colors, parameters)
            } else {
                if ("extrapolate" === extensionMode) {
                    paletteObj._extensionStrategy = getExtrapolateColorsStrategy(colors, parameters)
                } else {
                    paletteObj._extensionStrategy = getColorMixer(colors, parameters)
                }
            }
            paletteObj.reset();
            return paletteObj
        }

        function getAlteredPalette(originalPalette, step) {
            var palette = [];
            var i;
            var ii = originalPalette.length;
            for (i = 0; i < ii; ++i) {
                palette.push(getNewColor(originalPalette[i], step))
            }
            return palette
        }

        function getNewColor(currentColor, step) {
            var newColor = new _Color(currentColor).alter(step);
            var lightness = getLightness(newColor);
            if (lightness > 200 || lightness < 55) {
                newColor = new _Color(currentColor).alter(-step / 2)
            }
            return newColor.toHex()
        }

        function getLightness(color) {
            return .3 * color.r + .59 * color.g + .11 * color.b
        }

        function getDiscretePalette(source, size, themeDefaultPalette) {
            var palette = size > 0 ? createDiscreteColors(getPalette(source, {
                type: "gradientSet",
                themeDefault: themeDefaultPalette
            }), size) : [];
            return {
                getColor: function(index) {
                    return palette[index] || null
                }
            }
        }

        function createDiscreteColors(source, count) {
            var colorCount = count - 1;
            var sourceCount = source.length - 1;
            var colors = [];
            var gradient = [];
            var i;

            function addColor(pos) {
                var k = sourceCount * pos;
                var kl = _floor(k);
                var kr = _ceil(k);
                gradient.push(colors[kl].blend(colors[kr], k - kl).toHex())
            }
            for (i = 0; i <= sourceCount; ++i) {
                colors.push(new _Color(source[i]))
            }
            if (colorCount > 0) {
                for (i = 0; i <= colorCount; ++i) {
                    addColor(i / colorCount)
                }
            } else {
                addColor(.5)
            }
            return gradient
        }

        function getGradientPalette(source, themeDefaultPalette) {
            var palette = getPalette(source, {
                type: "gradientSet",
                themeDefault: themeDefaultPalette
            });
            var color1 = new _Color(palette[0]);
            var color2 = new _Color(palette[1]);
            return {
                getColor: function(ratio) {
                    return 0 <= ratio && ratio <= 1 ? color1.blend(color2, ratio).toHex() : null
                }
            }
        }

        function selectPaletteOnSeniority(source, themeDefaultPalette) {
            var result = source || (void 0 === currentPaletteName ? themeDefaultPalette : currentPalette());
            if ("default" === result) {
                _errors2.default.log("W0016", '"palette"', "Default", "18.1", 'Use the "Office" value instead.')
            }
            return result
        }
        exports._DEBUG_palettes = palettes
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/series/area_series.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var objectUtils = __webpack_require__( /*! ../../core/utils/object */ 47);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var scatterSeries = __webpack_require__( /*! ./scatter_series */ 110).chart;
        var lineSeries = __webpack_require__( /*! ./line_series */ 210);
        var chartLineSeries = lineSeries.chart.line;
        var polarLineSeries = lineSeries.polar.line;
        var _map = __webpack_require__( /*! ../core/utils */ 13).map;
        var _extend = extend;
        var calculateBezierPoints = lineSeries.chart.spline._calculateBezierPoints;
        exports.chart = {};
        exports.polar = {};
        var baseAreaMethods = {
            _createBorderElement: chartLineSeries._createMainElement,
            _createLegendState: function(styleOptions, defaultColor) {
                return {
                    fill: styleOptions.color || defaultColor,
                    opacity: styleOptions.opacity,
                    hatching: styleOptions.hatching
                }
            },
            getValueRangeInitialValue: function() {
                if ("logarithmic" !== this.valueAxisType && "datetime" !== this.valueType && false !== this.showZero) {
                    return 0
                } else {
                    return scatterSeries.getValueRangeInitialValue.call(this)
                }
            },
            _getDefaultSegment: function(segment) {
                var defaultSegment = chartLineSeries._getDefaultSegment(segment);
                defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());
                return defaultSegment
            },
            _updateElement: function(element, segment, animate, complete) {
                var lineParams = {
                    points: segment.line
                };
                var areaParams = {
                    points: segment.area
                };
                var borderElement = element.line;
                if (animate) {
                    borderElement && borderElement.animate(lineParams);
                    element.area.animate(areaParams, {}, complete)
                } else {
                    borderElement && borderElement.attr(lineParams);
                    element.area.attr(areaParams)
                }
            },
            _removeElement: function(element) {
                element.line && element.line.remove();
                element.area.remove()
            },
            _drawElement: function(segment) {
                return {
                    line: this._bordersGroup && this._createBorderElement(segment.line, {
                        "stroke-width": this._styles.normal.border["stroke-width"]
                    }).append(this._bordersGroup),
                    area: this._createMainElement(segment.area).append(this._elementsGroup)
                }
            },
            _applyStyle: function(style) {
                var that = this;
                that._elementsGroup && that._elementsGroup.smartAttr(style.elements);
                that._bordersGroup && that._bordersGroup.attr(style.border);
                (that._graphics || []).forEach(function(graphic) {
                    graphic.line && graphic.line.attr({
                        "stroke-width": style.border["stroke-width"]
                    }).sharp()
                })
            },
            _parseStyle: function(options, defaultColor, defaultBorderColor) {
                var borderOptions = options.border || {};
                var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);
                borderStyle.stroke = borderOptions.visible && borderStyle["stroke-width"] ? borderStyle.stroke : "none";
                borderStyle["stroke-width"] = borderStyle["stroke-width"] || 1;
                return {
                    border: borderStyle,
                    elements: {
                        stroke: "none",
                        fill: options.color || defaultColor,
                        hatching: options.hatching,
                        opacity: options.opacity
                    }
                }
            },
            _areBordersVisible: function() {
                var options = this._options;
                return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible
            },
            _createMainElement: function(points, settings) {
                return this._renderer.path(points, "area").attr(settings)
            },
            _getTrackerSettings: function(segment) {
                return {
                    "stroke-width": segment.singlePointSegment ? this._defaultTrackerWidth : 0
                }
            },
            _getMainPointsFromSegment: function(segment) {
                return segment.area
            }
        };

        function createAreaPoints(points) {
            return _map(points, function(pt) {
                return pt.getCoords()
            }).concat(_map(points.slice().reverse(), function(pt) {
                return pt.getCoords(true)
            }))
        }
        var areaSeries = exports.chart.area = _extend({}, chartLineSeries, baseAreaMethods, {
            _prepareSegment: function(points, rotated) {
                var that = this;
                var processedPoints = that._processSinglePointsAreaSegment(points, rotated);
                var areaPoints = createAreaPoints(processedPoints);
                var argAxis = that.getArgumentAxis();
                if (argAxis.getAxisPosition) {
                    var argAxisPosition = argAxis.getAxisPosition();
                    var axisOptions = argAxis.getOptions();
                    var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);
                    if (axisOptions.visible) {
                        areaPoints.forEach(function(p, i) {
                            if (p) {
                                var index = 1 === points.length ? 0 : i < points.length ? i : areaPoints.length - 1 - i;
                                rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);
                                !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset)
                            }
                        })
                    }
                }
                return {
                    line: processedPoints,
                    area: areaPoints,
                    singlePointSegment: processedPoints !== points
                }
            },
            _processSinglePointsAreaSegment: function(points, rotated) {
                if (points && 1 === points.length) {
                    var p = points[0];
                    var p1 = objectUtils.clone(p);
                    p1[rotated ? "y" : "x"] += 1;
                    p1.argument = null;
                    return [p, p1]
                }
                return points
            }
        });
        exports.polar.area = _extend({}, polarLineSeries, baseAreaMethods, {
            _prepareSegment: function(points, rotated, lastSegment) {
                lastSegment && polarLineSeries._closeSegment.call(this, points);
                return areaSeries._prepareSegment.call(this, points)
            },
            _processSinglePointsAreaSegment: function(points) {
                return lineSeries.polar.line._prepareSegment.call(this, points).line
            }
        });
        exports.chart.steparea = _extend({}, areaSeries, {
            _prepareSegment: function(points, rotated) {
                var stepLineSeries = lineSeries.chart.stepline;
                points = areaSeries._processSinglePointsAreaSegment(points, rotated);
                return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated)
            },
            getSeriesPairCoord: lineSeries.chart.stepline.getSeriesPairCoord
        });
        exports.chart.splinearea = _extend({}, areaSeries, {
            _areaPointsToSplineAreaPoints: function(areaPoints) {
                var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];
                var middlePoint = areaPoints[areaPoints.length / 2];
                areaPoints.splice(areaPoints.length / 2, 0, {
                    x: previousMiddlePoint.x,
                    y: previousMiddlePoint.y
                }, {
                    x: middlePoint.x,
                    y: middlePoint.y
                });
                if (previousMiddlePoint.defaultCoords) {
                    areaPoints[areaPoints.length / 2].defaultCoords = true
                }
                if (middlePoint.defaultCoords) {
                    areaPoints[areaPoints.length / 2 - 1].defaultCoords = true
                }
            },
            _prepareSegment: function(points, rotated) {
                var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);
                var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));
                this._areaPointsToSplineAreaPoints(areaSegment.area);
                areaSegment.singlePointSegment = processedPoints !== points;
                return areaSegment
            },
            _getDefaultSegment: function(segment) {
                var areaDefaultSegment = areaSeries._getDefaultSegment(segment);
                this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);
                return areaDefaultSegment
            },
            _createMainElement: function(points, settings) {
                return this._renderer.path(points, "bezierarea").attr(settings)
            },
            _createBorderElement: lineSeries.chart.spline._createMainElement,
            getSeriesPairCoord: lineSeries.chart.spline.getSeriesPairCoord,
            _getNearestPoints: lineSeries.chart.spline._getNearestPoints,
            _getBezierPoints: lineSeries.chart.spline._getBezierPoints,
            obtainCubicBezierTCoef: lineSeries.chart.spline.obtainCubicBezierTCoef
        })
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/node.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;

        function Node() {}
        var updateTile = [updateLeaf, updateGroup];
        _extend(Node.prototype, {
            value: 0,
            isNode: function() {
                return !!(this.nodes && this.level < this.ctx.maxLevel)
            },
            isActive: function() {
                var ctx = this.ctx;
                return this.level >= ctx.minLevel && this.level <= ctx.maxLevel
            },
            updateStyles: function() {
                var that = this;
                var isNode = Number(that.isNode());
                that.state = that._buildState(that.ctx.settings[isNode].state, !isNode && that.color && {
                    fill: that.color
                })
            },
            _buildState: function(state, extra) {
                var base = _extend({}, state);
                return extra ? _extend(base, extra) : base
            },
            updateLabelStyle: function() {
                var settings = this.ctx.settings[Number(this.isNode())];
                this.labelState = settings.labelState;
                this.labelParams = settings.labelParams
            },
            _getState: function() {
                return this.state
            },
            applyState: function() {
                updateTile[Number(this.isNode())](this.tile, this._getState())
            }
        });

        function updateLeaf(content, attrs) {
            content.smartAttr(attrs)
        }

        function updateGroup(content, attrs) {
            content.outer.attr({
                stroke: attrs.stroke,
                "stroke-width": attrs["stroke-width"],
                "stroke-opacity": attrs["stroke-opacity"]
            });
            content.inner.smartAttr({
                fill: attrs.fill,
                opacity: attrs.opacity,
                hatching: attrs.hatching
            })
        }
        module.exports = Node
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/exporter/file_saver.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _dom_adapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _window = __webpack_require__( /*! ../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _events_engine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _ui = __webpack_require__( /*! ../ui/widget/ui.errors */ 18);
        var _ui2 = _interopRequireDefault(_ui);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _type2 = _interopRequireDefault(_type);
        var _console = __webpack_require__( /*! ../core/utils/console */ 65);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var window = _window2.default.getWindow();
        var navigator = _window2.default.getNavigator();
        var FILE_EXTESIONS = {
            EXCEL: "xlsx",
            CSS: "css",
            PNG: "png",
            JPEG: "jpeg",
            GIF: "gif",
            SVG: "svg",
            PDF: "pdf"
        };
        var MIME_TYPES = exports.MIME_TYPES = {
            CSS: "text/css",
            EXCEL: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            PNG: "image/png",
            JPEG: "image/jpeg",
            GIF: "image/gif",
            SVG: "image/svg+xml",
            PDF: "application/pdf"
        };
        exports.fileSaver = {
            _revokeObjectURLTimeout: 3e4,
            _getDataUri: function(format, data) {
                var mimeType = this._getMimeType(format);
                return "data:".concat(mimeType, ";base64,").concat(data)
            },
            _getMimeType: function(format) {
                return MIME_TYPES[format] || "application/octet-stream"
            },
            _linkDownloader: function(fileName, href) {
                var exportLinkElement = _dom_adapter2.default.createElement("a");
                exportLinkElement.download = fileName;
                exportLinkElement.href = href;
                exportLinkElement.target = "_blank";
                return exportLinkElement
            },
            _formDownloader: function(proxyUrl, fileName, contentType, data) {
                var formAttributes = {
                    method: "post",
                    action: proxyUrl,
                    enctype: "multipart/form-data"
                };
                var exportForm = (0, _renderer2.default)("<form>").css({
                    display: "none"
                }).attr(formAttributes);
                exportForm.append('<input type="hidden" name="fileName" value="' + fileName + '" />');
                exportForm.append('<input type="hidden" name="contentType" value="' + contentType + '" />');
                exportForm.append('<input type="hidden" name="data" value="' + data + '" />');
                exportForm.appendTo("body");
                _events_engine2.default.trigger(exportForm, "submit");
                if (_events_engine2.default.trigger(exportForm, "submit")) {
                    exportForm.remove()
                }
                return exportForm
            },
            _saveByProxy: function(proxyUrl, fileName, format, data) {
                var contentType = this._getMimeType(format);
                return this._formDownloader(proxyUrl, fileName, contentType, data)
            },
            _winJSBlobSave: function(blob, fileName, format) {
                var savePicker = new Windows.Storage.Pickers.FileSavePicker;
                savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
                var fileExtension = FILE_EXTESIONS[format];
                if (fileExtension) {
                    var mimeType = this._getMimeType(format);
                    savePicker.fileTypeChoices.insert(mimeType, ["." + fileExtension])
                }
                savePicker.suggestedFileName = fileName;
                savePicker.pickSaveFileAsync().then(function(file) {
                    if (file) {
                        file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function(outputStream) {
                            var inputStream = blob.msDetachStream();
                            Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function() {
                                outputStream.flushAsync().done(function() {
                                    inputStream.close();
                                    outputStream.close()
                                })
                            })
                        })
                    }
                })
            },
            _click: function(link) {
                try {
                    link.dispatchEvent(new MouseEvent("click", {
                        cancelable: true
                    }))
                } catch (e) {
                    var event = _dom_adapter2.default.getDocument().createEvent("MouseEvents");
                    event.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
                    link.dispatchEvent(event)
                }
            },
            _saveBlobAs: function(fileName, format, data) {
                var _this = this;
                this._blobSaved = false;
                if (_type2.default.isDefined(navigator.msSaveOrOpenBlob)) {
                    navigator.msSaveOrOpenBlob(data, fileName);
                    this._blobSaved = true
                } else {
                    if (_type2.default.isDefined(window.WinJS)) {
                        this._winJSBlobSave(data, fileName, format);
                        this._blobSaved = true
                    } else {
                        var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
                        if (_type2.default.isDefined(URL)) {
                            var objectURL = URL.createObjectURL(data);
                            var downloadLink = this._linkDownloader(fileName, objectURL);
                            setTimeout(function() {
                                URL.revokeObjectURL(objectURL);
                                _this._objectUrlRevoked = true
                            }, this._revokeObjectURLTimeout);
                            this._click(downloadLink)
                        } else {
                            _console.logger.warn("window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL is not defined")
                        }
                    }
                }
            },
            saveAs: function(fileName, format, data, proxyURL, forceProxy) {
                var fileExtension = FILE_EXTESIONS[format];
                if (fileExtension) {
                    fileName += "." + fileExtension
                }
                if (_type2.default.isDefined(proxyURL)) {
                    _ui2.default.log("W0001", "Export", "proxyURL", "19.2", "This option is no longer required")
                }
                if (forceProxy) {
                    this._saveByProxy(proxyURL, fileName, format, data)
                } else {
                    if (_type2.default.isFunction(window.Blob)) {
                        this._saveBlobAs(fileName, format, data)
                    } else {
                        if (_type2.default.isDefined(proxyURL) && !_type2.default.isDefined(navigator.userAgent.match(/iPad/i))) {
                            this._saveByProxy(proxyURL, fileName, format, data)
                        } else {
                            if (!_type2.default.isDefined(navigator.userAgent.match(/iPad/i))) {
                                _ui2.default.log("E1034")
                            }
                            var downloadLink = this._linkDownloader(fileName, this._getDataUri(format, data));
                            this._click(downloadLink)
                        }
                    }
                }
            }
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/events/contextmenu.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../core/renderer */ 2);
        var eventsEngine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var support = __webpack_require__( /*! ../core/utils/support */ 46);
        var devices = __webpack_require__( /*! ../core/devices */ 15);
        var Class = __webpack_require__( /*! ../core/class */ 16);
        var registerEvent = __webpack_require__( /*! ./core/event_registrator */ 77);
        var eventUtils = __webpack_require__( /*! ./utils */ 8);
        var holdEvent = __webpack_require__( /*! ./hold */ 95);
        var CONTEXTMENU_NAMESPACE = "dxContexMenu";
        var CONTEXTMENU_NAMESPACED_EVENT_NAME = eventUtils.addNamespace("contextmenu", CONTEXTMENU_NAMESPACE);
        var HOLD_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(holdEvent.name, CONTEXTMENU_NAMESPACE);
        var CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
        var ContextMenu = Class.inherit({
            setup: function(element) {
                var $element = $(element);
                eventsEngine.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
                if (support.touch || devices.isSimulator()) {
                    eventsEngine.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this))
                }
            },
            _holdHandler: function(e) {
                if (eventUtils.isMouseEvent(e) && !devices.isSimulator()) {
                    return
                }
                this._fireContextMenu(e)
            },
            _contextMenuHandler: function(e) {
                this._fireContextMenu(e)
            },
            _fireContextMenu: function(e) {
                return eventUtils.fireEvent({
                    type: CONTEXTMENU_EVENT_NAME,
                    originalEvent: e
                })
            },
            teardown: function(element) {
                eventsEngine.off(element, "." + CONTEXTMENU_NAMESPACE)
            }
        });
        registerEvent(CONTEXTMENU_EVENT_NAME, new ContextMenu);
        exports.name = CONTEXTMENU_EVENT_NAME
    }, ,
    /*!******************************************!*\
      !*** ./artifacts/transpiled/exporter.js ***!
      \******************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var fileSaver = __webpack_require__( /*! ./exporter/file_saver */ 176).fileSaver;
        var excelCreator = __webpack_require__( /*! ./exporter/excel_creator */ 450);
        var imageCreator = __webpack_require__( /*! ./exporter/image_creator */ 278);
        var svgCreator = __webpack_require__( /*! ./exporter/svg_creator */ 462);
        var _isFunction = __webpack_require__( /*! ./core/utils/type */ 1).isFunction;
        var Deferred = __webpack_require__( /*! ./core/utils/deferred */ 6).Deferred;
        exports.export = function(data, options, getData) {
            if (!data) {
                return (new Deferred).resolve()
            }
            var exportingAction = options.exportingAction;
            var exportedAction = options.exportedAction;
            var fileSavingAction = options.fileSavingAction;
            var eventArgs = {
                fileName: options.fileName,
                format: options.format,
                cancel: false
            };
            _isFunction(exportingAction) && exportingAction(eventArgs);
            if (!eventArgs.cancel) {
                return getData(data, options).then(function(blob) {
                    _isFunction(exportedAction) && exportedAction();
                    if (_isFunction(fileSavingAction)) {
                        eventArgs.data = blob;
                        fileSavingAction(eventArgs)
                    }
                    if (!eventArgs.cancel) {
                        fileSaver.saveAs(eventArgs.fileName, options.format, blob, options.proxyUrl, options.forceProxy)
                    }
                })
            }
            return (new Deferred).resolve()
        };
        exports.fileSaver = fileSaver;
        exports.excel = {
            creator: excelCreator.ExcelCreator,
            getData: excelCreator.getData,
            formatConverter: __webpack_require__( /*! ./exporter/excel_format_converter */ 186)
        };
        exports.excel.__internals = excelCreator.__internals;
        exports.image = {
            creator: imageCreator.imageCreator,
            getData: imageCreator.getData,
            testFormats: imageCreator.testFormats
        };
        exports.pdf = {
            getData: __webpack_require__( /*! ./exporter/pdf_creator */ 464).getData
        };
        exports.svg = {
            creator: svgCreator.svgCreator,
            getData: svgCreator.getData
        }
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/core/utils/size.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var window = __webpack_require__( /*! ../../core/utils/window */ 7).getWindow();
        var typeUtils = __webpack_require__( /*! ../utils/type */ 1);
        var SPECIAL_HEIGHT_VALUES = ["auto", "none", "inherit", "initial"];
        var getSizeByStyles = function(elementStyles, styles) {
            var result = 0;
            styles.forEach(function(style) {
                result += parseFloat(elementStyles[style]) || 0
            });
            return result
        };
        var getElementBoxParams = function(name, elementStyles) {
            var beforeName = "width" === name ? "Left" : "Top";
            var afterName = "width" === name ? "Right" : "Bottom";
            return {
                padding: getSizeByStyles(elementStyles, ["padding" + beforeName, "padding" + afterName]),
                border: getSizeByStyles(elementStyles, ["border" + beforeName + "Width", "border" + afterName + "Width"]),
                margin: getSizeByStyles(elementStyles, ["margin" + beforeName, "margin" + afterName])
            }
        };
        var getBoxSizingOffset = function(name, elementStyles, boxParams) {
            var size = elementStyles[name];
            if ("border-box" === elementStyles.boxSizing && size.length && "%" !== size[size.length - 1]) {
                return boxParams.border + boxParams.padding
            }
            return 0
        };
        var getSize = function(element, name, include) {
            var elementStyles = window.getComputedStyle(element);
            var boxParams = getElementBoxParams(name, elementStyles);
            var clientRect = element.getClientRects().length;
            var boundingClientRect = element.getBoundingClientRect()[name];
            var result = clientRect ? boundingClientRect : 0;
            if (result <= 0) {
                result = parseFloat(elementStyles[name] || element.style[name]) || 0;
                result -= getBoxSizingOffset(name, elementStyles, boxParams)
            } else {
                result -= boxParams.padding + boxParams.border
            }
            if (include.paddings) {
                result += boxParams.padding
            }
            if (include.borders) {
                result += boxParams.border
            }
            if (include.margins) {
                result += boxParams.margin
            }
            return result
        };
        var getContainerHeight = function(container) {
            return typeUtils.isWindow(container) ? container.innerHeight : container.offsetHeight
        };
        var parseHeight = function(value, container) {
            if (value.indexOf("px") > 0) {
                value = parseInt(value.replace("px", ""))
            } else {
                if (value.indexOf("%") > 0) {
                    value = parseInt(value.replace("%", "")) * getContainerHeight(container) / 100
                } else {
                    if (!isNaN(value)) {
                        value = parseInt(value)
                    }
                }
            }
            return value
        };
        var getHeightWithOffset = function(value, offset, container) {
            if (!value) {
                return null
            }
            if (SPECIAL_HEIGHT_VALUES.indexOf(value) > -1) {
                return offset ? null : value
            }
            if (typeUtils.isString(value)) {
                value = parseHeight(value, container)
            }
            if (typeUtils.isNumeric(value)) {
                return Math.max(0, value + offset)
            }
            var operationString = offset < 0 ? " - " : " ";
            return "calc(" + value + operationString + Math.abs(offset) + "px)"
        };
        var addOffsetToMaxHeight = function(value, offset, container) {
            var maxHeight = getHeightWithOffset(value, offset, container);
            return null !== maxHeight ? maxHeight : "none"
        };
        var addOffsetToMinHeight = function(value, offset, container) {
            var minHeight = getHeightWithOffset(value, offset, container);
            return null !== minHeight ? minHeight : 0
        };
        var getVerticalOffsets = function(element, withMargins) {
            if (!element) {
                return 0
            }
            var boxParams = getElementBoxParams("height", window.getComputedStyle(element));
            return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0)
        };
        var getVisibleHeight = function(element) {
            if (element) {
                var boundingClientRect = element.getBoundingClientRect();
                if (boundingClientRect.height) {
                    return boundingClientRect.height
                }
            }
            return 0
        };
        exports.getSize = getSize;
        exports.getElementBoxParams = getElementBoxParams;
        exports.addOffsetToMaxHeight = addOffsetToMaxHeight;
        exports.addOffsetToMinHeight = addOffsetToMinHeight;
        exports.getVerticalOffsets = getVerticalOffsets;
        exports.getVisibleHeight = getVisibleHeight;
        exports.parseHeight = parseHeight
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/ui/resizable.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _translator = __webpack_require__( /*! ../animation/translator */ 28);
        var _translator2 = _interopRequireDefault(_translator);
        var _component_registrator = __webpack_require__( /*! ../core/component_registrator */ 9);
        var _component_registrator2 = _interopRequireDefault(_component_registrator);
        var _dom_component = __webpack_require__( /*! ../core/dom_component */ 68);
        var _dom_component2 = _interopRequireDefault(_dom_component);
        var _renderer = __webpack_require__( /*! ../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _array = __webpack_require__( /*! ../core/utils/array */ 14);
        var _common = __webpack_require__( /*! ../core/utils/common */ 3);
        var _common2 = _interopRequireDefault(_common);
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _math = __webpack_require__( /*! ../core/utils/math */ 31);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _type2 = _interopRequireDefault(_type);
        var _window = __webpack_require__( /*! ../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _events_engine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _drag = __webpack_require__( /*! ../events/drag */ 69);
        var _drag2 = _interopRequireDefault(_drag);
        var _position = __webpack_require__( /*! ../core/utils/position */ 21);
        var _utils = __webpack_require__( /*! ../events/utils */ 8);
        var _dom = __webpack_require__( /*! ../core/utils/dom */ 11);
        var _dom2 = _interopRequireDefault(_dom);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var isPlainObject = _type2.default.isPlainObject;
        var isFunction = _type2.default.isFunction;
        var RESIZABLE = "dxResizable";
        var RESIZABLE_CLASS = "dx-resizable";
        var RESIZABLE_RESIZING_CLASS = "dx-resizable-resizing";
        var RESIZABLE_HANDLE_CLASS = "dx-resizable-handle";
        var RESIZABLE_HANDLE_TOP_CLASS = "dx-resizable-handle-top";
        var RESIZABLE_HANDLE_BOTTOM_CLASS = "dx-resizable-handle-bottom";
        var RESIZABLE_HANDLE_LEFT_CLASS = "dx-resizable-handle-left";
        var RESIZABLE_HANDLE_RIGHT_CLASS = "dx-resizable-handle-right";
        var RESIZABLE_HANDLE_CORNER_CLASS = "dx-resizable-handle-corner";
        var DRAGSTART_START_EVENT_NAME = (0, _utils.addNamespace)(_drag2.default.start, RESIZABLE);
        var DRAGSTART_EVENT_NAME = (0, _utils.addNamespace)(_drag2.default.move, RESIZABLE);
        var DRAGSTART_END_EVENT_NAME = (0, _utils.addNamespace)(_drag2.default.end, RESIZABLE);
        var SIDE_BORDER_WIDTH_STYLES = {
            left: "borderLeftWidth",
            top: "borderTopWidth",
            right: "borderRightWidth",
            bottom: "borderBottomWidth"
        };
        var Resizable = _dom_component2.default.inherit({
            _getDefaultOptions: function() {
                return (0, _extend.extend)(this.callBase(), {
                    handles: "all",
                    step: "1",
                    stepPrecision: "simple",
                    area: void 0,
                    minWidth: 30,
                    maxWidth: 1 / 0,
                    minHeight: 30,
                    maxHeight: 1 / 0,
                    onResizeStart: null,
                    onResize: null,
                    onResizeEnd: null,
                    roundStepValue: true
                })
            },
            _init: function() {
                this.callBase();
                this.$element().addClass(RESIZABLE_CLASS)
            },
            _initMarkup: function() {
                this.callBase();
                this._renderHandles()
            },
            _render: function() {
                this.callBase();
                this._renderActions()
            },
            _renderActions: function() {
                this._resizeStartAction = this._createActionByOption("onResizeStart");
                this._resizeEndAction = this._createActionByOption("onResizeEnd");
                this._resizeAction = this._createActionByOption("onResize")
            },
            _renderHandles: function() {
                this._handles = [];
                var handles = this.option("handles");
                if ("none" === handles) {
                    return
                }
                var directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
                (0, _iterator.each)(directions, function(index, handleName) {
                    this._renderHandle(handleName)
                }.bind(this));
                (0, _array.inArray)("bottom", directions) + 1 && (0, _array.inArray)("right", directions) + 1 && this._renderHandle("corner-bottom-right");
                (0, _array.inArray)("bottom", directions) + 1 && (0, _array.inArray)("left", directions) + 1 && this._renderHandle("corner-bottom-left");
                (0, _array.inArray)("top", directions) + 1 && (0, _array.inArray)("right", directions) + 1 && this._renderHandle("corner-top-right");
                (0, _array.inArray)("top", directions) + 1 && (0, _array.inArray)("left", directions) + 1 && this._renderHandle("corner-top-left");
                this._attachEventHandlers()
            },
            _renderHandle: function(handleName) {
                var $handle = (0, _renderer2.default)("<div>").addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + "-" + handleName).appendTo(this.$element());
                this._handles.push($handle)
            },
            _attachEventHandlers: function() {
                if (this.option("disabled")) {
                    return
                }
                var handlers = {};
                handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
                handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
                handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
                this._handles.forEach(function(handleElement) {
                    _events_engine2.default.on(handleElement, handlers, {
                        direction: "both",
                        immediate: true
                    })
                })
            },
            _detachEventHandlers: function() {
                this._handles.forEach(function(handleElement) {
                    _events_engine2.default.off(handleElement)
                })
            },
            _toggleEventHandlers: function(shouldAttachEvents) {
                shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers()
            },
            _dragStartHandler: function(e) {
                var $element = this.$element();
                if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
                    e.cancel = true;
                    return
                }
                this._toggleResizingClass(true);
                this._movingSides = this._getMovingSides(e);
                this._elementLocation = _translator2.default.locate($element);
                var elementRect = (0, _position.getBoundingRect)($element.get(0));
                this._elementSize = {
                    width: elementRect.width,
                    height: elementRect.height
                };
                this._renderDragOffsets(e);
                this._resizeStartAction({
                    event: e,
                    width: this._elementSize.width,
                    height: this._elementSize.height,
                    handles: this._movingSides
                });
                e.targetElements = null
            },
            _toggleResizingClass: function(value) {
                this.$element().toggleClass(RESIZABLE_RESIZING_CLASS, value)
            },
            _renderDragOffsets: function(e) {
                var area = this._getArea();
                if (!area) {
                    return
                }
                var $handle = (0, _renderer2.default)(e.target).closest("." + RESIZABLE_HANDLE_CLASS);
                var handleWidth = $handle.outerWidth();
                var handleHeight = $handle.outerHeight();
                var handleOffset = $handle.offset();
                var areaOffset = area.offset;
                var scrollOffset = this._getAreaScrollOffset();
                e.maxLeftOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
                e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
                e.maxTopOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
                e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY
            },
            _getBorderWidth: function($element, direction) {
                if (_type2.default.isWindow($element.get(0))) {
                    return 0
                }
                var borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
                return parseInt(borderWidth) || 0
            },
            _dragHandler: function(e) {
                var $element = this.$element();
                var sides = this._movingSides;
                var location = this._elementLocation;
                var size = this._elementSize;
                var offset = this._getOffset(e);
                var width = size.width + offset.x * (sides.left ? -1 : 1);
                var height = size.height + offset.y * (sides.top ? -1 : 1);
                if (offset.x || "strict" === this.option("stepPrecision")) {
                    this._renderWidth(width)
                }
                if (offset.y || "strict" === this.option("stepPrecision")) {
                    this._renderHeight(height)
                }
                var elementRect = (0, _position.getBoundingRect)($element.get(0));
                var offsetTop = offset.y - ((elementRect.height || height) - height);
                var offsetLeft = offset.x - ((elementRect.width || width) - width);
                _translator2.default.move($element, {
                    top: location.top + (sides.top ? offsetTop : 0),
                    left: location.left + (sides.left ? offsetLeft : 0)
                });
                this._resizeAction({
                    event: e,
                    width: this.option("width") || width,
                    height: this.option("height") || height,
                    handles: this._movingSides
                });
                _dom2.default.triggerResizeEvent($element)
            },
            _getOffset: function(e) {
                var offset = e.offset;
                var steps = _common2.default.pairToObject(this.option("step"), !this.option("roundStepValue"));
                var sides = this._getMovingSides(e);
                var strictPrecision = "strict" === this.option("stepPrecision");
                if (!sides.left && !sides.right) {
                    offset.x = 0
                }
                if (!sides.top && !sides.bottom) {
                    offset.y = 0
                }
                return strictPrecision ? this._getStrictOffset(offset, steps, sides) : this._getSimpleOffset(offset, steps)
            },
            _getSimpleOffset: function(offset, steps) {
                return {
                    x: offset.x - offset.x % steps.h,
                    y: offset.y - offset.y % steps.v
                }
            },
            _getStrictOffset: function(offset, steps, sides) {
                var location = this._elementLocation;
                var size = this._elementSize;
                var xPos = sides.left ? location.left : location.left + size.width;
                var yPos = sides.top ? location.top : location.top + size.height;
                var newXShift = (xPos + offset.x) % steps.h;
                var newYShift = (yPos + offset.y) % steps.v;
                var sign = Math.sign || function(x) {
                    x = +x;
                    if (0 === x || isNaN(x)) {
                        return x
                    }
                    return x > 0 ? 1 : -1
                };
                var separatorOffset = function(steps, offset) {
                    return (1 + .2 * sign(offset)) % 1 * steps
                };
                var isSmallOffset = function(offset, steps) {
                    return Math.abs(offset) < .2 * steps
                };
                var newOffsetX = offset.x - newXShift;
                var newOffsetY = offset.y - newYShift;
                if (newXShift > separatorOffset(steps.h, offset.x)) {
                    newOffsetX += steps.h
                }
                if (newYShift > separatorOffset(steps.v, offset.y)) {
                    newOffsetY += steps.v
                }
                return {
                    x: (sides.left || sides.right) && !isSmallOffset(offset.x, steps.h) ? newOffsetX : 0,
                    y: (sides.top || sides.bottom) && !isSmallOffset(offset.y, steps.v) ? newOffsetY : 0
                }
            },
            _getMovingSides: function(e) {
                var $target = (0, _renderer2.default)(e.target);
                var hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left");
                var hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right");
                var hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left");
                var hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right");
                return {
                    top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,
                    left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,
                    bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,
                    right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass
                }
            },
            _getArea: function() {
                var area = this.option("area");
                if (isFunction(area)) {
                    area = area.call(this)
                }
                if (isPlainObject(area)) {
                    return this._getAreaFromObject(area)
                }
                return this._getAreaFromElement(area)
            },
            _getAreaScrollOffset: function() {
                var area = this.option("area");
                var isElement = !isFunction(area) && !isPlainObject(area);
                var scrollOffset = {
                    scrollY: 0,
                    scrollX: 0
                };
                if (isElement) {
                    var areaElement = (0, _renderer2.default)(area)[0];
                    if (_type2.default.isWindow(areaElement)) {
                        scrollOffset.scrollX = areaElement.pageXOffset;
                        scrollOffset.scrollY = areaElement.pageYOffset
                    }
                }
                return scrollOffset
            },
            _getAreaFromObject: function(area) {
                var result = {
                    width: area.right - area.left,
                    height: area.bottom - area.top,
                    offset: {
                        left: area.left,
                        top: area.top
                    }
                };
                this._correctAreaGeometry(result);
                return result
            },
            _getAreaFromElement: function(area) {
                var $area = (0, _renderer2.default)(area);
                var result;
                if ($area.length) {
                    result = {
                        width: $area.innerWidth(),
                        height: $area.innerHeight(),
                        offset: (0, _extend.extend)({
                            top: 0,
                            left: 0
                        }, _type2.default.isWindow($area[0]) ? {} : $area.offset())
                    };
                    this._correctAreaGeometry(result, $area)
                }
                return result
            },
            _correctAreaGeometry: function(result, $area) {
                var areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
                var areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
                result.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
                result.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
                result.width -= this.$element().outerWidth() - this.$element().innerWidth();
                result.height -= this.$element().outerHeight() - this.$element().innerHeight()
            },
            _dragEndHandler: function(e) {
                var $element = this.$element();
                this._resizeEndAction({
                    event: e,
                    width: $element.outerWidth(),
                    height: $element.outerHeight(),
                    handles: this._movingSides
                });
                this._toggleResizingClass(false)
            },
            _renderWidth: function(width) {
                this.option("width", (0, _math.fitIntoRange)(width, this.option("minWidth"), this.option("maxWidth")))
            },
            _renderHeight: function(height) {
                this.option("height", (0, _math.fitIntoRange)(height, this.option("minHeight"), this.option("maxHeight")))
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case "disabled":
                        this._toggleEventHandlers(!args.value);
                        this.callBase(args);
                        break;
                    case "handles":
                        this._invalidate();
                        break;
                    case "minWidth":
                    case "maxWidth":
                        _window2.default.hasWindow() && this._renderWidth(this.$element().outerWidth());
                        break;
                    case "minHeight":
                    case "maxHeight":
                        _window2.default.hasWindow() && this._renderHeight(this.$element().outerHeight());
                        break;
                    case "onResize":
                    case "onResizeStart":
                    case "onResizeEnd":
                        this._renderActions();
                        break;
                    case "area":
                    case "stepPrecision":
                    case "step":
                    case "roundStepValue":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _clean: function() {
                this.$element().find("." + RESIZABLE_HANDLE_CLASS).remove()
            },
            _useTemplates: function() {
                return false
            }
        });
        (0, _component_registrator2.default)(RESIZABLE, Resizable);
        module.exports = Resizable
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/ui/overlay/z_index.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.clearStack = exports.remove = exports.create = exports.base = void 0;
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var baseZIndex = 1500;
        var zIndexStack = [];
        exports.base = function(ZIndex) {
            baseZIndex = (0, _common.ensureDefined)(ZIndex, baseZIndex);
            return baseZIndex
        };
        exports.create = function() {
            var baseIndex = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : baseZIndex;
            var length = zIndexStack.length;
            var index = (length ? zIndexStack[length - 1] : baseIndex) + 1;
            zIndexStack.push(index);
            return index
        };
        exports.remove = function(zIndex) {
            var position = zIndexStack.indexOf(zIndex);
            if (position >= 0) {
                zIndexStack.splice(position, 1)
            }
        };
        exports.clearStack = function() {
            zIndexStack = []
        }
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/events/swipe.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventUtils = __webpack_require__( /*! ./utils */ 8);
        var GestureEmitter = __webpack_require__( /*! ./gesture/emitter.gesture */ 166);
        var registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 101);
        var SWIPE_START_EVENT = "dxswipestart";
        var SWIPE_EVENT = "dxswipe";
        var SWIPE_END_EVENT = "dxswipeend";
        var HorizontalStrategy = {
            defaultItemSizeFunc: function() {
                return this.getElement().width()
            },
            getBounds: function() {
                return [this._maxLeftOffset, this._maxRightOffset]
            },
            calcOffsetRatio: function(e) {
                var endEventData = eventUtils.eventData(e);
                return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e)
            },
            isFastSwipe: function(e) {
                var endEventData = eventUtils.eventData(e);
                return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time
            }
        };
        var VerticalStrategy = {
            defaultItemSizeFunc: function() {
                return this.getElement().height()
            },
            getBounds: function() {
                return [this._maxTopOffset, this._maxBottomOffset]
            },
            calcOffsetRatio: function(e) {
                var endEventData = eventUtils.eventData(e);
                return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e)
            },
            isFastSwipe: function(e) {
                var endEventData = eventUtils.eventData(e);
                return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time
            }
        };
        var STRATEGIES = {
            horizontal: HorizontalStrategy,
            vertical: VerticalStrategy
        };
        var SwipeEmitter = GestureEmitter.inherit({
            TICK_INTERVAL: 300,
            FAST_SWIPE_SPEED_LIMIT: 10,
            ctor: function(element) {
                this.callBase(element);
                this.direction = "horizontal";
                this.elastic = true
            },
            _getStrategy: function() {
                return STRATEGIES[this.direction]
            },
            _defaultItemSizeFunc: function() {
                return this._getStrategy().defaultItemSizeFunc.call(this)
            },
            _itemSizeFunc: function() {
                return this.itemSizeFunc || this._defaultItemSizeFunc
            },
            _init: function(e) {
                this._tickData = eventUtils.eventData(e)
            },
            _start: function(e) {
                this._savedEventData = eventUtils.eventData(e);
                e = this._fireEvent(SWIPE_START_EVENT, e);
                if (!e.cancel) {
                    this._maxLeftOffset = e.maxLeftOffset;
                    this._maxRightOffset = e.maxRightOffset;
                    this._maxTopOffset = e.maxTopOffset;
                    this._maxBottomOffset = e.maxBottomOffset
                }
            },
            _move: function(e) {
                var strategy = this._getStrategy();
                var moveEventData = eventUtils.eventData(e);
                var offset = strategy.calcOffsetRatio.call(this, e);
                offset = this._fitOffset(offset, this.elastic);
                if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
                    this._tickData = moveEventData
                }
                this._fireEvent(SWIPE_EVENT, e, {
                    offset: offset
                });
                e.preventDefault()
            },
            _end: function(e) {
                var strategy = this._getStrategy();
                var offsetRatio = strategy.calcOffsetRatio.call(this, e);
                var isFast = strategy.isFastSwipe.call(this, e);
                var startOffset = offsetRatio;
                var targetOffset = this._calcTargetOffset(offsetRatio, isFast);
                startOffset = this._fitOffset(startOffset, this.elastic);
                targetOffset = this._fitOffset(targetOffset, false);
                this._fireEvent(SWIPE_END_EVENT, e, {
                    offset: startOffset,
                    targetOffset: targetOffset
                })
            },
            _fitOffset: function(offset, elastic) {
                var strategy = this._getStrategy();
                var bounds = strategy.getBounds.call(this);
                if (offset < -bounds[0]) {
                    return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0]
                }
                if (offset > bounds[1]) {
                    return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1]
                }
                return offset
            },
            _calcTargetOffset: function(offsetRatio, isFast) {
                var result;
                if (isFast) {
                    result = Math.ceil(Math.abs(offsetRatio));
                    if (offsetRatio < 0) {
                        result = -result
                    }
                } else {
                    result = Math.round(offsetRatio)
                }
                return result
            }
        });
        registerEmitter({
            emitter: SwipeEmitter,
            events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
        });
        exports.swipe = SWIPE_EVENT;
        exports.start = SWIPE_START_EVENT;
        exports.end = SWIPE_END_EVENT
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/core/polyfills/weak_map.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var inArray = __webpack_require__( /*! ../../core/utils/array */ 14).inArray;
        var windowUtils = __webpack_require__( /*! ../../core/utils/window */ 7);
        var weakMap = windowUtils.hasWindow() ? windowUtils.getWindow().WeakMap : WeakMap;
        if (!weakMap) {
            weakMap = function() {
                var keys = [];
                var values = [];
                this.set = function(key, value) {
                    var index = inArray(key, keys);
                    if (index === -1) {
                        keys.push(key);
                        values.push(value)
                    } else {
                        values[index] = value
                    }
                };
                this.get = function(key) {
                    var index = inArray(key, keys);
                    if (index === -1) {
                        return
                    }
                    return values[index]
                };
                this.has = function(key) {
                    var index = inArray(key, keys);
                    if (index === -1) {
                        return false
                    }
                    return true
                };
                this.delete = function(key) {
                    var index = inArray(key, keys);
                    if (index === -1) {
                        return
                    }
                    keys.splice(index, 1);
                    values.splice(index, 1)
                }
            }
        }
        module.exports = weakMap
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/core/memorized_callbacks.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _callbacks = __webpack_require__( /*! ./utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var MemorizedCallbacks = function() {
            function MemorizedCallbacks() {
                _classCallCheck(this, MemorizedCallbacks);
                this.memory = [];
                this.callbacks = (0, _callbacks2.default)()
            }
            _createClass(MemorizedCallbacks, [{
                key: "add",
                value: function(fn) {
                    (0, _iterator.each)(this.memory, function(_, item) {
                        return fn.apply(fn, item)
                    });
                    this.callbacks.add(fn)
                }
            }, {
                key: "remove",
                value: function(fn) {
                    this.callbacks.remove(fn)
                }
            }, {
                key: "fire",
                value: function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key]
                    }
                    this.memory.push(args);
                    this.callbacks.fire.apply(this.callbacks, args)
                }
            }]);
            return MemorizedCallbacks
        }();
        exports.default = MemorizedCallbacks
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel_format_converter.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _string = __webpack_require__( /*! ../core/utils/string */ 43);
        var _string2 = _interopRequireDefault(_string);
        var _number = __webpack_require__( /*! ../localization/number */ 49);
        var _number2 = _interopRequireDefault(_number);
        var _date = __webpack_require__( /*! ../localization/date */ 35);
        var _date2 = _interopRequireDefault(_date);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _date3 = __webpack_require__( /*! ../localization/ldml/date.format */ 215);
        var _language_codes = __webpack_require__( /*! ../localization/language_codes */ 298);
        __webpack_require__( /*! ../localization/currency */ 131);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var ARABIC_ZERO_CODE = 1632;
        var DEFINED_NUMBER_FORMTATS = {
            thousands: "#,##0{0},&quot;K&quot;",
            millions: "#,##0{0},,&quot;M&quot;",
            billions: "#,##0{0},,,&quot;B&quot;",
            trillions: "#,##0{0},,,,&quot;T&quot;",
            percent: "0{0}%",
            decimal: "#{0}",
            fixedpoint: "#,##0{0}",
            exponential: "0{0}E+00",
            currency: " "
        };
        var PERIOD_REGEXP = /a+/g;
        var DAY_REGEXP = /E/g;
        var DO_REGEXP = /dE+/g;
        var STANDALONE_MONTH_REGEXP = /L/g;
        var HOUR_REGEXP = /h/g;
        var SLASH_REGEXP = /\//g;
        var SQUARE_OPEN_BRACKET_REGEXP = /\[/g;
        var SQUARE_CLOSE_BRACKET_REGEXP = /]/g;
        var ANY_REGEXP = /./g;
        var excelFormatConverter = module.exports = {
            _applyPrecision: function(format, precision) {
                var result;
                var i;
                if (precision > 0) {
                    result = "decimal" !== format ? "." : "";
                    for (i = 0; i < precision; i++) {
                        result += "0"
                    }
                    return result
                }
                return ""
            },
            _hasArabicDigits: function(text) {
                var code;
                for (var i = 0; i < text.length; i++) {
                    code = text.charCodeAt(i);
                    if (code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10) {
                        return true
                    }
                }
                return false
            },
            _convertDateFormatToOpenXml: function(format) {
                return format.replace(SLASH_REGEXP, "\\/").split("'").map(function(datePart, index) {
                    if (index % 2 === 0) {
                        return datePart.replace(PERIOD_REGEXP, "AM/PM").replace(DO_REGEXP, "d").replace(DAY_REGEXP, "d").replace(STANDALONE_MONTH_REGEXP, "M").replace(HOUR_REGEXP, "H").replace(SQUARE_OPEN_BRACKET_REGEXP, "\\[").replace(SQUARE_CLOSE_BRACKET_REGEXP, "\\]")
                    }
                    if (datePart) {
                        return datePart.replace(ANY_REGEXP, "\\$&")
                    }
                    return "'"
                }).join("")
            },
            _convertDateFormat: function(format) {
                var formattedValue = (_date2.default.format(new Date(2009, 8, 8, 6, 5, 4), format) || "").toString();
                var result = (0, _date3.getFormat)(function(value) {
                    return _date2.default.format(value, format)
                });
                if (result) {
                    result = this._convertDateFormatToOpenXml(result);
                    result = this._getLanguageInfo(formattedValue) + result
                }
                return result
            },
            _getLanguageInfo: function(defaultPattern) {
                var languageID = (0, _language_codes.getLanguageId)();
                var languageIDStr = languageID ? languageID.toString(16) : "";
                var languageInfo = "";
                if (this._hasArabicDigits(defaultPattern)) {
                    while (languageIDStr.length < 3) {
                        languageIDStr = "0" + languageIDStr
                    }
                    languageInfo = "[$-2010" + languageIDStr + "]"
                } else {
                    if (languageIDStr) {
                        languageInfo = "[$-" + languageIDStr + "]"
                    }
                }
                return languageInfo
            },
            _convertNumberFormat: function(format, precision, currency) {
                var result;
                var excelFormat;
                if ("currency" === format) {
                    excelFormat = _number2.default.getOpenXmlCurrencyFormat(currency)
                } else {
                    excelFormat = DEFINED_NUMBER_FORMTATS[format.toLowerCase()]
                }
                if (excelFormat) {
                    result = _string2.default.format(excelFormat, this._applyPrecision(format, precision))
                }
                return result
            },
            convertFormat: function(format, precision, type, currency) {
                if ((0, _type.isDefined)(format)) {
                    if ("date" === type) {
                        return excelFormatConverter._convertDateFormat(format)
                    } else {
                        if ((0, _type.isString)(format) && DEFINED_NUMBER_FORMTATS[format.toLowerCase()]) {
                            return excelFormatConverter._convertNumberFormat(format, precision, currency)
                        }
                    }
                }
            }
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/options/utils.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.getNestedOptionValue = exports.getParentName = exports.getFieldName = exports.deviceMatch = exports.normalizeOptions = exports.convertRulesToOptions = void 0;
        var _devices = __webpack_require__( /*! ../devices */ 15);
        var _devices2 = _interopRequireDefault(_devices);
        var _type = __webpack_require__( /*! ../utils/type */ 1);
        var _common = __webpack_require__( /*! ../utils/common */ 3);
        var _extend = __webpack_require__( /*! ../utils/extend */ 0);
        var _data = __webpack_require__( /*! ../utils/data */ 20);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var cachedGetters = {};
        exports.convertRulesToOptions = function(rules) {
            var currentDevice = _devices2.default.current();
            return rules.reduce(function(options, _ref) {
                var device = _ref.device,
                    ruleOptions = _ref.options;
                var deviceFilter = device || {};
                var match = (0, _type.isFunction)(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
                if (match) {
                    (0, _extend.extend)(true, options, ruleOptions)
                }
                return options
            }, {})
        };
        exports.normalizeOptions = function(options, value) {
            return "string" !== typeof options ? options : _defineProperty({}, options, value)
        };
        var deviceMatch = exports.deviceMatch = function(device, filter) {
            return (0, _type.isEmptyObject)(filter) || (0, _common.findBestMatches)(device, [filter]).length > 0
        };
        exports.getFieldName = function(fullName) {
            return fullName.substr(fullName.lastIndexOf(".") + 1)
        };
        exports.getParentName = function(fullName) {
            return fullName.substr(0, fullName.lastIndexOf("."))
        };
        exports.getNestedOptionValue = function(optionsObject, name) {
            cachedGetters[name] = cachedGetters[name] || (0, _data.compileGetter)(name);
            return cachedGetters[name](optionsObject, {
                functionsAsIs: true
            })
        }
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/animation/presets/presets.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Component = __webpack_require__( /*! ../../core/component */ 115);
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var devices = __webpack_require__( /*! ../../core/devices */ 15);
        var fx = __webpack_require__( /*! ../fx */ 40);
        var directionPostfixes = {
            forward: " dx-forward",
            backward: " dx-backward",
            none: " dx-no-direction",
            undefined: " dx-no-direction"
        };
        var optionPrefix = "preset_";
        var AnimationPresetCollection = Component.inherit({
            ctor: function() {
                this.callBase.apply(this, arguments);
                this._registeredPresets = [];
                this.resetToDefaults()
            },
            _getDefaultOptions: function() {
                return extend(this.callBase(), {
                    defaultAnimationDuration: 400,
                    defaultAnimationDelay: 0,
                    defaultStaggerAnimationDuration: 300,
                    defaultStaggerAnimationDelay: 40,
                    defaultStaggerAnimationStartDelay: 500
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                    device: function(_device) {
                        return _device.phone
                    },
                    options: {
                        defaultStaggerAnimationDuration: 350,
                        defaultStaggerAnimationDelay: 50,
                        defaultStaggerAnimationStartDelay: 0
                    }
                }, {
                    device: function() {
                        return devices.current().android || devices.real.android
                    },
                    options: {
                        defaultAnimationDelay: 100
                    }
                }])
            },
            _getPresetOptionName: function(animationName) {
                return optionPrefix + animationName
            },
            _createAndroidSlideAnimationConfig: function(throughOpacity, widthMultiplier) {
                var that = this;
                var createBaseConfig = function(configModifier) {
                    return {
                        type: "slide",
                        delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
                        duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
                    }
                };
                return {
                    enter: function($element, configModifier) {
                        var width = $element.parent().width() * widthMultiplier;
                        var direction = configModifier.direction;
                        var config = createBaseConfig(configModifier);
                        config.to = {
                            left: 0,
                            opacity: 1
                        };
                        if ("forward" === direction) {
                            config.from = {
                                left: width,
                                opacity: throughOpacity
                            }
                        } else {
                            if ("backward" === direction) {
                                config.from = {
                                    left: -width,
                                    opacity: throughOpacity
                                }
                            } else {
                                config.from = {
                                    left: 0,
                                    opacity: 0
                                }
                            }
                        }
                        return fx.createAnimation($element, config)
                    },
                    leave: function($element, configModifier) {
                        var width = $element.parent().width() * widthMultiplier;
                        var direction = configModifier.direction;
                        var config = createBaseConfig(configModifier);
                        config.from = {
                            left: 0,
                            opacity: 1
                        };
                        if ("forward" === direction) {
                            config.to = {
                                left: -width,
                                opacity: throughOpacity
                            }
                        } else {
                            if ("backward" === direction) {
                                config.to = {
                                    left: width,
                                    opacity: throughOpacity
                                }
                            } else {
                                config.to = {
                                    left: 0,
                                    opacity: 0
                                }
                            }
                        }
                        return fx.createAnimation($element, config)
                    }
                }
            },
            _createOpenDoorConfig: function() {
                var that = this;
                var createBaseConfig = function(configModifier) {
                    return {
                        type: "css",
                        extraCssClasses: "dx-opendoor-animation",
                        delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
                        duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
                    }
                };
                return {
                    enter: function($element, configModifier) {
                        var direction = configModifier.direction;
                        var config = createBaseConfig(configModifier);
                        config.delay = "none" === direction ? config.delay : config.duration;
                        config.from = "dx-enter dx-opendoor-animation" + directionPostfixes[direction];
                        config.to = "dx-enter-active";
                        return fx.createAnimation($element, config)
                    },
                    leave: function($element, configModifier) {
                        var direction = configModifier.direction;
                        var config = createBaseConfig(configModifier);
                        config.from = "dx-leave dx-opendoor-animation" + directionPostfixes[direction];
                        config.to = "dx-leave-active";
                        return fx.createAnimation($element, config)
                    }
                }
            },
            _createWinPopConfig: function() {
                var that = this;
                var baseConfig = {
                    type: "css",
                    extraCssClasses: "dx-win-pop-animation",
                    duration: that.option("defaultAnimationDuration")
                };
                return {
                    enter: function($element, configModifier) {
                        var config = baseConfig;
                        var direction = configModifier.direction;
                        config.delay = "none" === direction ? that.option("defaultAnimationDelay") : that.option("defaultAnimationDuration") / 2;
                        config.from = "dx-enter dx-win-pop-animation" + directionPostfixes[direction];
                        config.to = "dx-enter-active";
                        return fx.createAnimation($element, config)
                    },
                    leave: function($element, configModifier) {
                        var config = baseConfig;
                        var direction = configModifier.direction;
                        config.delay = that.option("defaultAnimationDelay");
                        config.from = "dx-leave dx-win-pop-animation" + directionPostfixes[direction];
                        config.to = "dx-leave-active";
                        return fx.createAnimation($element, config)
                    }
                }
            },
            resetToDefaults: function() {
                this.clear();
                this.registerDefaultPresets();
                this.applyChanges()
            },
            clear: function(name) {
                var that = this;
                var newRegisteredPresets = [];
                each(this._registeredPresets, function(index, preset) {
                    if (!name || name === preset.name) {
                        that.option(that._getPresetOptionName(preset.name), void 0)
                    } else {
                        newRegisteredPresets.push(preset)
                    }
                });
                this._registeredPresets = newRegisteredPresets;
                this.applyChanges()
            },
            registerPreset: function(name, config) {
                this._registeredPresets.push({
                    name: name,
                    config: config
                })
            },
            applyChanges: function() {
                var that = this;
                var customRules = [];
                each(this._registeredPresets, function(index, preset) {
                    var rule = {
                        device: preset.config.device,
                        options: {}
                    };
                    rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
                    customRules.push(rule)
                });
                this._setOptionsByDevice(customRules)
            },
            getPreset: function(name) {
                var result = name;
                while ("string" === typeof result) {
                    result = this.option(this._getPresetOptionName(result))
                }
                return result
            },
            registerDefaultPresets: function() {
                this.registerPreset("pop", {
                    animation: {
                        extraCssClasses: "dx-android-pop-animation",
                        delay: this.option("defaultAnimationDelay"),
                        duration: this.option("defaultAnimationDuration")
                    }
                });
                this.registerPreset("openDoor", {
                    animation: this._createOpenDoorConfig()
                });
                this.registerPreset("win-pop", {
                    animation: this._createWinPopConfig()
                });
                this.registerPreset("fade", {
                    animation: {
                        extraCssClasses: "dx-fade-animation",
                        delay: this.option("defaultAnimationDelay"),
                        duration: this.option("defaultAnimationDuration")
                    }
                });
                this.registerPreset("slide", {
                    device: function() {
                        return devices.current().android || devices.real.android
                    },
                    animation: this._createAndroidSlideAnimationConfig(1, 1)
                });
                this.registerPreset("slide", {
                    device: function() {
                        return !devices.current().android && !devices.real.android
                    },
                    animation: {
                        extraCssClasses: "dx-slide-animation",
                        delay: this.option("defaultAnimationDelay"),
                        duration: this.option("defaultAnimationDuration")
                    }
                });
                this.registerPreset("ios7-slide", {
                    animation: {
                        extraCssClasses: "dx-ios7-slide-animation",
                        delay: this.option("defaultAnimationDelay"),
                        duration: this.option("defaultAnimationDuration")
                    }
                });
                this.registerPreset("overflow", {
                    animation: {
                        extraCssClasses: "dx-overflow-animation",
                        delay: this.option("defaultAnimationDelay"),
                        duration: this.option("defaultAnimationDuration")
                    }
                });
                this.registerPreset("ios7-toolbar", {
                    device: function() {
                        return !devices.current().android && !devices.real.android
                    },
                    animation: {
                        extraCssClasses: "dx-ios7-toolbar-animation",
                        delay: this.option("defaultAnimationDelay"),
                        duration: this.option("defaultAnimationDuration")
                    }
                });
                this.registerPreset("ios7-toolbar", {
                    device: function() {
                        return devices.current().android || devices.real.android
                    },
                    animation: this._createAndroidSlideAnimationConfig(0, .4)
                });
                this.registerPreset("stagger-fade", {
                    animation: {
                        extraCssClasses: "dx-fade-animation",
                        staggerDelay: this.option("defaultStaggerAnimationDelay"),
                        duration: this.option("defaultStaggerAnimationDuration"),
                        delay: this.option("defaultStaggerAnimationStartDelay")
                    }
                });
                this.registerPreset("stagger-slide", {
                    animation: {
                        extraCssClasses: "dx-slide-animation",
                        staggerDelay: this.option("defaultStaggerAnimationDelay"),
                        duration: this.option("defaultStaggerAnimationDuration"),
                        delay: this.option("defaultStaggerAnimationStartDelay")
                    }
                });
                this.registerPreset("stagger-fade-slide", {
                    animation: {
                        extraCssClasses: "dx-fade-slide-animation",
                        staggerDelay: this.option("defaultStaggerAnimationDelay"),
                        duration: this.option("defaultStaggerAnimationDuration"),
                        delay: this.option("defaultStaggerAnimationStartDelay")
                    }
                });
                this.registerPreset("stagger-drop", {
                    animation: {
                        extraCssClasses: "dx-drop-animation",
                        staggerDelay: this.option("defaultStaggerAnimationDelay"),
                        duration: this.option("defaultStaggerAnimationDuration"),
                        delay: this.option("defaultStaggerAnimationStartDelay")
                    }
                });
                this.registerPreset("stagger-fade-drop", {
                    animation: {
                        extraCssClasses: "dx-fade-drop-animation",
                        staggerDelay: this.option("defaultStaggerAnimationDelay"),
                        duration: this.option("defaultStaggerAnimationDuration"),
                        delay: this.option("defaultStaggerAnimationStartDelay")
                    }
                });
                this.registerPreset("stagger-fade-rise", {
                    animation: {
                        extraCssClasses: "dx-fade-rise-animation",
                        staggerDelay: this.option("defaultStaggerAnimationDelay"),
                        duration: this.option("defaultStaggerAnimationDuration"),
                        delay: this.option("defaultStaggerAnimationStartDelay")
                    }
                });
                this.registerPreset("stagger-3d-drop", {
                    animation: {
                        extraCssClasses: "dx-3d-drop-animation",
                        staggerDelay: this.option("defaultStaggerAnimationDelay"),
                        duration: this.option("defaultStaggerAnimationDuration"),
                        delay: this.option("defaultStaggerAnimationStartDelay")
                    }
                });
                this.registerPreset("stagger-fade-zoom", {
                    animation: {
                        extraCssClasses: "dx-fade-zoom-animation",
                        staggerDelay: this.option("defaultStaggerAnimationDelay"),
                        duration: this.option("defaultStaggerAnimationDuration"),
                        delay: this.option("defaultStaggerAnimationStartDelay")
                    }
                })
            }
        });
        exports.PresetCollection = AnimationPresetCollection;
        var animationPresets = new AnimationPresetCollection;
        exports.presets = animationPresets
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/integration/angular/module.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var angular = __webpack_require__( /*! angular */ 287);
        module.exports = angular.module("dx", [])
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/data/query_adapters.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = {}
    },
    /*!****************************************************************************************!*\
      !*** ./artifacts/transpiled/ui/collection/ui.collection_widget.edit.strategy.plain.js ***!
      \****************************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var inArray = __webpack_require__( /*! ../../core/utils/array */ 14).inArray;
        var EditStrategy = __webpack_require__( /*! ./ui.collection_widget.edit.strategy */ 498);
        var PlainEditStrategy = EditStrategy.inherit({
            _getPlainItems: function() {
                return this._collectionWidget.option("items") || []
            },
            getIndexByItemData: function(itemData) {
                var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
                if (keyOf) {
                    return this.getIndexByKey(keyOf(itemData))
                } else {
                    return inArray(itemData, this._getPlainItems())
                }
            },
            getItemDataByIndex: function(index) {
                return this._getPlainItems()[index]
            },
            deleteItemAtIndex: function(index) {
                this._getPlainItems().splice(index, 1)
            },
            itemsGetter: function() {
                return this._getPlainItems()
            },
            getKeysByItems: function(items) {
                var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
                var result = items;
                if (keyOf) {
                    result = [];
                    for (var i = 0; i < items.length; i++) {
                        result.push(keyOf(items[i]))
                    }
                }
                return result
            },
            getIndexByKey: function(key) {
                var cache = this._cache;
                var keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
                if (cache && !cache.keys) {
                    cache.keys = keys
                }
                if ("object" === _typeof(key)) {
                    for (var i = 0, length = keys.length; i < length; i++) {
                        if (this._equalKeys(key, keys[i])) {
                            return i
                        }
                    }
                } else {
                    return keys.indexOf(key)
                }
                return -1
            },
            getItemsByKeys: function(keys, items) {
                return (items || keys).slice()
            },
            moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
                var items = this._getPlainItems();
                var movedItemData = items[movingIndex];
                items.splice(movingIndex, 1);
                items.splice(destinationIndex, 0, movedItemData)
            },
            _isItemIndex: function(index) {
                return "number" === typeof index && Math.round(index) === index
            },
            _getNormalizedItemIndex: function(itemElement) {
                return this._collectionWidget._itemElements().index(itemElement)
            },
            _normalizeItemIndex: function(index) {
                return index
            },
            _denormalizeItemIndex: function(index) {
                return index
            },
            _getItemByNormalizedIndex: function(index) {
                return index > -1 ? this._collectionWidget._itemElements().eq(index) : null
            },
            _itemsFromSameParent: function() {
                return true
            }
        });
        module.exports = PlainEditStrategy
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/localization/globalize/number.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        __webpack_require__( /*! ./core */ 136);
        var _globalize = __webpack_require__( /*! globalize */ 79);
        var _globalize2 = _interopRequireDefault(_globalize);
        var _number = __webpack_require__( /*! ../number */ 49);
        var _number2 = _interopRequireDefault(_number);
        var _errors = __webpack_require__( /*! ../../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        __webpack_require__( /*! globalize/number */ 79);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        if (_globalize2.default && _globalize2.default.formatNumber) {
            var enNumbers = {
                main: {
                    en: {
                        identity: {
                            version: {
                                _cldrVersion: "28",
                                _number: "$Revision: 11972 $"
                            },
                            language: "en"
                        },
                        numbers: {
                            defaultNumberingSystem: "latn",
                            otherNumberingSystems: {
                                "native": "latn"
                            },
                            minimumGroupingDigits: "1",
                            "symbols-numberSystem-latn": {
                                decimal: ".",
                                group: ",",
                                list: ";",
                                percentSign: "%",
                                plusSign: "+",
                                minusSign: "-",
                                exponential: "E",
                                superscriptingExponent: "\xd7",
                                perMille: "\u2030",
                                infinity: "\u221e",
                                nan: "NaN",
                                timeSeparator: ":"
                            },
                            "decimalFormats-numberSystem-latn": {
                                standard: "#,##0.###",
                                "long": {
                                    decimalFormat: {
                                        "1000-count-one": "0 thousand",
                                        "1000-count-other": "0 thousand",
                                        "10000-count-one": "00 thousand",
                                        "10000-count-other": "00 thousand",
                                        "100000-count-one": "000 thousand",
                                        "100000-count-other": "000 thousand",
                                        "1000000-count-one": "0 million",
                                        "1000000-count-other": "0 million",
                                        "10000000-count-one": "00 million",
                                        "10000000-count-other": "00 million",
                                        "100000000-count-one": "000 million",
                                        "100000000-count-other": "000 million",
                                        "1000000000-count-one": "0 billion",
                                        "1000000000-count-other": "0 billion",
                                        "10000000000-count-one": "00 billion",
                                        "10000000000-count-other": "00 billion",
                                        "100000000000-count-one": "000 billion",
                                        "100000000000-count-other": "000 billion",
                                        "1000000000000-count-one": "0 trillion",
                                        "1000000000000-count-other": "0 trillion",
                                        "10000000000000-count-one": "00 trillion",
                                        "10000000000000-count-other": "00 trillion",
                                        "100000000000000-count-one": "000 trillion",
                                        "100000000000000-count-other": "000 trillion"
                                    }
                                },
                                "short": {
                                    decimalFormat: {
                                        "1000-count-one": "0K",
                                        "1000-count-other": "0K",
                                        "10000-count-one": "00K",
                                        "10000-count-other": "00K",
                                        "100000-count-one": "000K",
                                        "100000-count-other": "000K",
                                        "1000000-count-one": "0M",
                                        "1000000-count-other": "0M",
                                        "10000000-count-one": "00M",
                                        "10000000-count-other": "00M",
                                        "100000000-count-one": "000M",
                                        "100000000-count-other": "000M",
                                        "1000000000-count-one": "0B",
                                        "1000000000-count-other": "0B",
                                        "10000000000-count-one": "00B",
                                        "10000000000-count-other": "00B",
                                        "100000000000-count-one": "000B",
                                        "100000000000-count-other": "000B",
                                        "1000000000000-count-one": "0T",
                                        "1000000000000-count-other": "0T",
                                        "10000000000000-count-one": "00T",
                                        "10000000000000-count-other": "00T",
                                        "100000000000000-count-one": "000T",
                                        "100000000000000-count-other": "000T"
                                    }
                                }
                            },
                            "scientificFormats-numberSystem-latn": {
                                standard: "#E0"
                            },
                            "percentFormats-numberSystem-latn": {
                                standard: "#,##0%"
                            },
                            "currencyFormats-numberSystem-latn": {
                                currencySpacing: {
                                    beforeCurrency: {
                                        currencyMatch: "[:^S:]",
                                        surroundingMatch: "[:digit:]",
                                        insertBetween: "\xa0"
                                    },
                                    afterCurrency: {
                                        currencyMatch: "[:^S:]",
                                        surroundingMatch: "[:digit:]",
                                        insertBetween: "\xa0"
                                    }
                                },
                                standard: "\xa4#,##0.00",
                                accounting: "\xa4#,##0.00;(\xa4#,##0.00)",
                                "short": {
                                    standard: {
                                        "1000-count-one": "\xa40K",
                                        "1000-count-other": "\xa40K",
                                        "10000-count-one": "\xa400K",
                                        "10000-count-other": "\xa400K",
                                        "100000-count-one": "\xa4000K",
                                        "100000-count-other": "\xa4000K",
                                        "1000000-count-one": "\xa40M",
                                        "1000000-count-other": "\xa40M",
                                        "10000000-count-one": "\xa400M",
                                        "10000000-count-other": "\xa400M",
                                        "100000000-count-one": "\xa4000M",
                                        "100000000-count-other": "\xa4000M",
                                        "1000000000-count-one": "\xa40B",
                                        "1000000000-count-other": "\xa40B",
                                        "10000000000-count-one": "\xa400B",
                                        "10000000000-count-other": "\xa400B",
                                        "100000000000-count-one": "\xa4000B",
                                        "100000000000-count-other": "\xa4000B",
                                        "1000000000000-count-one": "\xa40T",
                                        "1000000000000-count-other": "\xa40T",
                                        "10000000000000-count-one": "\xa400T",
                                        "10000000000000-count-other": "\xa400T",
                                        "100000000000000-count-one": "\xa4000T",
                                        "100000000000000-count-other": "\xa4000T"
                                    }
                                },
                                "unitPattern-count-one": "{0} {1}",
                                "unitPattern-count-other": "{0} {1}"
                            },
                            "miscPatterns-numberSystem-latn": {
                                atLeast: "{0}+",
                                range: "{0}\u2013{1}"
                            }
                        }
                    }
                }
            };
            if ("en" === _globalize2.default.locale().locale) {
                _globalize2.default.load(enNumbers);
                _globalize2.default.locale("en")
            }
            var formattersCache = {};
            var getFormatter = function(format) {
                var formatter;
                var formatCacheKey;
                if ("object" === _typeof(format)) {
                    formatCacheKey = _globalize2.default.locale().locale + ":" + JSON.stringify(format)
                } else {
                    formatCacheKey = _globalize2.default.locale().locale + ":" + format
                }
                formatter = formattersCache[formatCacheKey];
                if (!formatter) {
                    formatter = formattersCache[formatCacheKey] = _globalize2.default.numberFormatter(format)
                }
                return formatter
            };
            var globalizeNumberLocalization = {
                engine: function() {
                    return "globalize"
                },
                _formatNumberCore: function(value, format, formatConfig) {
                    if ("exponential" === format) {
                        return this.callBase.apply(this, arguments)
                    }
                    return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value)
                },
                _normalizeFormatConfig: function(format, formatConfig, value) {
                    var config;
                    if ("decimal" === format) {
                        config = {
                            minimumIntegerDigits: formatConfig.precision || 1,
                            useGrouping: false,
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 20,
                            round: value < 0 ? "ceil" : "floor"
                        }
                    } else {
                        config = this._getPrecisionConfig(formatConfig.precision)
                    }
                    if ("percent" === format) {
                        config.style = "percent"
                    }
                    return config
                },
                _getPrecisionConfig: function(precision) {
                    var config;
                    if (null === precision) {
                        config = {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 20
                        }
                    } else {
                        config = {
                            minimumFractionDigits: precision || 0,
                            maximumFractionDigits: precision || 0
                        }
                    }
                    return config
                },
                format: function(value, _format) {
                    if ("number" !== typeof value) {
                        return value
                    }
                    _format = this._normalizeFormat(_format);
                    if (!_format || "function" !== typeof _format && !_format.type && !_format.formatter) {
                        return getFormatter(_format)(value)
                    }
                    return this.callBase.apply(this, arguments)
                },
                parse: function(text, format) {
                    if (!text) {
                        return
                    }
                    if (format && (format.parser || "string" === typeof format)) {
                        return this.callBase.apply(this, arguments)
                    }
                    if (format) {
                        _errors2.default.log("W0011")
                    }
                    var result = _globalize2.default.parseNumber(text);
                    if (isNaN(result)) {
                        result = this.callBase.apply(this, arguments)
                    }
                    return result
                }
            };
            _number2.default.resetInjection();
            _number2.default.inject(globalizeNumberLocalization)
        }
    }, , , , , , , , , , , , , , ,
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/components/legend.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _extend2 = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _layout_element = __webpack_require__( /*! ../core/layout_element */ 258);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _title = __webpack_require__( /*! ../core/title */ 109);
        var _title2 = _interopRequireDefault(_title);
        var _object = __webpack_require__( /*! ../../core/utils/object */ 47);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _renderer = __webpack_require__( /*! ../core/renderers/renderer */ 163);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _Number = Number;
        var _math = Math;
        var _round = _math.round;
        var _max = _math.max;
        var _min = _math.min;
        var _ceil = _math.ceil;
        var _isDefined = _type.isDefined;
        var _isFunction = _type.isFunction;
        var _enumParser = _utils.enumParser;
        var _normalizeEnum = _utils.normalizeEnum;
        var _extend = _extend2.extend;
        var DEFAULT_MARGIN = 10;
        var DEFAULT_MARKER_HATCHING_WIDTH = 2;
        var DEFAULT_MARKER_HATCHING_STEP = 5;
        var CENTER = "center";
        var RIGHT = "right";
        var LEFT = "left";
        var TOP = "top";
        var BOTTOM = "bottom";
        var HORIZONTAL = "horizontal";
        var VERTICAL = "vertical";
        var INSIDE = "inside";
        var OUTSIDE = "outside";
        var NONE = "none";
        var HEIGHT = "height";
        var WIDTH = "width";
        var parseHorizontalAlignment = _enumParser([LEFT, CENTER, RIGHT]);
        var parseVerticalAlignment = _enumParser([TOP, BOTTOM]);
        var parseOrientation = _enumParser([VERTICAL, HORIZONTAL]);
        var parseItemTextPosition = _enumParser([LEFT, RIGHT, TOP, BOTTOM]);
        var parsePosition = _enumParser([OUTSIDE, INSIDE]);
        var parseItemsAlignment = _enumParser([LEFT, CENTER, RIGHT]);

        function getState(state, color, stateName) {
            if (!state) {
                return
            }
            var colorFromAction = state.fill;
            return (0, _extend2.extend)({}, {
                state: stateName,
                fill: colorFromAction === NONE ? color : colorFromAction,
                opacity: state.opacity,
                hatching: _extend({}, state.hatching, {
                    step: DEFAULT_MARKER_HATCHING_STEP,
                    width: DEFAULT_MARKER_HATCHING_WIDTH
                })
            })
        }

        function getAttributes(item, state, size) {
            var attrs = (0, _renderer.processHatchingAttrs)(item, state);
            if (attrs.fill && 0 === attrs.fill.indexOf("DevExpress")) {
                attrs.fill = (0, _renderer.getFuncIri)(attrs.fill)
            }
            attrs.opacity = attrs.opacity >= 0 ? attrs.opacity : 1;
            return (0, _extend2.extend)({}, attrs, {
                size: size
            })
        }

        function parseMargins(options) {
            var margin = options.margin;
            if (margin >= 0) {
                margin = _Number(options.margin);
                margin = {
                    top: margin,
                    bottom: margin,
                    left: margin,
                    right: margin
                }
            } else {
                margin = {
                    top: margin.top >= 0 ? _Number(margin.top) : DEFAULT_MARGIN,
                    bottom: margin.bottom >= 0 ? _Number(margin.bottom) : DEFAULT_MARGIN,
                    left: margin.left >= 0 ? _Number(margin.left) : DEFAULT_MARGIN,
                    right: margin.right >= 0 ? _Number(margin.right) : DEFAULT_MARGIN
                }
            }
            options.margin = margin
        }

        function getSizeItem(options, markerBBox, labelBBox) {
            var defaultXMargin = 7;
            var defaultTopMargin = 4;
            var width;
            var height;
            switch (options.itemTextPosition) {
                case LEFT:
                case RIGHT:
                    width = markerBBox.width + defaultXMargin + labelBBox.width;
                    height = _max(markerBBox.height, labelBBox.height);
                    break;
                case TOP:
                case BOTTOM:
                    width = _max(markerBBox.width, labelBBox.width);
                    height = markerBBox.height + defaultTopMargin + labelBBox.height
            }
            return {
                width: width,
                height: height
            }
        }

        function calculateBBoxLabelAndMarker(markerBBox, labelBBox) {
            var bBox = {};
            bBox.left = _min(markerBBox.x, labelBBox.x);
            bBox.top = _min(markerBBox.y, labelBBox.y);
            bBox.right = _max(markerBBox.x + markerBBox.width, labelBBox.x + labelBBox.width);
            bBox.bottom = _max(markerBBox.y + markerBBox.height, labelBBox.y + labelBBox.height);
            return bBox
        }

        function applyMarkerState(id, idToIndexMap, items, stateName) {
            var item = idToIndexMap && items[idToIndexMap[id]];
            if (item) {
                item.renderMarker(item.states[stateName])
            }
        }

        function parseOptions(options, textField, allowInsidePosition) {
            if (!options) {
                return null
            }
            var debug = __webpack_require__( /*! ../../core/utils/console */ 65).debug;
            debug.assertParam(options.visible, "Visibility was not passed");
            debug.assertParam(options.markerSize, "markerSize was not passed");
            debug.assertParam(options.font.color, "fontColor was not passed");
            debug.assertParam(options.font.family, "fontFamily was not passed");
            debug.assertParam(options.font.size, "fontSize was not passed");
            debug.assertParam(options.paddingLeftRight, "paddingLeftRight was not passed");
            debug.assertParam(options.paddingTopBottom, "paddingTopBottom was not passed");
            debug.assertParam(options.columnItemSpacing, "columnItemSpacing was not passed");
            debug.assertParam(options.rowItemSpacing, "rowItemSpacing was not passed");
            parseMargins(options);
            options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, RIGHT);
            options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, options.horizontalAlignment === CENTER ? BOTTOM : TOP);
            options.orientation = parseOrientation(options.orientation, options.horizontalAlignment === CENTER ? HORIZONTAL : VERTICAL);
            options.itemTextPosition = parseItemTextPosition(options.itemTextPosition, options.orientation === HORIZONTAL ? BOTTOM : RIGHT);
            options.position = allowInsidePosition ? parsePosition(options.position, OUTSIDE) : OUTSIDE;
            options.itemsAlignment = parseItemsAlignment(options.itemsAlignment, null);
            options.hoverMode = _normalizeEnum(options.hoverMode);
            options.customizeText = _isFunction(options.customizeText) ? options.customizeText : function() {
                return this[textField]
            };
            options.customizeHint = _isFunction(options.customizeHint) ? options.customizeHint : _common.noop;
            options._incidentOccurred = options._incidentOccurred || _common.noop;
            return options
        }

        function createSquareMarker(renderer, size) {
            return renderer.rect(0, 0, size, size)
        }

        function createCircleMarker(renderer, size) {
            return renderer.circle(size / 2, size / 2, size / 2)
        }

        function isCircle(type) {
            return "circle" === _normalizeEnum(type)
        }

        function inRect(rect, x, y) {
            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom
        }

        function checkLinesSize(lines, layoutOptions, countItems, margins) {
            var position = {
                x: 0,
                y: 0
            };
            var maxMeasureLength = 0;
            var maxAltMeasureLength = 0;
            var margin = 0;
            if ("y" === layoutOptions.direction) {
                margin = margins.top + margins.bottom
            } else {
                margin = margins.left + margins.right
            }
            lines.forEach(function(line, i) {
                var firstItem = line[0];
                var lineLength = line.length;
                line.forEach(function(item, index) {
                    var offset = item.offset || layoutOptions.spacing;
                    position[layoutOptions.direction] += item[layoutOptions.measure] + (index !== lineLength - 1 ? offset : 0);
                    maxMeasureLength = _max(maxMeasureLength, position[layoutOptions.direction])
                });
                position[layoutOptions.direction] = 0;
                position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + firstItem.altOffset || layoutOptions.altSpacing;
                maxAltMeasureLength = _max(maxAltMeasureLength, position[layoutOptions.altDirection])
            });
            if (maxMeasureLength + margin > layoutOptions.length) {
                layoutOptions.countItem = decreaseItemCount(layoutOptions, countItems);
                return true
            }
        }

        function decreaseItemCount(layoutOptions, countItems) {
            layoutOptions.altCountItem++;
            return _ceil(countItems / layoutOptions.altCountItem)
        }

        function getLineLength(line, layoutOptions) {
            return line.reduce(function(lineLength, item) {
                var offset = item.offset || layoutOptions.spacing;
                return lineLength + item[layoutOptions.measure] + offset
            }, 0)
        }

        function getMaxLineLength(lines, layoutOptions) {
            return lines.reduce(function(maxLineLength, line) {
                return _max(maxLineLength, getLineLength(line, layoutOptions))
            }, 0)
        }

        function getInitPositionForDirection(line, layoutOptions, maxLineLength) {
            var lineLength = getLineLength(line, layoutOptions);
            var initPosition;
            switch (layoutOptions.itemsAlignment) {
                case RIGHT:
                    initPosition = maxLineLength - lineLength;
                    break;
                case CENTER:
                    initPosition = (maxLineLength - lineLength) / 2;
                    break;
                default:
                    initPosition = 0
            }
            return initPosition
        }

        function getPos(layoutOptions) {
            switch (layoutOptions.itemTextPosition) {
                case BOTTOM:
                    return {
                        horizontal: CENTER, vertical: TOP
                    };
                case TOP:
                    return {
                        horizontal: CENTER, vertical: BOTTOM
                    };
                case LEFT:
                    return {
                        horizontal: RIGHT, vertical: CENTER
                    };
                case RIGHT:
                    return {
                        horizontal: LEFT, vertical: CENTER
                    }
            }
        }

        function getLines(lines, layoutOptions, itemIndex) {
            var tableLine = {};
            if (itemIndex % layoutOptions.countItem === 0) {
                if (layoutOptions.markerOffset) {
                    lines.push([], [])
                } else {
                    lines.push([])
                }
            }
            if (layoutOptions.markerOffset) {
                tableLine.firstLine = lines[lines.length - 1];
                tableLine.secondLine = lines[lines.length - 2]
            } else {
                tableLine.firstLine = tableLine.secondLine = lines[lines.length - 1]
            }
            return tableLine
        }

        function setMaxInLine(line, measure) {
            var maxLineSize = line.reduce(function(maxLineSize, item) {
                var itemMeasure = item ? item[measure] : maxLineSize;
                return _max(maxLineSize, itemMeasure)
            }, 0);
            line.forEach(function(item) {
                if (item) {
                    item[measure] = maxLineSize
                }
            })
        }

        function transpose(array) {
            var width = array.length;
            var height = array[0].length;
            var i;
            var j;
            var transposeArray = [];
            for (i = 0; i < height; i++) {
                transposeArray[i] = [];
                for (j = 0; j < width; j++) {
                    transposeArray[i][j] = array[j][i]
                }
            }
            return transposeArray
        }

        function getAlign(position) {
            switch (position) {
                case TOP:
                case BOTTOM:
                    return CENTER;
                case LEFT:
                    return RIGHT;
                case RIGHT:
                    return LEFT
            }
        }
        var getMarkerCreator = function(type) {
            return isCircle(type) ? createCircleMarker : createSquareMarker
        };

        function getTitleHorizontalAlignment(options) {
            if (options.horizontalAlignment === CENTER) {
                return CENTER
            } else {
                if (options.itemTextPosition === RIGHT) {
                    return LEFT
                } else {
                    if (options.itemTextPosition === LEFT) {
                        return RIGHT
                    } else {
                        return CENTER
                    }
                }
            }
        }
        var _Legend = exports.Legend = function(settings) {
            var that = this;
            that._renderer = settings.renderer;
            that._legendGroup = settings.group;
            that._backgroundClass = settings.backgroundClass;
            that._itemGroupClass = settings.itemGroupClass;
            that._textField = settings.textField;
            that._getCustomizeObject = settings.getFormatObject;
            that._titleGroupClass = settings.titleGroupClass;
            that._allowInsidePosition = settings.allowInsidePosition;
            that._widget = settings.widget
        };
        var legendPrototype = _Legend.prototype = (0, _object.clone)(_layout_element.LayoutElement.prototype);
        (0, _extend2.extend)(legendPrototype, {
            constructor: _Legend,
            getOptions: function() {
                return this._options
            },
            update: function() {
                var data = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                var options = arguments.length > 1 ? arguments[1] : void 0;
                var themeManagerTitleOptions = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                var that = this;
                options = that._options = parseOptions(options, that._textField, that._allowInsidePosition) || {};
                var initMarkerSize = options.markerSize;
                this._data = data.map(function(dataItem) {
                    dataItem.size = _Number(dataItem.size > 0 ? dataItem.size : initMarkerSize);
                    dataItem.marker = getAttributes(dataItem, dataItem.states.normal);
                    Object.defineProperty(dataItem.marker, "size", {
                        get: function() {
                            return dataItem.size
                        },
                        set: function(value) {
                            dataItem.size = value
                        }
                    });
                    Object.defineProperty(dataItem.marker, "opacity", {
                        get: function() {
                            return dataItem.states.normal.opacity
                        },
                        set: function(value) {
                            dataItem.states.normal.opacity = dataItem.states.hover.opacity = dataItem.states.selection.opacity = value
                        }
                    });
                    return dataItem
                });
                if (options.customizeItems) {
                    that._data = options.customizeItems(data.slice()) || data
                }
                that._boundingRect = {
                    width: 0,
                    height: 0,
                    x: 0,
                    y: 0
                };
                if (that.isVisible() && !that._title) {
                    that._title = new _title2.default.Title({
                        renderer: that._renderer,
                        cssClass: that._titleGroupClass,
                        root: that._legendGroup
                    })
                }
                if (that._title) {
                    var titleOptions = options.title;
                    themeManagerTitleOptions.horizontalAlignment = getTitleHorizontalAlignment(options);
                    that._title.update(themeManagerTitleOptions, titleOptions)
                }
                this.erase();
                return that
            },
            isVisible: function() {
                return this._options && this._options.visible
            },
            draw: function(width, height) {
                var that = this;
                var options = that._options;
                var items = that._getItemData();
                that._size = {
                    width: width,
                    height: height
                };
                that.erase();
                if (!(that.isVisible() && items && items.length)) {
                    return that
                }
                that._insideLegendGroup = that._renderer.g().enableLinks().append(that._legendGroup);
                that._title.changeLink(that._insideLegendGroup);
                that._createBackground();
                if (that._title.hasText()) {
                    var horizontalPadding = that._background ? 2 * that._options.paddingLeftRight : 0;
                    that._title.draw(width - horizontalPadding, height)
                }
                that._markersGroup = that._renderer.g().attr({
                    "class": that._itemGroupClass
                }).append(that._insideLegendGroup);
                that._createItems(items);
                that._locateElements(options);
                that._finalUpdate(options);
                var size = that.getLayoutOptions();
                if (size.width > width || size.height > height) {
                    that.freeSpace()
                }
                return that
            },
            probeDraw: function(width, height) {
                return this.draw(width, height)
            },
            _createItems: function(items) {
                var that = this;
                var options = that._options;
                var renderer = that._renderer;
                var maxBBoxHeight = 0;
                var createMarker = getMarkerCreator(options.markerShape);
                that._markersId = {};
                var templateFunction = !options.markerTemplate ? function(dataItem, group) {
                    var attrs = dataItem.marker;
                    createMarker(renderer, attrs.size).attr({
                        fill: attrs.fill,
                        opacity: attrs.opacity
                    }).append({
                        element: group
                    })
                } : options.markerTemplate;
                var template = that._widget._getTemplate(templateFunction);
                var markersGroup = that._markersGroup;
                markersGroup.css((0, _utils.patchFontOptions)(options.font));
                that._items = (items || []).map(function(dataItem, i) {
                    var stateOfDataItem = dataItem.states;
                    var normalState = stateOfDataItem.normal;
                    var normalStateFill = normalState.fill;
                    dataItem.size = dataItem.marker.size;
                    var states = {
                        normal: (0, _extend2.extend)(normalState, {
                            fill: normalStateFill || options.markerColor || options.defaultColor,
                            state: "normal"
                        }),
                        hover: getState(stateOfDataItem.hover, normalStateFill, "hovered"),
                        selection: getState(stateOfDataItem.selection, normalStateFill, "selected")
                    };
                    dataItem.states = states;
                    var itemGroup = renderer.g().append(markersGroup);
                    var markerGroup = renderer.g().attr({
                        "class": "dxl-marker"
                    }).append(itemGroup);
                    var item = {
                        label: that._createLabel(dataItem, itemGroup),
                        marker: markerGroup,
                        renderer: renderer,
                        group: itemGroup,
                        tracker: {
                            id: dataItem.id,
                            argument: dataItem.argument,
                            argumentIndex: dataItem.argumentIndex
                        },
                        states: states,
                        itemTextPosition: options.itemTextPosition,
                        markerOffset: 0,
                        bBoxes: [],
                        renderMarker: function(state) {
                            dataItem.marker = getAttributes(item, state, dataItem.size);
                            markerGroup.clear();
                            var isRendered = false;
                            template.render({
                                model: dataItem,
                                container: markerGroup.element,
                                onRendered: function() {
                                    isRendered = true;
                                    if (isAsyncRendering) {
                                        that._widget._requestChange(["LAYOUT"])
                                    }
                                }
                            });
                            var isAsyncRendering = !isRendered && 0 === markerGroup.element.childNodes.length
                        }
                    };
                    item.renderMarker(states.normal);
                    that._createHint(dataItem, itemGroup);
                    if (void 0 !== dataItem.id) {
                        that._markersId[dataItem.id] = i
                    }
                    return item
                }).map(function(item) {
                    var labelBBox = item.label.getBBox();
                    var markerBBox = item.marker.getBBox();
                    item.markerBBox = markerBBox;
                    item.markerSize = Math.max(markerBBox.width, markerBBox.height);
                    var bBox = getSizeItem(options, markerBBox, labelBBox);
                    item.labelBBox = labelBBox;
                    item.bBox = bBox;
                    maxBBoxHeight = _max(maxBBoxHeight, bBox.height);
                    return item
                });
                if (options.equalRowHeight) {
                    that._items.forEach(function(item) {
                        return item.bBox.height = maxBBoxHeight
                    })
                }
            },
            _getItemData: function() {
                var items = this._data || [];
                var options = this._options || {};
                if (options.inverted) {
                    items = items.slice().reverse()
                }
                return items.filter(function(i) {
                    return i.visible
                })
            },
            _finalUpdate: function(options) {
                this._adjustBackgroundSettings(options);
                this._setBoundingRect(options.margin)
            },
            erase: function() {
                var that = this;
                var insideLegendGroup = that._insideLegendGroup;
                insideLegendGroup && insideLegendGroup.dispose();
                that._insideLegendGroup = that._markersGroup = that._x1 = that._x2 = that._y2 = that._y2 = null;
                return that
            },
            _locateElements: function(locationOptions) {
                this._moveInInitialValues();
                this._locateRowsColumns(locationOptions)
            },
            _moveInInitialValues: function() {
                var that = this;
                that._title.hasText() && that._title.move([0, 0]);
                that._legendGroup && that._legendGroup.move(0, 0);
                that._background && that._background.attr({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                })
            },
            applySelected: function(id) {
                applyMarkerState(id, this._markersId, this._items, "selection");
                return this
            },
            applyHover: function(id) {
                applyMarkerState(id, this._markersId, this._items, "hover");
                return this
            },
            resetItem: function(id) {
                applyMarkerState(id, this._markersId, this._items, "normal");
                return this
            },
            _createLabel: function(data, group) {
                var labelFormatObject = this._getCustomizeObject(data);
                var options = this._options;
                var align = getAlign(options.itemTextPosition);
                var text = options.customizeText.call(labelFormatObject, labelFormatObject);
                var fontStyle = _isDefined(data.textOpacity) ? {
                    color: options.font.color,
                    opacity: data.textOpacity
                } : {};
                return this._renderer.text(text, 0, 0).css((0, _utils.patchFontOptions)(fontStyle)).attr({
                    align: align,
                    "class": options.cssClass
                }).append(group)
            },
            _createHint: function(data, group) {
                var labelFormatObject = this._getCustomizeObject(data);
                var text = this._options.customizeHint.call(labelFormatObject, labelFormatObject);
                if (_isDefined(text) && "" !== text) {
                    group.setTitle(text)
                }
            },
            _createBackground: function() {
                var that = this;
                var isInside = that._options.position === INSIDE;
                var color = that._options.backgroundColor;
                var fill = color || (isInside ? that._options.containerBackgroundColor : NONE);
                if (that._options.border.visible || (isInside || color) && color !== NONE) {
                    that._background = that._renderer.rect(0, 0, 0, 0).attr({
                        fill: fill,
                        "class": that._backgroundClass
                    }).append(that._insideLegendGroup)
                }
            },
            _locateRowsColumns: function(options) {
                var that = this;
                var iteration = 0;
                var layoutOptions = that._getItemsLayoutOptions();
                var countItems = that._items.length;
                var lines;
                do {
                    lines = [];
                    that._createLines(lines, layoutOptions);
                    that._alignLines(lines, layoutOptions);
                    iteration++
                } while (checkLinesSize(lines, layoutOptions, countItems, options.margin) && iteration < countItems);
                that._applyItemPosition(lines, layoutOptions)
            },
            _createLines: function(lines, layoutOptions) {
                this._items.forEach(function(item, i) {
                    var tableLine = getLines(lines, layoutOptions, i);
                    var labelBox = {
                        width: item.labelBBox.width,
                        height: item.labelBBox.height,
                        element: item.label,
                        bBox: item.labelBBox,
                        pos: getPos(layoutOptions),
                        itemIndex: i
                    };
                    var markerBox = {
                        width: item.markerBBox.width,
                        height: item.markerBBox.height,
                        element: item.marker,
                        pos: {
                            horizontal: CENTER,
                            vertical: CENTER
                        },
                        bBox: {
                            width: item.markerBBox.width,
                            height: item.markerBBox.height,
                            x: item.markerBBox.x,
                            y: item.markerBBox.y
                        },
                        itemIndex: i
                    };
                    var firstItem;
                    var secondItem;
                    var offsetDirection = layoutOptions.markerOffset ? "altOffset" : "offset";
                    if (layoutOptions.inverseLabelPosition) {
                        firstItem = labelBox;
                        secondItem = markerBox
                    } else {
                        firstItem = markerBox;
                        secondItem = labelBox
                    }
                    firstItem[offsetDirection] = layoutOptions.labelOffset;
                    tableLine.secondLine.push(firstItem);
                    tableLine.firstLine.push(secondItem)
                })
            },
            _alignLines: function(lines, layoutOptions) {
                var i;
                var measure = layoutOptions.altMeasure;
                lines.forEach(function(line) {
                    return setMaxInLine(line, measure)
                });
                measure = layoutOptions.measure;
                if (layoutOptions.itemsAlignment) {
                    if (layoutOptions.markerOffset) {
                        for (i = 0; i < lines.length;) {
                            transpose([lines[i++], lines[i++]]).forEach(processLine)
                        }
                    }
                } else {
                    transpose(lines).forEach(processLine)
                }

                function processLine(line) {
                    setMaxInLine(line, measure)
                }
            },
            _applyItemPosition: function(lines, layoutOptions) {
                var that = this;
                var position = {
                    x: 0,
                    y: 0
                };
                var maxLineLength = getMaxLineLength(lines, layoutOptions);
                lines.forEach(function(line) {
                    var firstItem = line[0];
                    var altOffset = firstItem.altOffset || layoutOptions.altSpacing;
                    position[layoutOptions.direction] = getInitPositionForDirection(line, layoutOptions, maxLineLength);
                    line.forEach(function(item) {
                        var offset = item.offset || layoutOptions.spacing;
                        var wrap = new _layout_element.WrapperLayoutElement(item.element, item.bBox);
                        var itemBBoxOptions = {
                            x: position.x,
                            y: position.y,
                            width: item.width,
                            height: item.height
                        };
                        var itemBBox = new _layout_element.WrapperLayoutElement(null, itemBBoxOptions);
                        var itemLegend = that._items[item.itemIndex];
                        wrap.position({
                            of: itemBBox,
                            my: item.pos,
                            at: item.pos
                        });
                        itemLegend.bBoxes.push(itemBBox);
                        position[layoutOptions.direction] += item[layoutOptions.measure] + offset
                    });
                    position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + altOffset
                });
                this._items.forEach(function(item) {
                    var itemBBox = calculateBBoxLabelAndMarker(item.bBoxes[0].getLayoutOptions(), item.bBoxes[1].getLayoutOptions());
                    var horizontal = that._options.columnItemSpacing / 2;
                    var vertical = that._options.rowItemSpacing / 2;
                    item.tracker.left = itemBBox.left - horizontal;
                    item.tracker.right = itemBBox.right + horizontal;
                    item.tracker.top = itemBBox.top - vertical;
                    item.tracker.bottom = itemBBox.bottom + vertical
                })
            },
            _getItemsLayoutOptions: function() {
                var that = this;
                var options = that._options;
                var orientation = options.orientation;
                var layoutOptions = {
                    itemsAlignment: options.itemsAlignment,
                    orientation: options.orientation
                };
                var width = that._size.width - (that._background ? 2 * options.paddingLeftRight : 0);
                var height = that._size.height - (that._background ? 2 * options.paddingTopBottom : 0);
                if (orientation === HORIZONTAL) {
                    layoutOptions.length = width;
                    layoutOptions.spacing = options.columnItemSpacing;
                    layoutOptions.direction = "x";
                    layoutOptions.measure = WIDTH;
                    layoutOptions.altMeasure = HEIGHT;
                    layoutOptions.altDirection = "y";
                    layoutOptions.altSpacing = options.rowItemSpacing;
                    layoutOptions.countItem = options.columnCount;
                    layoutOptions.altCountItem = options.rowCount;
                    layoutOptions.marginTextLabel = 4;
                    layoutOptions.labelOffset = 7;
                    if (options.itemTextPosition === BOTTOM || options.itemTextPosition === TOP) {
                        layoutOptions.labelOffset = 4;
                        layoutOptions.markerOffset = true
                    }
                } else {
                    layoutOptions.length = height;
                    layoutOptions.spacing = options.rowItemSpacing;
                    layoutOptions.direction = "y";
                    layoutOptions.measure = HEIGHT;
                    layoutOptions.altMeasure = WIDTH;
                    layoutOptions.altDirection = "x";
                    layoutOptions.altSpacing = options.columnItemSpacing;
                    layoutOptions.countItem = options.rowCount;
                    layoutOptions.altCountItem = options.columnCount;
                    layoutOptions.marginTextLabel = 7;
                    layoutOptions.labelOffset = 4;
                    if (options.itemTextPosition === RIGHT || options.itemTextPosition === LEFT) {
                        layoutOptions.labelOffset = 7;
                        layoutOptions.markerOffset = true
                    }
                }
                if (!layoutOptions.countItem) {
                    if (layoutOptions.altCountItem) {
                        layoutOptions.countItem = _ceil(that._items.length / layoutOptions.altCountItem)
                    } else {
                        layoutOptions.countItem = that._items.length
                    }
                }
                if (options.itemTextPosition === TOP || options.itemTextPosition === LEFT) {
                    layoutOptions.inverseLabelPosition = true
                }
                layoutOptions.itemTextPosition = options.itemTextPosition;
                layoutOptions.altCountItem = layoutOptions.altCountItem || _ceil(that._items.length / layoutOptions.countItem);
                return layoutOptions
            },
            _adjustBackgroundSettings: function(locationOptions) {
                if (!this._background) {
                    return
                }
                var border = locationOptions.border;
                var legendBox = this._calculateTotalBox();
                var backgroundSettings = {
                    x: _round(legendBox.x - locationOptions.paddingLeftRight),
                    y: _round(legendBox.y - locationOptions.paddingTopBottom),
                    width: _round(legendBox.width) + 2 * locationOptions.paddingLeftRight,
                    height: _round(legendBox.height),
                    opacity: locationOptions.backgroundOpacity
                };
                if (border.visible && border.width && border.color && border.color !== NONE) {
                    backgroundSettings["stroke-width"] = border.width;
                    backgroundSettings.stroke = border.color;
                    backgroundSettings["stroke-opacity"] = border.opacity;
                    backgroundSettings.dashStyle = border.dashStyle;
                    backgroundSettings.rx = border.cornerRadius || 0;
                    backgroundSettings.ry = border.cornerRadius || 0
                }
                this._background.attr(backgroundSettings)
            },
            _setBoundingRect: function(margin) {
                if (!this._insideLegendGroup) {
                    return
                }
                var box = this._calculateTotalBox();
                box.height += margin.top + margin.bottom;
                box.widthWithoutMargins = box.width;
                box.width += margin.left + margin.right;
                box.x -= margin.left;
                box.y -= margin.top;
                this._boundingRect = box
            },
            _calculateTotalBox: function() {
                var markerBox = this._markersGroup.getBBox();
                var titleBox = this._title.getCorrectedLayoutOptions();
                var box = this._insideLegendGroup.getBBox();
                var verticalPadding = this._background ? 2 * this._options.paddingTopBottom : 0;
                box.height = markerBox.height + titleBox.height + verticalPadding;
                titleBox.width > box.width && (box.width = titleBox.width);
                return box
            },
            getActionCallback: function(point) {
                var that = this;
                if (that._options.visible) {
                    return function(act) {
                        that[act](point.index)
                    }
                } else {
                    return _common.noop
                }
            },
            getLayoutOptions: function() {
                var options = this._options;
                var boundingRect = this._insideLegendGroup ? this._boundingRect : {
                    width: 0,
                    height: 0,
                    x: 0,
                    y: 0
                };
                if (options) {
                    boundingRect.verticalAlignment = options.verticalAlignment;
                    boundingRect.horizontalAlignment = options.horizontalAlignment;
                    if (options.orientation === HORIZONTAL) {
                        boundingRect.cutLayoutSide = options.verticalAlignment;
                        boundingRect.cutSide = "vertical"
                    } else {
                        if (options.horizontalAlignment === CENTER) {
                            boundingRect.cutLayoutSide = options.verticalAlignment;
                            boundingRect.cutSide = "vertical"
                        } else {
                            boundingRect.cutLayoutSide = options.horizontalAlignment;
                            boundingRect.cutSide = "horizontal"
                        }
                    }
                    boundingRect.position = {
                        horizontal: options.horizontalAlignment,
                        vertical: options.verticalAlignment
                    };
                    return boundingRect
                }
                return null
            },
            shift: function(x, y) {
                var that = this;
                var box = {};
                if (that._insideLegendGroup) {
                    that._insideLegendGroup.attr({
                        translateX: x - that._boundingRect.x,
                        translateY: y - that._boundingRect.y
                    })
                }
                that._title && that._shiftTitle(that._boundingRect.widthWithoutMargins);
                that._markersGroup && that._shiftMarkers();
                if (that._insideLegendGroup) {
                    box = that._legendGroup.getBBox()
                }
                that._x1 = box.x;
                that._y1 = box.y;
                that._x2 = box.x + box.width;
                that._y2 = box.y + box.height;
                return that
            },
            _shiftTitle: function(boxWidth) {
                var that = this;
                var title = that._title;
                var titleBox = title.getCorrectedLayoutOptions();
                if (!titleBox || !title.hasText()) {
                    return
                }
                var width = boxWidth - (that._background ? 2 * that._options.paddingLeftRight : 0);
                var titleOptions = title.getOptions();
                var titleY = titleBox.y + titleOptions.margin.top;
                var titleX = 0;
                if (titleOptions.verticalAlignment === BOTTOM && that._markersGroup) {
                    titleY += that._markersGroup.getBBox().height
                }
                if (titleOptions.horizontalAlignment === RIGHT) {
                    titleX = width - titleBox.width
                } else {
                    if (titleOptions.horizontalAlignment === CENTER) {
                        titleX = (width - titleBox.width) / 2
                    }
                }
                title.shift(titleX, titleY)
            },
            _shiftMarkers: function() {
                var titleBox = this._title.getLayoutOptions();
                var markerBox = this._markersGroup.getBBox();
                var titleOptions = this._title.getOptions() || {};
                var center = 0;
                var y = 0;
                if (titleBox.width > markerBox.width && this._options.horizontalAlignment === CENTER) {
                    center = titleBox.width / 2 - markerBox.width / 2
                }
                if (titleOptions.verticalAlignment === TOP) {
                    y = titleBox.height
                }
                if (0 !== center || 0 !== y) {
                    this._markersGroup.attr({
                        translateX: center,
                        translateY: y
                    });
                    this._items.forEach(function(item) {
                        item.tracker.left += center;
                        item.tracker.right += center;
                        item.tracker.top += y;
                        item.tracker.bottom += y
                    })
                }
            },
            getPosition: function() {
                return this._options.position
            },
            coordsIn: function(x, y) {
                return x >= this._x1 && x <= this._x2 && y >= this._y1 && y <= this._y2
            },
            getItemByCoord: function(x, y) {
                var items = this._items;
                var legendGroup = this._insideLegendGroup;
                x -= legendGroup.attr("translateX");
                y -= legendGroup.attr("translateY");
                for (var i = 0; i < items.length; i++) {
                    if (inRect(items[i].tracker, x, y)) {
                        return items[i].tracker
                    }
                }
                return null
            },
            dispose: function() {
                var that = this;
                that._title && that._title.dispose();
                that._legendGroup = that._insideLegendGroup = that._title = that._renderer = that._options = that._data = that._items = null;
                return that
            },
            layoutOptions: function() {
                if (!this.isVisible()) {
                    return null
                }
                var pos = this.getLayoutOptions();
                return {
                    horizontalAlignment: this._options.horizontalAlignment,
                    verticalAlignment: this._options.verticalAlignment,
                    side: pos.cutSide,
                    priority: 1,
                    position: this.getPosition()
                }
            },
            measure: function(size) {
                this.draw(size[0], size[1]);
                var rect = this.getLayoutOptions();
                return [rect.width, rect.height]
            },
            move: function(rect) {
                this.shift(rect[0], rect[1])
            },
            freeSpace: function() {
                this._options._incidentOccurred("W2104");
                this.erase()
            }
        });
        exports.plugin = {
            name: "legend",
            init: function() {
                var that = this;
                var group = this._renderer.g().attr({
                    "class": this._rootClassPrefix + "-legend"
                }).enableLinks().append(that._renderer.root);
                that._legend = new exports.Legend({
                    renderer: that._renderer,
                    group: group,
                    widget: this,
                    itemGroupClass: this._rootClassPrefix + "-item",
                    titleGroupClass: this._rootClassPrefix + "-title",
                    textField: "text",
                    getFormatObject: function(data) {
                        return {
                            item: data.item,
                            text: data.text
                        }
                    }
                });
                that._layout.add(that._legend)
            },
            extenders: {
                _applyTilesAppearance: function() {
                    var that = this;
                    this._items.forEach(function(item) {
                        that._applyLegendItemStyle(item.id, item.getState())
                    })
                },
                _buildNodes: function() {
                    this._createLegendItems()
                }
            },
            members: {
                _applyLegendItemStyle: function(id, state) {
                    var legend = this._legend;
                    switch (state) {
                        case "hover":
                            legend.applyHover(id);
                            break;
                        case "selection":
                            legend.applySelected(id);
                            break;
                        default:
                            legend.resetItem(id)
                    }
                },
                _createLegendItems: function() {
                    if (this._legend.update(this._getLegendData(), this._getOption("legend"), this._themeManager.theme("legend").title)) {
                        this._requestChange(["LAYOUT"])
                    }
                }
            },
            dispose: function() {
                this._legend.dispose()
            },
            customize: function(constructor) {
                constructor.prototype._proxyData.push(function(x, y) {
                    if (this._legend.coordsIn(x, y)) {
                        var item = this._legend.getItemByCoord(x, y);
                        if (item) {
                            return {
                                id: item.id,
                                type: "legend"
                            }
                        }
                    }
                });
                constructor.addChange({
                    code: "LEGEND",
                    handler: function() {
                        this._createLegendItems()
                    },
                    isThemeDependent: true,
                    option: "legend",
                    isOptionChange: true
                })
            }
        };
        var __getMarkerCreator = getMarkerCreator;
        exports._DEBUG_stubMarkerCreator = function(callback) {
            getMarkerCreator = function() {
                return callback
            }
        };
        exports._DEBUG_restoreMarkerCreator = function() {
            getMarkerCreator = __getMarkerCreator
        }
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/bar_point.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var _extend = extend;
        var _math = Math;
        var _floor = _math.floor;
        var _abs = _math.abs;
        var symbolPoint = __webpack_require__( /*! ./symbol_point */ 126);
        var CANVAS_POSITION_DEFAULT = "canvas_position_default";
        var DEFAULT_BAR_TRACKER_SIZE = 9;
        var CORRECTING_BAR_TRACKER_VALUE = 4;
        var RIGHT = "right";
        var LEFT = "left";
        var TOP = "top";
        var BOTTOM = "bottom";

        function getLabelOrientation(point) {
            var initialValue = point.initialValue;
            var invert = point._getValTranslator().getBusinessRange().invert;
            var isDiscreteValue = "discrete" === point.series.valueAxisType;
            var isFullStacked = point.series.isFullStackedSeries();
            var notAxisInverted = !isDiscreteValue && (initialValue >= 0 && !invert || initialValue < 0 && invert) || isDiscreteValue && !invert || isFullStacked;
            return notAxisInverted ? TOP : BOTTOM
        }
        module.exports = _extend({}, symbolPoint, {
            correctCoordinates: function(correctOptions) {
                var that = this;
                var correction = _floor(correctOptions.offset - correctOptions.width / 2);
                if (that._options.rotated) {
                    that.height = correctOptions.width;
                    that.yCorrection = correction;
                    that.xCorrection = null
                } else {
                    that.width = correctOptions.width;
                    that.xCorrection = correction;
                    that.yCorrection = null
                }
            },
            _getGraphicBBox: function(location) {
                var bBox = {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
                if (location) {
                    var isTop = "top" === location;
                    if (!this._options.rotated) {
                        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
                        bBox.height = 0
                    } else {
                        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
                        bBox.width = 0
                    }
                }
                return bBox
            },
            _getLabelConnector: function(location) {
                return this._getGraphicBBox(location)
            },
            _getLabelPosition: function() {
                var position = getLabelOrientation(this);
                if (this._options.rotated) {
                    position = position === TOP ? RIGHT : LEFT
                }
                return position
            },
            _getLabelCoords: function(label) {
                var that = this;
                var coords;
                if (0 === that.initialValue && that.series.isFullStackedSeries()) {
                    if (!this._options.rotated) {
                        coords = that._getLabelCoordOfPosition(label, TOP)
                    } else {
                        coords = that._getLabelCoordOfPosition(label, RIGHT)
                    }
                } else {
                    if ("inside" === label.getLayoutOptions().position) {
                        coords = that._getLabelCoordOfPosition(label, "inside")
                    } else {
                        coords = symbolPoint._getLabelCoords.call(this, label)
                    }
                }
                return coords
            },
            _drawLabel: function() {
                this._label.pointPosition = "inside" !== this._label.getLayoutOptions().position && getLabelOrientation(this);
                symbolPoint._drawLabel.call(this)
            },
            hideInsideLabel: function(label, coord) {
                var graphicBBox = this._getGraphicBBox();
                var labelBBox = label.getBoundingRect();
                if (this._options.resolveLabelsOverlapping) {
                    if ((coord.y <= graphicBBox.y && coord.y + labelBBox.height >= graphicBBox.y + graphicBBox.height || coord.x <= graphicBBox.x && coord.x + labelBBox.width >= graphicBBox.x + graphicBBox.width) && !(coord.y > graphicBBox.y + graphicBBox.height || coord.y + labelBBox.height < graphicBBox.y || coord.x > graphicBBox.x + graphicBBox.width || coord.x + labelBBox.width < graphicBBox.x)) {
                        label.draw(false);
                        return true
                    }
                }
                return false
            },
            _showForZeroValues: function() {
                return this._options.label.showForZeroValues || this.initialValue
            },
            _drawMarker: function(renderer, group, animationEnabled) {
                var that = this;
                var style = that._getStyle();
                var r = that._options.cornerRadius;
                var rotated = that._options.rotated;
                var _that$getMarkerCoords = that.getMarkerCoords(),
                    x = _that$getMarkerCoords.x,
                    y = _that$getMarkerCoords.y,
                    width = _that$getMarkerCoords.width,
                    height = _that$getMarkerCoords.height;
                if (animationEnabled) {
                    if (rotated) {
                        width = 0;
                        x = that.defaultX
                    } else {
                        height = 0;
                        y = that.defaultY
                    }
                }
                that.graphic = renderer.rect(x, y, width, height).attr({
                    rx: r,
                    ry: r
                }).smartAttr(style).data({
                    "chart-data-point": that
                }).append(group)
            },
            _getSettingsForTracker: function() {
                var that = this;
                var y = that.y;
                var height = that.height;
                var x = that.x;
                var width = that.width;
                if (that._options.rotated) {
                    if (1 === width) {
                        width = DEFAULT_BAR_TRACKER_SIZE;
                        x -= CORRECTING_BAR_TRACKER_VALUE
                    }
                } else {
                    if (1 === height) {
                        height = DEFAULT_BAR_TRACKER_SIZE;
                        y -= CORRECTING_BAR_TRACKER_VALUE
                    }
                }
                return {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                }
            },
            getGraphicSettings: function() {
                var graphic = this.graphic;
                return {
                    x: graphic.attr("x"),
                    y: graphic.attr("y"),
                    height: graphic.attr("height"),
                    width: graphic.attr("width")
                }
            },
            _getEdgeTooltipParams: function() {
                var isPositive = this.value >= 0;
                var xCoord;
                var yCoord;
                var invertedBusinessRange = this._getValTranslator().getBusinessRange().invert;
                var x = this.x,
                    y = this.y,
                    width = this.width,
                    height = this.height;
                if (this._options.rotated) {
                    yCoord = y + height / 2;
                    if (invertedBusinessRange) {
                        xCoord = isPositive ? x : x + width
                    } else {
                        xCoord = isPositive ? x + width : x
                    }
                } else {
                    xCoord = x + width / 2;
                    if (invertedBusinessRange) {
                        yCoord = isPositive ? y + height : y
                    } else {
                        yCoord = isPositive ? y : y + height
                    }
                }
                return {
                    x: xCoord,
                    y: yCoord,
                    offset: 0
                }
            },
            getTooltipParams: function(location) {
                if ("edge" === location) {
                    return this._getEdgeTooltipParams()
                }
                var center = this.getCenterCoord();
                center.offset = 0;
                return center
            },
            getCenterCoord: function() {
                var width = this.width,
                    height = this.height,
                    x = this.x,
                    y = this.y;
                return {
                    x: x + width / 2,
                    y: y + height / 2
                }
            },
            _truncateCoord: function(coord, bounds) {
                if (null === coord) {
                    return coord
                }
                if (coord < bounds[0]) {
                    return bounds[0]
                }
                if (coord > bounds[1]) {
                    return bounds[1]
                }
                return coord
            },
            _getErrorBarBaseEdgeLength: function() {
                return this._options.rotated ? this.height : this.width
            },
            _translateErrorBars: function(argVisibleArea) {
                symbolPoint._translateErrorBars.call(this);
                if (this._errorBarPos < argVisibleArea[0] || this._errorBarPos > argVisibleArea[1]) {
                    this._errorBarPos = void 0
                }
            },
            _translate: function() {
                var that = this;
                var rotated = that._options.rotated;
                var valAxis = rotated ? "x" : "y";
                var argAxis = rotated ? "y" : "x";
                var valIntervalName = rotated ? "width" : "height";
                var argIntervalName = rotated ? "height" : "width";
                var argTranslator = that._getArgTranslator();
                var valTranslator = that._getValTranslator();
                var argVisibleArea = that.series.getArgumentAxis().getVisibleArea();
                var valVisibleArea = that.series.getValueAxis().getVisibleArea();
                var arg;
                var val;
                var minVal;
                arg = argTranslator.translate(that.argument);
                that[argAxis] = arg = null === arg ? arg : arg + (that[argAxis + "Correction"] || 0);
                val = valTranslator.translate(that.value, 1);
                minVal = valTranslator.translate(that.minValue);
                that["v" + valAxis] = val;
                that["v" + argAxis] = arg + that[argIntervalName] / 2;
                val = that._truncateCoord(val, valVisibleArea);
                minVal = that._truncateCoord(minVal, valVisibleArea);
                that[valIntervalName] = _abs(val - minVal);
                val = val < minVal ? val : minVal;
                that._calculateVisibility(rotated ? val : arg, rotated ? arg : val, that.width, that.height);
                that[valAxis] = null === val ? val : val + (that[valAxis + "Correction"] || 0);
                that["min" + valAxis.toUpperCase()] = null === minVal ? minVal : minVal + (that[valAxis + "Correction"] || 0);
                that["default" + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);
                that._translateErrorBars(argVisibleArea);
                if (that.inVisibleArea && null !== that[argAxis]) {
                    if (that[argAxis] < argVisibleArea[0]) {
                        that[argIntervalName] = that[argIntervalName] - (argVisibleArea[0] - that[argAxis]);
                        that[argAxis] = argVisibleArea[0]
                    }
                    if (that[argAxis] + that[argIntervalName] > argVisibleArea[1]) {
                        that[argIntervalName] = argVisibleArea[1] - that[argAxis]
                    }
                }
            },
            _updateMarker: function(animationEnabled, style) {
                this.graphic.smartAttr(_extend({}, style, !animationEnabled ? this.getMarkerCoords() : {}))
            },
            getMarkerCoords: function() {
                var that = this;
                var x = that.x;
                var y = that.y;
                var width = that.width;
                var height = that.height;
                var argAxis = that.series.getArgumentAxis();
                var rotated = that._options.rotated;
                if (argAxis.getAxisPosition) {
                    var axisOptions = argAxis.getOptions();
                    var edgeOffset = Math.round(axisOptions.width / 2);
                    var argAxisPosition = argAxis.getAxisPosition();
                    if (axisOptions.visible) {
                        if (!rotated) {
                            height -= that.minY === that.defaultY && that.minY === argAxisPosition - argAxis.getAxisShift() ? edgeOffset : 0;
                            height < 0 && (height = 0)
                        } else {
                            var isStartFromAxis = that.minX === that.defaultX && that.minX === argAxisPosition - argAxis.getAxisShift();
                            x += isStartFromAxis ? edgeOffset : 0;
                            width -= isStartFromAxis ? edgeOffset : 0;
                            width < 0 && (width = 0)
                        }
                    }
                }
                return {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                }
            },
            coordsIn: function(x, y) {
                var that = this;
                return x >= that.x && x <= that.x + that.width && y >= that.y && y <= that.y + that.height
            }
        })
    },
    /*!**************************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/helpers/range_data_calculator.js ***!
      \**************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ../../core/utils */ 13);
        var _type = __webpack_require__( /*! ../../../core/utils/type */ 1);
        var _common = __webpack_require__( /*! ../../../core/utils/common */ 3);
        var DISCRETE = "discrete";
        var abs = Math.abs,
            floor = Math.floor,
            ceil = Math.ceil,
            min = Math.min;

        function continuousRangeCalculator(range, minValue, maxValue) {
            range.min = range.min < minValue ? range.min : minValue;
            range.max = range.max > maxValue ? range.max : maxValue
        }

        function createGetLogFunction(axisType, axis) {
            if ("logarithmic" !== axisType) {
                return null
            }
            var base = axis.getOptions().logarithmBase;
            return function(value) {
                var log = (0, _utils.getLog)(abs(value), base);
                var round = log < 0 ? floor : ceil;
                return round(log)
            }
        }

        function getRangeCalculator(axisType, axis, getLog) {
            var rangeCalculator = continuousRangeCalculator;
            if (axisType === DISCRETE) {
                rangeCalculator = function(range, minValue, maxValue) {
                    if (minValue !== maxValue) {
                        range.categories.push(maxValue)
                    }
                    range.categories.push(minValue)
                }
            } else {
                if (axis) {
                    rangeCalculator = function(range, value) {
                        var interval = axis.calculateInterval(value, range.prevValue);
                        var minInterval = range.interval;
                        range.interval = (minInterval < interval ? minInterval : interval) || minInterval;
                        range.prevValue = value;
                        continuousRangeCalculator(range, value, value)
                    }
                }
            }
            if (getLog) {
                return function(range, minValue, maxValue) {
                    var minArgs = [];
                    rangeCalculator(range, minValue, maxValue);
                    0 !== minValue && minArgs.push(getLog(minValue));
                    0 !== maxValue && minArgs.push(getLog(maxValue));
                    var linearThreshold = min.apply(null, minArgs);
                    range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold
                }
            }
            return rangeCalculator
        }

        function getInitialRange(axisType, dataType, firstValue) {
            var range = {
                axisType: axisType,
                dataType: dataType
            };
            if (axisType === DISCRETE) {
                range.categories = []
            } else {
                range.min = firstValue;
                range.max = firstValue
            }
            return range
        }

        function processCategories(range) {
            if (range.categories) {
                range.categories = (0, _utils.unique)(range.categories)
            }
            return range
        }

        function getValueForArgument(point, extraPoint, x, range) {
            if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {
                var y1 = point.value;
                var y2 = extraPoint.value;
                var x1 = point.argument;
                var x2 = extraPoint.argument;
                var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();
                return "datetime" === range.dataType ? new Date(r) : r
            } else {
                return point.value
            }
        }

        function calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {
            var value = getValueForArgument(point, prevPoint, bound, range);
            rangeCalculator(range, value, value)
        }

        function isLineSeries(series) {
            return series.type.toLowerCase().indexOf("line") >= 0 || series.type.toLowerCase().indexOf("area") >= 0
        }

        function getViewportReducer(series) {
            var rangeCalculator = getRangeCalculator(series.valueAxisType);
            var argumentAxis = series.getArgumentAxis();
            var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};
            var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;
            if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {
                var range = series.getArgumentAxis().getTranslator().getBusinessRange();
                var add = (0, _utils.getAddFunction)(range, false);
                var interval = range.interval;
                if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {
                    viewport.startValue = add(viewport.startValue, interval, -1);
                    viewport.endValue = add(viewport.endValue, interval)
                }
            }
            var viewportFilter = getViewPortFilter(viewport);
            return function(range, point, index, points) {
                var argument = point.argument;
                if (!point.hasValue()) {
                    return range
                }
                if (viewportFilter(argument)) {
                    if (!range.startCalc) {
                        range.startCalc = true;
                        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)
                    }
                    rangeCalculator(range, point.getMinValue(), point.getMaxValue())
                } else {
                    if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {
                        if (!range.startCalc) {
                            calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)
                        }
                        range.endCalc = true;
                        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue)
                    }
                }
                return range
            }
        }

        function getViewPortFilter(viewport) {
            if (viewport.categories) {
                var dictionary = viewport.categories.reduce(function(result, category) {
                    result[category.valueOf()] = true;
                    return result
                }, {});
                return function(argument) {
                    return (0, _type.isDefined)(argument) && dictionary[argument.valueOf()]
                }
            }
            if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {
                return function() {
                    return true
                }
            }
            if (!(0, _type.isDefined)(viewport.endValue)) {
                return function(argument) {
                    return argument >= viewport.startValue
                }
            }
            if (!(0, _type.isDefined)(viewport.startValue)) {
                return function(argument) {
                    return argument <= viewport.endValue
                }
            }
            return function(argument) {
                return argument >= viewport.startValue && argument <= viewport.endValue
            }
        }
        module.exports = {
            getViewPortFilter: getViewPortFilter,
            getArgumentRange: function(series) {
                var data = series._data || [];
                var range = {};
                if (data.length) {
                    if (series.argumentAxisType === DISCRETE) {
                        range = {
                            categories: data.map(function(item) {
                                return item.argument
                            })
                        }
                    } else {
                        var interval;
                        if (data.length > 1) {
                            var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);
                            var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);
                            interval = min(i1, i2)
                        }
                        range = {
                            min: data[0].argument,
                            max: data[data.length - 1].argument,
                            interval: interval
                        }
                    }
                }
                return processCategories(range)
            },
            getRangeData: function(series) {
                var points = series.getPoints();
                var useAggregation = series.useAggregation();
                var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));
                var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));
                var viewportReducer = getViewportReducer(series);
                var range = points.reduce(function(range, point, index, points) {
                    var argument = point.argument;
                    if (!point.isArgumentCorrect()) {
                        return range
                    }
                    argumentCalculator(range.arg, argument, argument);
                    if (point.hasValue()) {
                        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());
                        viewportReducer(range.viewport, point, index, points)
                    }
                    return range
                }, {
                    arg: getInitialRange(series.argumentAxisType, series.argumentType),
                    val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),
                    viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)
                });
                if (useAggregation) {
                    var argumentRange = this.getArgumentRange(series);
                    if (series.argumentAxisType === DISCRETE) {
                        range.arg = argumentRange
                    } else {
                        var viewport = series.getArgumentAxis().getViewport();
                        if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {
                            argumentCalculator(range.arg, argumentRange.min, argumentRange.min)
                        }
                        if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {
                            argumentCalculator(range.arg, argumentRange.max, argumentRange.max)
                        }
                    }
                }
                processCategories(range.arg);
                processCategories(range.val);
                return range
            },
            getViewport: function(series) {
                var points = series.getPoints();
                var range = {};
                var reducer = getViewportReducer(series);
                range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);
                points.some(function(point, index) {
                    reducer(range, point, index, points);
                    return range.endCalc
                });
                return range
            },
            getPointsInViewPort: function(series) {
                var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});
                var valueViewPort = series.getValueAxis().visualRange() || {};
                var valueViewPortFilter = getViewPortFilter(valueViewPort);
                var points = series.getPoints();
                var addValue = function(values, point, isEdge) {
                    var minValue = point.getMinValue();
                    var maxValue = point.getMaxValue();
                    var isMinValueInViewPort = valueViewPortFilter(minValue);
                    var isMaxValueInViewPort = valueViewPortFilter(maxValue);
                    if (isMinValueInViewPort) {
                        values.push(minValue)
                    }
                    if (maxValue !== minValue && isMaxValueInViewPort) {
                        values.push(maxValue)
                    }
                    if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {
                        if (!values.length) {
                            values.push(valueViewPort.startValue)
                        } else {
                            values.push(valueViewPort.endValue)
                        }
                    }
                };
                var addEdgePoints = isLineSeries(series) ? function(result, points, index) {
                    var point = points[index];
                    var prevPoint = points[index - 1];
                    var nextPoint = points[index + 1];
                    if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {
                        addValue(result[1], point, true)
                    }
                    if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {
                        addValue(result[1], point, true)
                    }
                } : _common.noop;
                var checkPointInViewport = function(result, point, index) {
                    if (argumentViewPortFilter(point.argument)) {
                        addValue(result[0], point)
                    } else {
                        addEdgePoints(result, points, index)
                    }
                    return result
                };
                return points.reduce(checkPointInViewport, [
                    [],
                    []
                ])
            }
        }
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/series/line_series.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var series = __webpack_require__( /*! ./scatter_series */ 110);
        var chartScatterSeries = series.chart;
        var polarScatterSeries = series.polar;
        var objectUtils = __webpack_require__( /*! ../../core/utils/object */ 47);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var mathUtils = __webpack_require__( /*! ../../core/utils/math */ 31);
        var normalizeAngle = vizUtils.normalizeAngle;
        var DISCRETE = "discrete";
        var _map = vizUtils.map;
        var _extend = extend;
        var _each = each;
        var round = Math.round,
            sqrt = Math.sqrt,
            pow = Math.pow,
            min = Math.min,
            max = Math.max,
            abs = Math.abs;
        exports.chart = {};
        exports.polar = {};

        function clonePoint(point, newX, newY, newAngle) {
            var p = objectUtils.clone(point);
            p.x = newX;
            p.y = newY;
            p.angle = newAngle;
            return p
        }

        function getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {
            var correctAngle = point.angle + nextStepAngle;
            var cosSin = vizUtils.getCosAndSin(correctAngle);
            var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;
            var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;
            return clonePoint(prevPoint, x, y, correctAngle)
        }

        function obtainCubicBezierTCoef(p, p0, p1, p2, p3) {
            var d = p0 - p;
            var c = 3 * p1 - 3 * p0;
            var b = 3 * p2 - 6 * p1 + 3 * p0;
            var a = p3 - 3 * p2 + 3 * p1 - p0;
            return mathUtils.solveCubicEquation(a, b, c, d)
        }
        var lineMethods = {
            autoHidePointMarkersEnabled: function() {
                return true
            },
            _applyGroupSettings: function(style, settings, group) {
                var that = this;
                settings = _extend(settings, style);
                that._applyElementsClipRect(settings);
                group.attr(settings)
            },
            _setGroupsSettings: function(animationEnabled) {
                var that = this;
                var style = that._styles.normal;
                that._applyGroupSettings(style.elements, {
                    "class": "dxc-elements"
                }, that._elementsGroup);
                that._bordersGroup && that._applyGroupSettings(style.border, {
                    "class": "dxc-borders"
                }, that._bordersGroup);
                chartScatterSeries._setGroupsSettings.call(that, animationEnabled);
                animationEnabled && that._markersGroup && that._markersGroup.attr({
                    opacity: .001
                })
            },
            _createGroups: function() {
                var that = this;
                that._createGroup("_elementsGroup", that, that._group);
                that._areBordersVisible() && that._createGroup("_bordersGroup", that, that._group);
                chartScatterSeries._createGroups.call(that)
            },
            _areBordersVisible: function() {
                return false
            },
            _getDefaultSegment: function(segment) {
                return {
                    line: _map(segment.line || [], function(pt) {
                        return pt.getDefaultCoords()
                    })
                }
            },
            _prepareSegment: function(points) {
                return {
                    line: points
                }
            },
            _parseLineOptions: function(options, defaultColor) {
                return {
                    stroke: options.color || defaultColor,
                    "stroke-width": options.width,
                    dashStyle: options.dashStyle || "solid"
                }
            },
            _parseStyle: function(options, defaultColor) {
                return {
                    elements: this._parseLineOptions(options, defaultColor)
                }
            },
            _applyStyle: function(style) {
                var that = this;
                that._elementsGroup && that._elementsGroup.attr(style.elements);
                _each(that._graphics || [], function(_, graphic) {
                    graphic.line && graphic.line.attr({
                        "stroke-width": style.elements["stroke-width"]
                    }).sharp()
                })
            },
            _drawElement: function(segment, group) {
                return {
                    line: this._createMainElement(segment.line, {
                        "stroke-width": this._styles.normal.elements["stroke-width"]
                    }).append(group)
                }
            },
            _removeElement: function(element) {
                element.line.remove()
            },
            _updateElement: function(element, segment, animate, animationComplete) {
                var params = {
                    points: segment.line
                };
                var lineElement = element.line;
                animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params)
            },
            _animateComplete: function() {
                var that = this;
                chartScatterSeries._animateComplete.call(that);
                that._markersGroup && that._markersGroup.animate({
                    opacity: 1
                }, {
                    duration: that._defaultDuration
                })
            },
            _animate: function() {
                var that = this;
                var lastIndex = that._graphics.length - 1;
                _each(that._graphics || [], function(i, elem) {
                    var complete;
                    if (i === lastIndex) {
                        complete = function() {
                            that._animateComplete()
                        }
                    }
                    that._updateElement(elem, that._segments[i], true, complete)
                })
            },
            _drawPoint: function(options) {
                chartScatterSeries._drawPoint.call(this, {
                    point: options.point,
                    groups: options.groups
                })
            },
            _createMainElement: function(points, settings) {
                return this._renderer.path(points, "line").attr(settings)
            },
            _sortPoints: function(points, rotated) {
                return rotated ? points.sort(function(p1, p2) {
                    return p2.y - p1.y
                }) : points.sort(function(p1, p2) {
                    return p1.x - p2.x
                })
            },
            _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {
                var that = this;
                var rotated = that._options.rotated;
                var forceDefaultSegment = false;
                var segment = that._prepareSegment(points, rotated, lastSegment);
                that._segments.push(segment);
                if (!that._graphics[segmentCount]) {
                    that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup)
                } else {
                    if (!animationEnabled) {
                        that._updateElement(that._graphics[segmentCount], segment)
                    } else {
                        if (forceDefaultSegment) {
                            that._updateElement(that._graphics[segmentCount], that._getDefaultSegment(segment))
                        }
                    }
                }
            },
            _getTrackerSettings: function() {
                var that = this;
                var defaultTrackerWidth = that._defaultTrackerWidth;
                var strokeWidthFromElements = that._styles.normal.elements["stroke-width"];
                return {
                    "stroke-width": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,
                    fill: "none"
                }
            },
            _getMainPointsFromSegment: function(segment) {
                return segment.line
            },
            _drawTrackerElement: function(segment) {
                return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))
            },
            _updateTrackerElement: function(segment, element) {
                var settings = this._getTrackerSettings(segment);
                settings.points = this._getMainPointsFromSegment(segment);
                element.attr(settings)
            },
            checkSeriesViewportCoord: function(axis, coord) {
                if (0 === this._points.length) {
                    return false
                }
                var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();
                var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);
                var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);
                var rotated = this.getOptions().rotated;
                var inverted = axis.getOptions().inverted;
                return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min
            }
        };
        var lineSeries = exports.chart.line = _extend({}, chartScatterSeries, lineMethods, {
            getPointCenterByArg: function(arg) {
                var value = this.getArgumentAxis().getTranslator().translate(arg);
                return {
                    x: value,
                    y: value
                }
            },
            getSeriesPairCoord: function(coord, isArgument) {
                var that = this;
                var oppositeCoord = null;
                var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
                var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;
                for (var i = 0; i < nearestPoints.length; i++) {
                    var p = nearestPoints[i];
                    var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);
                    var b = p[0].vy - p[0].vx * k;
                    var tmpCoord = void 0;
                    if (p[1].vx - p[0].vx === 0) {
                        tmpCoord = needValueCoord ? p[0].vy : p[0].vx
                    } else {
                        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k
                    }
                    if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
                        oppositeCoord = tmpCoord;
                        break
                    }
                }
                return oppositeCoord
            }
        });
        exports.chart.stepline = _extend({}, lineSeries, {
            _calculateStepLinePoints: function(points) {
                var segment = [];
                var coordName = this._options.rotated ? "x" : "y";
                _each(points, function(i, pt) {
                    var point;
                    if (!i) {
                        segment.push(pt);
                        return
                    }
                    var step = segment[segment.length - 1][coordName];
                    if (step !== pt[coordName]) {
                        point = objectUtils.clone(pt);
                        point[coordName] = step;
                        segment.push(point)
                    }
                    segment.push(pt)
                });
                return segment
            },
            _prepareSegment: function(points) {
                return lineSeries._prepareSegment(this._calculateStepLinePoints(points))
            },
            getSeriesPairCoord: function(coord, isArgument) {
                var oppositeCoord;
                var rotated = this._options.rotated;
                var isOpposite = !isArgument && !rotated || isArgument && rotated;
                var coordName = !isOpposite ? "vx" : "vy";
                var oppositeCoordName = !isOpposite ? "vy" : "vx";
                var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
                for (var i = 0; i < nearestPoints.length; i++) {
                    var p = nearestPoints[i];
                    var tmpCoord = void 0;
                    if (isArgument) {
                        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]
                    } else {
                        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]
                    }
                    if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
                        oppositeCoord = tmpCoord;
                        break
                    }
                }
                return oppositeCoord
            }
        });
        exports.chart.spline = _extend({}, lineSeries, {
            _calculateBezierPoints: function(src, rotated) {
                var bezierPoints = [];
                var pointsCopy = src;
                var checkExtremum = function(otherPointCoord, pointCoord, controlCoord) {
                    return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord
                };
                if (1 !== pointsCopy.length) {
                    pointsCopy.forEach(function(curPoint, i) {
                        var leftControlX;
                        var leftControlY;
                        var rightControlX;
                        var rightControlY;
                        var prevPoint = pointsCopy[i - 1];
                        var nextPoint = pointsCopy[i + 1];
                        var x1;
                        var x2;
                        var y1;
                        var y2;
                        var lambda = .5;
                        var a;
                        var b;
                        var c;
                        var xc;
                        var yc;
                        var shift;
                        if (!i || i === pointsCopy.length - 1) {
                            bezierPoints.push(curPoint, curPoint);
                            return
                        }
                        var xCur = curPoint.x;
                        var yCur = curPoint.y;
                        x1 = prevPoint.x;
                        x2 = nextPoint.x;
                        y1 = prevPoint.y;
                        y2 = nextPoint.y;
                        var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));
                        if (curIsExtremum) {
                            if (!rotated) {
                                rightControlY = leftControlY = yCur;
                                rightControlX = (xCur + nextPoint.x) / 2;
                                leftControlX = (xCur + prevPoint.x) / 2
                            } else {
                                rightControlX = leftControlX = xCur;
                                rightControlY = (yCur + nextPoint.y) / 2;
                                leftControlY = (yCur + prevPoint.y) / 2
                            }
                        } else {
                            a = y2 - y1;
                            b = x1 - x2;
                            c = y1 * x2 - x1 * y2;
                            if (!rotated) {
                                if (!b) {
                                    bezierPoints.push(curPoint, curPoint, curPoint);
                                    return
                                }
                                xc = xCur;
                                yc = -1 * (a * xc + c) / b;
                                shift = yc - yCur;
                                y1 -= shift;
                                y2 -= shift
                            } else {
                                if (!a) {
                                    bezierPoints.push(curPoint, curPoint, curPoint);
                                    return
                                }
                                yc = yCur;
                                xc = -1 * (b * yc + c) / a;
                                shift = xc - xCur;
                                x1 -= shift;
                                x2 -= shift
                            }
                            rightControlX = (xCur + lambda * x2) / (1 + lambda);
                            rightControlY = (yCur + lambda * y2) / (1 + lambda);
                            leftControlX = (xCur + lambda * x1) / (1 + lambda);
                            leftControlY = (yCur + lambda * y1) / (1 + lambda)
                        }
                        if (!rotated) {
                            leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);
                            rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY)
                        } else {
                            leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);
                            rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX)
                        }
                        var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
                        var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
                        bezierPoints.push(leftPoint, curPoint, rightPoint)
                    })
                } else {
                    bezierPoints.push(pointsCopy[0])
                }
                return bezierPoints
            },
            _prepareSegment: function(points, rotated) {
                return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated))
            },
            _createMainElement: function(points, settings) {
                return this._renderer.path(points, "bezier").attr(settings)
            },
            getSeriesPairCoord: function(coord, isArgument) {
                var that = this;
                var oppositeCoord = null;
                var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;
                var coordName = !isOpposite ? "vx" : "vy";
                var bezierCoordName = !isOpposite ? "x" : "y";
                var oppositeCoordName = !isOpposite ? "vy" : "vx";
                var bezierOppositeCoordName = !isOpposite ? "y" : "x";
                var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();
                var visibleArea = axis.getVisibleArea();
                var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
                var _loop = function(i) {
                    var p = nearestPoints[i];
                    if (1 === p.length) {
                        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName])
                    } else {
                        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);
                        ts.forEach(function(t) {
                            if (t >= 0 && t <= 1) {
                                var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];
                                if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {
                                    oppositeCoord = tmpCoord
                                }
                            }
                        })
                    }
                    if (null !== oppositeCoord) {
                        return "break"
                    }
                };
                for (var i = 0; i < nearestPoints.length; i++) {
                    var _ret = _loop(i);
                    if ("break" === _ret) {
                        break
                    }
                }
                return oppositeCoord
            },
            _getNearestPoints: function(point, nextPoint, bezierPoints) {
                var index = bezierPoints.indexOf(point);
                return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint]
            },
            _getBezierPoints: function() {
                return this._segments.length > 0 ? this._segments.reduce(function(a, seg) {
                    return a.concat(seg.line)
                }, []) : []
            }
        });
        exports.polar.line = _extend({}, polarScatterSeries, lineMethods, {
            _sortPoints: function(points) {
                return points
            },
            _prepareSegment: function(points, rotated, lastSegment) {
                var preparedPoints = [];
                var centerPoint = this.getValueAxis().getCenter();
                var i;
                lastSegment && this._closeSegment(points);
                if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {
                    for (i = 1; i < points.length; i++) {
                        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint))
                    }
                    if (!preparedPoints.length) {
                        preparedPoints = points
                    }
                } else {
                    return lineSeries._prepareSegment.call(this, points)
                }
                return {
                    line: preparedPoints
                }
            },
            _getRemainingAngle: function(angle) {
                var normAngle = normalizeAngle(angle);
                return angle >= 0 ? 360 - normAngle : -normAngle
            },
            _closeSegment: function(points) {
                var point;
                if (this._segments.length) {
                    point = this._segments[0].line[0]
                } else {
                    point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle)
                }
                point = this._modifyReflectedPoint(point, points[points.length - 1]);
                if (point) {
                    points.push(point)
                }
            },
            _modifyReflectedPoint: function(point, lastPoint) {
                if (lastPoint.angle === point.angle) {
                    return
                }
                if (normalizeAngle(round(lastPoint.angle)) === normalizeAngle(round(point.angle))) {
                    point.angle = lastPoint.angle
                } else {
                    var differenceAngle = lastPoint.angle - point.angle;
                    point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle)
                }
                return point
            },
            _getTangentPoints: function(point, prevPoint, centerPoint) {
                var tangentPoints = [];
                var betweenAngle = Math.round(prevPoint.angle - point.angle);
                var tan = (prevPoint.radius - point.radius) / betweenAngle;
                var i;
                if (0 === betweenAngle) {
                    tangentPoints = [prevPoint, point]
                } else {
                    if (betweenAngle > 0) {
                        for (i = betweenAngle; i >= 0; i--) {
                            tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i))
                        }
                    } else {
                        for (i = 0; i >= betweenAngle; i--) {
                            tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i))
                        }
                    }
                }
                return tangentPoints
            },
            getSeriesPairCoord: function(params, isArgument) {
                var that = this;
                var argAxis = that.getArgumentAxis();
                var paramName = isArgument ? "angle" : "radius";
                var coordParam = params[paramName];
                var centerPoint = argAxis.getCenter();
                var getLengthByCoords = function(p1, p2) {
                    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2))
                };
                var isInsideInterval = function(prevPoint, point, _ref) {
                    var x = _ref.x,
                        y = _ref.y;
                    return getLengthByCoords({
                        x: x,
                        y: y
                    }, centerPoint) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y
                };
                var coords;
                var neighborPoints = that.getNeighborPoints(coordParam, paramName);
                if (1 === neighborPoints.length) {
                    coords = neighborPoints[0]
                } else {
                    if (neighborPoints.length > 1) {
                        var prevPoint = neighborPoints[0];
                        var point = neighborPoints[1];
                        if (that.argumentAxisType !== DISCRETE && that.valueAxisType !== DISCRETE) {
                            var tan;
                            var stepAngle;
                            if (isArgument) {
                                tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);
                                stepAngle = coordParam - point.angle
                            } else {
                                tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);
                                stepAngle = (coordParam - point.radius) / tan
                            }
                            coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle)
                        } else {
                            if (isArgument) {
                                var cosSin = vizUtils.getCosAndSin(-coordParam);
                                var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);
                                var b1 = prevPoint.y - prevPoint.x * k1;
                                var k2 = cosSin.sin / cosSin.cos;
                                var b2 = centerPoint.y - k2 * centerPoint.x;
                                var x = (b2 - b1) / (k1 - k2);
                                var y = k1 * x + b1;
                                if (isInsideInterval(prevPoint, point, {
                                        x: x,
                                        y: y
                                    })) {
                                    var quarter = abs(mathUtils.trunc((360 + coordParam) / 90) % 4);
                                    if (0 === quarter && x >= centerPoint.x && y <= centerPoint.y || 1 === quarter && x <= centerPoint.x && y <= centerPoint.y || 2 === quarter && x <= centerPoint.x && y >= centerPoint.y || 3 === quarter && x >= centerPoint.x && y >= centerPoint.y) {
                                        coords = {
                                            x: x,
                                            y: y
                                        }
                                    }
                                }
                            } else {
                                var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);
                                var y0 = prevPoint.y - prevPoint.x * k;
                                var a = 1 + k * k;
                                var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;
                                var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);
                                var d = b * b - 4 * a * c;
                                if (d >= 0) {
                                    var x1 = (-b - sqrt(d)) / (2 * a);
                                    var x2 = (-b + sqrt(d)) / (2 * a);
                                    var y1 = k * x1 + y0;
                                    var y2 = k * x2 + y0;
                                    coords = isInsideInterval(prevPoint, point, {
                                        x: x1,
                                        y: y1
                                    }) ? {
                                        x: x1,
                                        y: y1
                                    } : isInsideInterval(prevPoint, point, {
                                        x: x2,
                                        y: y2
                                    }) ? {
                                        x: x2,
                                        y: y2
                                    } : void 0
                                }
                            }
                        }
                    }
                }
                return coords
            },
            getNeighborPoints: function(param, paramName) {
                var points = this.getPoints();
                var neighborPoints = [];
                if (this.getOptions().closed) {
                    points = _extend(true, [], points);
                    var lastPoint = points[points.length - 1];
                    var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);
                    var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);
                    var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);
                    var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);
                    if (forwardRefPoint) {
                        points.unshift(forwardRefPoint)
                    }
                    if (rearwardRefPoint) {
                        points.push(rearwardRefPoint)
                    }
                }
                for (var i = 1; i < points.length; i++) {
                    if (points[i - 1][paramName] === param) {
                        neighborPoints.push(points[i - 1])
                    } else {
                        if (points[i][paramName] === param) {
                            neighborPoints.push(points[i])
                        } else {
                            if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {
                                neighborPoints.push(points[i - 1]);
                                neighborPoints.push(points[i])
                            }
                        }
                    }
                    if (neighborPoints.length > 0) {
                        break
                    }
                }
                return neighborPoints
            }
        })
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/base_axis.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _smart_formatter = __webpack_require__( /*! ./smart_formatter */ 424);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _utils2 = _interopRequireDefault(_utils);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _axes_constants = __webpack_require__( /*! ./axes_constants */ 263);
        var _axes_constants2 = _interopRequireDefault(_axes_constants);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _format_helper = __webpack_require__( /*! ../../format_helper */ 63);
        var _format_helper2 = _interopRequireDefault(_format_helper);
        var _parse_utils = __webpack_require__( /*! ../components/parse_utils */ 260);
        var _parse_utils2 = _interopRequireDefault(_parse_utils);
        var _tick_generator = __webpack_require__( /*! ./tick_generator */ 425);
        var _tick_generator2 = _interopRequireDefault(_tick_generator);
        var _translator2d = __webpack_require__( /*! ../translators/translator2d */ 264);
        var _translator2d2 = _interopRequireDefault(_translator2d);
        var _range = __webpack_require__( /*! ../translators/range */ 112);
        var _tick = __webpack_require__( /*! ./tick */ 426);
        var _math2 = __webpack_require__( /*! ../../core/utils/math */ 31);
        var _date = __webpack_require__( /*! ../../core/utils/date */ 24);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _xy_axes = __webpack_require__( /*! ./xy_axes */ 427);
        var _xy_axes2 = _interopRequireDefault(_xy_axes);
        var _polar_axes = __webpack_require__( /*! ./polar_axes */ 834);
        var _polar_axes2 = _interopRequireDefault(_polar_axes);
        var _constant_line = __webpack_require__( /*! ./constant_line */ 835);
        var _constant_line2 = _interopRequireDefault(_constant_line);
        var _strip = __webpack_require__( /*! ./strip */ 836);
        var _strip2 = _interopRequireDefault(_strip);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var convertTicksToValues = _axes_constants2.default.convertTicksToValues;
        var patchFontOptions = _utils2.default.patchFontOptions;
        var getVizRangeObject = _utils2.default.getVizRangeObject;
        var getLog = _utils2.default.getLogExt;
        var raiseTo = _utils2.default.raiseToExt;
        var valueOf = _utils2.default.valueOf;
        var _math = Math;
        var _abs = _math.abs;
        var _max = _math.max;
        var _min = _math.min;
        var _isArray = Array.isArray;
        var DEFAULT_AXIS_LABEL_SPACING = 5;
        var MAX_GRID_BORDER_ADHENSION = 4;
        var TOP = _axes_constants2.default.top;
        var BOTTOM = _axes_constants2.default.bottom;
        var LEFT = _axes_constants2.default.left;
        var RIGHT = _axes_constants2.default.right;
        var CENTER = _axes_constants2.default.center;
        var KEEP = "keep";
        var SHIFT = "shift";
        var RESET = "reset";
        var ROTATE = "rotate";
        var DEFAULT_AXIS_DIVISION_FACTOR = 50;
        var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;
        var SCROLL_THRESHOLD = 5;
        var MIN_BAR_MARGIN = 5;
        var MAX_MARGIN_VALUE = .8;
        var dateIntervals = {
            day: 864e5,
            week: 6048e5
        };

        function getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {
            var _options$workWeek;
            var allowNegatives = _ref.allowNegatives,
                linearThreshold = _ref.linearThreshold;
            return _tick_generator2.default.tickGenerator({
                axisType: options.type,
                dataType: options.dataType,
                logBase: options.logarithmBase,
                allowNegatives: allowNegatives,
                linearThreshold: linearThreshold,
                axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),
                minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),
                numberMultipliers: options.numberMultipliers,
                calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,
                allowDecimals: options.allowDecimals,
                endOnTick: options.endOnTick,
                incidentOccurred: incidentOccurred,
                firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],
                skipTickGeneration: skipTickGeneration,
                skipCalculationLimits: options.skipCalculationLimits,
                generateExtraTick: options.generateExtraTick,
                minTickInterval: options.minTickInterval,
                rangeIsEmpty: rangeIsEmpty
            })
        }

        function createMajorTick(axis, renderer, skippedCategory) {
            var options = axis.getOptions();
            return (0, _tick.tick)(axis, renderer, options.tick, options.grid, skippedCategory, false)
        }

        function createMinorTick(axis, renderer) {
            var options = axis.getOptions();
            return (0, _tick.tick)(axis, renderer, options.minorTick, options.minorGrid)
        }

        function createBoundaryTick(axis, renderer, isFirst) {
            var options = axis.getOptions();
            return (0, _tick.tick)(axis, renderer, (0, _extend.extend)({}, options.tick, {
                visible: options.showCustomBoundaryTicks
            }), options.grid, void 0, false, isFirst ? -1 : 1)
        }

        function callAction(elements, action, actionArgument1, actionArgument2) {
            (elements || []).forEach(function(e) {
                return e[action](actionArgument1, actionArgument2)
            })
        }

        function initTickCoords(ticks) {
            callAction(ticks, "initCoords")
        }

        function drawTickMarks(ticks, options) {
            callAction(ticks, "drawMark", options)
        }

        function drawGrids(ticks, drawLine) {
            callAction(ticks, "drawGrid", drawLine)
        }

        function updateTicksPosition(ticks, options, animate) {
            callAction(ticks, "updateTickPosition", options, animate)
        }

        function updateGridsPosition(ticks, animate) {
            callAction(ticks, "updateGridPosition", animate)
        }
        var measureLabels = exports.measureLabels = function(items) {
            items.forEach(function(item) {
                item.labelBBox = item.label ? item.label.getBBox() : {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }
            })
        };

        function cleanUpInvalidTicks(ticks) {
            var i = ticks.length - 1;
            for (i; i >= 0; i--) {
                if (!removeInvalidTick(ticks, i)) {
                    break
                }
            }
            for (i = 0; i < ticks.length; i++) {
                if (removeInvalidTick(ticks, i)) {
                    i--
                } else {
                    break
                }
            }
        }

        function removeInvalidTick(ticks, i) {
            if (null === ticks[i].coords.x || null === ticks[i].coords.y) {
                ticks.splice(i, 1);
                return true
            }
            return false
        }

        function validateAxisOptions(options) {
            var _labelOptions$minSpac;
            var labelOptions = options.label;
            var position = options.position;
            var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;
            var secondaryPosition = options.isHorizontal ? TOP : RIGHT;
            var labelPosition = labelOptions.position;
            if (position !== defaultPosition && position !== secondaryPosition) {
                position = defaultPosition
            }
            if (!labelPosition || "outside" === labelPosition) {
                labelPosition = position
            } else {
                if ("inside" === labelPosition) {
                    var _TOP$BOTTOM$LEFT$RIGH;
                    labelPosition = (_TOP$BOTTOM$LEFT$RIGH = {}, _defineProperty(_TOP$BOTTOM$LEFT$RIGH, TOP, BOTTOM), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, BOTTOM, TOP), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, LEFT, RIGHT), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, RIGHT, LEFT), _TOP$BOTTOM$LEFT$RIGH)[position]
                }
            }
            if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {
                labelPosition = position
            }
            if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {
                var _TOP$BOTTOM$LEFT$RIGH2;
                labelOptions.alignment = (_TOP$BOTTOM$LEFT$RIGH2 = {}, _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, TOP, CENTER), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, BOTTOM, CENTER), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, LEFT, RIGHT), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, RIGHT, LEFT), _TOP$BOTTOM$LEFT$RIGH2)[labelPosition]
            }
            options.position = position;
            labelOptions.position = labelPosition;
            options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : "none";
            labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;
            options.type && (options.type = options.type.toLowerCase());
            options.argumentType && (options.argumentType = options.argumentType.toLowerCase());
            options.valueType && (options.valueType = options.valueType.toLowerCase())
        }

        function getOptimalAngle(boxes, labelOpt) {
            var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;
            return angle < 45 ? -45 : -90
        }

        function updateLabels(ticks, step, func) {
            ticks.forEach(function(tick, index) {
                if (tick.label) {
                    if (index % step !== 0) {
                        tick.removeLabel()
                    } else {
                        if (func) {
                            func(tick, index)
                        }
                    }
                }
            })
        }

        function getZoomBoundValue(optionValue, dataValue) {
            if (void 0 === optionValue) {
                return dataValue
            } else {
                if (null === optionValue) {
                    return
                } else {
                    return optionValue
                }
            }
        }

        function configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {
            var tickGeneratorOptions = (0, _extend.extend)({}, options, {
                endOnTick: true,
                axisDivisionFactor: axisDivisionFactor,
                skipCalculationLimits: true,
                generateExtraTick: true,
                minTickInterval: minTickInterval
            });
            return function(tickInterval, skipTickGeneration, min, max, breaks) {
                return getTickGenerator(tickGeneratorOptions, _common.noop, skipTickGeneration, viewPort.isEmpty(), function(v) {
                    return v
                }, viewPort)({
                    min: min,
                    max: max,
                    categories: viewPort.categories,
                    isSpacedMargin: viewPort.isSpacedMargin
                }, screenDelta, tickInterval, (0, _type.isDefined)(tickInterval), void 0, void 0, void 0, breaks)
            }
        }

        function convertVisualRangeObject(visualRange, optionValue) {
            return _utils2.default.convertVisualRangeObject(visualRange, !_isArray(optionValue))
        }

        function getConstantLineSharpDirection(coord, axisCanvas) {
            return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1
        }
        var calculateCanvasMargins = exports.calculateCanvasMargins = function(bBoxes, canvas) {
            var cLeft = canvas.left;
            var cTop = canvas.top;
            var cRight = canvas.width - canvas.right;
            var cBottom = canvas.height - canvas.bottom;
            return bBoxes.reduce(function(margins, bBox) {
                if (!bBox || bBox.isEmpty) {
                    return margins
                }
                return {
                    left: _max(margins.left, cLeft - bBox.x),
                    top: _max(margins.top, cTop - bBox.y),
                    right: _max(margins.right, bBox.x + bBox.width - cRight),
                    bottom: _max(margins.bottom, bBox.y + bBox.height - cBottom)
                }
            }, {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            })
        };
        var Axis = exports.Axis = function(renderSettings) {
            var that = this;
            that._renderer = renderSettings.renderer;
            that._incidentOccurred = renderSettings.incidentOccurred;
            that._eventTrigger = renderSettings.eventTrigger;
            that._stripsGroup = renderSettings.stripsGroup;
            that._labelAxesGroup = renderSettings.labelAxesGroup;
            that._constantLinesGroup = renderSettings.constantLinesGroup;
            that._scaleBreaksGroup = renderSettings.scaleBreaksGroup;
            that._axesContainerGroup = renderSettings.axesContainerGroup;
            that._gridContainerGroup = renderSettings.gridGroup;
            that._axisCssPrefix = renderSettings.widgetClass + "-" + (renderSettings.axisClass ? renderSettings.axisClass + "-" : "");
            that._setType(renderSettings.axisType, renderSettings.drawingType);
            that._createAxisGroups();
            that._translator = that._createTranslator();
            that.isArgumentAxis = renderSettings.isArgumentAxis;
            that._viewport = {};
            that._firstDrawing = true;
            that._initRange = {}
        };
        Axis.prototype = {
            constructor: Axis,
            _drawAxis: function() {
                var options = this._options;
                if (!options.visible) {
                    return
                }
                this._axisElement = this._createAxisElement();
                this._updateAxisElementPosition();
                this._axisElement.attr({
                    "stroke-width": options.width,
                    stroke: options.color,
                    "stroke-opacity": options.opacity
                }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup)
            },
            _createPathElement: function(points, attr, sharpDirection) {
                return this.sharp(this._renderer.path(points, "line").attr(attr), sharpDirection)
            },
            sharp: function(svgElement) {
                var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return svgElement.sharp(this._getSharpParam(), sharpDirection)
            },
            customPositionIsAvailable: function() {
                return false
            },
            getOppositeAxis: _common.noop,
            getCustomPosition: _common.noop,
            getCustomBoundaryPosition: _common.noop,
            hasCustomPosition: function() {
                return false
            },
            customPositionIsBoundaryOppositeAxis: function() {
                return false
            },
            getResolvedBoundaryPosition: function() {
                return this.getOptions().position
            },
            getAxisSharpDirection: function() {
                var position = this.getResolvedBoundaryPosition();
                return this.hasCustomPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1
            },
            getSharpDirectionByCoords: function(coords) {
                var canvas = this._getCanvasStartEnd();
                var maxCoord = Math.max(canvas.start, canvas.end);
                return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? "x" : "y"] ? 1 : -1
            },
            _getGridLineDrawer: function() {
                var that = this;
                return function(tick, gridStyle) {
                    var grid = that._getGridPoints(tick.coords);
                    if (grid.points) {
                        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords))
                    }
                    return null
                }
            },
            _getGridPoints: function(coords) {
                var that = this;
                var isHorizontal = this._isHorizontal;
                var tickPositionField = isHorizontal ? "x" : "y";
                var orthogonalPositions = this._orthogonalPositions;
                var positionFrom = orthogonalPositions.start;
                var positionTo = orthogonalPositions.end;
                var borderOptions = that.borderOptions;
                var canvasStart = isHorizontal ? LEFT : TOP;
                var canvasEnd = isHorizontal ? RIGHT : BOTTOM;
                var axisCanvas = that.getCanvas();
                var canvas = {
                    left: axisCanvas.left,
                    right: axisCanvas.width - axisCanvas.right,
                    top: axisCanvas.top,
                    bottom: axisCanvas.height - axisCanvas.bottom
                };
                var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;
                var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;
                var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;
                var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;
                if (that.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {
                    return {
                        points: null
                    }
                }
                return {
                    points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null
                }
            },
            _getConstantLinePos: function(parsedValue, canvasStart, canvasEnd) {
                var value = this._getTranslatedCoord(parsedValue);
                if (!(0, _type.isDefined)(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {
                    return
                }
                return value
            },
            _getConstantLineGraphicAttributes: function(value) {
                var positionFrom = this._orthogonalPositions.start;
                var positionTo = this._orthogonalPositions.end;
                return {
                    points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]
                }
            },
            _createConstantLine: function(value, attr) {
                return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()))
            },
            _drawConstantLineLabelText: function(text, x, y, _ref2, group) {
                var font = _ref2.font,
                    cssClass = _ref2.cssClass;
                return this._renderer.text(text, x, y).css(patchFontOptions((0, _extend.extend)({}, this._options.label.font, font))).attr({
                    align: "center",
                    "class": cssClass
                }).append(group)
            },
            _drawConstantLineLabels: function(parsedValue, lineLabelOptions, value, group) {
                var _text;
                var that = this;
                var text = lineLabelOptions.text;
                var options = that._options;
                var labelOptions = options.label;
                that._checkAlignmentConstantLineLabels(lineLabelOptions);
                text = null !== (_text = text) && void 0 !== _text ? _text : that.formatLabel(parsedValue, labelOptions);
                var coords = that._getConstantLineLabelsCoords(value, lineLabelOptions);
                return that._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group)
            },
            _getStripPos: function(startValue, endValue, canvasStart, canvasEnd, range) {
                var isContinuous = !!(range.minVisible || range.maxVisible);
                var categories = (range.categories || []).reduce(function(result, cat) {
                    result.push(cat.valueOf());
                    return result
                }, []);
                var start;
                var end;
                var swap;
                var startCategoryIndex;
                var endCategoryIndex;
                var min = range.minVisible;
                if (!isContinuous) {
                    if ((0, _type.isDefined)(startValue) && (0, _type.isDefined)(endValue)) {
                        var parsedStartValue = this.parser(startValue);
                        var parsedEndValue = this.parser(endValue);
                        startCategoryIndex = (0, _array.inArray)((0, _type.isDefined)(parsedStartValue) ? parsedStartValue.valueOf() : void 0, categories);
                        endCategoryIndex = (0, _array.inArray)((0, _type.isDefined)(parsedEndValue) ? parsedEndValue.valueOf() : void 0, categories);
                        if (startCategoryIndex === -1 || endCategoryIndex === -1) {
                            return {
                                from: 0,
                                to: 0
                            }
                        }
                        if (startCategoryIndex > endCategoryIndex) {
                            swap = endValue;
                            endValue = startValue;
                            startValue = swap
                        }
                    }
                }
                if ((0, _type.isDefined)(startValue)) {
                    startValue = this.validateUnit(startValue, "E2105", "strip");
                    start = this._getTranslatedCoord(startValue, -1);
                    if (!(0, _type.isDefined)(start) && isContinuous) {
                        start = startValue < min ? canvasStart : canvasEnd
                    }
                } else {
                    start = canvasStart
                }
                if ((0, _type.isDefined)(endValue)) {
                    endValue = this.validateUnit(endValue, "E2105", "strip");
                    end = this._getTranslatedCoord(endValue, 1);
                    if (!(0, _type.isDefined)(end) && isContinuous) {
                        end = endValue > min ? canvasEnd : canvasStart
                    }
                } else {
                    end = canvasEnd
                }
                return start < end ? {
                    from: start,
                    to: end
                } : {
                    from: end,
                    to: start
                }
            },
            _getStripGraphicAttributes: function(fromPoint, toPoint) {
                var x;
                var y;
                var width;
                var height;
                var orthogonalPositions = this._orthogonalPositions;
                var positionFrom = orthogonalPositions.start;
                var positionTo = orthogonalPositions.end;
                if (this._isHorizontal) {
                    x = fromPoint;
                    y = _min(positionFrom, positionTo);
                    width = toPoint - fromPoint;
                    height = _abs(positionFrom - positionTo)
                } else {
                    x = _min(positionFrom, positionTo);
                    y = fromPoint;
                    width = _abs(positionFrom - positionTo);
                    height = _abs(fromPoint - toPoint)
                }
                return {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                }
            },
            _createStrip: function(attrs) {
                return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height)
            },
            _adjustStripLabels: function() {
                var that = this;
                this._strips.forEach(function(strip) {
                    if (strip.label) {
                        strip.label.attr(that._getAdjustedStripLabelCoords(strip))
                    }
                })
            },
            _adjustLabelsCoord: function(offset, maxWidth, checkCanvas) {
                var that = this;
                that._majorTicks.forEach(function(tick) {
                    if (tick.label) {
                        tick.updateMultilineTextAlignment();
                        tick.label.attr(that._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas))
                    }
                })
            },
            _adjustLabels: function(offset) {
                var that = this;
                var options = that.getOptions();
                var positionsAreConsistent = options.position === options.label.position;
                var maxSize = that._majorTicks.reduce(function(size, tick) {
                    if (!tick.label) {
                        return size
                    }
                    var bBox = tick.labelRotationAngle ? _utils2.default.rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;
                    return {
                        width: _max(size.width || 0, bBox.width),
                        height: _max(size.height || 0, bBox.height),
                        offset: _max(size.offset || 0, tick.labelOffset || 0)
                    }
                }, {});
                var additionalOffset = positionsAreConsistent ? that._isHorizontal ? maxSize.height : maxSize.width : 0;
                that._adjustLabelsCoord(offset, maxSize.width);
                return offset + additionalOffset + (additionalOffset && that._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0)
            },
            _getLabelAdjustedCoord: function(tick, offset, maxWidth) {
                offset = offset || 0;
                var that = this;
                var options = that._options;
                var box = _utils2.default.rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);
                var textAlign = tick.labelAlignment || options.label.alignment;
                var isDiscrete = "discrete" === that._options.type;
                var isFlatLabel = tick.labelRotationAngle % 90 === 0;
                var indentFromAxis = options.label.indentFromAxis;
                var labelPosition = options.label.position;
                var axisPosition = that._axisPosition;
                var labelCoords = tick.labelCoords;
                var labelX = labelCoords.x;
                var translateX;
                var translateY;
                if (that._isHorizontal) {
                    if (labelPosition === BOTTOM) {
                        translateY = axisPosition + indentFromAxis - box.y + offset
                    } else {
                        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset
                    }
                    if (textAlign === RIGHT) {
                        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width
                    } else {
                        if (textAlign === LEFT) {
                            translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x
                        } else {
                            translateX = labelX - box.x - box.width / 2
                        }
                    }
                } else {
                    translateY = labelCoords.y - box.y - box.height / 2;
                    if (labelPosition === LEFT) {
                        if (textAlign === LEFT) {
                            translateX = axisPosition - indentFromAxis - maxWidth - box.x
                        } else {
                            if (textAlign === CENTER) {
                                translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2
                            } else {
                                translateX = axisPosition - indentFromAxis - box.x - box.width
                            }
                        }
                        translateX -= offset
                    } else {
                        if (textAlign === RIGHT) {
                            translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width
                        } else {
                            if (textAlign === CENTER) {
                                translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2
                            } else {
                                translateX = axisPosition + indentFromAxis - box.x
                            }
                        }
                        translateX += offset
                    }
                }
                return {
                    translateX: translateX,
                    translateY: translateY
                }
            },
            _createAxisConstantLineGroups: function() {
                var that = this;
                var renderer = that._renderer;
                var classSelector = that._axisCssPrefix;
                var constantLinesClass = classSelector + "constant-lines";
                var insideGroup = renderer.g().attr({
                    "class": constantLinesClass
                });
                var outsideGroup1 = renderer.g().attr({
                    "class": constantLinesClass
                });
                var outsideGroup2 = renderer.g().attr({
                    "class": constantLinesClass
                });
                return {
                    inside: insideGroup,
                    outside1: outsideGroup1,
                    left: outsideGroup1,
                    top: outsideGroup1,
                    outside2: outsideGroup2,
                    right: outsideGroup2,
                    bottom: outsideGroup2,
                    remove: function() {
                        this.inside.remove();
                        this.outside1.remove();
                        this.outside2.remove()
                    },
                    clear: function() {
                        this.inside.clear();
                        this.outside1.clear();
                        this.outside2.clear()
                    }
                }
            },
            _createAxisGroups: function() {
                var that = this;
                var renderer = that._renderer;
                var classSelector = that._axisCssPrefix;
                that._axisGroup = renderer.g().attr({
                    "class": classSelector + "axis"
                });
                that._axisStripGroup = renderer.g().attr({
                    "class": classSelector + "strips"
                });
                that._axisGridGroup = renderer.g().attr({
                    "class": classSelector + "grid"
                });
                that._axisElementsGroup = renderer.g().attr({
                    "class": classSelector + "elements"
                }).append(that._axisGroup);
                that._axisLineGroup = renderer.g().attr({
                    "class": classSelector + "line"
                }).append(that._axisGroup);
                that._axisTitleGroup = renderer.g().attr({
                    "class": classSelector + "title"
                }).append(that._axisGroup);
                that._axisConstantLineGroups = {
                    above: that._createAxisConstantLineGroups(),
                    under: that._createAxisConstantLineGroups()
                };
                that._axisStripLabelGroup = renderer.g().attr({
                    "class": classSelector + "axis-labels"
                })
            },
            _clearAxisGroups: function() {
                var that = this;
                that._axisGroup.remove();
                that._axisStripGroup.remove();
                that._axisStripLabelGroup.remove();
                that._axisConstantLineGroups.above.remove();
                that._axisConstantLineGroups.under.remove();
                that._axisGridGroup.remove();
                that._axisTitleGroup.clear();
                that._axisElementsGroup.clear();
                that._axisLineGroup && that._axisLineGroup.clear();
                that._axisStripGroup && that._axisStripGroup.clear();
                that._axisGridGroup && that._axisGridGroup.clear();
                that._axisConstantLineGroups.above.clear();
                that._axisConstantLineGroups.under.clear();
                that._axisStripLabelGroup && that._axisStripLabelGroup.clear()
            },
            _getLabelFormatObject: function(value, labelOptions, range, point, tickInterval, ticks) {
                range = range || this._getViewportRange();
                var formatObject = {
                    value: value,
                    valueText: (0, _smart_formatter.smartFormatter)(value, {
                        labelOptions: labelOptions,
                        ticks: ticks || convertTicksToValues(this._majorTicks),
                        tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,
                        dataType: this._options.dataType,
                        logarithmBase: this._options.logarithmBase,
                        type: this._options.type,
                        showTransition: !this._options.marker.visible,
                        point: point
                    }) || "",
                    min: range.minVisible,
                    max: range.maxVisible
                };
                if (point) {
                    formatObject.point = point
                }
                return formatObject
            },
            formatLabel: function(value, labelOptions, range, point, tickInterval, ticks) {
                var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);
                return (0, _type.isFunction)(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText
            },
            formatHint: function(value, labelOptions, range) {
                var formatObject = this._getLabelFormatObject(value, labelOptions, range);
                return (0, _type.isFunction)(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0
            },
            formatRange: function(startValue, endValue, interval) {
                return (0, _smart_formatter.formatRange)(startValue, endValue, interval, this.getOptions())
            },
            _setTickOffset: function() {
                var options = this._options;
                var discreteAxisDivisionMode = options.discreteAxisDivisionMode;
                this._tickOffset = +("crossLabels" !== discreteAxisDivisionMode || !discreteAxisDivisionMode)
            },
            getMargins: function() {
                var that = this;
                if (that.hasCustomPosition()) {
                    return {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }
                }
                var options = that._options;
                var position = options.position;
                var placeholderSize = options.placeholderSize;
                var canvas = that.getCanvas();
                var cLeft = canvas.left;
                var cTop = canvas.top;
                var cRight = canvas.width - canvas.right;
                var cBottom = canvas.height - canvas.bottom;
                var edgeMarginCorrection = _max(options.grid.visible && options.grid.width || 0, options.tick.visible && options.tick.width || 0);
                var constantLineAboveSeries = that._axisConstantLineGroups.above;
                var constantLineUnderSeries = that._axisConstantLineGroups.under;
                var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(function(group) {
                    return group && group.getBBox()
                }).concat(function(group) {
                    var box = group && group.getBBox();
                    if (!box || box.isEmpty) {
                        return box
                    }
                    if (that._isHorizontal) {
                        box.x = cLeft;
                        box.width = cRight - cLeft
                    } else {
                        box.y = cTop;
                        box.height = cBottom - cTop
                    }
                    return box
                }(that._axisTitleGroup));
                var margins = calculateCanvasMargins(boxes, canvas);
                margins[position] += options.crosshairMargin;
                if (placeholderSize) {
                    margins[position] = placeholderSize
                }
                if (edgeMarginCorrection) {
                    if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {
                        margins.right = edgeMarginCorrection
                    }
                    if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {
                        margins.bottom = edgeMarginCorrection
                    }
                }
                return margins
            },
            validateUnit: function(unit, idError, parameters) {
                var that = this;
                unit = that.parser(unit);
                if (void 0 === unit && idError) {
                    that._incidentOccurred(idError, [parameters])
                }
                return unit
            },
            _setType: function(axisType, drawingType) {
                var that = this;
                var axisTypeMethods;
                switch (axisType) {
                    case "xyAxes":
                        axisTypeMethods = _xy_axes2.default;
                        break;
                    case "polarAxes":
                        axisTypeMethods = _polar_axes2.default
                }(0, _extend.extend)(that, axisTypeMethods[drawingType])
            },
            _getSharpParam: function() {
                return true
            },
            _disposeBreaksGroup: _common.noop,
            dispose: function() {
                var that = this;
                [that._axisElementsGroup, that._axisStripGroup, that._axisGroup].forEach(function(g) {
                    g.dispose()
                });
                that._strips = that._title = null;
                that._axisStripGroup = that._axisConstantLineGroups = that._axisStripLabelGroup = that._axisBreaksGroup = null;
                that._axisLineGroup = that._axisElementsGroup = that._axisGridGroup = null;
                that._axisGroup = that._axisTitleGroup = null;
                that._axesContainerGroup = that._stripsGroup = that._constantLinesGroup = null;
                that._renderer = that._options = that._textOptions = that._textFontStyles = null;
                that._translator = null;
                that._majorTicks = that._minorTicks = null;
                that._disposeBreaksGroup()
            },
            getOptions: function() {
                return this._options
            },
            setPane: function(pane) {
                this.pane = pane;
                this._options.pane = pane
            },
            setTypes: function(type, axisType, typeSelector) {
                this._options.type = type || this._options.type;
                this._options[typeSelector] = axisType || this._options[typeSelector];
                this._updateTranslator()
            },
            resetTypes: function(typeSelector) {
                this._options.type = this._initTypes.type;
                this._options[typeSelector] = this._initTypes[typeSelector]
            },
            getTranslator: function() {
                return this._translator
            },
            updateOptions: function(options) {
                var that = this;
                var labelOpt = options.label;
                validateAxisOptions(options);
                that._options = options;
                options.tick = options.tick || {};
                options.minorTick = options.minorTick || {};
                options.grid = options.grid || {};
                options.minorGrid = options.minorGrid || {};
                options.title = options.title || {};
                options.marker = options.marker || {};
                that._initTypes = {
                    type: options.type,
                    argumentType: options.argumentType,
                    valueType: options.valueType
                };
                that._setTickOffset();
                that._isHorizontal = options.isHorizontal;
                that.pane = options.pane;
                that.name = options.name;
                that.priority = options.priority;
                that._hasLabelFormat = "" !== labelOpt.format && (0, _type.isDefined)(labelOpt.format);
                that._textOptions = {
                    opacity: labelOpt.opacity,
                    align: "center",
                    "class": labelOpt.cssClass
                };
                that._textFontStyles = _utils2.default.patchFontOptions(labelOpt.font);
                if (options.type === _axes_constants2.default.logarithmic) {
                    if (options.logarithmBaseError) {
                        that._incidentOccurred("E2104");
                        delete options.logarithmBaseError
                    }
                }
                that._updateTranslator();
                that._createConstantLines();
                that._strips = (options.strips || []).map(function(o) {
                    return (0, _strip2.default)(that, o)
                });
                that._majorTicks = that._minorTicks = null;
                that._firstDrawing = true
            },
            calculateInterval: function(value, prevValue) {
                var options = this._options;
                if (!options || options.type !== _axes_constants2.default.logarithmic) {
                    return _abs(value - prevValue)
                }
                var _Range = new _range.Range(this.getTranslator().getBusinessRange()),
                    allowNegatives = _Range.allowNegatives,
                    linearThreshold = _Range.linearThreshold;
                return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold))
            },
            getCanvasRange: function() {
                var translator = this._translator;
                return {
                    startValue: translator.from(translator.translate("canvas_position_start")),
                    endValue: translator.from(translator.translate("canvas_position_end"))
                }
            },
            _processCanvas: function(canvas) {
                return canvas
            },
            updateCanvas: function(canvas, canvasRedesign) {
                if (!canvasRedesign) {
                    var positions = this._orthogonalPositions = {
                        start: !this._isHorizontal ? canvas.left : canvas.top,
                        end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom
                    };
                    positions.center = positions.start + (positions.end - positions.start) / 2
                } else {
                    this._orthogonalPositions = null
                }
                this._canvas = canvas;
                this._translator.updateCanvas(this._processCanvas(canvas));
                this._initAxisPositions()
            },
            getCanvas: function() {
                return this._canvas
            },
            getAxisShift: function() {
                return this._axisShift || 0
            },
            hideTitle: function() {
                var that = this;
                if (that._options.title.text) {
                    that._incidentOccurred("W2105", [that._isHorizontal ? "horizontal" : "vertical"]);
                    that._axisTitleGroup.clear()
                }
            },
            getTitle: function() {
                return this._title
            },
            hideOuterElements: function() {
                var that = this;
                var options = that._options;
                if ((options.label.visible || that._outsideConstantLines.length) && !that._translator.getBusinessRange().isEmpty()) {
                    that._incidentOccurred("W2106", [that._isHorizontal ? "horizontal" : "vertical"]);
                    that._axisElementsGroup.clear();
                    callAction(that._outsideConstantLines, "removeLabel")
                }
            },
            adjustViewport: function(businessRange) {
                var that = this;
                var options = that._options;
                var isDiscrete = options.type === _axes_constants2.default.discrete;
                var categories = that._seriesData && that._seriesData.categories || [];
                var wholeRange = that.adjustRange(getVizRangeObject(options.wholeRange));
                var visualRange = that.getViewport() || {};
                var result = new _range.Range(businessRange);
                that._addConstantLinesToRange(result, "minVisible", "maxVisible");
                var minDefined = (0, _type.isDefined)(visualRange.startValue);
                var maxDefined = (0, _type.isDefined)(visualRange.endValue);
                if (!isDiscrete) {
                    minDefined = minDefined && (!(0, _type.isDefined)(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);
                    maxDefined = maxDefined && (!(0, _type.isDefined)(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue)
                }
                var minVisible = minDefined ? visualRange.startValue : result.minVisible;
                var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;
                if (!isDiscrete) {
                    var _wholeRange$startValu, _wholeRange$endValue;
                    result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;
                    result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max
                } else {
                    var categoriesInfo = _utils2.default.getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);
                    categories = categoriesInfo.categories;
                    result.categories = categories
                }
                var adjustedVisualRange = _utils2.default.adjustVisualRange({
                    axisType: options.type,
                    dataType: options.dataType,
                    base: options.logarithmBase
                }, {
                    startValue: minDefined ? visualRange.startValue : void 0,
                    endValue: maxDefined ? visualRange.endValue : void 0,
                    length: visualRange.length
                }, {
                    categories: categories,
                    min: wholeRange.startValue,
                    max: wholeRange.endValue
                }, {
                    categories: categories,
                    min: minVisible,
                    max: maxVisible
                });
                result.minVisible = adjustedVisualRange.startValue;
                result.maxVisible = adjustedVisualRange.endValue;
                !(0, _type.isDefined)(result.min) && (result.min = result.minVisible);
                !(0, _type.isDefined)(result.max) && (result.max = result.maxVisible);
                result.addRange({});
                return result
            },
            adjustRange: function(range) {
                range = range || {};
                var isDiscrete = this._options.type === _axes_constants2.default.discrete;
                var isLogarithmic = this._options.type === _axes_constants2.default.logarithmic;
                var disabledNegatives = false === this._options.allowNegatives;
                if (isLogarithmic) {
                    range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;
                    range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue
                }
                if (!isDiscrete && (0, _type.isDefined)(range.startValue) && (0, _type.isDefined)(range.endValue) && range.startValue > range.endValue) {
                    var tmp = range.endValue;
                    range.endValue = range.startValue;
                    range.startValue = tmp
                }
                return range
            },
            _getVisualRangeUpdateMode: function(viewport, newRange, oppositeValue) {
                var value = this._options.visualRangeUpdateMode;
                var translator = this._translator;
                var range = this._seriesData;
                if (this.isArgumentAxis) {
                    if ([SHIFT, KEEP, RESET].indexOf(value) === -1) {
                        if (range.axisType === _axes_constants2.default.discrete) {
                            var categories = range.categories;
                            var newCategories = newRange.categories;
                            var visualRange = this.visualRange();
                            if (categories && newCategories && categories.length && newCategories.map(function(c) {
                                    return c.valueOf()
                                }).join(",").indexOf(categories.map(function(c) {
                                    return c.valueOf()
                                }).join(",")) !== -1 && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {
                                value = KEEP
                            } else {
                                value = RESET
                            }
                        } else {
                            var minPoint = translator.translate(range.min);
                            var minVisiblePoint = translator.translate(viewport.startValue);
                            var maxPoint = translator.translate(range.max);
                            var maxVisiblePoint = translator.translate(viewport.endValue);
                            if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {
                                value = RESET
                            } else {
                                if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {
                                    value = SHIFT
                                } else {
                                    value = KEEP
                                }
                            }
                        }
                    }
                } else {
                    if ([KEEP, RESET].indexOf(value) === -1) {
                        if (oppositeValue === KEEP) {
                            value = KEEP
                        } else {
                            value = RESET
                        }
                    }
                }
                return value
            },
            _handleBusinessRangeChanged: function(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {
                var that = this;
                var visualRange = this.visualRange();
                if (axisReinitialized || that._translator.getBusinessRange().isEmpty()) {
                    return
                }
                var visualRangeUpdateMode = that._lastVisualRangeUpdateMode = that._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);
                if (!that.isArgumentAxis) {
                    var viewport = that.getViewport();
                    if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue) && !(0, _type.isDefined)(viewport.length)) {
                        visualRangeUpdateMode = RESET
                    }
                }
                that._prevDataWasEmpty && (visualRangeUpdateMode = KEEP);
                if (visualRangeUpdateMode === KEEP) {
                    that._setVisualRange([visualRange.startValue, visualRange.endValue])
                }
                if (visualRangeUpdateMode === RESET) {
                    that._setVisualRange([null, null])
                }
                if (visualRangeUpdateMode === SHIFT) {
                    that._setVisualRange({
                        length: that.getVisualRangeLength()
                    })
                }
            },
            getVisualRangeLength: function(range) {
                var currentBusinessRange = range || this._translator.getBusinessRange();
                var type = this._options.type;
                var length;
                if (type === _axes_constants2.default.logarithmic) {
                    length = (0, _math2.adjust)(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible))
                } else {
                    if (type === _axes_constants2.default.discrete) {
                        var categoriesInfo = _utils2.default.getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);
                        length = categoriesInfo.categories.length
                    } else {
                        length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible
                    }
                }
                return length
            },
            getVisualRangeCenter: function(range) {
                var businessRange = this._translator.getBusinessRange();
                var currentBusinessRange = range || businessRange;
                var _this$_options = this._options,
                    type = _this$_options.type,
                    logarithmBase = _this$_options.logarithmBase;
                var center;
                if (!(0, _type.isDefined)(currentBusinessRange.minVisible) || !(0, _type.isDefined)(currentBusinessRange.maxVisible)) {
                    return
                }
                if (type === _axes_constants2.default.logarithmic) {
                    var allowNegatives = currentBusinessRange.allowNegatives,
                        linearThreshold = currentBusinessRange.linearThreshold,
                        minVisible = currentBusinessRange.minVisible,
                        maxVisible = currentBusinessRange.maxVisible;
                    center = raiseTo((0, _math2.adjust)(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold)
                } else {
                    if (type === _axes_constants2.default.discrete) {
                        var categoriesInfo = _utils2.default.getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);
                        var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;
                        center = businessRange.categories.indexOf(categoriesInfo.categories[index])
                    } else {
                        center = (currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2
                    }
                }
                return center
            },
            setBusinessRange: function(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {
                var that = this;
                var options = that._options;
                var isDiscrete = options.type === _axes_constants2.default.discrete;
                that._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);
                that._seriesData = new _range.Range(range);
                var dataIsEmpty = that._seriesData.isEmpty();
                that._prevDataWasEmpty = dataIsEmpty;
                that._seriesData.addRange({
                    categories: options.categories,
                    dataType: options.dataType,
                    axisType: options.type,
                    base: options.logarithmBase,
                    invert: options.inverted
                });
                if (options.type === _axes_constants2.default.logarithmic) {
                    that._seriesData.addRange({
                        allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0
                    });
                    if (!isNaN(options.linearThreshold)) {
                        that._seriesData.linearThreshold = options.linearThreshold
                    }
                }
                if (!isDiscrete) {
                    if (!(0, _type.isDefined)(that._seriesData.min) && !(0, _type.isDefined)(that._seriesData.max)) {
                        var visualRange = that.getViewport();
                        visualRange && that._seriesData.addRange({
                            min: visualRange.startValue,
                            max: visualRange.endValue
                        })
                    }
                    var synchronizedValue = options.synchronizedValue;
                    if ((0, _type.isDefined)(synchronizedValue)) {
                        that._seriesData.addRange({
                            min: synchronizedValue,
                            max: synchronizedValue
                        })
                    }
                }
                that._seriesData.minVisible = void 0 === that._seriesData.minVisible ? that._seriesData.min : that._seriesData.minVisible;
                that._seriesData.maxVisible = void 0 === that._seriesData.maxVisible ? that._seriesData.max : that._seriesData.maxVisible;
                if (!that.isArgumentAxis && options.showZero) {
                    that._seriesData.correctValueZeroLevel()
                }
                that._seriesData.sortCategories(that.getCategoriesSorter(argCategories));
                that._seriesData.breaks = that._breaks = that._getScaleBreaks(options, that._seriesData, that._series, that.isArgumentAxis);
                that._translator.updateBusinessRange(that.adjustViewport(that._seriesData))
            },
            _addConstantLinesToRange: function(dataRange, minValueField, maxValueField) {
                this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(function(cl) {
                    if (cl.options.extendAxis) {
                        var _dataRange$addRange;
                        var value = cl.getParsedValue();
                        dataRange.addRange((_dataRange$addRange = {}, _defineProperty(_dataRange$addRange, minValueField, value), _defineProperty(_dataRange$addRange, maxValueField, value), _dataRange$addRange))
                    }
                })
            },
            setGroupSeries: function(series) {
                this._series = series
            },
            getLabelsPosition: function() {
                var that = this;
                var options = that._options;
                var position = options.position;
                var labelShift = options.label.indentFromAxis + (that._axisShift || 0) + that._constantLabelOffset;
                var axisPosition = that._axisPosition;
                return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift
            },
            getFormattedValue: function(value, options, point) {
                var labelOptions = this._options.label;
                return (0, _type.isDefined)(value) ? this.formatLabel(value, (0, _extend.extend)(true, {}, labelOptions, options), void 0, point) : null
            },
            _getBoundaryTicks: function(majors, viewPort) {
                var that = this;
                var length = majors.length;
                var options = that._options;
                var customBounds = options.customBoundTicks;
                var min = viewPort.minVisible;
                var max = viewPort.maxVisible;
                var addMinMax = options.showCustomBoundaryTicks ? that._boundaryTicksVisibility : {};
                var boundaryTicks = [];
                if (options.type === _axes_constants2.default.discrete) {
                    if (that._tickOffset && 0 !== majors.length) {
                        boundaryTicks = [majors[0], majors[majors.length - 1]]
                    }
                } else {
                    if (customBounds) {
                        if (addMinMax.min && (0, _type.isDefined)(customBounds[0])) {
                            boundaryTicks.push(customBounds[0])
                        }
                        if (addMinMax.max && (0, _type.isDefined)(customBounds[1])) {
                            boundaryTicks.push(customBounds[1])
                        }
                    } else {
                        if (addMinMax.min && (0 === length || majors[0] > min)) {
                            boundaryTicks.push(min)
                        }
                        if (addMinMax.max && (0 === length || majors[length - 1] < max)) {
                            boundaryTicks.push(max)
                        }
                    }
                }
                return boundaryTicks
            },
            setPercentLabelFormat: function() {
                if (!this._hasLabelFormat) {
                    this._options.label.format = "percent"
                }
            },
            resetAutoLabelFormat: function() {
                if (!this._hasLabelFormat) {
                    delete this._options.label.format
                }
            },
            getMultipleAxesSpacing: function() {
                return this._options.multipleAxesSpacing || 0
            },
            getTicksValues: function() {
                return {
                    majorTicksValues: convertTicksToValues(this._majorTicks),
                    minorTicksValues: convertTicksToValues(this._minorTicks)
                }
            },
            estimateTickInterval: function(canvas) {
                var that = this;
                that.updateCanvas(canvas);
                return that._tickInterval !== that._getTicks(that.adjustViewport(that._seriesData), _common.noop, true).tickInterval
            },
            setTicks: function(ticks) {
                var majors = ticks.majorTicks || [];
                this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));
                this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));
                this._isSynchronized = true
            },
            _adjustDivisionFactor: function(val) {
                return val
            },
            _getTicks: function(viewPort, incidentOccurred, skipTickGeneration) {
                var that = this;
                var options = that._options;
                var customTicks = options.customTicks;
                var customMinorTicks = options.customMinorTicks;
                return getTickGenerator(options, incidentOccurred || that._incidentOccurred, skipTickGeneration, that._translator.getBusinessRange().isEmpty(), that._adjustDivisionFactor.bind(that), viewPort)({
                    min: viewPort.minVisible,
                    max: viewPort.maxVisible,
                    categories: viewPort.categories,
                    isSpacedMargin: viewPort.isSpacedMargin
                }, that._getScreenDelta(), options.tickInterval, "ignore" === options.label.overlappingBehavior || options.forceUserTickInterval, {
                    majors: customTicks,
                    minors: customMinorTicks
                }, options.minorTickInterval, options.minorTickCount, that._breaks)
            },
            _createTicksAndLabelFormat: function(range, incidentOccurred) {
                var options = this._options;
                var ticks = this._getTicks(range, incidentOccurred, false);
                if (!range.isEmpty() && options.type === _axes_constants2.default.discrete && "datetime" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {
                    options.label.format = _format_helper2.default.getDateFormatByTicks(ticks.ticks)
                }
                return ticks
            },
            getAggregationInfo: function(useAllAggregatedPoints, range) {
                var _visualRange$startVal, _visualRange$endValue;
                var that = this;
                var options = that._options;
                var marginOptions = that._marginOptions;
                var businessRange = new _range.Range(that.getTranslator().getBusinessRange()).addRange(range);
                var visualRange = that.getViewport();
                var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;
                var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;
                var ticks = [];
                if (options.type === _axes_constants2.default.discrete && options.aggregateByCategory) {
                    return {
                        aggregateByCategory: true
                    }
                }
                var aggregationInterval = options.aggregationInterval;
                var aggregationGroupWidth = options.aggregationGroupWidth;
                if (!aggregationGroupWidth && marginOptions) {
                    if (marginOptions.checkInterval) {
                        aggregationGroupWidth = options.axisDivisionFactor
                    }
                    if (marginOptions.sizePointNormalState) {
                        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor)
                    }
                }
                var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;
                var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, that._getScreenDelta(), minInterval);
                var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, that._breaks).tickInterval;
                if (options.type !== _axes_constants2.default.discrete) {
                    var min = useAllAggregatedPoints ? businessRange.min : minVisible;
                    var max = useAllAggregatedPoints ? businessRange.max : maxVisible;
                    if ((0, _type.isDefined)(min) && (0, _type.isDefined)(max)) {
                        var add = _utils2.default.getAddFunction({
                            base: options.logarithmBase,
                            axisType: options.type,
                            dataType: options.dataType
                        }, false);
                        var start = min;
                        var end = max;
                        if (!useAllAggregatedPoints) {
                            var maxMinDistance = Math.max(that.calculateInterval(max, min), "datetime" === options.dataType ? (0, _date.dateToMilliseconds)(tickInterval) : tickInterval);
                            start = add(min, maxMinDistance, -1);
                            end = add(max, maxMinDistance)
                        }
                        start = start < businessRange.min ? businessRange.min : start;
                        end = end > businessRange.max ? businessRange.max : end;
                        var breaks = that._getScaleBreaks(options, {
                            minVisible: start,
                            maxVisible: end
                        }, that._series, that.isArgumentAxis);
                        ticks = generateTicks(tickInterval, false, start, end, breaks).ticks
                    }
                }
                that._aggregationInterval = tickInterval;
                return {
                    interval: tickInterval,
                    ticks: ticks
                }
            },
            createTicks: function(canvas) {
                var that = this;
                var renderer = that._renderer;
                var options = that._options;
                if (!canvas) {
                    return
                }
                that._isSynchronized = false;
                that.updateCanvas(canvas);
                that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _common.noop, true).tickInterval;
                var range = that._getViewportRange();
                var margins = this._calculateValueMargins();
                range.addRange({
                    minVisible: margins.minValue,
                    maxVisible: margins.maxValue,
                    isSpacedMargin: margins.isSpacedMargin
                });
                var ticks = that._createTicksAndLabelFormat(range);
                var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());
                if (options.showCustomBoundaryTicks && boundaryTicks.length) {
                    that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));
                    if (boundaryTicks.length > 1) {
                        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)))
                    }
                } else {
                    that._boundaryTicks = []
                }
                var minors = (ticks.minorTicks || []).filter(function(minor) {
                    return !boundaryTicks.some(function(boundary) {
                        return valueOf(boundary) === valueOf(minor)
                    })
                });
                that._tickInterval = ticks.tickInterval;
                that._minorTickInterval = ticks.minorTickInterval;
                var oldMajorTicks = that._majorTicks || [];
                var majorTicksByValues = oldMajorTicks.reduce(function(r, t) {
                    r[t.value.valueOf()] = t;
                    return r
                }, {});
                var sameType = (0, _type.type)(ticks.ticks[0]) === (0, _type.type)(oldMajorTicks[0] && oldMajorTicks[0].value);
                var skippedCategory = that._getSkippedCategory(ticks.ticks);
                var majorTicks = ticks.ticks.map(function(v) {
                    var tick = majorTicksByValues[v.valueOf()];
                    if (tick && sameType) {
                        delete majorTicksByValues[v.valueOf()];
                        tick.setSkippedCategory(skippedCategory);
                        return tick
                    } else {
                        return createMajorTick(that, renderer, skippedCategory)(v)
                    }
                });
                that._majorTicks = majorTicks;
                var oldMinorTicks = that._minorTicks || [];
                that._minorTicks = minors.map(function(v, i) {
                    var minorTick = oldMinorTicks[i];
                    if (minorTick) {
                        minorTick.updateValue(v);
                        return minorTick
                    }
                    return createMinorTick(that, renderer)(v)
                });
                that._ticksToRemove = Object.keys(majorTicksByValues).map(function(k) {
                    return majorTicksByValues[k]
                }).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));
                that._correctedBreaks = ticks.breaks;
                that._reinitTranslator(that._getViewportRange())
            },
            _reinitTranslator: function(range) {
                var that = this;
                var translator = that._translator;
                if (that._correctedBreaks) {
                    range.breaks = that._correctedBreaks
                }
                if (that._isSynchronized) {
                    return
                }
                translator.updateBusinessRange(range)
            },
            _getViewportRange: function() {
                return this.adjustViewport(this._seriesData)
            },
            setMarginOptions: function(options) {
                this._marginOptions = options
            },
            getMarginOptions: function() {
                var _this$_marginOptions;
                return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {}
            },
            _calculateRangeInterval: function(interval) {
                var isDateTime = "datetime" === this._options.dataType;
                var minArgs = [];
                var addToArgs = function(value) {
                    (0, _type.isDefined)(value) && minArgs.push(isDateTime ? (0, _date.dateToMilliseconds)(value) : value)
                };
                addToArgs(this._tickInterval);
                addToArgs(this._estimatedTickInterval);
                (0, _type.isDefined)(interval) && minArgs.push(interval);
                addToArgs(this._aggregationInterval);
                return this._calculateWorkWeekInterval(_min.apply(this, minArgs))
            },
            _calculateWorkWeekInterval: function(businessInterval) {
                var options = this._options;
                if ("datetime" === options.dataType && options.workdaysOnly && businessInterval) {
                    var workWeek = options.workWeek.length * dateIntervals.day;
                    var weekend = dateIntervals.week - workWeek;
                    if (workWeek !== businessInterval && weekend < businessInterval) {
                        var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);
                        businessInterval = weekend >= businessInterval ? dateIntervals.day : businessInterval - weekend * weekendsCount
                    } else {
                        if (weekend >= businessInterval && businessInterval > dateIntervals.day) {
                            businessInterval = dateIntervals.day
                        }
                    }
                }
                return businessInterval
            },
            _calculateValueMargins: function(ticks) {
                this._resetMargins();
                var that = this;
                var margins = that.getMarginOptions();
                var marginSize = (margins.size || 0) / 2;
                var options = that._options;
                var dataRange = that._getViewportRange();
                var viewPort = that.getViewport();
                var screenDelta = that._getScreenDelta();
                var isDiscrete = (options.type || "").indexOf(_axes_constants2.default.discrete) !== -1;
                var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !that.customPositionIsBoundaryOppositeAxis();
                var translator = that._translator;
                var minValueMargin = options.minValueMargin;
                var maxValueMargin = options.maxValueMargin;
                var minPadding = 0;
                var maxPadding = 0;
                var interval = 0;
                var rangeInterval;
                if (dataRange.stubData || !screenDelta) {
                    return {
                        startPadding: 0,
                        endPadding: 0
                    }
                }

                function getConvertIntervalCoefficient(intervalInPx) {
                    var ratioOfCanvasRange = translator.ratioOfCanvasRange();
                    return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta))
                }
                if (that.isArgumentAxis && margins.checkInterval) {
                    rangeInterval = that._calculateRangeInterval(dataRange.interval);
                    var pxInterval = translator.getInterval(rangeInterval);
                    if (isFinite(pxInterval)) {
                        interval = Math.ceil(pxInterval / (2 * getConvertIntervalCoefficient(pxInterval)))
                    } else {
                        rangeInterval = 0
                    }
                }
                var minPercentPadding;
                var maxPercentPadding;
                var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;
                if (valueMarginsEnabled) {
                    if ((0, _type.isDefined)(minValueMargin)) {
                        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0
                    } else {
                        if (!that.isArgumentAxis && margins.checkInterval && valueOf(dataRange.minVisible) > 0 && valueOf(dataRange.minVisible) === valueOf(dataRange.min)) {
                            minPadding = MIN_BAR_MARGIN
                        } else {
                            minPadding = Math.max(marginSize, interval);
                            minPadding = Math.min(maxPaddingValue, minPadding)
                        }
                    }
                    if ((0, _type.isDefined)(maxValueMargin)) {
                        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0
                    } else {
                        if (!that.isArgumentAxis && margins.checkInterval && valueOf(dataRange.maxVisible) < 0 && valueOf(dataRange.maxVisible) === valueOf(dataRange.max)) {
                            maxPadding = MIN_BAR_MARGIN
                        } else {
                            maxPadding = Math.max(marginSize, interval);
                            maxPadding = Math.min(maxPaddingValue, maxPadding)
                        }
                    }
                }
                var percentStick = margins.percentStick && !this.isArgumentAxis;
                if (percentStick) {
                    if (1 === _abs(dataRange.max)) {
                        maxPadding = 0
                    }
                    if (1 === _abs(dataRange.min)) {
                        minPadding = 0
                    }
                }
                var canvasStartEnd = that._getCanvasStartEnd();
                var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);
                var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;
                if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {
                    if (void 0 !== minPercentPadding) {
                        minPadding = screenDeltaWithMargins * minPercentPadding
                    }
                    if (void 0 !== maxPercentPadding) {
                        maxPadding = screenDeltaWithMargins * maxPercentPadding
                    }
                }
                var minValue;
                var maxValue;
                if (options.type !== _axes_constants2.default.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {
                    var length = ticks.length;
                    var firstTickPosition = translator.translate(ticks[0].value);
                    var lastTickPosition = translator.translate(ticks[length - 1].value);
                    var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;
                    var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);
                    var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);
                    if (minTickPadding > minPadding || maxTickPadding > maxPadding) {
                        var commonPadding = maxTickPadding + minTickPadding;
                        var coeff = getConvertIntervalCoefficient(commonPadding);
                        if (minTickPadding >= minPadding) {
                            minValue = ticks[0].value
                        }
                        if (maxTickPadding >= maxPadding) {
                            maxValue = ticks[length - 1].value
                        }
                        minPadding = _max(minTickPadding, minPadding) / coeff;
                        maxPadding = _max(maxTickPadding, maxPadding) / coeff
                    }
                }
                minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;
                maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;
                if (!isDiscrete) {
                    if (this._translator.isInverted()) {
                        var _minValue, _maxValue;
                        minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);
                        maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1)
                    } else {
                        var _minValue2, _maxValue2;
                        minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);
                        maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1)
                    }
                }

                function correctZeroLevel(minPoint, maxPoint) {
                    var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);
                    var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);
                    var coeff = getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding);
                    minPadding = minExpectedPadding / coeff;
                    maxPadding = maxExpectedPadding / coeff
                }
                if (!that.isArgumentAxis) {
                    if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {
                        correctZeroLevel(translator.translate(0), translator.translate(maxValue));
                        minValue = 0
                    }
                    if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {
                        correctZeroLevel(translator.translate(minValue), translator.translate(0));
                        maxValue = 0
                    }
                }
                return {
                    startPadding: this._translator.isInverted() ? maxPadding : minPadding,
                    endPadding: this._translator.isInverted() ? minPadding : maxPadding,
                    minValue: minValue,
                    maxValue: maxValue,
                    interval: rangeInterval,
                    isSpacedMargin: minPadding === maxPadding && 0 !== minPadding
                }
            },
            applyMargins: function() {
                if (this._isSynchronized) {
                    return
                }
                var margins = this._calculateValueMargins(this._majorTicks);
                var canvas = (0, _extend.extend)({}, this._canvas, {
                    startPadding: margins.startPadding,
                    endPadding: margins.endPadding
                });
                this._translator.updateCanvas(this._processCanvas(canvas));
                if (isFinite(margins.interval)) {
                    var br = this._translator.getBusinessRange();
                    br.addRange({
                        interval: margins.interval
                    });
                    this._translator.updateBusinessRange(br)
                }
            },
            _resetMargins: function() {
                this._reinitTranslator(this._getViewportRange());
                if (this._canvas) {
                    this._translator.updateCanvas(this._processCanvas(this._canvas))
                }
            },
            _createConstantLines: function() {
                var _this = this;
                var constantLines = (this._options.constantLines || []).map(function(o) {
                    return (0, _constant_line2.default)(_this, o)
                });
                this._outsideConstantLines = constantLines.filter(function(l) {
                    return "outside" === l.labelPosition
                });
                this._insideConstantLines = constantLines.filter(function(l) {
                    return "inside" === l.labelPosition
                })
            },
            draw: function(canvas, borderOptions) {
                var that = this;
                var options = this._options;
                that.borderOptions = borderOptions || {
                    visible: false
                };
                that._resetMargins();
                that.createTicks(canvas);
                that.applyMargins();
                that._clearAxisGroups();
                initTickCoords(that._majorTicks);
                initTickCoords(that._minorTicks);
                initTickCoords(that._boundaryTicks);
                that._axisGroup.append(that._axesContainerGroup);
                that._drawAxis();
                that._drawTitle();
                drawTickMarks(that._majorTicks, options.tick);
                drawTickMarks(that._minorTicks, options.minorTick);
                drawTickMarks(that._boundaryTicks, options.tick);
                var drawGridLine = that._getGridLineDrawer();
                drawGrids(that._majorTicks, drawGridLine);
                drawGrids(that._minorTicks, drawGridLine);
                callAction(that._majorTicks, "drawLabel", that._getViewportRange());
                that._majorTicks.forEach(function(tick) {
                    tick.labelRotationAngle = 0;
                    tick.labelAlignment = void 0;
                    tick.labelOffset = 0
                });
                callAction(that._outsideConstantLines.concat(that._insideConstantLines), "draw");
                callAction(that._strips, "draw");
                that._dateMarkers = that._drawDateMarkers() || [];
                that._labelAxesGroup && that._axisStripLabelGroup.append(that._labelAxesGroup);
                that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);
                that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);
                if (that._constantLinesGroup) {
                    that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);
                    that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);
                    that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);
                    that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);
                    that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);
                    that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under)
                }
                that._measureTitle();
                measureLabels(that._majorTicks);
                var textWidth;
                var textHeight;
                var convertedTickInterval;
                var tickInterval = that._tickInterval;
                if ((0, _type.isDefined)(tickInterval)) {
                    convertedTickInterval = that.getTranslator().getInterval("datetime" === options.dataType ? (0, _date.dateToMilliseconds)(tickInterval) : tickInterval)
                }
                var usefulSpace = (0, _type.isDefined)(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;
                if (that._isHorizontal) {
                    textWidth = convertedTickInterval;
                    textHeight = usefulSpace
                } else {
                    textWidth = usefulSpace;
                    textHeight = convertedTickInterval
                }
                var displayMode = that._validateDisplayMode(options.label.displayMode);
                var overlappingMode = that._validateOverlappingMode(options.label.overlappingBehavior, displayMode);
                var wordWrapMode = options.label.wordWrap || "none";
                var overflowMode = options.label.textOverflow || "none";
                if (("none" !== wordWrapMode || "none" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && "auto" !== overlappingMode) {
                    var correctByWidth = false;
                    var correctByHeight = false;
                    if (textWidth) {
                        if (that._majorTicks.some(function(tick) {
                                return tick.labelBBox.width > textWidth
                            })) {
                            correctByWidth = true
                        }
                    }
                    if (textHeight) {
                        if (that._majorTicks.some(function(tick) {
                                return tick.labelBBox.height > textHeight
                            })) {
                            correctByHeight = true
                        }
                    }
                    if (correctByWidth || correctByHeight) {
                        that._majorTicks.forEach(function(tick) {
                            tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label)
                        });
                        measureLabels(that._majorTicks)
                    }
                }
                measureLabels(that._outsideConstantLines);
                measureLabels(that._insideConstantLines);
                measureLabels(that._strips);
                measureLabels(that._dateMarkers);
                that._adjustConstantLineLabels(that._insideConstantLines);
                that._adjustStripLabels();
                var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);
                if (!that._translator.getBusinessRange().isEmpty()) {
                    that._setLabelsPlacement();
                    offset = that._adjustLabels(offset)
                }
                offset = that._adjustDateMarkers(offset);
                that._adjustTitle(offset)
            },
            _measureTitle: _common.noop,
            animate: function() {
                callAction(this._majorTicks, "animateLabels")
            },
            updateSize: function(canvas, animate) {
                var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
                var that = this;
                that.updateCanvas(canvas);
                if (updateTitle) {
                    that._checkTitleOverflow();
                    that._measureTitle();
                    that._updateTitleCoords()
                }
                that._reinitTranslator(that._getViewportRange());
                that.applyMargins();
                var animationEnabled = !that._firstDrawing && animate;
                var options = this._options;
                initTickCoords(that._majorTicks);
                initTickCoords(that._minorTicks);
                initTickCoords(that._boundaryTicks);
                cleanUpInvalidTicks(that._majorTicks);
                cleanUpInvalidTicks(that._minorTicks);
                cleanUpInvalidTicks(that._boundaryTicks);
                if (this._axisElement) {
                    that._updateAxisElementPosition()
                }
                updateTicksPosition(that._majorTicks, options.tick, animationEnabled);
                updateTicksPosition(that._minorTicks, options.minorTick, animationEnabled);
                updateTicksPosition(that._boundaryTicks, options.tick);
                callAction(that._majorTicks, "updateLabelPosition", animationEnabled);
                that._outsideConstantLines.concat(that._insideConstantLines || []).forEach(function(l) {
                    return l.updatePosition(animationEnabled)
                });
                callAction(that._strips, "updatePosition", animationEnabled);
                updateGridsPosition(that._majorTicks, animationEnabled);
                updateGridsPosition(that._minorTicks, animationEnabled);
                if (animationEnabled) {
                    callAction(that._ticksToRemove || [], "fadeOutElements")
                }
                that.prepareAnimation();
                that._ticksToRemove = null;
                if (!that._translator.getBusinessRange().isEmpty()) {
                    that._firstDrawing = false
                }
            },
            prepareAnimation: function() {
                var that = this;
                var action = "saveCoords";
                callAction(that._majorTicks, action);
                callAction(that._minorTicks, action);
                callAction(that._insideConstantLines, action);
                callAction(that._outsideConstantLines, action);
                callAction(that._strips, action)
            },
            applyClipRects: function(elementsClipID, canvasClipID) {
                this._axisGroup.attr({
                    "clip-path": canvasClipID
                });
                this._axisStripGroup.attr({
                    "clip-path": elementsClipID
                })
            },
            _mergeViewportOptions: function() {
                var that = this;
                var options = that._options;
                var visualRange = {};
                var visualRangeOptionValue = options._customVisualRange;
                if (((0, _type.isDefined)(options.max) || (0, _type.isDefined)(options.min)) && !(0, _type.isDefined)(visualRangeOptionValue.startValue) && !(0, _type.isDefined)(visualRangeOptionValue.endValue) && !(0, _type.isDefined)(visualRangeOptionValue.length)) {
                    visualRange = {
                        startValue: options.min,
                        endValue: options.max
                    }
                } else {
                    visualRange = visualRangeOptionValue
                }
                that._setVisualRange(visualRange)
            },
            _validateVisualRange: function(visualRange) {
                var range = getVizRangeObject(visualRange);
                if (void 0 !== range.startValue) {
                    range.startValue = this.validateUnit(range.startValue)
                }
                if (void 0 !== range.endValue) {
                    range.endValue = this.validateUnit(range.endValue)
                }
                return convertVisualRangeObject(range, visualRange)
            },
            _validateOptions: function(options) {
                var that = this;
                if (void 0 !== options.min) {
                    options.min = that.validateUnit(options.min, "E2106")
                }
                if (void 0 !== options.max) {
                    options.max = that.validateUnit(options.max, "E2106")
                }
                options.wholeRange = that._validateVisualRange(options.wholeRange);
                options.visualRange = options._customVisualRange = that._validateVisualRange(options._customVisualRange);
                that._mergeViewportOptions()
            },
            validate: function() {
                var that = this;
                var options = that._options;
                var dataType = that.isArgumentAxis ? options.argumentType : options.valueType;
                var parser = dataType ? _parse_utils2.default.getParser(dataType) : function(unit) {
                    return unit
                };
                that.parser = parser;
                options.dataType = dataType;
                that._validateOptions(options)
            },
            resetVisualRange: function(isSilent) {
                this._seriesData.minVisible = this._seriesData.min;
                this._seriesData.maxVisible = this._seriesData.max;
                this.handleZooming([null, null], {
                    start: !!isSilent,
                    end: !!isSilent
                })
            },
            _setVisualRange: function(visualRange, allowPartialUpdate) {
                var range = this.adjustRange(_utils2.default.getVizRangeObject(visualRange));
                if (allowPartialUpdate) {
                    (0, _type.isDefined)(range.startValue) && (this._viewport.startValue = range.startValue);
                    (0, _type.isDefined)(range.endValue) && (this._viewport.endValue = range.endValue)
                } else {
                    this._viewport = range
                }
            },
            _applyZooming: function(visualRange, allowPartialUpdate) {
                var that = this;
                that._resetVisualRangeOption();
                that._setVisualRange(visualRange, allowPartialUpdate);
                var viewPort = that.getViewport();
                that._breaks = that._getScaleBreaks(that._options, {
                    minVisible: viewPort.startValue,
                    maxVisible: viewPort.endValue
                }, that._series, that.isArgumentAxis);
                that._translator.updateBusinessRange(that._getViewportRange())
            },
            getZoomStartEventArg: function(event, actionType) {
                return {
                    axis: this,
                    range: this.visualRange(),
                    cancel: false,
                    event: event,
                    actionType: actionType
                }
            },
            getZoomEndEventArg: function(previousRange, event, actionType, zoomFactor, shift) {
                var newRange = this.visualRange();
                return {
                    axis: this,
                    previousRange: previousRange,
                    range: newRange,
                    cancel: false,
                    event: event,
                    actionType: actionType,
                    zoomFactor: zoomFactor,
                    shift: shift,
                    rangeStart: newRange.startValue,
                    rangeEnd: newRange.endValue
                }
            },
            getZoomBounds: function() {
                var wholeRange = _utils2.default.getVizRangeObject(this._options.wholeRange);
                var range = this.getTranslator().getBusinessRange();
                var secondPriorityRange = {
                    startValue: getZoomBoundValue(this._initRange.startValue, range.min),
                    endValue: getZoomBoundValue(this._initRange.endValue, range.max)
                };
                return {
                    startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),
                    endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)
                }
            },
            setInitRange: function() {
                this._initRange = {};
                if (0 === Object.keys(this._options.wholeRange || {}).length) {
                    this._initRange = this.getZoomBounds()
                }
            },
            _resetVisualRangeOption: function() {
                this._options._customVisualRange = {}
            },
            setCustomVisualRange: function(range) {
                this._options._customVisualRange = range
            },
            visualRange: function visualRange() {
                var that = this;
                var args = arguments;
                var visualRange;
                if (0 === args.length) {
                    var adjustedRange = that._getAdjustedBusinessRange();
                    var startValue = adjustedRange.minVisible;
                    var endValue = adjustedRange.maxVisible;
                    if (that._options.type === _axes_constants2.default.discrete) {
                        var _startValue, _endValue;
                        startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];
                        endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];
                        return {
                            startValue: startValue,
                            endValue: endValue,
                            categories: _utils2.default.getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories
                        }
                    }
                    return {
                        startValue: startValue,
                        endValue: endValue
                    }
                } else {
                    if (_isArray(args[0])) {
                        visualRange = args[0]
                    } else {
                        if ((0, _type.isPlainObject)(args[0])) {
                            visualRange = (0, _extend.extend)({}, args[0])
                        } else {
                            visualRange = [args[0], args[1]]
                        }
                    }
                }
                var zoomResults = that.handleZooming(visualRange, args[1]);
                if (!zoomResults.isPrevented) {
                    that._visualRange(that, zoomResults)
                }
            },
            handleZooming: function(visualRange, preventEvents, domEvent, action) {
                var that = this;
                preventEvents = preventEvents || {};
                if ((0, _type.isDefined)(visualRange)) {
                    visualRange = that._validateVisualRange(visualRange);
                    visualRange.action = action
                }
                var zoomStartEvent = that.getZoomStartEventArg(domEvent, action);
                var previousRange = zoomStartEvent.range;
                !preventEvents.start && that._eventTrigger("zoomStart", zoomStartEvent);
                var zoomResults = {
                    isPrevented: zoomStartEvent.cancel,
                    skipEventRising: preventEvents.skipEventRising,
                    range: visualRange || zoomStartEvent.range
                };
                if (!zoomStartEvent.cancel) {
                    (0, _type.isDefined)(visualRange) && that._applyZooming(visualRange, preventEvents.allowPartialUpdate);
                    if (!(0, _type.isDefined)(that._storedZoomEndParams)) {
                        that._storedZoomEndParams = {
                            startRange: previousRange,
                            type: this.getOptions().type
                        }
                    }
                    that._storedZoomEndParams.event = domEvent;
                    that._storedZoomEndParams.action = action;
                    that._storedZoomEndParams.prevent = !!preventEvents.end
                }
                return zoomResults
            },
            handleZoomEnd: function() {
                var that = this;
                if ((0, _type.isDefined)(that._storedZoomEndParams) && !that._storedZoomEndParams.prevent) {
                    var previousRange = that._storedZoomEndParams.startRange;
                    var domEvent = that._storedZoomEndParams.event;
                    var action = that._storedZoomEndParams.action;
                    var previousBusinessRange = {
                        minVisible: previousRange.startValue,
                        maxVisible: previousRange.endValue,
                        categories: previousRange.categories
                    };
                    var typeIsNotChanged = that.getOptions().type === that._storedZoomEndParams.type;
                    var shift = typeIsNotChanged ? (0, _math2.adjust)(that.getVisualRangeCenter() - that.getVisualRangeCenter(previousBusinessRange)) : NaN;
                    var zoomFactor = typeIsNotChanged ? +(Math.round(that.getVisualRangeLength(previousBusinessRange) / that.getVisualRangeLength() + "e+2") + "e-2") : NaN;
                    var zoomEndEvent = that.getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);
                    zoomEndEvent.cancel = that.isZoomingLowerLimitOvercome(1 === zoomFactor ? "pan" : "zoom", zoomFactor);
                    that._eventTrigger("zoomEnd", zoomEndEvent);
                    if (zoomEndEvent.cancel) {
                        that.restorePreviousVisualRange(previousRange)
                    }
                    that._storedZoomEndParams = null
                }
            },
            restorePreviousVisualRange: function(previousRange) {
                var that = this;
                that._storedZoomEndParams = null;
                that._applyZooming(previousRange);
                that._visualRange(that, previousRange)
            },
            isZoomingLowerLimitOvercome: function(actionType, zoomFactor, range) {
                var that = this;
                var options = that._options;
                var minZoom = options.minVisualRangeLength;
                var isOvercoming = "zoom" === actionType && zoomFactor >= 1;
                var businessRange = that._translator.getBusinessRange();
                var visualRange;
                if ((0, _type.isDefined)(range)) {
                    visualRange = that.adjustRange(_utils2.default.getVizRangeObject(range));
                    visualRange = {
                        minVisible: visualRange.startValue,
                        maxVisible: visualRange.endValue,
                        categories: businessRange.categories
                    }
                }
                var visualRangeLength = that.getVisualRangeLength(visualRange);
                if ("discrete" !== options.type) {
                    if ((0, _type.isDefined)(minZoom)) {
                        if ("datetime" === options.dataType && !(0, _type.isNumeric)(minZoom)) {
                            minZoom = (0, _date.dateToMilliseconds)(minZoom)
                        }
                        isOvercoming &= minZoom >= visualRangeLength
                    } else {
                        var canvasLength = that._translator.canvasLength;
                        var fullRange = {
                            minVisible: businessRange.min,
                            maxVisible: businessRange.max,
                            categories: businessRange.categories
                        };
                        isOvercoming &= that.getVisualRangeLength(fullRange) / canvasLength >= visualRangeLength
                    }
                } else {
                    !(0, _type.isDefined)(minZoom) && (minZoom = 1);
                    isOvercoming &= (0, _type.isDefined)(range) && that.getVisualRangeLength() === minZoom && visualRangeLength <= minZoom
                }
                return !!isOvercoming
            },
            dataVisualRangeIsReduced: function() {
                var minDataValue;
                var maxDataValue;
                var translator = this.getTranslator();
                if ("discrete" === this._options.type) {
                    var categories = translator.getBusinessRange().categories;
                    minDataValue = categories[0];
                    maxDataValue = categories[categories.length - 1]
                } else {
                    var seriesData = this._seriesData;
                    minDataValue = seriesData.min;
                    maxDataValue = seriesData.max
                }
                if (!(0, _type.isDefined)(minDataValue) || !(0, _type.isDefined)(maxDataValue)) {
                    return false
                }
                var startPoint = translator.translate(minDataValue);
                var endPoint = translator.translate(maxDataValue);
                var edges = [Math.min(startPoint, endPoint), Math.max(startPoint, endPoint)];
                var visualRange = this.visualRange();
                var visualRangeStartPoint = translator.translate(visualRange.startValue);
                var visualRangeEndPoint = translator.translate(visualRange.endValue);
                return visualRangeStartPoint > edges[0] && visualRangeStartPoint < edges[1] || visualRangeEndPoint > edges[0] && visualRangeEndPoint < edges[1] || visualRangeStartPoint === visualRangeEndPoint && edges[0] !== edges[1]
            },
            isExtremePosition: function(isMax) {
                var extremeDataValue;
                var seriesData;
                if ("discrete" === this._options.type) {
                    seriesData = this._translator.getBusinessRange();
                    extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0]
                } else {
                    seriesData = this.getZoomBounds();
                    extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue
                }
                var translator = this.getTranslator();
                var extremePoint = translator.translate(extremeDataValue);
                var visualRange = this.visualRange();
                var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);
                return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD
            },
            getViewport: function() {
                return this._viewport
            },
            getFullTicks: function() {
                var majors = this._majorTicks || [];
                if (this._options.type === _axes_constants2.default.discrete) {
                    return convertTicksToValues(majors)
                } else {
                    return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function(a, b) {
                        return valueOf(a) - valueOf(b)
                    })
                }
            },
            measureLabels: function(canvas, withIndents) {
                var that = this;
                var options = that._options;
                var widthAxis = options.visible ? options.width : 0;
                var ticks;
                var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;
                var tickInterval;
                var viewportRange = that._getViewportRange();
                if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {
                    return {
                        height: widthAxis,
                        width: widthAxis,
                        x: 0,
                        y: 0
                    }
                }
                if (that._majorTicks) {
                    ticks = convertTicksToValues(that._majorTicks)
                } else {
                    that.updateCanvas(canvas);
                    ticks = that._createTicksAndLabelFormat(viewportRange, _common.noop);
                    tickInterval = ticks.tickInterval;
                    ticks = ticks.ticks
                }
                var maxText = ticks.reduce(function(prevLabel, tick, index) {
                    var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);
                    if (prevLabel.length < label.length) {
                        return label
                    } else {
                        return prevLabel
                    }
                }, that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));
                var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);
                var box = text.getBBox();
                text.remove();
                return {
                    x: box.x,
                    y: box.y,
                    width: box.width + indent,
                    height: box.height + indent
                }
            },
            _setLabelsPlacement: function() {
                if (!this._options.label.visible) {
                    return
                }
                var that = this;
                var labelOpt = that._options.label;
                var displayMode = that._validateDisplayMode(labelOpt.displayMode);
                var overlappingMode = that._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);
                var ignoreOverlapping = "none" === overlappingMode || "ignore" === overlappingMode;
                var behavior = {
                    rotationAngle: labelOpt.rotationAngle,
                    staggeringSpacing: labelOpt.staggeringSpacing
                };
                var notRecastStep;
                var boxes = that._majorTicks.map(function(tick) {
                    return tick.labelBBox
                });
                var step = that._getStep(boxes);
                switch (displayMode) {
                    case ROTATE:
                        if (ignoreOverlapping) {
                            notRecastStep = true;
                            step = 1
                        }
                        that._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);
                        break;
                    case "stagger":
                        if (ignoreOverlapping) {
                            step = 2
                        }
                        that._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);
                        break;
                    default:
                        that._applyLabelOverlapping(boxes, overlappingMode, step, behavior)
                }
            },
            _applyLabelOverlapping: function(boxes, mode, step, behavior) {
                var that = this;
                var labelOpt = that._options.label;
                var majorTicks = that._majorTicks;
                if ("none" === mode || "ignore" === mode) {
                    return
                }
                var checkLabels = function(box, index, array) {
                    if (0 === index) {
                        return false
                    }
                    return _axes_constants2.default.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment)
                };
                if (step > 1 && boxes.some(checkLabels)) {
                    that._applyLabelMode(mode, step, boxes, behavior)
                }
                that._checkBoundedLabelsOverlapping(majorTicks, boxes, mode)
            },
            _applyLabelMode: function(mode, step, boxes, behavior, notRecastStep) {
                var that = this;
                var majorTicks = that._majorTicks;
                var labelOpt = that._options.label;
                var angle = behavior.rotationAngle;
                var labelHeight;
                var alignment;
                var func;
                switch (mode) {
                    case ROTATE:
                        if (!labelOpt.userAlignment) {
                            alignment = angle < 0 ? RIGHT : LEFT;
                            if (angle % 90 === 0) {
                                alignment = CENTER
                            }
                        }
                        step = notRecastStep ? step : that._getStep(boxes, angle);
                        func = function(tick) {
                            tick.label.rotate(angle);
                            tick.labelRotationAngle = angle;
                            alignment && (tick.labelAlignment = alignment)
                        };
                        updateLabels(majorTicks, step, func);
                        break;
                    case "stagger":
                        labelHeight = that._getMaxLabelHeight(boxes, behavior.staggeringSpacing);
                        func = function(tick, index) {
                            if (index / (step - 1) % 2 !== 0) {
                                tick.labelOffset = labelHeight
                            }
                        };
                        updateLabels(majorTicks, step - 1, func);
                        break;
                    case "auto":
                    case "_auto":
                        if (2 === step) {
                            that._applyLabelMode("stagger", step, boxes, behavior)
                        } else {
                            that._applyLabelMode(ROTATE, step, boxes, {
                                rotationAngle: getOptimalAngle(boxes, labelOpt)
                            })
                        }
                        break;
                    default:
                        updateLabels(majorTicks, step)
                }
            },
            getMarkerTrackers: _common.noop,
            _drawDateMarkers: _common.noop,
            _adjustDateMarkers: _common.noop,
            coordsIn: _common.noop,
            areCoordsOutsideAxis: _common.noop,
            _getSkippedCategory: _common.noop,
            _initAxisPositions: _common.noop,
            _drawTitle: _common.noop,
            _updateTitleCoords: _common.noop,
            _adjustConstantLineLabels: _common.noop,
            _createTranslator: function() {
                return new _translator2d2.default.Translator2D({}, {}, {})
            },
            _updateTranslator: function() {
                var translator = this._translator;
                translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions())
            },
            _getTranslatorOptions: function() {
                var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;
                var options = this._options;
                return {
                    isHorizontal: this._isHorizontal,
                    shiftZeroValue: !this.isArgumentAxis,
                    interval: options.semiDiscreteInterval,
                    firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],
                    stick: this._getStick(),
                    breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0
                }
            },
            getVisibleArea: function() {
                var canvas = this._getCanvasStartEnd();
                return [canvas.start, canvas.end].sort(function(a, b) {
                    return a - b
                })
            },
            _getCanvasStartEnd: function() {
                var isHorizontal = this._isHorizontal;
                var canvas = this._canvas || {};
                var invert = this._translator.getBusinessRange().invert;
                var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];
                invert && coords.reverse();
                return {
                    start: coords[0],
                    end: coords[1]
                }
            },
            _getScreenDelta: function() {
                var that = this;
                var canvas = that._getCanvasStartEnd();
                var breaks = that._breaks;
                var breaksLength = breaks ? breaks.length : 0;
                var screenDelta = _abs(canvas.start - canvas.end);
                return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0)
            },
            _getScaleBreaks: function() {
                return []
            },
            _adjustTitle: _common.noop,
            _checkTitleOverflow: _common.noop,
            getSpiderTicks: _common.noop,
            setSpiderTicks: _common.noop,
            _checkBoundedLabelsOverlapping: _common.noop,
            drawScaleBreaks: _common.noop,
            _visualRange: _common.noop,
            _rotateConstantLine: _common.noop,
            applyVisualRangeSetter: function(visualRangeSetter) {
                this._visualRange = visualRangeSetter
            },
            getCategoriesSorter: function(argCategories) {
                var sort;
                if (this.isArgumentAxis) {
                    sort = argCategories
                } else {
                    var categoriesSortingMethod = this._options.categoriesSortingMethod;
                    sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories
                }
                return sort
            },
            _getAdjustedBusinessRange: function() {
                return this.adjustViewport(this._translator.getBusinessRange())
            },
            _getTickMarkPoints: _common.noop,
            _validateOverlappingMode: _common.noop,
            _getStep: _common.noop,
            _validateDisplayMode: _common.noop,
            shift: _common.noop
        }
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/core/annotations.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.plugins = exports.__test_utils = exports.createAnnotations = void 0;
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _tooltip = __webpack_require__( /*! ../core/tooltip */ 111);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _utils = __webpack_require__( /*! ./utils */ 13);
        var _plaque = __webpack_require__( /*! ./plaque */ 422);
        var _pointer = __webpack_require__( /*! ../../events/pointer */ 23);
        var _pointer2 = _interopRequireDefault(_pointer);
        var _drag = __webpack_require__( /*! ../../events/drag */ 69);
        var _drag2 = _interopRequireDefault(_drag);
        var _utils2 = __webpack_require__( /*! ../../events/utils */ 8);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var EVENT_NS = "annotations";
        var DOT_EVENT_NS = "." + EVENT_NS;
        var POINTER_ACTION = (0, _utils2.addNamespace)([_pointer2.default.down, _pointer2.default.move], EVENT_NS);
        var POINTER_UP_EVENT_NAME = (0, _utils2.addNamespace)(_pointer2.default.up, EVENT_NS);
        var DRAG_START_EVENT_NAME = _drag2.default.start + DOT_EVENT_NS;
        var DRAG_EVENT_NAME = _drag2.default.move + DOT_EVENT_NS;
        var DRAG_END_EVENT_NAME = _drag2.default.end + DOT_EVENT_NS;

        function coreAnnotation(options, contentTemplate) {
            return {
                draw: function(widget, group) {
                    var _this = this;
                    var annotationGroup = widget._renderer.g().append(group).css((0, _utils.patchFontOptions)(options.font));
                    this.plaque = new _plaque.Plaque((0, _extend.extend)(true, {}, options, {
                        cornerRadius: (options.border || {}).cornerRadius
                    }), widget, annotationGroup, contentTemplate, (0, _type.isDefined)(options.value) || (0, _type.isDefined)(options.argument));
                    this.plaque.draw(widget._getAnnotationCoords(this));
                    if (options.allowDragging) {
                        annotationGroup.on(DRAG_START_EVENT_NAME, {
                            immediate: true
                        }, function(e) {
                            _this._dragOffsetX = _this.plaque.x - e.pageX;
                            _this._dragOffsetY = _this.plaque.y - e.pageY
                        }).on(DRAG_EVENT_NAME, function(e) {
                            _this.plaque.move(e.pageX + _this._dragOffsetX, e.pageY + _this._dragOffsetY)
                        }).on(DRAG_END_EVENT_NAME, function(e) {
                            _this.offsetX = (_this.offsetX || 0) + e.offset.x;
                            _this.offsetY = (_this.offsetY || 0) + e.offset.y
                        })
                    }
                },
                hitTest: function(x, y) {
                    return this.plaque.hitTest(x, y)
                },
                showTooltip: function(tooltip, _ref) {
                    var x = _ref.x,
                        y = _ref.y;
                    if (tooltip.annotation !== this) {
                        tooltip.setTemplate(this.options.tooltipTemplate);
                        if (tooltip.show(this.options, {
                                x: x,
                                y: y
                            }, {
                                target: this.options
                            }, this.options.customizeTooltip)) {
                            tooltip.annotation = this
                        }
                    } else {
                        tooltip.move(x, y)
                    }
                }
            }
        }

        function getTemplateFunction(options, widget) {
            var template;
            if ("text" === options.type) {
                template = function(item, groupElement) {
                    var text = widget._renderer.text(item.text).attr({
                        "class": item.cssClass
                    }).append({
                        element: groupElement
                    });
                    if (item.width > 0 || item.height > 0) {
                        text.setMaxSize(item.width, item.height, {
                            wordWrap: item.wordWrap,
                            textOverflow: item.textOverflow
                        })
                    }
                }
            } else {
                if ("image" === options.type) {
                    template = function(item, groupElement) {
                        var _ref2 = item.image || {},
                            width = _ref2.width,
                            height = _ref2.height,
                            url = _ref2.url,
                            location = _ref2.location;
                        var outerWidth = item.width,
                            outerHeight = item.height;
                        var imageWidth = outerWidth > 0 ? Math.min(width, outerWidth) : width;
                        var imageHeight = outerHeight > 0 ? Math.min(height, outerHeight) : height;
                        widget._renderer.image(0, 0, imageWidth, imageHeight, url, location || "center").append({
                            element: groupElement
                        })
                    }
                } else {
                    if ("custom" === options.type) {
                        template = options.template
                    }
                }
            }
            return template
        }

        function getImageObject(image) {
            return "string" === typeof image ? {
                url: image
            } : image
        }
        var createAnnotations = exports.createAnnotations = function(widget, items) {
            var commonAnnotationSettings = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            var customizeAnnotation = arguments.length > 3 ? arguments[3] : void 0;
            var pullOptions = arguments.length > 4 ? arguments[4] : void 0;
            var commonImageOptions = getImageObject(commonAnnotationSettings.image);
            return items.reduce(function(arr, item) {
                var currentImageOptions = getImageObject(item.image);
                var customizedItem = (0, _type.isFunction)(customizeAnnotation) ? customizeAnnotation(item) : {};
                if (customizedItem) {
                    customizedItem.image = getImageObject(customizedItem.image)
                }
                var options = (0, _extend.extend)(true, {}, commonAnnotationSettings, item, {
                    image: commonImageOptions
                }, {
                    image: currentImageOptions
                }, customizedItem);
                var templateFunction = getTemplateFunction(options, widget);
                var annotation = templateFunction && (0, _extend.extend)(true, pullOptions(options), coreAnnotation(options, widget._getTemplate(templateFunction)));
                annotation && arr.push(annotation);
                return arr
            }, [])
        };
        exports.__test_utils = {
            stub_createAnnotations: function(stub) {
                this.old_createAnnotations = createAnnotations;
                exports.createAnnotations = createAnnotations = stub
            },
            restore_createAnnotations: function() {
                exports.createAnnotations = createAnnotations = this.old_createAnnotations
            }
        };
        var chartPlugin = {
            name: "annotations_chart",
            init: function() {},
            dispose: function() {},
            members: {
                _getAnnotationCoords: function(annotation) {
                    var _axis, _axis2;
                    var coords = {
                        offsetX: annotation.offsetX,
                        offsetY: annotation.offsetY
                    };
                    var argCoordName = this._options.silent("rotated") ? "y" : "x";
                    var valCoordName = this._options.silent("rotated") ? "x" : "y";
                    var argAxis = this.getArgumentAxis();
                    var argument = argAxis.validateUnit(annotation.argument);
                    var axis = this.getValueAxis(annotation.axis);
                    var series;
                    var pane = null === (_axis = axis) || void 0 === _axis ? void 0 : _axis.pane;
                    if (annotation.series) {
                        var _series;
                        series = this.series.filter(function(s) {
                            return s.name === annotation.series
                        })[0];
                        axis = null === (_series = series) || void 0 === _series ? void 0 : _series.getValueAxis();
                        (0, _type.isDefined)(axis) && (pane = axis.pane)
                    }
                    if ((0, _type.isDefined)(argument)) {
                        if (series) {
                            var center = series.getPointCenterByArg(argument);
                            center && (coords[argCoordName] = center[argCoordName])
                        } else {
                            coords[argCoordName] = argAxis.getTranslator().translate(argument)
                        }!(0, _type.isDefined)(pane) && (pane = argAxis.pane)
                    }
                    var value = null === (_axis2 = axis) || void 0 === _axis2 ? void 0 : _axis2.validateUnit(annotation.value);
                    if ((0, _type.isDefined)(value)) {
                        var _axis3;
                        coords[valCoordName] = null === (_axis3 = axis) || void 0 === _axis3 ? void 0 : _axis3.getTranslator().translate(value);
                        !(0, _type.isDefined)(pane) && (0, _type.isDefined)(axis) && (pane = axis.pane)
                    }
                    coords.canvas = this._getCanvasForPane(pane);
                    if ((0, _type.isDefined)(coords[argCoordName]) && !(0, _type.isDefined)(value)) {
                        var _series2;
                        if (!(0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
                            coords[valCoordName] = argAxis.getAxisPosition()
                        } else {
                            if ((0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
                                coords[valCoordName] = this._argumentAxes.filter(function(a) {
                                    return a.pane === axis.pane
                                })[0].getAxisPosition()
                            } else {
                                if (null === (_series2 = series) || void 0 === _series2 ? void 0 : _series2.checkSeriesViewportCoord(argAxis, coords[argCoordName])) {
                                    coords[valCoordName] = series.getSeriesPairCoord(coords[argCoordName], true)
                                }
                            }
                        }
                    }
                    if (!(0, _type.isDefined)(argument) && (0, _type.isDefined)(coords[valCoordName])) {
                        if ((0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
                            coords[argCoordName] = axis.getAxisPosition()
                        } else {
                            if ((0, _type.isDefined)(series)) {
                                if (series.checkSeriesViewportCoord(axis, coords[valCoordName])) {
                                    coords[argCoordName] = series.getSeriesPairCoord(coords[valCoordName], false)
                                }
                            }
                        }
                    }
                    return coords
                },
                _annotationsPointerEventHandler: function(event) {
                    var originalEvent = event.originalEvent || {};
                    var touch = originalEvent.touches && originalEvent.touches[0] || {};
                    var rootOffset = this._renderer.getRootOffset();
                    var coords = {
                        x: touch.pageX || originalEvent.pageX || event.pageX,
                        y: touch.pageY || originalEvent.pageY || event.pageY
                    };
                    var annotation = this._annotations.items.filter(function(a) {
                        return a.hitTest(coords.x - rootOffset.left, coords.y - rootOffset.top)
                    })[0];
                    if (!annotation || !annotation.options.tooltipEnabled) {
                        this._annotations.hideTooltip();
                        return
                    }
                    this.hideTooltip();
                    this.clearHover();
                    if (annotation.options.allowDragging && event.type === _pointer2.default.down) {
                        this._annotations._hideToolTipForDrag = true
                    }
                    if (!this._annotations._hideToolTipForDrag) {
                        annotation.showTooltip(this._annotations.tooltip, coords);
                        event.stopPropagation()
                    }
                },
                _pullOptions: function(options) {
                    return {
                        type: options.type,
                        name: options.name,
                        x: options.x,
                        y: options.y,
                        value: options.value,
                        argument: options.argument,
                        axis: options.axis,
                        series: options.series,
                        options: options,
                        offsetX: options.offsetX,
                        offsetY: options.offsetY
                    }
                }
            }
        };
        var polarChartPlugin = {
            name: "annotations_polar_chart",
            init: function() {},
            dispose: function() {},
            members: {
                _getAnnotationCoords: function(annotation) {
                    var coords = {
                        offsetX: annotation.offsetX,
                        offsetY: annotation.offsetY,
                        canvas: this._calcCanvas()
                    };
                    var argAxis = this.getArgumentAxis();
                    var argument = argAxis.validateUnit(annotation.argument);
                    var value = this.getValueAxis().validateUnit(annotation.value);
                    var radius = annotation.radius;
                    var angle = annotation.angle;
                    var pointCoords;
                    var series;
                    if (annotation.series) {
                        series = this.series.filter(function(s) {
                            return s.name === annotation.series
                        })[0]
                    }(0, _extend.extend)(true, coords, this.getXYFromPolar(angle, radius, argument, value));
                    if ((0, _type.isDefined)(series)) {
                        if ((0, _type.isDefined)(coords.angle) && !(0, _type.isDefined)(value) && !(0, _type.isDefined)(radius)) {
                            if (!(0, _type.isDefined)(argument)) {
                                argument = argAxis.getTranslator().from(isFinite(angle) ? this.getActualAngle(angle) : coords.angle)
                            }
                            pointCoords = series.getSeriesPairCoord({
                                argument: argument,
                                angle: -coords.angle
                            }, true)
                        } else {
                            if ((0, _type.isDefined)(coords.radius) && !(0, _type.isDefined)(argument) && !(0, _type.isDefined)(angle)) {
                                pointCoords = series.getSeriesPairCoord({
                                    radius: coords.radius
                                }, false)
                            }
                        }
                        if ((0, _type.isDefined)(pointCoords)) {
                            coords.x = pointCoords.x;
                            coords.y = pointCoords.y
                        }
                    }
                    if (annotation.series && !(0, _type.isDefined)(pointCoords)) {
                        coords.x = coords.y = void 0
                    }
                    return coords
                },
                _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
                _pullOptions: function(options) {
                    var polarOptions = (0, _extend.extend)({}, {
                        radius: options.radius,
                        angle: options.angle
                    }, chartPlugin.members._pullOptions(options));
                    delete polarOptions.axis;
                    return polarOptions
                }
            }
        };
        var corePlugin = {
            name: "annotations_core",
            init: function() {
                this._annotations = {
                    items: [],
                    _hideToolTipForDrag: false,
                    tooltip: new _tooltip.Tooltip({
                        cssClass: "".concat(this._rootClassPrefix, "-annotation-tooltip"),
                        eventTrigger: this._eventTrigger,
                        widgetRoot: this.element(),
                        widget: this
                    }),
                    hideTooltip: function() {
                        this.tooltip.annotation = null;
                        this.tooltip.hide()
                    }
                };
                this._annotations.tooltip.setRendererOptions(this._getRendererOptions());
                var tooltipOptions = (0, _extend.extend)({}, this._themeManager.getOptions("tooltip"));
                tooltipOptions.contentTemplate = tooltipOptions.customizeTooltip = void 0;
                this._annotations.tooltip.update(tooltipOptions)
            },
            dispose: function() {
                this._annotationsGroup.linkRemove().linkOff();
                _events_engine2.default.off((0, _dom_adapter.getDocument)(), DOT_EVENT_NS);
                this._annotationsGroup.off(DOT_EVENT_NS);
                this._annotations.tooltip && this._annotations.tooltip.dispose()
            },
            extenders: {
                _createHtmlStructure: function() {
                    var _this2 = this;
                    this._annotationsGroup = this._renderer.g().attr({
                        "class": "".concat(this._rootClassPrefix, "-annotations")
                    }).linkOn(this._renderer.root, "annotations").linkAppend();
                    _events_engine2.default.on((0, _dom_adapter.getDocument)(), POINTER_ACTION, function() {
                        return _this2._annotations.hideTooltip()
                    });
                    _events_engine2.default.on((0, _dom_adapter.getDocument)(), POINTER_UP_EVENT_NAME, function(event) {
                        _this2._annotations._hideToolTipForDrag = false;
                        _this2._annotationsPointerEventHandler(event)
                    });
                    this._annotationsGroup.on(POINTER_ACTION, this._annotationsPointerEventHandler.bind(this))
                },
                _renderExtraElements: function() {
                    var _this3 = this;
                    this._annotationsGroup.clear();
                    this._annotations.items.forEach(function(item) {
                        return item.draw(_this3, _this3._annotationsGroup)
                    })
                },
                _stopCurrentHandling: function() {
                    this._annotations.hideTooltip()
                }
            },
            members: {
                _buildAnnotations: function() {
                    this._annotations.items = [];
                    var items = this._getOption("annotations");
                    if (!(null === items || void 0 === items ? void 0 : items.length)) {
                        return
                    }
                    this._annotations.items = createAnnotations(this, items, this._getOption("commonAnnotationSettings"), this._getOption("customizeAnnotation"), this._pullOptions)
                },
                _getAnnotationCoords: function() {
                    return {}
                },
                _pullOptions: function() {
                    return {}
                }
            },
            customize: function(constructor) {
                constructor.addChange({
                    code: "ANNOTATIONITEMS",
                    handler: function() {
                        this._requestChange(["ANNOTATIONS"])
                    },
                    isOptionChange: true,
                    option: "annotations"
                });
                constructor.addChange({
                    code: "ANNOTATIONSSETTINGS",
                    handler: function() {
                        this._requestChange(["ANNOTATIONS"])
                    },
                    isOptionChange: true,
                    option: "commonAnnotationSettings"
                });
                constructor.addChange({
                    code: "ANNOTATIONS",
                    handler: function() {
                        this._buildAnnotations();
                        this._change(["FORCE_RENDER"])
                    },
                    isThemeDependent: true,
                    isOptionChange: true
                })
            },
            fontFields: ["commonAnnotationSettings.font"]
        };
        exports.plugins = {
            core: corePlugin,
            chart: chartPlugin,
            polarChart: polarChartPlugin
        }
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/common.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dxBaseGauge = __webpack_require__( /*! ./base_gauge */ 153).dxBaseGauge;
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var _isDefined = typeUtils.isDefined;
        var _isArray = Array.isArray;
        var _isNumber = typeUtils.isNumeric;
        var axisModule = __webpack_require__( /*! ../axes/base_axis */ 211);
        var _map = __webpack_require__( /*! ../core/utils */ 13).map;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var _compareArrays = __webpack_require__( /*! ./base_gauge */ 153).compareArrays;
        var _isFinite = isFinite;
        var _Number = Number;
        var _min = Math.min;
        var _max = Math.max;
        var _extend = extend;
        var _each = each;
        var _noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var SHIFT_ANGLE = 90;
        var OPTION_VALUE = "value";
        var OPTION_SUBVALUES = "subvalues";
        var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 5;
        var DEFAULT_NUMBER_MULTIPLIERS = [1, 2, 5];

        function processValue(value, fallbackValue) {
            if (null === value) {
                return value
            }
            return _isFinite(value) ? _Number(value) : fallbackValue
        }

        function parseArrayOfNumbers(arg) {
            return _isArray(arg) ? arg : _isNumber(arg) ? [arg] : null
        }
        exports.dxGauge = dxBaseGauge.inherit({
            _initCore: function() {
                var that = this;
                var renderer = that._renderer;
                that._setupValue(that.option(OPTION_VALUE));
                that.__subvalues = parseArrayOfNumbers(that.option(OPTION_SUBVALUES));
                that._setupSubvalues(that.__subvalues);
                selectMode(that);
                that.callBase.apply(that, arguments);
                that._rangeContainer = new that._factory.RangeContainer({
                    renderer: renderer,
                    container: renderer.root,
                    translator: that._translator,
                    themeManager: that._themeManager
                });
                that._initScale()
            },
            _fontFields: ["scale.label.font", "valueIndicators.rangebar.text.font", "valueIndicators.textcloud.text.font", "indicator.text.font"],
            _initScale: function() {
                var that = this;
                that._scaleGroup = that._renderer.g().attr({
                    "class": "dxg-scale"
                }).linkOn(that._renderer.root, "scale");
                that._scale = new axisModule.Axis({
                    incidentOccurred: that._incidentOccurred,
                    renderer: that._renderer,
                    axesContainerGroup: that._scaleGroup,
                    axisType: that._scaleTypes.type,
                    drawingType: that._scaleTypes.drawingType,
                    widgetClass: "dxg"
                })
            },
            _disposeCore: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                that._scale.dispose();
                that._scaleGroup.linkOff();
                that._rangeContainer.dispose();
                that._disposeValueIndicators();
                that._scale = that._scaleGroup = that._rangeContainer = null
            },
            _disposeValueIndicators: function() {
                var that = this;
                that._valueIndicator && that._valueIndicator.dispose();
                that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.dispose();
                that._valueIndicator = that._subvalueIndicatorsSet = null
            },
            _setupDomainCore: function() {
                var that = this;
                var scaleOption = that.option("scale") || {};
                var startValue = that.option("startValue");
                var endValue = that.option("endValue");
                startValue = _isNumber(startValue) ? _Number(startValue) : _isNumber(scaleOption.startValue) ? _Number(scaleOption.startValue) : 0;
                endValue = _isNumber(endValue) ? _Number(endValue) : _isNumber(scaleOption.endValue) ? _Number(scaleOption.endValue) : 100;
                that._baseValue = startValue < endValue ? startValue : endValue;
                that._translator.setDomain(startValue, endValue)
            },
            _cleanContent: function() {
                var that = this;
                that._rangeContainer.clean();
                that._cleanValueIndicators()
            },
            _measureScale: function(scaleOptions) {
                var that = this;
                var majorTick = scaleOptions.tick;
                var majorTickEnabled = majorTick.visible && majorTick.length > 0 && majorTick.width > 0;
                var minorTick = scaleOptions.minorTick;
                var minorTickEnabled = minorTick.visible && minorTick.length > 0 && minorTick.width > 0;
                var label = scaleOptions.label;
                var indentFromTick = Number(label.indentFromTick);
                if (!majorTickEnabled && !minorTickEnabled && !label.visible) {
                    return {}
                }
                var textParams = that._scale.measureLabels(extend({}, that._canvas));
                var layoutValue = that._getScaleLayoutValue();
                var result = {
                    min: layoutValue,
                    max: layoutValue
                };
                var coefs = that._getTicksCoefficients(scaleOptions);
                var innerCoef = coefs.inner;
                var outerCoef = coefs.outer;
                if (majorTickEnabled) {
                    result.min = _min(result.min, layoutValue - innerCoef * majorTick.length);
                    result.max = _max(result.max, layoutValue + outerCoef * majorTick.length)
                }
                if (minorTickEnabled) {
                    result.min = _min(result.min, layoutValue - innerCoef * minorTick.length);
                    result.max = _max(result.max, layoutValue + outerCoef * minorTick.length)
                }
                label.visible && that._correctScaleIndents(result, indentFromTick, textParams);
                return result
            },
            _renderContent: function() {
                var that = this;
                var scaleOptions = that._prepareScaleSettings();
                that._rangeContainer.render(_extend(that._getOption("rangeContainer"), {
                    vertical: that._area.vertical
                }));
                that._renderScale(scaleOptions);
                var elements = _map([that._rangeContainer].concat(that._prepareValueIndicators()), function(element) {
                    return element && element.enabled ? element : null
                });
                that._applyMainLayout(elements, that._measureScale(scaleOptions));
                _each(elements, function(_, element) {
                    element.resize(that._getElementLayout(element.getOffset()))
                });
                that._shiftScale(that._getElementLayout(0), scaleOptions);
                that._beginValueChanging();
                that._updateActiveElements();
                that._endValueChanging()
            },
            _prepareScaleSettings: function() {
                var that = this;
                var userOptions = that.option("scale");
                var scaleOptions = extend(true, {}, that._themeManager.theme("scale"), userOptions);
                scaleOptions.label.indentFromAxis = 0;
                scaleOptions.isHorizontal = !that._area.vertical;
                scaleOptions.forceUserTickInterval |= _isDefined(userOptions) && _isDefined(userOptions.tickInterval) && !_isDefined(userOptions.scaleDivisionFactor);
                scaleOptions.axisDivisionFactor = scaleOptions.scaleDivisionFactor || that._gridSpacingFactor;
                scaleOptions.minorAxisDivisionFactor = scaleOptions.minorScaleDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
                scaleOptions.numberMultipliers = DEFAULT_NUMBER_MULTIPLIERS;
                scaleOptions.tickOrientation = that._getTicksOrientation(scaleOptions);
                if (scaleOptions.label.useRangeColors) {
                    scaleOptions.label.customizeColor = function() {
                        return that._rangeContainer.getColorForValue(this.value)
                    }
                }
                return scaleOptions
            },
            _renderScale: function(scaleOptions) {
                var that = this;
                var bounds = that._translator.getDomain();
                var startValue = bounds[0];
                var endValue = bounds[1];
                var angles = that._translator.getCodomain();
                var invert = startValue > endValue;
                var min = _min(startValue, endValue);
                var max = _max(startValue, endValue);
                scaleOptions.min = min;
                scaleOptions.max = max;
                scaleOptions.startAngle = SHIFT_ANGLE - angles[0];
                scaleOptions.endAngle = SHIFT_ANGLE - angles[1];
                scaleOptions.skipViewportExtending = true;
                that._scale.updateOptions(scaleOptions);
                that._scale.setBusinessRange({
                    axisType: "continuous",
                    dataType: "numeric",
                    min: min,
                    max: max,
                    invert: invert
                });
                that._updateScaleTickIndent(scaleOptions);
                that._scaleGroup.linkAppend();
                that._scale.draw(extend({}, that._canvas))
            },
            _updateIndicatorSettings: function(settings) {
                var that = this;
                settings.currentValue = settings.baseValue = _isFinite(that._translator.translate(settings.baseValue)) ? _Number(settings.baseValue) : that._baseValue;
                settings.vertical = that._area.vertical;
                if (settings.text && !settings.text.format) {
                    settings.text.format = that._defaultFormatOptions
                }
            },
            _prepareIndicatorSettings: function(options, defaultTypeField) {
                var that = this;
                var theme = that._themeManager.theme("valueIndicators");
                var type = _normalizeEnum(options.type || that._themeManager.theme(defaultTypeField));
                var settings = _extend(true, {}, theme._default, theme[type], options);
                settings.type = type;
                settings.animation = that._animationSettings;
                settings.containerBackgroundColor = that._containerBackgroundColor;
                that._updateIndicatorSettings(settings);
                return settings
            },
            _cleanValueIndicators: function() {
                this._valueIndicator && this._valueIndicator.clean();
                this._subvalueIndicatorsSet && this._subvalueIndicatorsSet.clean()
            },
            _prepareValueIndicators: function() {
                var that = this;
                that._prepareValueIndicator();
                null !== that.__subvalues && that._prepareSubvalueIndicators();
                return [that._valueIndicator, that._subvalueIndicatorsSet]
            },
            _updateActiveElements: function() {
                this._updateValueIndicator();
                this._updateSubvalueIndicators()
            },
            _prepareValueIndicator: function() {
                var that = this;
                var target = that._valueIndicator;
                var settings = that._prepareIndicatorSettings(that.option("valueIndicator") || {}, "valueIndicatorType");
                if (target && target.type !== settings.type) {
                    target.dispose();
                    target = null
                }
                if (!target) {
                    target = that._valueIndicator = that._createIndicator(settings.type, that._renderer.root, "dxg-value-indicator", "value-indicator")
                }
                target.render(settings)
            },
            _createSubvalueIndicatorsSet: function() {
                var that = this;
                var root = that._renderer.root;
                return new ValueIndicatorsSet({
                    createIndicator: function(type, i) {
                        return that._createIndicator(type, root, "dxg-subvalue-indicator", "subvalue-indicator", i)
                    },
                    createPalette: function(palette) {
                        return that._themeManager.createPalette(palette)
                    }
                })
            },
            _prepareSubvalueIndicators: function() {
                var that = this;
                var target = that._subvalueIndicatorsSet;
                var settings = that._prepareIndicatorSettings(that.option("subvalueIndicator") || {}, "subvalueIndicatorType");
                if (!target) {
                    target = that._subvalueIndicatorsSet = that._createSubvalueIndicatorsSet()
                }
                var isRecreate = settings.type !== target.type;
                target.type = settings.type;
                var dummy = that._createIndicator(settings.type, that._renderer.root);
                if (dummy) {
                    dummy.dispose();
                    target.render(settings, isRecreate)
                }
            },
            _setupValue: function(value) {
                this.__value = processValue(value, this.__value)
            },
            _setupSubvalues: function(subvalues) {
                var vals = void 0 === subvalues ? this.__subvalues : parseArrayOfNumbers(subvalues);
                var i;
                var ii;
                var list;
                if (null === vals) {
                    return
                }
                for (i = 0, ii = vals.length, list = []; i < ii; ++i) {
                    list.push(processValue(vals[i], this.__subvalues[i]))
                }
                this.__subvalues = list
            },
            _updateValueIndicator: function() {
                var that = this;
                that._valueIndicator && that._valueIndicator.value(that.__value, that._noAnimation)
            },
            _updateSubvalueIndicators: function() {
                var that = this;
                that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.values(that.__subvalues, that._noAnimation)
            },
            value: function(arg) {
                if (void 0 !== arg) {
                    this._changeValue(arg);
                    return this
                }
                return this.__value
            },
            subvalues: function(arg) {
                if (void 0 !== arg) {
                    this._changeSubvalues(arg);
                    return this
                }
                return null !== this.__subvalues ? this.__subvalues.slice() : void 0
            },
            _changeValue: function(value) {
                var that = this;
                that._setupValue(value);
                that._beginValueChanging();
                that._updateValueIndicator();
                if (that.__value !== that.option(OPTION_VALUE)) {
                    that.option(OPTION_VALUE, that.__value)
                }
                that._endValueChanging()
            },
            _changeSubvalues: function(subvalues) {
                var that = this;
                if (null !== that.__subvalues) {
                    that._setupSubvalues(subvalues);
                    that._beginValueChanging();
                    that._updateSubvalueIndicators();
                    that._endValueChanging()
                } else {
                    that.__subvalues = parseArrayOfNumbers(subvalues);
                    that._setContentSize();
                    that._renderContent()
                }
                if (!_compareArrays(that.__subvalues, that.option(OPTION_SUBVALUES))) {
                    that.option(OPTION_SUBVALUES, that.__subvalues)
                }
            },
            _optionChangesMap: {
                scale: "DOMAIN",
                rangeContainer: "MOSTLY_TOTAL",
                valueIndicator: "MOSTLY_TOTAL",
                subvalueIndicator: "MOSTLY_TOTAL",
                containerBackgroundColor: "MOSTLY_TOTAL",
                value: "VALUE",
                subvalues: "SUBVALUES",
                valueIndicators: "MOSTLY_TOTAL"
            },
            _customChangesOrder: ["VALUE", "SUBVALUES"],
            _change_VALUE: function() {
                this._changeValue(this.option(OPTION_VALUE))
            },
            _change_SUBVALUES: function() {
                this._changeSubvalues(this.option(OPTION_SUBVALUES))
            },
            _applyMainLayout: null,
            _getElementLayout: null,
            _createIndicator: function(type, owner, className, trackerType, trackerIndex, _strict) {
                var that = this;
                var indicator = that._factory.createIndicator({
                    renderer: that._renderer,
                    translator: that._translator,
                    owner: owner,
                    tracker: that._tracker,
                    className: className
                }, type, _strict);
                if (indicator) {
                    indicator.type = type;
                    indicator._trackerInfo = {
                        type: trackerType,
                        index: trackerIndex
                    }
                }
                return indicator
            },
            _getApproximateScreenRange: null
        });

        function valueGetter(arg) {
            return arg ? arg.value : null
        }

        function setupValues(that, fieldName, optionItems) {
            var currentValues = that[fieldName];
            var newValues = _isArray(optionItems) ? _map(optionItems, valueGetter) : [];
            var i = 0;
            var ii = newValues.length;
            var list = [];
            for (; i < ii; ++i) {
                list.push(processValue(newValues[i], currentValues[i]))
            }
            that[fieldName] = list
        }

        function selectMode(gauge) {
            if (void 0 === gauge.option(OPTION_VALUE) && void 0 === gauge.option(OPTION_SUBVALUES)) {
                if (void 0 !== gauge.option("valueIndicators")) {
                    disableDefaultMode(gauge);
                    selectHardMode(gauge)
                }
            }
        }

        function disableDefaultMode(that) {
            that.value = that.subvalues = _noop;
            that._setupValue = that._setupSubvalues = that._updateValueIndicator = that._updateSubvalueIndicators = null
        }

        function selectHardMode(that) {
            that._indicatorValues = [];
            setupValues(that, "_indicatorValues", that.option("valueIndicators"));
            that._valueIndicators = [];
            var _applyMostlyTotalChange = that._applyMostlyTotalChange;
            that._applyMostlyTotalChange = function() {
                setupValues(this, "_indicatorValues", this.option("valueIndicators"));
                _applyMostlyTotalChange.call(this)
            };
            that._updateActiveElements = updateActiveElements_hardMode;
            that._prepareValueIndicators = prepareValueIndicators_hardMode;
            that._disposeValueIndicators = disposeValueIndicators_hardMode;
            that._cleanValueIndicators = cleanValueIndicators_hardMode;
            that.indicatorValue = indicatorValue_hardMode
        }

        function updateActiveElements_hardMode() {
            var that = this;
            _each(that._valueIndicators, function(_, valueIndicator) {
                valueIndicator.value(that._indicatorValues[valueIndicator.index], that._noAnimation)
            })
        }

        function prepareValueIndicators_hardMode() {
            var that = this;
            var valueIndicators = that._valueIndicators || [];
            var userOptions = that.option("valueIndicators");
            var optionList = [];
            var i = 0;
            var ii;
            for (ii = _isArray(userOptions) ? userOptions.length : 0; i < ii; ++i) {
                optionList.push(userOptions[i])
            }
            for (ii = valueIndicators.length; i < ii; ++i) {
                optionList.push(null)
            }
            var newValueIndicators = [];
            _each(optionList, function(i, userSettings) {
                var valueIndicator = valueIndicators[i];
                if (!userSettings) {
                    valueIndicator && valueIndicator.dispose();
                    return
                }
                var settings = that._prepareIndicatorSettings(userSettings, "valueIndicatorType");
                if (valueIndicator && valueIndicator.type !== settings.type) {
                    valueIndicator.dispose();
                    valueIndicator = null
                }
                if (!valueIndicator) {
                    valueIndicator = that._createIndicator(settings.type, that._renderer.root, "dxg-value-indicator", "value-indicator", i, true)
                }
                if (valueIndicator) {
                    valueIndicator.index = i;
                    valueIndicator.render(settings);
                    newValueIndicators.push(valueIndicator)
                }
            });
            that._valueIndicators = newValueIndicators;
            return that._valueIndicators
        }

        function disposeValueIndicators_hardMode() {
            _each(this._valueIndicators, function(_, valueIndicator) {
                valueIndicator.dispose()
            });
            this._valueIndicators = null
        }

        function cleanValueIndicators_hardMode() {
            _each(this._valueIndicators, function(_, valueIndicator) {
                valueIndicator.clean()
            })
        }

        function indicatorValue_hardMode(index, value) {
            return accessPointerValue(this, this._valueIndicators, this._indicatorValues, index, value)
        }

        function accessPointerValue(that, pointers, values, index, value) {
            if (void 0 !== value) {
                if (void 0 !== values[index]) {
                    values[index] = processValue(value, values[index]);
                    pointers[index] && pointers[index].value(values[index])
                }
                return that
            } else {
                return values[index]
            }
        }

        function ValueIndicatorsSet(parameters) {
            this._parameters = parameters;
            this._indicators = []
        }
        ValueIndicatorsSet.prototype = {
            constructor: ValueIndicatorsSet,
            dispose: function() {
                var that = this;
                _each(that._indicators, function(_, indicator) {
                    indicator.dispose()
                });
                that._parameters = that._options = that._indicators = that._colorPalette = that._palette = null;
                return that
            },
            clean: function() {
                var that = this;
                that._sample && that._sample.clean().dispose();
                _each(that._indicators, function(_, indicator) {
                    indicator.clean()
                });
                that._sample = that._options = that._palette = null;
                return that
            },
            render: function(options, isRecreate) {
                var that = this;
                that._options = options;
                that._sample = that._parameters.createIndicator(that.type);
                that._sample.render(options);
                that.enabled = that._sample.enabled;
                that._palette = _isDefined(options.palette) ? that._parameters.createPalette(options.palette) : null;
                if (that.enabled) {
                    that._generatePalette(that._indicators.length);
                    that._indicators = _map(that._indicators, function(indicator, i) {
                        if (isRecreate) {
                            indicator.dispose();
                            indicator = that._parameters.createIndicator(that.type, i)
                        }
                        indicator.render(that._getIndicatorOptions(i));
                        return indicator
                    })
                }
                return that
            },
            getOffset: function() {
                return this._sample.getOffset()
            },
            resize: function(layout) {
                var that = this;
                that._layout = layout;
                _each(that._indicators, function(_, indicator) {
                    indicator.resize(layout)
                });
                return that
            },
            measure: function(layout) {
                return this._sample.measure(layout)
            },
            _getIndicatorOptions: function(index) {
                var result = this._options;
                if (this._colorPalette) {
                    result = _extend({}, result, {
                        color: this._colorPalette[index]
                    })
                }
                return result
            },
            _generatePalette: function(count) {
                var that = this;
                var colors = null;
                if (that._palette) {
                    that._palette.reset();
                    colors = that._palette.generateColors(count, {
                        repeat: true
                    })
                }
                that._colorPalette = colors
            },
            _adjustIndicatorsCount: function(count) {
                var that = this;
                var indicators = that._indicators;
                var i;
                var ii;
                var indicator;
                var indicatorsLen = indicators.length;
                if (indicatorsLen > count) {
                    for (i = count, ii = indicatorsLen; i < ii; ++i) {
                        indicators[i].clean().dispose()
                    }
                    that._indicators = indicators.slice(0, count);
                    that._generatePalette(indicators.length)
                } else {
                    if (indicatorsLen < count) {
                        that._generatePalette(count);
                        for (i = indicatorsLen, ii = count; i < ii; ++i) {
                            indicator = that._parameters.createIndicator(that.type, i);
                            indicator.render(that._getIndicatorOptions(i)).resize(that._layout);
                            indicators.push(indicator)
                        }
                    }
                }
            },
            values: function(arg, _noAnimation) {
                var that = this;
                if (!that.enabled) {
                    return
                }
                if (void 0 !== arg) {
                    if (!_isArray(arg)) {
                        arg = _isFinite(arg) ? [Number(arg)] : null
                    }
                    if (arg) {
                        that._adjustIndicatorsCount(arg.length);
                        _each(that._indicators, function(i, indicator) {
                            indicator.value(arg[i], _noAnimation)
                        })
                    }
                    return that
                }
                return _map(that._indicators, function(indicator) {
                    return indicator.value()
                })
            }
        };
        exports.createIndicatorCreator = function(indicators) {
            return function(parameters, type, _strict) {
                var indicatorType = indicators[_normalizeEnum(type)] || !_strict && indicators._default;
                return indicatorType ? new indicatorType(parameters) : null
            }
        }
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector/common.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _format = __webpack_require__( /*! ../axes/smart_formatter */ 424).smartFormatter;
        var isFunction = __webpack_require__( /*! ../../core/utils/type */ 1).isFunction;
        var HEIGHT_COMPACT_MODE = 24;
        var POINTER_SIZE = 4;
        var EMPTY_SLIDER_MARKER_TEXT = ". . .";
        var utils = {
            trackerSettings: {
                fill: "grey",
                stroke: "grey",
                opacity: 1e-4
            },
            animationSettings: {
                duration: 250
            }
        };
        var consts = {
            emptySliderMarkerText: EMPTY_SLIDER_MARKER_TEXT,
            pointerSize: POINTER_SIZE
        };
        var formatValue = function(value, formatOptions, tickIntervalsInfo, valueType, type, logarithmBase) {
            var formatObject = {
                value: value,
                valueText: _format(value, {
                    labelOptions: formatOptions,
                    ticks: tickIntervalsInfo ? tickIntervalsInfo.ticks : [],
                    tickInterval: tickIntervalsInfo ? tickIntervalsInfo.tickInterval : void 0,
                    dataType: valueType,
                    type: type,
                    logarithmBase: logarithmBase
                })
            };
            return String(isFunction(formatOptions.customizeText) ? formatOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText)
        };
        exports.utils = utils;
        exports.consts = consts;
        exports.formatValue = formatValue;
        exports.HEIGHT_COMPACT_MODE = HEIGHT_COMPACT_MODE
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/localization/ldml/date.format.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _number = __webpack_require__( /*! ../number */ 49);
        var _number2 = _interopRequireDefault(_number);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var ARABIC_COMMA = "\u060c";
        var FORMAT_SEPARATORS = " .,:;/\\<>()-[]" + ARABIC_COMMA;
        var AM_PM_PATTERN = ". m.";
        var checkDigit = function(char) {
            var code = char && _number2.default.convertDigits(char, false).charCodeAt(0);
            var zeroCode = _number2.default.convertDigits("0", false).charCodeAt(0);
            return zeroCode <= code && code < zeroCode + 10
        };
        var checkPatternContinue = function(text, index, isDigit) {
            var char = text[index];
            var nextChar = text[index + 1];
            if (!isDigit) {
                if ("." === char || " " === char && text.slice(index - 1, index + 3) === AM_PM_PATTERN) {
                    return true
                }
                if ("-" === char && !checkDigit(nextChar)) {
                    return true
                }
            }
            return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char)
        };
        var getPatternStartIndex = function(defaultPattern, index) {
            if (!checkDigit(defaultPattern[index])) {
                while (index > 0 && !checkDigit(defaultPattern[index - 1]) && ("." === defaultPattern[index - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index - 1]) < 0)) {
                    index--
                }
            }
            return index
        };
        var getDifference = function(defaultPattern, patterns, processedIndexes, isDigit) {
            var i = 0;
            var result = [];
            var patternsFilter = function(pattern) {
                return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit)
            };
            if (!Array.isArray(patterns)) {
                patterns = [patterns]
            }
            for (i = 0; i < defaultPattern.length; i++) {
                if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
                    i = getPatternStartIndex(defaultPattern, i);
                    do {
                        isDigit = checkDigit(defaultPattern[i]);
                        if (!result.length && !isDigit && checkDigit(patterns[0][i])) {
                            break
                        }
                        result.push(i);
                        processedIndexes.unshift(i);
                        i++
                    } while (defaultPattern[i] && checkPatternContinue(defaultPattern, i, isDigit));
                    break
                }
            }
            if (1 === result.length && ("0" === defaultPattern[processedIndexes[0] - 1] || "\u0660" === defaultPattern[processedIndexes[0] - 1])) {
                processedIndexes.unshift(processedIndexes[0] - 1)
            }
            return result
        };
        var replaceCharsCore = function(pattern, indexes, char, patternPositions) {
            var baseCharIndex = indexes[0];
            var patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
            indexes.forEach(function(_, index) {
                pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1)
            });
            if (1 === indexes.length) {
                pattern = pattern.replace("0" + char, char + char);
                pattern = pattern.replace("\u0660" + char, char + char)
            }
            return pattern
        };
        var replaceChars = function(pattern, indexes, char, patternPositions) {
            var i;
            var index;
            var patternIndex;
            if (!checkDigit(pattern[indexes[0]] || "0")) {
                var letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
                while (indexes.length > letterCount) {
                    index = indexes.pop();
                    patternIndex = patternPositions[index];
                    patternPositions[index] = -1;
                    for (i = index + 1; i < patternPositions.length; i++) {
                        patternPositions[i]--
                    }
                    pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1)
                }
                index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;
                while (indexes.length < letterCount) {
                    indexes.push(indexes[indexes.length - 1] + 1);
                    for (i = index; i < patternPositions.length; i++) {
                        patternPositions[i]++
                    }
                    pattern = pattern.substr(0, patternIndex) + " " + pattern.substr(patternIndex)
                }
            }
            pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
            return pattern
        };
        var formatValue = function(value, formatter) {
            if (Array.isArray(value)) {
                return value.map(function(value) {
                    return (formatter(value) || "").toString()
                })
            }
            return (formatter(value) || "").toString()
        };
        var ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;
        var escapeChars = function(pattern, defaultPattern, processedIndexes, patternPositions) {
            var escapeIndexes = defaultPattern.split("").map(function(char, index) {
                if (processedIndexes.indexOf(index) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || "'" === char)) {
                    return patternPositions[index]
                }
                return -1
            });
            pattern = pattern.split("").map(function(char, index) {
                var result = char;
                var isCurrentCharEscaped = escapeIndexes.indexOf(index) >= 0;
                var isPrevCharEscaped = index > 0 && escapeIndexes.indexOf(index - 1) >= 0;
                var isNextCharEscaped = escapeIndexes.indexOf(index + 1) >= 0;
                if (isCurrentCharEscaped) {
                    if (!isPrevCharEscaped) {
                        result = "'" + result
                    }
                    if (!isNextCharEscaped) {
                        result += "'"
                    }
                }
                return result
            }).join("");
            return pattern
        };
        var getFormat = function(formatter) {
            var processedIndexes = [];
            var defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);
            var patternPositions = defaultPattern.split("").map(function(_, index) {
                return index
            });
            var result = defaultPattern;
            var replacedPatterns = {};
            var datePatterns = [{
                date: new Date(2009, 8, 8, 6, 5, 4, 100),
                pattern: "S"
            }, {
                date: new Date(2009, 8, 8, 6, 5, 2),
                pattern: "s"
            }, {
                date: new Date(2009, 8, 8, 6, 2, 4),
                pattern: "m"
            }, {
                date: new Date(2009, 8, 8, 18, 5, 4),
                pattern: "H",
                isDigit: true
            }, {
                date: new Date(2009, 8, 8, 2, 5, 4),
                pattern: "h",
                isDigit: true
            }, {
                date: new Date(2009, 8, 8, 18, 5, 4),
                pattern: "a",
                isDigit: false
            }, {
                date: new Date(2009, 8, 1, 6, 5, 4),
                pattern: "d"
            }, {
                date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
                pattern: "E"
            }, {
                date: new Date(2009, 9, 6, 6, 5, 4),
                pattern: "M"
            }, {
                date: new Date(1998, 8, 8, 6, 5, 4),
                pattern: "y"
            }];
            if (!result) {
                return
            }
            datePatterns.forEach(function(test) {
                var diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);
                var pattern = "M" === test.pattern && !replacedPatterns.d ? "L" : test.pattern;
                result = replaceChars(result, diff, pattern, patternPositions);
                replacedPatterns[pattern] = diff.length
            });
            result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);
            if (processedIndexes.length) {
                return result
            }
        };
        exports.getFormat = getFormat
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/core/utils/svg.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var window = __webpack_require__( /*! ./window */ 7).getWindow();
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);

        function getMarkup(element, backgroundColor) {
            var temp = domAdapter.createElement("div");
            var clone = element.cloneNode(true);
            if (backgroundColor) {
                $(clone).css("backgroundColor", backgroundColor)
            }
            temp.appendChild(clone);
            return temp.innerHTML
        }

        function fixNamespaces(markup) {
            var first = true;
            if (markup.indexOf("xmlns:xlink") === -1) {
                markup = markup.replace("<svg", '<svg xmlns:xlink="http://www.w3.org/1999/xlink"')
            }
            markup = markup.replace(/xmlns="[\s\S]*?"/gi, function(match) {
                if (!first) {
                    return ""
                }
                first = false;
                return match
            });
            return markup.replace(/xmlns:NS1="[\s\S]*?"/gi, "").replace(/NS1:xmlns:xlink="([\s\S]*?)"/gi, 'xmlns:xlink="$1"')
        }

        function decodeHtmlEntities(markup) {
            return markup.replace(/&quot;/gi, "&#34;").replace(/&amp;/gi, "&#38;").replace(/&apos;/gi, "&#39;").replace(/&lt;/gi, "&#60;").replace(/&gt;/gi, "&#62;").replace(/&nbsp;/gi, "&#160;").replace(/&shy;/gi, "&#173;")
        }
        exports.getSvgMarkup = function(element, backgroundColor) {
            return fixNamespaces(decodeHtmlEntities(getMarkup(element, backgroundColor)))
        };
        exports.getSvgElement = function(markup) {
            return domAdapter.isNode(markup) ? markup : (new window.DOMParser).parseFromString(markup, "image/svg+xml").childNodes[0]
        }
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/localization/ldml/date.parser.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var escapeRegExp = __webpack_require__( /*! ../../core/utils/common */ 3).escapeRegExp;
        var FORMAT_TYPES = {
            3: "abbreviated",
            4: "wide",
            5: "narrow"
        };
        var monthRegExpGenerator = function(count, dateParts) {
            if (count > 2) {
                return Object.keys(FORMAT_TYPES).map(function(count) {
                    return ["format", "standalone"].map(function(type) {
                        return dateParts.getMonthNames(FORMAT_TYPES[count], type).join("|")
                    }).join("|")
                }).join("|")
            }
            return "0?[1-9]|1[012]"
        };
        var PATTERN_REGEXPS = {
            y: function(count) {
                return "[0-9]+"
            },
            M: monthRegExpGenerator,
            L: monthRegExpGenerator,
            Q: function(count, dateParts) {
                if (count > 2) {
                    return dateParts.getQuarterNames(FORMAT_TYPES[count], "format").join("|")
                }
                return "0?[1-4]"
            },
            E: function(count, dateParts) {
                return "\\D*"
            },
            a: function(count, dateParts) {
                return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], "format").join("|")
            },
            d: function(count) {
                return "0?[1-9]|[12][0-9]|3[01]"
            },
            H: function(count) {
                return "0?[0-9]|1[0-9]|2[0-3]"
            },
            h: function(count) {
                return "0?[1-9]|1[012]"
            },
            m: function(count) {
                return "0?[0-9]|[1-5][0-9]"
            },
            s: function(count) {
                return "0?[0-9]|[1-5][0-9]"
            },
            S: function(count) {
                return "[0-9]{1," + count + "}"
            }
        };
        var parseNumber = Number;
        var caseInsensitiveIndexOf = function(array, value) {
            return array.map(function(item) {
                return item.toLowerCase()
            }).indexOf(value.toLowerCase())
        };
        var monthPatternParser = function(text, count, dateParts) {
            if (count > 2) {
                return ["format", "standalone"].map(function(type) {
                    return Object.keys(FORMAT_TYPES).map(function(count) {
                        var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);
                        return caseInsensitiveIndexOf(monthNames, text)
                    })
                }).reduce(function(a, b) {
                    return a.concat(b)
                }).filter(function(index) {
                    return index >= 0
                })[0]
            }
            return parseNumber(text) - 1
        };
        var PATTERN_PARSERS = {
            y: function(text, count) {
                var year = parseNumber(text);
                if (2 === count) {
                    return year < 30 ? 2e3 + year : 1900 + year
                }
                return year
            },
            M: monthPatternParser,
            L: monthPatternParser,
            Q: function(text, count, dateParts) {
                if (count > 2) {
                    return dateParts.getQuarterNames(FORMAT_TYPES[count], "format").indexOf(text)
                }
                return parseNumber(text) - 1
            },
            E: function(text, count, dateParts) {
                var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], "format");
                return caseInsensitiveIndexOf(dayNames, text)
            },
            a: function(text, count, dateParts) {
                var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], "format");
                return caseInsensitiveIndexOf(periodNames, text)
            },
            d: parseNumber,
            H: parseNumber,
            h: parseNumber,
            m: parseNumber,
            s: parseNumber,
            S: function(text, count) {
                count = Math.max(count, 3);
                text = text.slice(0, 3);
                while (count < 3) {
                    text += "0";
                    count++
                }
                return parseNumber(text)
            }
        };
        var ORDERED_PATTERNS = ["y", "M", "d", "h", "m", "s", "S"];
        var PATTERN_SETTERS = {
            y: "setFullYear",
            M: "setMonth",
            L: "setMonth",
            a: function(date, value, datePartValues) {
                var hours = date.getHours();
                var hourPartValue = datePartValues.h;
                if (void 0 !== hourPartValue && hourPartValue !== hours) {
                    hours--
                }
                if (!value && 12 === hours) {
                    hours = 0
                } else {
                    if (value && 12 !== hours) {
                        hours += 12
                    }
                }
                date.setHours(hours)
            },
            d: "setDate",
            H: "setHours",
            h: "setHours",
            m: "setMinutes",
            s: "setSeconds",
            S: "setMilliseconds"
        };
        var getSameCharCount = function(text, index) {
            var char = text[index];
            var count = 0;
            do {
                index++;
                count++
            } while (text[index] === char);
            return count
        };
        var createPattern = function(char, count) {
            var result = "";
            for (var i = 0; i < count; i++) {
                result += char
            }
            return result
        };
        var getRegExpInfo = function(format, dateParts) {
            var regexpText = "";
            var stubText = "";
            var isEscaping;
            var patterns = [];
            var addPreviousStub = function() {
                if (stubText) {
                    patterns.push("'" + stubText + "'");
                    regexpText += escapeRegExp(stubText) + ")";
                    stubText = ""
                }
            };
            for (var i = 0; i < format.length; i++) {
                var char = format[i];
                var isEscapeChar = "'" === char;
                var regexpPart = PATTERN_REGEXPS[char];
                if (isEscapeChar) {
                    isEscaping = !isEscaping;
                    if ("'" !== format[i - 1]) {
                        continue
                    }
                }
                if (regexpPart && !isEscaping) {
                    var count = getSameCharCount(format, i);
                    var pattern = createPattern(char, count);
                    addPreviousStub();
                    patterns.push(pattern);
                    regexpText += "(" + regexpPart(count, dateParts) + ")";
                    i += count - 1
                } else {
                    if (!stubText) {
                        regexpText += "("
                    }
                    stubText += char
                }
            }
            addPreviousStub();
            return {
                patterns: patterns,
                regexp: new RegExp("^" + regexpText + "$", "i")
            }
        };
        var getPatternSetters = function() {
            return PATTERN_SETTERS
        };
        var setPatternPart = function(date, pattern, text, dateParts, datePartValues) {
            var patternChar = pattern[0];
            var partSetter = PATTERN_SETTERS[patternChar];
            var partParser = PATTERN_PARSERS[patternChar];
            if (partSetter && partParser) {
                var value = partParser(text, pattern.length, dateParts);
                datePartValues[pattern] = value;
                if (date[partSetter]) {
                    date[partSetter](value)
                } else {
                    partSetter(date, value, datePartValues)
                }
            }
        };
        var setPatternPartFromNow = function(date, pattern, now) {
            var setterName = PATTERN_SETTERS[pattern];
            var getterName = "g" + setterName.substr(1);
            var value = now[getterName]();
            date[setterName](value)
        };
        var getShortPatterns = function(fullPatterns) {
            return fullPatterns.map(function(pattern) {
                if ("'" === pattern[0]) {
                    return ""
                } else {
                    return "H" === pattern[0] ? "h" : pattern[0]
                }
            })
        };
        var getMaxOrderedPatternIndex = function(patterns) {
            var indexes = patterns.map(function(pattern) {
                return ORDERED_PATTERNS.indexOf(pattern)
            });
            return Math.max.apply(Math, indexes)
        };
        var getOrderedFormatPatterns = function(formatPatterns) {
            var otherPatterns = formatPatterns.filter(function(pattern) {
                return ORDERED_PATTERNS.indexOf(pattern) < 0
            });
            return ORDERED_PATTERNS.concat(otherPatterns)
        };
        var getParser = function(format, dateParts) {
            var regExpInfo = getRegExpInfo(format, dateParts);
            return function(text) {
                var regExpResult = regExpInfo.regexp.exec(text);
                if (regExpResult) {
                    var now = new Date;
                    var date = new Date(now.getFullYear(), 0, 1);
                    var formatPatterns = getShortPatterns(regExpInfo.patterns);
                    var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
                    var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
                    var datePartValues = {};
                    orderedFormatPatterns.forEach(function(pattern, index) {
                        if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {
                            return
                        }
                        var patternIndex = formatPatterns.indexOf(pattern);
                        if (patternIndex >= 0) {
                            var regExpPattern = regExpInfo.patterns[patternIndex];
                            var regExpText = regExpResult[patternIndex + 1];
                            setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues)
                        } else {
                            setPatternPartFromNow(date, pattern, now)
                        }
                    });
                    return date
                }
                return null
            }
        };
        exports.getParser = getParser;
        exports.getRegExpInfo = getRegExpInfo;
        exports.getPatternSetters = getPatternSetters
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/ui/selection/selection.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var deferredStrategy = __webpack_require__( /*! ./selection.strategy.deferred */ 499);
        var standardStrategy = __webpack_require__( /*! ./selection.strategy.standard */ 500);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var Deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6).Deferred;
        module.exports = Class.inherit({
            ctor: function(options) {
                this.options = extend(this._getDefaultOptions(), options, {
                    selectedItemKeys: options.selectedKeys || []
                });
                this._selectionStrategy = this.options.deferred ? new deferredStrategy(this.options) : new standardStrategy(this.options);
                this._focusedItemIndex = -1;
                if (!this.options.equalByReference) {
                    this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys)
                }
            },
            _getDefaultOptions: function() {
                return {
                    allowNullValue: false,
                    deferred: false,
                    equalByReference: false,
                    mode: "multiple",
                    selectedItems: [],
                    selectionFilter: [],
                    maxFilterLengthInRequest: 0,
                    onSelectionChanged: noop,
                    key: noop,
                    keyOf: function(item) {
                        return item
                    },
                    load: function() {
                        return (new Deferred).resolve([])
                    },
                    totalCount: function() {
                        return -1
                    },
                    isSelectableItem: function() {
                        return true
                    },
                    isItemSelected: function() {
                        return false
                    },
                    getItemData: function(item) {
                        return item
                    },
                    dataFields: noop,
                    filter: noop
                }
            },
            validate: function() {
                this._selectionStrategy.validate()
            },
            getSelectedItemKeys: function() {
                return this._selectionStrategy.getSelectedItemKeys()
            },
            getSelectedItems: function() {
                return this._selectionStrategy.getSelectedItems()
            },
            selectionFilter: function(value) {
                if (void 0 === value) {
                    return this.options.selectionFilter
                }
                var filterIsChanged = this.options.selectionFilter !== value && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value);
                this.options.selectionFilter = value;
                filterIsChanged && this.onSelectionChanged()
            },
            setSelection: function(keys) {
                return this.selectedItemKeys(keys)
            },
            select: function(keys) {
                return this.selectedItemKeys(keys, true)
            },
            deselect: function(keys) {
                return this.selectedItemKeys(keys, true, true)
            },
            selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
                var that = this;
                keys = keys || [];
                keys = Array.isArray(keys) ? keys : [keys];
                that.validate();
                return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll)
            },
            clearSelection: function() {
                return this.selectedItemKeys([])
            },
            _addSelectedItem: function(itemData, key) {
                this._selectionStrategy.addSelectedItem(key, itemData)
            },
            _removeSelectedItem: function(key) {
                this._selectionStrategy.removeSelectedItem(key)
            },
            _setSelectedItems: function(keys, items) {
                this._selectionStrategy.setSelectedItems(keys, items)
            },
            onSelectionChanged: function() {
                this._selectionStrategy.onSelectionChanged()
            },
            changeItemSelection: function(itemIndex, keys) {
                var isSelectedItemsChanged;
                var items = this.options.plainItems();
                var item = items[itemIndex];
                if (!this.isSelectable() || !this.isDataItem(item)) {
                    return false
                }
                var itemData = this.options.getItemData(item);
                var itemKey = this.options.keyOf(itemData);
                keys = keys || {};
                if (keys.shift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
                    isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items)
                } else {
                    if (keys.control) {
                        this._resetItemSelectionWhenShiftKeyPressed();
                        var isSelected = this._selectionStrategy.isItemDataSelected(itemData);
                        if ("single" === this.options.mode) {
                            this.clearSelectedItems()
                        }
                        if (isSelected) {
                            this._removeSelectedItem(itemKey)
                        } else {
                            this._addSelectedItem(itemData, itemKey)
                        }
                        isSelectedItemsChanged = true
                    } else {
                        this._resetItemSelectionWhenShiftKeyPressed();
                        var isKeysEqual = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
                        if (1 !== this.options.selectedItemKeys.length || !isKeysEqual) {
                            this._setSelectedItems([itemKey], [itemData]);
                            isSelectedItemsChanged = true
                        }
                    }
                }
                if (isSelectedItemsChanged) {
                    this._focusedItemIndex = itemIndex;
                    this.onSelectionChanged();
                    return true
                }
            },
            isDataItem: function(item) {
                return this.options.isSelectableItem(item)
            },
            isSelectable: function() {
                return "single" === this.options.mode || "multiple" === this.options.mode
            },
            isItemDataSelected: function(data) {
                return this._selectionStrategy.isItemDataSelected(data)
            },
            isItemSelected: function(arg) {
                return this._selectionStrategy.isItemKeySelected(arg)
            },
            _resetItemSelectionWhenShiftKeyPressed: function() {
                delete this._shiftFocusedItemIndex
            },
            _resetFocusedItemIndex: function() {
                this._focusedItemIndex = -1
            },
            changeItemSelectionWhenShiftKeyPressed: function(itemIndex, items) {
                var isSelectedItemsChanged = false;
                var itemIndexStep;
                var index;
                var keyOf = this.options.keyOf;
                var focusedItem = items[this._focusedItemIndex];
                var focusedData = this.options.getItemData(focusedItem);
                var focusedKey = keyOf(focusedData);
                var isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
                if (!isDefined(this._shiftFocusedItemIndex)) {
                    this._shiftFocusedItemIndex = this._focusedItemIndex
                }
                var data;
                var itemKey;
                if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
                    itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
                    for (index = this._focusedItemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
                        if (this.isDataItem(items[index])) {
                            itemKey = keyOf(this.options.getItemData(items[index]));
                            this._removeSelectedItem(itemKey);
                            isSelectedItemsChanged = true
                        }
                    }
                }
                if (itemIndex !== this._shiftFocusedItemIndex) {
                    itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
                    for (index = itemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
                        if (this.isDataItem(items[index])) {
                            data = this.options.getItemData(items[index]);
                            itemKey = keyOf(data);
                            this._addSelectedItem(data, itemKey);
                            isSelectedItemsChanged = true
                        }
                    }
                }
                if (this.isDataItem(focusedItem) && !isFocusedItemSelected) {
                    this._addSelectedItem(focusedData, focusedKey);
                    isSelectedItemsChanged = true
                }
                return isSelectedItemsChanged
            },
            clearSelectedItems: function() {
                this._setSelectedItems([], [])
            },
            selectAll: function(isOnePage) {
                this._resetFocusedItemIndex();
                if (isOnePage) {
                    return this._onePageSelectAll(false)
                } else {
                    return this.selectedItemKeys([], true, false, true)
                }
            },
            deselectAll: function(isOnePage) {
                this._resetFocusedItemIndex();
                if (isOnePage) {
                    return this._onePageSelectAll(true)
                } else {
                    return this.selectedItemKeys([], true, true, true)
                }
            },
            _onePageSelectAll: function(isDeselect) {
                var items = this._selectionStrategy.getSelectableItems(this.options.plainItems());
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    if (this.isDataItem(item)) {
                        var itemData = this.options.getItemData(item);
                        var itemKey = this.options.keyOf(itemData);
                        var isSelected = this.isItemSelected(itemKey);
                        if (!isSelected && !isDeselect) {
                            this._addSelectedItem(itemData, itemKey)
                        }
                        if (isSelected && isDeselect) {
                            this._removeSelectedItem(itemKey)
                        }
                    }
                }
                this.onSelectionChanged();
                return (new Deferred).resolve()
            },
            getSelectAllState: function(visibleOnly) {
                return this._selectionStrategy.getSelectAllState(visibleOnly)
            }
        })
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/bundles/modules/parts/core.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var DevExpress = __webpack_require__( /*! ../../../bundles/modules/core */ 155);
        __webpack_require__( /*! ../../../integration/jquery */ 285);
        __webpack_require__( /*! ../../../integration/angular */ 492);
        __webpack_require__( /*! ../../../integration/knockout */ 504);
        __webpack_require__( /*! ../../../localization/globalize/core */ 136);
        __webpack_require__( /*! ../../../localization/globalize/message */ 513);
        __webpack_require__( /*! ../../../localization/globalize/number */ 192);
        __webpack_require__( /*! ../../../localization/globalize/date */ 514);
        __webpack_require__( /*! ../../../localization/globalize/currency */ 515);
        __webpack_require__( /*! ../../../events/click */ 19);
        __webpack_require__( /*! ../../../events/contextmenu */ 177);
        __webpack_require__( /*! ../../../events/double_click */ 137);
        __webpack_require__( /*! ../../../events/drag */ 69);
        __webpack_require__( /*! ../../../events/hold */ 95);
        __webpack_require__( /*! ../../../events/hover */ 156);
        __webpack_require__( /*! ../../../events/pointer */ 23);
        __webpack_require__( /*! ../../../events/swipe */ 183);
        __webpack_require__( /*! ../../../events/transform */ 303);
        module.exports = DevExpress
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/mobile/hide_top_overlay.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var inArray = __webpack_require__( /*! ../core/utils/array */ 14).inArray;
        var hideCallback = function() {
            var callbacks = [];
            return {
                add: function(callback) {
                    var indexOfCallback = inArray(callback, callbacks);
                    if (indexOfCallback === -1) {
                        callbacks.push(callback)
                    }
                },
                remove: function(callback) {
                    var indexOfCallback = inArray(callback, callbacks);
                    if (indexOfCallback !== -1) {
                        callbacks.splice(indexOfCallback, 1)
                    }
                },
                fire: function() {
                    var callback = callbacks.pop();
                    var result = !!callback;
                    if (result) {
                        callback()
                    }
                    return result
                },
                hasCallback: function() {
                    return callbacks.length > 0
                },
                reset: function() {
                    callbacks = []
                }
            }
        }();
        module.exports = function() {
            return hideCallback.fire()
        };
        module.exports.hideCallback = hideCallback
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
    /*!********************************************!*\
      !*** ./artifacts/transpiled/viz/export.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./core/export */ 99)
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/base_chart.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _utils = __webpack_require__( /*! ../../events/utils */ 8);
        var _base_widget = __webpack_require__( /*! ../core/base_widget */ 102);
        var _base_widget2 = _interopRequireDefault(_base_widget);
        var _legend = __webpack_require__( /*! ../components/legend */ 207);
        var _legend2 = _interopRequireDefault(_legend);
        var _data_validator = __webpack_require__( /*! ../components/data_validator */ 259);
        var _data_validator2 = _interopRequireDefault(_data_validator);
        var _base_series = __webpack_require__( /*! ../series/base_series */ 261);
        var _base_series2 = _interopRequireDefault(_base_series);
        var _chart_theme_manager = __webpack_require__( /*! ../components/chart_theme_manager */ 420);
        var _chart_theme_manager2 = _interopRequireDefault(_chart_theme_manager);
        var _layout_manager = __webpack_require__( /*! ./layout_manager */ 421);
        var _layout_manager2 = _interopRequireDefault(_layout_manager);
        var _tracker = __webpack_require__( /*! ./tracker */ 827);
        var _tracker2 = _interopRequireDefault(_tracker);
        var _utils2 = __webpack_require__( /*! ../core/utils */ 13);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _isArray = Array.isArray;
        var REINIT_REFRESH_ACTION = "_reinit";
        var REINIT_DATA_SOURCE_REFRESH_ACTION = "_updateDataSource";
        var DATA_INIT_REFRESH_ACTION = "_dataInit";
        var FORCE_RENDER_REFRESH_ACTION = "_forceRender";
        var RESIZE_REFRESH_ACTION = "_resize";
        var ACTIONS_BY_PRIORITY = [REINIT_REFRESH_ACTION, REINIT_DATA_SOURCE_REFRESH_ACTION, DATA_INIT_REFRESH_ACTION, FORCE_RENDER_REFRESH_ACTION, RESIZE_REFRESH_ACTION];
        var DEFAULT_OPACITY = .3;
        var REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS = ["series", "commonSeriesSettings", "dataPrepareSettings", "seriesSelectionMode", "pointSelectionMode", "synchronizeMultiAxes", "resolveLabelsOverlapping"];
        var REFRESH_SERIES_FAMILIES_ACTION_OPTIONS = ["equalBarWidth", "minBubbleSize", "maxBubbleSize", "barWidth", "barGroupPadding", "barGroupWidth", "negativesAsZeroes", "negativesAsZeros"];
        var FORCE_RENDER_REFRESH_ACTION_OPTIONS = ["adaptiveLayout", "crosshair", "resolveLabelOverlapping", "adjustOnZoom", "zoomingMode", "scrollingMode", "stickyHovering"];
        var FONT = "font";

        function checkHeightRollingStock(rollingStocks, stubCanvas) {
            var canvasSize = stubCanvas.end - stubCanvas.start;
            var size = 0;
            rollingStocks.forEach(function(rollingStock) {
                size += rollingStock.getBoundingRect().width
            });
            while (canvasSize < size) {
                size -= findAndKillSmallValue(rollingStocks)
            }
        }

        function findAndKillSmallValue(rollingStocks) {
            var smallestObject = rollingStocks.reduce(function(prev, rollingStock, index) {
                if (!rollingStock) {
                    return prev
                }
                var value = rollingStock.value();
                return value < prev.value ? {
                    value: value,
                    rollingStock: rollingStock,
                    index: index
                } : prev
            }, {
                rollingStock: void 0,
                value: 1 / 0,
                index: void 0
            });
            smallestObject.rollingStock.getLabels()[0].draw(false);
            var width = smallestObject.rollingStock.getBoundingRect().width;
            rollingStocks[smallestObject.index] = null;
            return width
        }

        function checkStackOverlap(rollingStocks) {
            var i;
            var j;
            var iLength;
            var jLength;
            var overlap = false;
            for (i = 0, iLength = rollingStocks.length - 1; i < iLength; i++) {
                for (j = i + 1, jLength = rollingStocks.length; j < jLength; j++) {
                    if (i !== j && checkStacksOverlapping(rollingStocks[i], rollingStocks[j], true)) {
                        overlap = true;
                        break
                    }
                }
                if (overlap) {
                    break
                }
            }
            return overlap
        }

        function resolveLabelOverlappingInOneDirection(points, canvas, isRotated, shiftFunction) {
            var customSorting = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : function() {
                return 0
            };
            var rollingStocks = [];
            var stubCanvas = {
                start: isRotated ? canvas.left : canvas.top,
                end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom
            };
            var hasStackedSeries = false;
            points.forEach(function(p) {
                if (!p) {
                    return
                }
                hasStackedSeries = hasStackedSeries || p.series.isStackedSeries() || p.series.isFullStackedSeries();
                p.getLabels().forEach(function(l) {
                    l.isVisible() && rollingStocks.push(new RollingStock(l, isRotated, shiftFunction))
                })
            });
            if (hasStackedSeries) {
                !isRotated && rollingStocks.reverse()
            } else {
                var rollingStocksTmp = rollingStocks.slice();
                rollingStocks.sort(function(a, b) {
                    return customSorting(a, b) || a.getInitialPosition() - b.getInitialPosition() || rollingStocksTmp.indexOf(a) - rollingStocksTmp.indexOf(b)
                })
            }
            if (!checkStackOverlap(rollingStocks)) {
                return false
            }
            checkHeightRollingStock(rollingStocks, stubCanvas);
            prepareOverlapStacks(rollingStocks);
            rollingStocks.reverse();
            moveRollingStock(rollingStocks, stubCanvas);
            return true
        }

        function checkStacksOverlapping(firstRolling, secondRolling, inTwoSides) {
            if (!firstRolling || !secondRolling) {
                return
            }
            var firstRect = firstRolling.getBoundingRect();
            var secondRect = secondRolling.getBoundingRect();
            var oppositeOverlapping = inTwoSides ? firstRect.oppositeStart <= secondRect.oppositeStart && firstRect.oppositeEnd > secondRect.oppositeStart || secondRect.oppositeStart <= firstRect.oppositeStart && secondRect.oppositeEnd > firstRect.oppositeStart : true;
            return firstRect.end > secondRect.start && oppositeOverlapping
        }

        function prepareOverlapStacks(rollingStocks) {
            var i;
            var currentRollingStock;
            var root;
            for (i = 0; i < rollingStocks.length - 1; i++) {
                currentRollingStock = root || rollingStocks[i];
                if (checkStacksOverlapping(currentRollingStock, rollingStocks[i + 1])) {
                    currentRollingStock.toChain(rollingStocks[i + 1]);
                    rollingStocks[i + 1] = null;
                    root = currentRollingStock
                } else {
                    root = rollingStocks[i + 1] || currentRollingStock
                }
            }
        }

        function moveRollingStock(rollingStocks, canvas) {
            var i;
            var j;
            var currentRollingStock;
            var nextRollingStock;
            var currentBBox;
            var nextBBox;
            for (i = 0; i < rollingStocks.length; i++) {
                currentRollingStock = rollingStocks[i];
                if (rollingStocksIsOut(currentRollingStock, canvas)) {
                    currentBBox = currentRollingStock.getBoundingRect();
                    for (j = i + 1; j < rollingStocks.length; j++) {
                        nextRollingStock = rollingStocks[j];
                        if (!nextRollingStock) {
                            continue
                        }
                        nextBBox = nextRollingStock.getBoundingRect();
                        if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {
                            nextRollingStock.toChain(currentRollingStock);
                            rollingStocks[i] = currentRollingStock = null;
                            break
                        }
                    }
                }
                currentRollingStock && currentRollingStock.setRollingStockInCanvas(canvas)
            }
        }

        function rollingStocksIsOut(rollingStock, canvas) {
            return rollingStock && rollingStock.getBoundingRect().end > canvas.end
        }

        function RollingStock(label, isRotated, shiftFunction) {
            var bBox = label.getBoundingRect();
            var x = bBox.x;
            var y = bBox.y;
            var endX = bBox.x + bBox.width;
            var endY = bBox.y + bBox.height;
            this.labels = [label];
            this.shiftFunction = shiftFunction;
            this._bBox = {
                start: isRotated ? x : y,
                width: isRotated ? bBox.width : bBox.height,
                end: isRotated ? endX : endY,
                oppositeStart: isRotated ? y : x,
                oppositeEnd: isRotated ? endY : endX
            };
            this._initialPosition = isRotated ? bBox.x : bBox.y;
            return this
        }
        RollingStock.prototype = {
            toChain: function(nextRollingStock) {
                var nextRollingStockBBox = nextRollingStock.getBoundingRect();
                nextRollingStock.shift(nextRollingStockBBox.start - this._bBox.end);
                this._changeBoxWidth(nextRollingStockBBox.width);
                this.labels = this.labels.concat(nextRollingStock.labels)
            },
            getBoundingRect: function() {
                return this._bBox
            },
            shift: function(shiftLength) {
                var shiftFunction = this.shiftFunction;
                (0, _iterator.each)(this.labels, function(index, label) {
                    var bBox = label.getBoundingRect();
                    var coords = shiftFunction(bBox, shiftLength);
                    if (!label.hideInsideLabel(coords)) {
                        label.shift(coords.x, coords.y)
                    }
                });
                this._bBox.end -= shiftLength;
                this._bBox.start -= shiftLength
            },
            setRollingStockInCanvas: function(canvas) {
                if (this._bBox.end > canvas.end) {
                    this.shift(this._bBox.end - canvas.end)
                }
            },
            getLabels: function() {
                return this.labels
            },
            value: function() {
                return this.labels[0].getData().value
            },
            getInitialPosition: function() {
                return this._initialPosition
            },
            _changeBoxWidth: function(width) {
                this._bBox.end += width;
                this._bBox.width += width
            }
        };

        function getLegendFields(name) {
            return {
                nameField: name + "Name",
                colorField: name + "Color",
                indexField: name + "Index"
            }
        }

        function getLegendSettings(legendDataField) {
            var formatObjectFields = getLegendFields(legendDataField);
            return {
                getFormatObject: function(data) {
                    var res = {};
                    res[formatObjectFields.indexField] = data.id;
                    res[formatObjectFields.colorField] = data.states.normal.fill;
                    res[formatObjectFields.nameField] = data.text;
                    return res
                },
                textField: formatObjectFields.nameField
            }
        }

        function checkOverlapping(firstRect, secondRect) {
            return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height)
        }
        var overlapping = {
            resolveLabelOverlappingInOneDirection: resolveLabelOverlappingInOneDirection
        };
        var BaseChart = _base_widget2.default.inherit({
            _eventsMap: {
                onSeriesClick: {
                    name: "seriesClick"
                },
                onPointClick: {
                    name: "pointClick"
                },
                onArgumentAxisClick: {
                    name: "argumentAxisClick"
                },
                onLegendClick: {
                    name: "legendClick"
                },
                onSeriesSelectionChanged: {
                    name: "seriesSelectionChanged"
                },
                onPointSelectionChanged: {
                    name: "pointSelectionChanged"
                },
                onSeriesHoverChanged: {
                    name: "seriesHoverChanged"
                },
                onPointHoverChanged: {
                    name: "pointHoverChanged"
                },
                onDone: {
                    name: "done"
                },
                onZoomStart: {
                    name: "zoomStart"
                },
                onZoomEnd: {
                    name: "zoomEnd"
                }
            },
            _fontFields: ["legend." + FONT, "legend.title." + FONT, "legend.title.subtitle." + FONT, "commonSeriesSettings.label." + FONT],
            _rootClassPrefix: "dxc",
            _rootClass: "dxc-chart",
            _initialChanges: ["INIT"],
            _themeDependentChanges: ["REFRESH_SERIES_REINIT"],
            _getThemeManagerOptions: function() {
                var themeOptions = this.callBase.apply(this, arguments);
                themeOptions.options = this.option();
                return themeOptions
            },
            _createThemeManager: function() {
                var chartOption = this.option();
                var themeManager = new _chart_theme_manager2.default.ThemeManager(this._getThemeManagerOptions());
                themeManager.setTheme(chartOption.theme, chartOption.rtlEnabled);
                return themeManager
            },
            _initCore: function() {
                var that = this;
                that._canvasClipRect = that._renderer.clipRect();
                that._createHtmlStructure();
                that._createLegend();
                that._createTracker();
                that._needHandleRenderComplete = true;
                that.layoutManager = new _layout_manager2.default.LayoutManager;
                that._createScrollBar();
                _events_engine2.default.on(that._$element, "contextmenu", function(event) {
                    that.eventType = "contextmenu";
                    if ((0, _utils.isTouchEvent)(event) || (0, _utils.isPointerEvent)(event)) {
                        event.preventDefault()
                    }
                });
                _events_engine2.default.on(that._$element, "MSHoldVisual", function(event) {
                    that.eventType = "MSHoldVisual";
                    event.preventDefault()
                })
            },
            _getLayoutItems: _common.noop,
            _layoutManagerOptions: function() {
                return this._themeManager.getOptions("adaptiveLayout")
            },
            _reinit: function() {
                var that = this;
                (0, _utils2.setCanvasValues)(that._canvas);
                that._reinitAxes();
                that._requestChange(["DATA_SOURCE", "DATA_INIT", "CORRECT_AXIS", "FULL_RENDER"])
            },
            _correctAxes: _common.noop,
            _createHtmlStructure: function() {
                var that = this;
                var renderer = that._renderer;
                var root = renderer.root;
                var createConstantLinesGroup = function() {
                    return renderer.g().attr({
                        "class": "dxc-constant-lines-group"
                    }).linkOn(root, "constant-lines")
                };
                that._constantLinesGroup = {
                    dispose: function() {
                        this.under.dispose();
                        this.above.dispose()
                    },
                    linkOff: function() {
                        this.under.linkOff();
                        this.above.linkOff()
                    },
                    clear: function() {
                        this.under.linkRemove().clear();
                        this.above.linkRemove().clear()
                    },
                    linkAppend: function() {
                        this.under.linkAppend();
                        this.above.linkAppend()
                    }
                };
                that._backgroundRect = renderer.rect().attr({
                    fill: "gray",
                    opacity: 1e-4
                }).append(root);
                that._panesBackgroundGroup = renderer.g().attr({
                    "class": "dxc-background"
                }).append(root);
                that._stripsGroup = renderer.g().attr({
                    "class": "dxc-strips-group"
                }).linkOn(root, "strips");
                that._gridGroup = renderer.g().attr({
                    "class": "dxc-grids-group"
                }).linkOn(root, "grids");
                that._panesBorderGroup = renderer.g().attr({
                    "class": "dxc-border"
                }).linkOn(root, "border");
                that._axesGroup = renderer.g().attr({
                    "class": "dxc-axes-group"
                }).linkOn(root, "axes");
                that._labelAxesGroup = renderer.g().attr({
                    "class": "dxc-strips-labels-group"
                }).linkOn(root, "strips-labels");
                that._constantLinesGroup.under = createConstantLinesGroup();
                that._seriesGroup = renderer.g().attr({
                    "class": "dxc-series-group"
                }).linkOn(root, "series");
                that._constantLinesGroup.above = createConstantLinesGroup();
                that._scaleBreaksGroup = renderer.g().attr({
                    "class": "dxc-scale-breaks"
                }).linkOn(root, "scale-breaks");
                that._labelsGroup = renderer.g().attr({
                    "class": "dxc-labels-group"
                }).linkOn(root, "labels");
                that._crosshairCursorGroup = renderer.g().attr({
                    "class": "dxc-crosshair-cursor"
                }).linkOn(root, "crosshair");
                that._legendGroup = renderer.g().attr({
                    "class": "dxc-legend",
                    "clip-path": that._getCanvasClipRectID()
                }).linkOn(root, "legend").linkAppend(root).enableLinks();
                that._scrollBarGroup = renderer.g().attr({
                    "class": "dxc-scroll-bar"
                }).linkOn(root, "scroll-bar")
            },
            _disposeObjectsInArray: function(propName, fieldNames) {
                (0, _iterator.each)(this[propName] || [], function(_, item) {
                    if (fieldNames && item) {
                        (0, _iterator.each)(fieldNames, function(_, field) {
                            item[field] && item[field].dispose()
                        })
                    } else {
                        item && item.dispose()
                    }
                });
                this[propName] = null
            },
            _disposeCore: function() {
                var that = this;
                var disposeObject = function(propName) {
                    if (that[propName]) {
                        that[propName].dispose();
                        that[propName] = null
                    }
                };
                var unlinkGroup = function(name) {
                    that[name].linkOff()
                };
                var disposeObjectsInArray = this._disposeObjectsInArray;
                that._renderer.stopAllAnimations();
                disposeObjectsInArray.call(that, "series");
                disposeObject("_tracker");
                disposeObject("_crosshair");
                that.layoutManager = that._userOptions = that._canvas = that._groupsData = null;
                unlinkGroup("_stripsGroup");
                unlinkGroup("_gridGroup");
                unlinkGroup("_axesGroup");
                unlinkGroup("_constantLinesGroup");
                unlinkGroup("_labelAxesGroup");
                unlinkGroup("_panesBorderGroup");
                unlinkGroup("_seriesGroup");
                unlinkGroup("_labelsGroup");
                unlinkGroup("_crosshairCursorGroup");
                unlinkGroup("_legendGroup");
                unlinkGroup("_scrollBarGroup");
                unlinkGroup("_scaleBreaksGroup");
                disposeObject("_canvasClipRect");
                disposeObject("_panesBackgroundGroup");
                disposeObject("_backgroundRect");
                disposeObject("_stripsGroup");
                disposeObject("_gridGroup");
                disposeObject("_axesGroup");
                disposeObject("_constantLinesGroup");
                disposeObject("_labelAxesGroup");
                disposeObject("_panesBorderGroup");
                disposeObject("_seriesGroup");
                disposeObject("_labelsGroup");
                disposeObject("_crosshairCursorGroup");
                disposeObject("_legendGroup");
                disposeObject("_scrollBarGroup");
                disposeObject("_scaleBreaksGroup")
            },
            _getAnimationOptions: function() {
                return this._themeManager.getOptions("animation")
            },
            _getDefaultSize: function() {
                return {
                    width: 400,
                    height: 400
                }
            },
            _getOption: function(name) {
                return this._themeManager.getOptions(name)
            },
            _applySize: function(rect) {
                this._rect = rect.slice();
                if (!this._changes.has("FULL_RENDER")) {
                    this._processRefreshData(RESIZE_REFRESH_ACTION)
                }
            },
            _resize: function() {
                this._doRender(this.__renderOptions || {
                    animate: false,
                    isResize: true
                })
            },
            _trackerType: "ChartTracker",
            _createTracker: function() {
                var that = this;
                that._tracker = new _tracker2.default[that._trackerType]({
                    seriesGroup: that._seriesGroup,
                    renderer: that._renderer,
                    tooltip: that._tooltip,
                    legend: that._legend,
                    eventTrigger: that._eventTrigger
                })
            },
            _getTrackerSettings: function() {
                return (0, _extend.extend)({
                    chart: this
                }, this._getSelectionModes())
            },
            _getSelectionModes: function() {
                var themeManager = this._themeManager;
                return {
                    seriesSelectionMode: themeManager.getOptions("seriesSelectionMode"),
                    pointSelectionMode: themeManager.getOptions("pointSelectionMode")
                }
            },
            _updateTracker: function(trackerCanvases) {
                var that = this;
                that._tracker.update(that._getTrackerSettings());
                that._tracker.setCanvases({
                    left: 0,
                    right: that._canvas.width,
                    top: 0,
                    bottom: that._canvas.height
                }, trackerCanvases)
            },
            _createCanvasFromRect: function(rect) {
                var currentCanvas = this._canvas;
                return (0, _utils2.setCanvasValues)({
                    left: rect[0],
                    top: rect[1],
                    right: currentCanvas.width - rect[2],
                    bottom: currentCanvas.height - rect[3],
                    width: currentCanvas.width,
                    height: currentCanvas.height
                })
            },
            _doRender: function(_options) {
                var that = this;
                if (0 === that._canvas.width && 0 === that._canvas.height) {
                    return
                }
                that._resetIsReady();
                var drawOptions = that._prepareDrawOptions(_options);
                var recreateCanvas = drawOptions.recreateCanvas;
                that._preserveOriginalCanvas();
                if (recreateCanvas) {
                    that.__currentCanvas = that._canvas
                } else {
                    that._canvas = that.__currentCanvas
                }
                that.DEBUG_canvas = (0, _utils2.setCanvasValues)(that._canvas);
                recreateCanvas && that._updateCanvasClipRect(that._canvas);
                this._canvas = this._createCanvasFromRect(this._rect);
                that._renderer.stopAllAnimations(true);
                that._cleanGroups();
                var startTime = new Date;
                that._renderElements(drawOptions);
                that._lastRenderingTime = new Date - startTime
            },
            _preserveOriginalCanvas: function() {
                this.__originalCanvas = this._canvas;
                this._canvas = (0, _extend.extend)({}, this._canvas)
            },
            _layoutAxes: _common.noop,
            _renderElements: function(drawOptions) {
                var that = this;
                var preparedOptions = that._prepareToRender(drawOptions);
                var isRotated = that._isRotated();
                var isLegendInside = that._isLegendInside();
                var trackerCanvases = [];
                var dirtyCanvas = (0, _extend.extend)({}, that._canvas);
                var argBusinessRange;
                var zoomMinArg;
                var zoomMaxArg;
                that.DEBUG_dirtyCanvas = dirtyCanvas;
                that._renderer.lock();
                if (drawOptions.drawLegend && that._legend) {
                    that._legendGroup.linkAppend()
                }
                that.layoutManager.setOptions(that._layoutManagerOptions());
                var layoutTargets = that._getLayoutTargets();
                this._layoutAxes(function(needSpace) {
                    var axisDrawOptions = needSpace ? (0, _extend.extend)({}, drawOptions, {
                        animate: false
                    }) : drawOptions;
                    var canvas = that._renderAxes(axisDrawOptions, preparedOptions);
                    that._shrinkAxes(needSpace, canvas)
                });
                that._applyClipRects(preparedOptions);
                that._appendSeriesGroups();
                that._createCrosshairCursor();
                layoutTargets.forEach(function(_ref) {
                    var canvas = _ref.canvas;
                    trackerCanvases.push({
                        left: canvas.left,
                        right: canvas.width - canvas.right,
                        top: canvas.top,
                        bottom: canvas.height - canvas.bottom
                    })
                });
                if (that._scrollBar) {
                    argBusinessRange = that._argumentAxes[0].getTranslator().getBusinessRange();
                    if ("discrete" === argBusinessRange.axisType && argBusinessRange.categories && argBusinessRange.categories.length <= 1 || "discrete" !== argBusinessRange.axisType && argBusinessRange.min === argBusinessRange.max) {
                        zoomMinArg = zoomMaxArg = void 0
                    } else {
                        zoomMinArg = argBusinessRange.minVisible;
                        zoomMaxArg = argBusinessRange.maxVisible
                    }
                    that._scrollBar.init(argBusinessRange, !that._argumentAxes[0].getOptions().valueMarginsEnabled).setPosition(zoomMinArg, zoomMaxArg)
                }
                that._updateTracker(trackerCanvases);
                that._updateLegendPosition(drawOptions, isLegendInside);
                that._applyPointMarkersAutoHiding();
                that._renderSeries(drawOptions, isRotated, isLegendInside);
                that._renderer.unlock()
            },
            _createCrosshairCursor: _common.noop,
            _appendSeriesGroups: function() {
                this._seriesGroup.linkAppend();
                this._labelsGroup.linkAppend();
                this._appendAdditionalSeriesGroups()
            },
            _renderSeries: function(drawOptions, isRotated, isLegendInside) {
                this._calculateSeriesLayout(drawOptions, isRotated);
                this._renderSeriesElements(drawOptions, isLegendInside)
            },
            _calculateSeriesLayout: function(drawOptions, isRotated) {
                drawOptions.hideLayoutLabels = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), isRotated) && !this._themeManager.getOptions("adaptiveLayout").keepLabels;
                this._updateSeriesDimensions(drawOptions)
            },
            _getArgFilter: function() {
                return function() {
                    return true
                }
            },
            _getValFilter: function(series) {
                return function() {
                    return true
                }
            },
            _getPointsToAnimation: function(series) {
                var _this = this;
                var argViewPortFilter = this._getArgFilter();
                return series.map(function(s) {
                    var valViewPortFilter = _this._getValFilter(s);
                    return s.getPoints().filter(function(p) {
                        return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)))
                    }).length
                })
            },
            _renderSeriesElements: function(drawOptions, isLegendInside) {
                var that = this;
                var i;
                var series = that.series;
                var singleSeries;
                var seriesLength = series.length;
                var resolveLabelOverlapping = that._themeManager.getOptions("resolveLabelOverlapping");
                var pointsToAnimation = that._getPointsToAnimation(series);
                for (i = 0; i < seriesLength; i++) {
                    singleSeries = series[i];
                    that._applyExtraSettings(singleSeries, drawOptions);
                    singleSeries.draw(drawOptions.animate && pointsToAnimation[i] <= drawOptions.animationPointsLimit && that._renderer.animationEnabled(), drawOptions.hideLayoutLabels, that._getLegendCallBack(singleSeries))
                }
                if ("none" === resolveLabelOverlapping) {
                    that._adjustSeriesLabels(false)
                } else {
                    that._locateLabels(resolveLabelOverlapping)
                }
                that._renderTrackers(isLegendInside);
                that._tracker.repairTooltip();
                that._clearCanvas();
                that._renderExtraElements();
                that._drawn();
                that._renderCompleteHandler()
            },
            _locateLabels: function(resolveLabelOverlapping) {
                this._resolveLabelOverlapping(resolveLabelOverlapping)
            },
            _renderExtraElements: function() {},
            _clearCanvas: function() {
                this._canvas = this.__originalCanvas
            },
            _resolveLabelOverlapping: function(resolveLabelOverlapping) {
                var func;
                switch (resolveLabelOverlapping) {
                    case "stack":
                        func = this._resolveLabelOverlappingStack;
                        break;
                    case "hide":
                        func = this._resolveLabelOverlappingHide;
                        break;
                    case "shift":
                        func = this._resolveLabelOverlappingShift
                }
                return (0, _type.isFunction)(func) && func.call(this)
            },
            _getVisibleSeries: function() {
                return (0, _common.grep)(this.getAllSeries(), function(series) {
                    return series.isVisible()
                })
            },
            _resolveLabelOverlappingHide: function() {
                var labels = [];
                var currentLabel;
                var nextLabel;
                var currentLabelRect;
                var nextLabelRect;
                var i;
                var j;
                var points;
                var series = this._getVisibleSeries();
                for (i = 0; i < series.length; i++) {
                    points = series[i].getVisiblePoints();
                    for (j = 0; j < points.length; j++) {
                        labels.push.apply(labels, points[j].getLabels())
                    }
                }
                for (i = 0; i < labels.length; i++) {
                    currentLabel = labels[i];
                    if (!currentLabel.isVisible()) {
                        continue
                    }
                    currentLabelRect = currentLabel.getBoundingRect();
                    for (j = i + 1; j < labels.length; j++) {
                        nextLabel = labels[j];
                        nextLabelRect = nextLabel.getBoundingRect();
                        if (checkOverlapping(currentLabelRect, nextLabelRect)) {
                            nextLabel.draw(false)
                        }
                    }
                }
            },
            _cleanGroups: function() {
                var that = this;
                that._stripsGroup.linkRemove().clear();
                that._gridGroup.linkRemove().clear();
                that._axesGroup.linkRemove().clear();
                that._constantLinesGroup.above.clear();
                that._labelAxesGroup.linkRemove().clear();
                that._labelsGroup.linkRemove().clear();
                that._crosshairCursorGroup.linkRemove().clear();
                that._scaleBreaksGroup.linkRemove().clear()
            },
            _allowLegendInsidePosition: function() {
                return false
            },
            _updateLegendPosition: _common.noop,
            _createLegend: function() {
                var that = this;
                var legendSettings = getLegendSettings(that._legendDataField);
                that._legend = new _legend2.default.Legend({
                    renderer: that._renderer,
                    widget: that,
                    group: that._legendGroup,
                    backgroundClass: "dxc-border",
                    itemGroupClass: "dxc-item",
                    titleGroupClass: "dxc-title",
                    textField: legendSettings.textField,
                    getFormatObject: legendSettings.getFormatObject,
                    allowInsidePosition: that._allowLegendInsidePosition()
                });
                that._updateLegend();
                that._layout.add(that._legend)
            },
            _updateLegend: function() {
                var that = this;
                var themeManager = that._themeManager;
                var legendOptions = themeManager.getOptions("legend");
                var legendData = that._getLegendData();
                legendOptions.containerBackgroundColor = themeManager.getOptions("containerBackgroundColor");
                legendOptions._incidentOccurred = that._incidentOccurred;
                that._legend.update(legendData, legendOptions, themeManager.theme("legend").title);
                this._change(["LAYOUT"])
            },
            _prepareDrawOptions: function(drawOptions) {
                var animationOptions = this._getAnimationOptions();
                var options = (0, _extend.extend)({}, {
                    force: false,
                    adjustAxes: true,
                    drawLegend: true,
                    drawTitle: true,
                    animate: animationOptions.enabled,
                    animationPointsLimit: animationOptions.maxPointCountSupported
                }, drawOptions, this.__renderOptions);
                if (!(0, _type.isDefined)(options.recreateCanvas)) {
                    options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle
                }
                return options
            },
            _processRefreshData: function(newRefreshAction) {
                var currentRefreshActionPosition = (0, _array.inArray)(this._currentRefreshData, ACTIONS_BY_PRIORITY);
                var newRefreshActionPosition = (0, _array.inArray)(newRefreshAction, ACTIONS_BY_PRIORITY);
                if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition) {
                    this._currentRefreshData = newRefreshAction
                }
                this._requestChange(["REFRESH"])
            },
            _getLegendData: function() {
                return (0, _utils2.map)(this._getLegendTargets(), function(item) {
                    var legendData = item.legendData;
                    var style = item.getLegendStyles;
                    var opacity = style.normal.opacity;
                    if (!item.visible) {
                        if (!(0, _type.isDefined)(opacity) || opacity > DEFAULT_OPACITY) {
                            opacity = DEFAULT_OPACITY
                        }
                        legendData.textOpacity = DEFAULT_OPACITY
                    }
                    var opacityStyle = {
                        opacity: opacity
                    };
                    legendData.states = {
                        hover: (0, _extend.extend)({}, style.hover, opacityStyle),
                        selection: (0, _extend.extend)({}, style.selection, opacityStyle),
                        normal: (0, _extend.extend)({}, style.normal, opacityStyle)
                    };
                    return legendData
                })
            },
            _getLegendOptions: function(item) {
                return {
                    legendData: {
                        text: item[this._legendItemTextField],
                        id: item.index,
                        visible: true
                    },
                    getLegendStyles: item.getLegendStyles(),
                    visible: item.isVisible()
                }
            },
            _disposeSeries: function(seriesIndex) {
                var _that$series;
                var that = this;
                if (that.series) {
                    if ((0, _type.isDefined)(seriesIndex)) {
                        that.series[seriesIndex].dispose();
                        that.series.splice(seriesIndex, 1)
                    } else {
                        (0, _iterator.each)(that.series, function(_, s) {
                            return s.dispose()
                        });
                        that.series.length = 0
                    }
                }
                if (!(null === (_that$series = that.series) || void 0 === _that$series ? void 0 : _that$series.length)) {
                    that.series = []
                }
            },
            _disposeSeriesFamilies: function() {
                var that = this;
                (0, _iterator.each)(that.seriesFamilies || [], function(_, family) {
                    family.dispose()
                });
                that.seriesFamilies = null;
                that._needHandleRenderComplete = true
            },
            _optionChanged: function(arg) {
                this._themeManager.resetOptions(arg.name);
                this.callBase.apply(this, arguments)
            },
            _applyChanges: function() {
                var that = this;
                that._themeManager.update(that._options.silent());
                that.callBase.apply(that, arguments)
            },
            _optionChangesMap: {
                animation: "ANIMATION",
                dataSource: "DATA_SOURCE",
                palette: "PALETTE",
                paletteExtensionMode: "PALETTE",
                legend: "FORCE_DATA_INIT",
                seriesTemplate: "FORCE_DATA_INIT",
                "export": "FORCE_RENDER",
                valueAxis: "AXES_AND_PANES",
                argumentAxis: "AXES_AND_PANES",
                commonAxisSettings: "AXES_AND_PANES",
                panes: "AXES_AND_PANES",
                defaultPane: "AXES_AND_PANES",
                useAggregation: "AXES_AND_PANES",
                containerBackgroundColor: "AXES_AND_PANES",
                rotated: "ROTATED",
                autoHidePointMarkers: "REFRESH_SERIES_REINIT",
                customizePoint: "REFRESH_SERIES_REINIT",
                customizeLabel: "REFRESH_SERIES_REINIT",
                scrollBar: "SCROLL_BAR"
            },
            _optionChangesOrder: ["ROTATED", "PALETTE", "REFRESH_SERIES_REINIT", "AXES_AND_PANES", "INIT", "REINIT", "DATA_SOURCE", "REFRESH_SERIES_DATA_INIT", "DATA_INIT", "FORCE_DATA_INIT", "REFRESH_AXES", "CORRECT_AXIS"],
            _customChangesOrder: ["ANIMATION", "REFRESH_SERIES_FAMILIES", "FORCE_RENDER", "VISUAL_RANGE", "SCROLL_BAR", "REINIT", "REFRESH", "FULL_RENDER"],
            _change_ANIMATION: function() {
                this._renderer.updateAnimationOptions(this._getAnimationOptions())
            },
            _change_DATA_SOURCE: function() {
                this._needHandleRenderComplete = true;
                this._updateDataSource()
            },
            _change_PALETTE: function() {
                this._themeManager.updatePalette();
                this._refreshSeries("DATA_INIT")
            },
            _change_REFRESH_SERIES_DATA_INIT: function() {
                this._refreshSeries("DATA_INIT")
            },
            _change_DATA_INIT: function() {
                if ((!this.series || this.needToPopulateSeries) && !this._changes.has("FORCE_DATA_INIT")) {
                    this._dataInit()
                }
            },
            _change_FORCE_DATA_INIT: function() {
                this._dataInit()
            },
            _change_REFRESH_SERIES_FAMILIES: function() {
                this._processSeriesFamilies();
                this._populateBusinessRange();
                this._processRefreshData(FORCE_RENDER_REFRESH_ACTION)
            },
            _change_FORCE_RENDER: function() {
                this._processRefreshData(FORCE_RENDER_REFRESH_ACTION)
            },
            _change_AXES_AND_PANES: function() {
                this._refreshSeries("INIT")
            },
            _change_ROTATED: function() {
                this._createScrollBar();
                this._refreshSeries("INIT")
            },
            _change_REFRESH_SERIES_REINIT: function() {
                this._refreshSeries("INIT")
            },
            _change_REFRESH_AXES: function() {
                var that = this;
                (0, _utils2.setCanvasValues)(that._canvas);
                that._reinitAxes();
                that._requestChange(["CORRECT_AXIS", "FULL_RENDER"])
            },
            _change_SCROLL_BAR: function() {
                this._createScrollBar();
                this._processRefreshData(FORCE_RENDER_REFRESH_ACTION)
            },
            _change_REINIT: function() {
                this._processRefreshData(REINIT_REFRESH_ACTION)
            },
            _refreshSeries: function(actionName) {
                this.needToPopulateSeries = true;
                this._requestChange([actionName])
            },
            _change_CORRECT_AXIS: function() {
                this._correctAxes()
            },
            _doRefresh: function() {
                var methodName = this._currentRefreshData;
                if (methodName) {
                    this._currentRefreshData = null;
                    this._renderer.stopAllAnimations(true);
                    this[methodName]()
                }
            },
            _updateCanvasClipRect: function(canvas) {
                var that = this;
                var width = Math.max(canvas.width - canvas.left - canvas.right, 0);
                var height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);
                that._canvasClipRect.attr({
                    x: canvas.left,
                    y: canvas.top,
                    width: width,
                    height: height
                });
                that._backgroundRect.attr({
                    x: canvas.left,
                    y: canvas.top,
                    width: width,
                    height: height
                })
            },
            _getCanvasClipRectID: function() {
                return this._canvasClipRect.id
            },
            _dataSourceChangedHandler: function() {
                if (this._changes.has("INIT")) {
                    this._requestChange(["DATA_INIT"])
                } else {
                    this._requestChange(["FORCE_DATA_INIT"])
                }
            },
            _dataInit: function() {
                this._dataSpecificInit(true)
            },
            _processSingleSeries: function(singleSeries) {
                singleSeries.createPoints(false)
            },
            _handleSeriesDataUpdated: function() {
                var _this2 = this;
                if (this._getVisibleSeries().some(function(s) {
                        return s.useAggregation()
                    })) {
                    this._populateMarginOptions()
                }
                this.series.forEach(function(s) {
                    return _this2._processSingleSeries(s)
                }, this)
            },
            _dataSpecificInit: function(needRedraw) {
                var that = this;
                if (!that.series || that.needToPopulateSeries) {
                    that.series = that._populateSeries()
                }
                that._repopulateSeries();
                that._seriesPopulatedHandlerCore();
                that._populateBusinessRange();
                that._tracker.updateSeries(that.series, this._changes.has("INIT"));
                that._updateLegend();
                if (needRedraw) {
                    this._requestChange(["FULL_RENDER"])
                }
            },
            _forceRender: function() {
                this._doRender({
                    force: true
                })
            },
            _repopulateSeries: function() {
                var that = this;
                var themeManager = that._themeManager;
                var data = that._dataSourceItems();
                var dataValidatorOptions = themeManager.getOptions("dataPrepareSettings");
                var seriesTemplate = themeManager.getOptions("seriesTemplate");
                if (seriesTemplate) {
                    that._populateSeries(data)
                }
                that._groupSeries();
                var parsedData = _data_validator2.default.validateData(data, that._groupsData, that._incidentOccurred, dataValidatorOptions);
                themeManager.resetPalette();
                that.series.forEach(function(singleSeries) {
                    singleSeries.updateData(parsedData[singleSeries.getArgumentField()])
                });
                that._handleSeriesDataUpdated()
            },
            _renderCompleteHandler: function() {
                var that = this;
                var allSeriesInited = true;
                if (that._needHandleRenderComplete) {
                    (0, _iterator.each)(that.series, function(_, s) {
                        allSeriesInited = allSeriesInited && s.canRenderCompleteHandle()
                    });
                    if (allSeriesInited) {
                        that._needHandleRenderComplete = false;
                        that._eventTrigger("done", {
                            target: that
                        })
                    }
                }
            },
            _dataIsReady: function() {
                return (0, _type.isDefined)(this.option("dataSource")) && this._dataIsLoaded()
            },
            _populateSeriesOptions: function(data) {
                var that = this;
                var themeManager = that._themeManager;
                var seriesTemplate = themeManager.getOptions("seriesTemplate");
                var seriesOptions = seriesTemplate ? (0, _utils2.processSeriesTemplate)(seriesTemplate, data || []) : that.option("series");
                var allSeriesOptions = _isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [];
                var extraOptions = that._getExtraOptions();
                var particularSeriesOptions;
                var seriesTheme;
                var seriesThemes = [];
                var seriesVisibilityChanged = function(target) {
                    that._specialProcessSeries();
                    that._populateBusinessRange(target && target.getValueAxis(), true);
                    that._renderer.stopAllAnimations(true);
                    that._updateLegend();
                    that._requestChange(["FULL_RENDER"])
                };
                for (var i = 0; i < allSeriesOptions.length; i++) {
                    particularSeriesOptions = (0, _extend.extend)(true, {}, allSeriesOptions[i], extraOptions);
                    if (!particularSeriesOptions.name) {
                        particularSeriesOptions.name = "Series " + (i + 1).toString()
                    }
                    particularSeriesOptions.rotated = that._isRotated();
                    particularSeriesOptions.customizePoint = themeManager.getOptions("customizePoint");
                    particularSeriesOptions.customizeLabel = themeManager.getOptions("customizeLabel");
                    particularSeriesOptions.visibilityChanged = seriesVisibilityChanged;
                    particularSeriesOptions.incidentOccurred = that._incidentOccurred;
                    seriesTheme = themeManager.getOptions("series", particularSeriesOptions, allSeriesOptions.length);
                    if (that._checkPaneName(seriesTheme)) {
                        seriesThemes.push(seriesTheme)
                    }
                }
                return seriesThemes
            },
            _populateSeries: function(data) {
                var that = this;
                var seriesBasis = [];
                var incidentOccurred = that._incidentOccurred;
                var seriesThemes = that._populateSeriesOptions(data);
                var particularSeries;
                var disposeSeriesFamilies = false;
                that.needToPopulateSeries = false;
                (0, _iterator.each)(seriesThemes, function(_, theme) {
                    var curSeries = that.series && that.series.filter(function(s) {
                        return s.name === theme.name && seriesBasis.map(function(sb) {
                            return sb.series
                        }).indexOf(s) === -1
                    })[0];
                    if (curSeries && curSeries.type === theme.type) {
                        seriesBasis.push({
                            series: curSeries,
                            options: theme
                        })
                    } else {
                        seriesBasis.push({
                            options: theme
                        });
                        disposeSeriesFamilies = true
                    }
                });
                that._tracker.clearHover();
                (0, _iterator.reverseEach)(that.series, function(index, series) {
                    if (!seriesBasis.some(function(s) {
                            return series === s.series
                        })) {
                        that._disposeSeries(index);
                        disposeSeriesFamilies = true
                    }
                });
                !disposeSeriesFamilies && (disposeSeriesFamilies = seriesBasis.some(function(sb) {
                    return sb.series.name !== seriesThemes[sb.series.index].name
                }));
                that.series = [];
                disposeSeriesFamilies && that._disposeSeriesFamilies();
                that._themeManager.resetPalette();
                var eventPipe = function(data) {
                    that.series.forEach(function(currentSeries) {
                        currentSeries.notify(data)
                    })
                };
                (0, _iterator.each)(seriesBasis, function(_, basis) {
                    var seriesTheme = basis.options;
                    var renderSettings = {
                        commonSeriesModes: that._getSelectionModes(),
                        argumentAxis: that.getArgumentAxis(),
                        valueAxis: that._getValueAxis(seriesTheme.pane, seriesTheme.axis)
                    };
                    if (basis.series) {
                        particularSeries = basis.series;
                        particularSeries.updateOptions(seriesTheme, renderSettings)
                    } else {
                        particularSeries = new _base_series2.default.Series((0, _extend.extend)({
                            renderer: that._renderer,
                            seriesGroup: that._seriesGroup,
                            labelsGroup: that._labelsGroup,
                            eventTrigger: that._eventTrigger,
                            eventPipe: eventPipe,
                            incidentOccurred: incidentOccurred
                        }, renderSettings), seriesTheme)
                    }
                    if (!particularSeries.isUpdated) {
                        incidentOccurred("E2101", [seriesTheme.type])
                    } else {
                        particularSeries.index = that.series.length;
                        that.series.push(particularSeries)
                    }
                });
                return that.series
            },
            getStackedPoints: function(point) {
                var stackName = point.series.getStackName();
                return this._getVisibleSeries().reduce(function(stackPoints, series) {
                    if (!(0, _type.isDefined)(series.getStackName()) && !(0, _type.isDefined)(stackName) || stackName === series.getStackName()) {
                        stackPoints = stackPoints.concat(series.getPointsByArg(point.argument))
                    }
                    return stackPoints
                }, [])
            },
            getAllSeries: function() {
                return (this.series || []).slice()
            },
            getSeriesByName: function(name) {
                var found = null;
                (0, _iterator.each)(this.series, function(i, singleSeries) {
                    if (singleSeries.name === name) {
                        found = singleSeries;
                        return false
                    }
                });
                return found
            },
            getSeriesByPos: function(pos) {
                return (this.series || [])[pos]
            },
            clearSelection: function() {
                this._tracker.clearSelection()
            },
            hideTooltip: function() {
                this._tracker._hideTooltip()
            },
            clearHover: function() {
                this._tracker.clearHover()
            },
            render: function(renderOptions) {
                var that = this;
                that.__renderOptions = renderOptions;
                that.__forceRender = renderOptions && renderOptions.force;
                that.callBase.apply(that, arguments);
                that.__renderOptions = that.__forceRender = null;
                return that
            },
            refresh: function() {
                this._disposeSeries();
                this._disposeSeriesFamilies();
                this._requestChange(["CONTAINER_SIZE", "REFRESH_SERIES_REINIT"])
            },
            _getMinSize: function() {
                var adaptiveLayout = this._layoutManagerOptions();
                return [adaptiveLayout.width, adaptiveLayout.height]
            },
            _change_REFRESH: function() {
                if (!this._changes.has("INIT")) {
                    this._doRefresh()
                } else {
                    this._currentRefreshData = null
                }
            },
            _change_FULL_RENDER: function() {
                this._forceRender()
            },
            _change_INIT: function() {
                this._reinit()
            },
            _stopCurrentHandling: function() {
                this._tracker.stopCurrentHandling()
            }
        });
        REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS.forEach(function(name) {
            BaseChart.prototype._optionChangesMap[name] = "REFRESH_SERIES_DATA_INIT"
        });
        FORCE_RENDER_REFRESH_ACTION_OPTIONS.forEach(function(name) {
            BaseChart.prototype._optionChangesMap[name] = "FORCE_RENDER"
        });
        REFRESH_SERIES_FAMILIES_ACTION_OPTIONS.forEach(function(name) {
            BaseChart.prototype._optionChangesMap[name] = "REFRESH_SERIES_FAMILIES"
        });
        exports.overlapping = overlapping;
        exports.BaseChart = BaseChart;
        BaseChart.addPlugin(__webpack_require__( /*! ../core/export */ 99).plugin);
        BaseChart.addPlugin(__webpack_require__( /*! ../core/title */ 109).plugin);
        BaseChart.addPlugin(__webpack_require__( /*! ../core/tooltip */ 111).plugin);
        BaseChart.addPlugin(__webpack_require__( /*! ../core/loading_indicator */ 127).plugin);
        BaseChart.addPlugin(__webpack_require__( /*! ../core/data_source */ 152).plugin);
        var _change_TITLE = BaseChart.prototype._change_TITLE;
        BaseChart.prototype._change_TITLE = function() {
            _change_TITLE.apply(this, arguments);
            this._change(["FORCE_RENDER"])
        }
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/base_theme_manager.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var paletteModule = __webpack_require__( /*! ../palette */ 173);
        var _isString = typeUtils.isString;
        var _parseScalar = __webpack_require__( /*! ./utils */ 13).parseScalar;
        var themeModule = __webpack_require__( /*! ../themes */ 50);
        var _getTheme = themeModule.getTheme;
        var _addCacheItem = themeModule.addCacheItem;
        var _removeCacheItem = themeModule.removeCacheItem;
        var _extend = extend;
        var _each = each;
        __webpack_require__( /*! ./themes/generic.light */ 804);
        __webpack_require__( /*! ./themes/generic.dark */ 805);
        __webpack_require__( /*! ./themes/generic.contrast */ 806);
        __webpack_require__( /*! ./themes/generic.carmine */ 807);
        __webpack_require__( /*! ./themes/generic.darkmoon */ 808);
        __webpack_require__( /*! ./themes/generic.softblue */ 809);
        __webpack_require__( /*! ./themes/generic.darkviolet */ 810);
        __webpack_require__( /*! ./themes/generic.greenmist */ 811);
        __webpack_require__( /*! ./themes/material */ 812);
        __webpack_require__( /*! ./themes/ios */ 813);

        function getThemePart(theme, path) {
            var _theme = theme;
            path && _each(path.split("."), function(_, pathItem) {
                return _theme = _theme[pathItem]
            });
            return _theme
        }
        exports.BaseThemeManager = Class.inherit({
            ctor: function(options) {
                this._themeSection = options.themeSection;
                this._fontFields = options.fontFields || [];
                _addCacheItem(this)
            },
            dispose: function() {
                var that = this;
                _removeCacheItem(that);
                that._callback = that._theme = that._font = null;
                return that
            },
            setCallback: function(callback) {
                this._callback = callback;
                return this
            },
            setTheme: function(theme, rtl) {
                this._current = theme;
                this._rtl = rtl;
                return this.refresh()
            },
            refresh: function() {
                var that = this;
                var current = that._current || {};
                var theme = _getTheme(current.name || current);
                that._themeName = theme.name;
                that._defaultPalette = theme.defaultPalette;
                that._font = _extend({}, theme.font, current.font);
                that._themeSection && _each(that._themeSection.split("."), function(_, path) {
                    theme = _extend(true, {}, theme[path])
                });
                that._theme = _extend(true, {}, theme, _isString(current) ? {} : current);
                that._initializeTheme();
                if (_parseScalar(that._rtl, that._theme.rtlEnabled)) {
                    _extend(true, that._theme, that._theme._rtl)
                }
                that._callback();
                return that
            },
            theme: function(path) {
                return getThemePart(this._theme, path)
            },
            themeName: function() {
                return this._themeName
            },
            createPalette: function(palette, options) {
                return paletteModule.createPalette(palette, options, this._defaultPalette)
            },
            createDiscretePalette: function(palette, count) {
                return paletteModule.getDiscretePalette(palette, count, this._defaultPalette)
            },
            createGradientPalette: function(palette) {
                return paletteModule.getGradientPalette(palette, this._defaultPalette)
            },
            getAccentColor: function(palette) {
                return paletteModule.getAccentColor(palette, this._defaultPalette)
            },
            _initializeTheme: function() {
                var that = this;
                _each(that._fontFields || [], function(_, path) {
                    that._initializeFont(getThemePart(that._theme, path))
                })
            },
            _initializeFont: function(font) {
                _extend(font, this._font, _extend({}, font))
            }
        })
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/viz/core/layout_element.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var _round = Math.round;
        var objectUtils = __webpack_require__( /*! ../../core/utils/object */ 47);
        var defaultOffset = {
            horizontal: 0,
            vertical: 0
        };
        var alignFactors = {
            center: .5,
            right: 1,
            bottom: 1,
            left: 0,
            top: 0
        };

        function LayoutElement(options) {
            this._options = options
        }
        LayoutElement.prototype = {
            constructor: LayoutElement,
            position: function(options) {
                var that = this;
                var ofBBox = options.of.getLayoutOptions();
                var myBBox = that.getLayoutOptions();
                var at = options.at;
                var my = options.my;
                var offset = options.offset || defaultOffset;
                var shiftX = -alignFactors[my.horizontal] * myBBox.width + ofBBox.x + alignFactors[at.horizontal] * ofBBox.width + parseInt(offset.horizontal);
                var shiftY = -alignFactors[my.vertical] * myBBox.height + ofBBox.y + alignFactors[at.vertical] * ofBBox.height + parseInt(offset.vertical);
                that.shift(_round(shiftX), _round(shiftY))
            },
            getLayoutOptions: noop
        };

        function WrapperLayoutElement(renderElement, bBox) {
            this._renderElement = renderElement;
            this._cacheBBox = bBox
        }
        var wrapperLayoutElementPrototype = WrapperLayoutElement.prototype = objectUtils.clone(LayoutElement.prototype);
        wrapperLayoutElementPrototype.constructor = WrapperLayoutElement;
        wrapperLayoutElementPrototype.getLayoutOptions = function() {
            return this._cacheBBox || this._renderElement.getBBox()
        };
        wrapperLayoutElementPrototype.shift = function(shiftX, shiftY) {
            var bBox = this.getLayoutOptions();
            this._renderElement.move(_round(shiftX - bBox.x), _round(shiftY - bBox.y))
        };
        exports.LayoutElement = LayoutElement;
        exports.WrapperLayoutElement = WrapperLayoutElement
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/components/data_validator.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var STRING = "string";
        var NUMERIC = "numeric";
        var DATETIME = "datetime";
        var DISCRETE = "discrete";
        var SEMIDISCRETE = "semidiscrete";
        var CONTINUOUS = "continuous";
        var LOGARITHMIC = "logarithmic";
        var VALUE_TYPE = "valueType";
        var ARGUMENT_TYPE = "argumentType";
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var axisTypeParser = __webpack_require__( /*! ../core/utils */ 13).enumParser([STRING, NUMERIC, DATETIME]);
        var _getParser = __webpack_require__( /*! ./parse_utils */ 260).getParser;
        var _isDefined = typeUtils.isDefined;
        var _isFunction = typeUtils.isFunction;
        var _isArray = Array.isArray;
        var _isString = typeUtils.isString;
        var _isDate = typeUtils.isDate;
        var _isNumber = typeUtils.isNumeric;
        var _isObject = typeUtils.isObject;

        function groupingValues(data, others, valueField, index) {
            if (index >= 0) {
                data.slice(index).forEach(function(cell) {
                    if (_isDefined(cell[valueField])) {
                        others[valueField] += cell[valueField];
                        cell[valueField] = void 0
                    }
                })
            }
        }

        function processGroups(groups) {
            groups.forEach(function(group) {
                group.valueType = group.valueAxisType = null;
                group.series.forEach(function(series) {
                    series.updateDataType({})
                });
                group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE)
            })
        }

        function sortValues(data, asc, selector) {
            var func = asc ? function(a, b) {
                return a - b
            } : function(a, b) {
                return b - a
            };
            data.sort(function(a, b) {
                var valA = selector(a);
                var valB = selector(b);
                var aa = _isDefined(valA) ? 1 : 0;
                var bb = _isDefined(valB) ? 1 : 0;
                return aa && bb ? func(valA, valB) : func(aa, bb)
            });
            return data
        }

        function resetArgumentAxes(axes) {
            axes && axes.forEach(function(axis) {
                axis.resetTypes(ARGUMENT_TYPE)
            })
        }

        function parseCategories(categories, parser) {
            var newArray = [];
            categories.forEach(function(category) {
                var parsedCategory = parser(category);
                void 0 !== parsedCategory && newArray.push(parsedCategory)
            });
            return newArray
        }

        function parseAxisCategories(groupsData, parsers) {
            var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;
            groupsData.groups.forEach(function(valueGroup, i) {
                var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;
                if (categories) {
                    valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1])
                }
            });
            if (argumentCategories) {
                groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0])
            }
        }

        function eigen(x) {
            return x
        }

        function getType(unit, type) {
            var result = type;
            if (type === STRING || _isString(unit)) {
                result = STRING
            } else {
                if (type === DATETIME || _isDate(unit)) {
                    result = DATETIME
                } else {
                    if (_isNumber(unit)) {
                        result = NUMERIC
                    }
                }
            }
            return result
        }

        function correctAxisType(type, axisType, hasCategories, incidentOccurred) {
            if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {
                incidentOccurred("E2002")
            }
            return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS
        }

        function validUnit(unit, field, incidentOccurred) {
            if (unit) {
                incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? "E2003" : "E2004", [field])
            }
        }

        function createParserUnit(type, axisType, incidentOccurred) {
            var parser = type ? _getParser(type) : eigen;
            var filterInfinity = axisType !== DISCRETE ? function(x) {
                return isFinite(x) || void 0 === x ? x : null
            } : eigen;
            return function(unit, field) {
                var parseUnit = filterInfinity(parser(unit));
                if (void 0 === parseUnit) {
                    validUnit(unit, field, incidentOccurred)
                }
                return parseUnit
            }
        }

        function prepareParsers(groupsData, incidentOccurred) {
            var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);
            var sizeParser;
            var valueParser;
            var categoryParsers = [argumentParser];
            var cache = {};
            var list = [];
            groupsData.groups.forEach(function(group, groupIndex) {
                group.series.forEach(function(series) {
                    valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);
                    sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);
                    cache[series.getArgumentField()] = argumentParser;
                    series.getValueFields().forEach(function(field) {
                        categoryParsers[groupIndex + 1] = valueParser;
                        cache[field] = valueParser
                    });
                    if (series.getSizeField()) {
                        cache[series.getSizeField()] = sizeParser
                    }
                })
            });
            for (var field in cache) {
                list.push([field, cache[field]])
            }
            list.length && parseAxisCategories(groupsData, categoryParsers);
            return list
        }

        function getParsedCell(cell, parsers) {
            var i;
            var ii = parsers.length;
            var obj = extend({}, cell);
            var field;
            var value;
            for (i = 0; i < ii; ++i) {
                field = parsers[i][0];
                value = cell[field];
                obj[field] = parsers[i][1](value, field)
            }
            return obj
        }

        function parse(data, parsers) {
            var parsedData = [];
            var i;
            var ii = data.length;
            parsedData.length = ii;
            for (i = 0; i < ii; ++i) {
                parsedData[i] = getParsedCell(data[i], parsers)
            }
            return parsedData
        }

        function findIndexByThreshold(data, valueField, threshold) {
            var i;
            var ii = data.length;
            var value;
            for (i = 0; i < ii; ++i) {
                value = data[i][valueField];
                if (_isDefined(value) && threshold > value) {
                    break
                }
            }
            return i
        }

        function groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {
            smallValuesGrouping = smallValuesGrouping || {};
            var mode = smallValuesGrouping.mode;
            var others = {};
            if (!mode || "none" === mode) {
                return
            }
            others[argumentField] = String(smallValuesGrouping.groupName || "others");
            others[valueField] = 0;
            var data = sortValues(originalData.slice(), false, function(a) {
                return a[valueField]
            });
            groupingValues(data, others, valueField, "smallValueThreshold" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);
            others[valueField] && originalData.push(others)
        }

        function groupPieData(data, groupsData) {
            var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];
            var isPie = firstSeries && ("pie" === firstSeries.type || "doughnut" === firstSeries.type || "donut" === firstSeries.type);
            if (!isPie) {
                return
            }
            groupsData.groups.forEach(function(group) {
                group.series.forEach(function(series) {
                    groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping)
                })
            })
        }

        function addUniqueItemToCollection(item, collection, itemsHash) {
            if (!itemsHash[item]) {
                collection.push(item);
                itemsHash[item] = true
            }
        }

        function getUniqueArgumentFields(groupsData) {
            var uniqueArgumentFields = [];
            var hash = {};
            groupsData.groups.forEach(function(group) {
                group.series.forEach(function(series) {
                    addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash)
                })
            });
            return uniqueArgumentFields
        }

        function sort(a, b) {
            var result = a - b;
            if (isNaN(result)) {
                if (!_isDefined(a)) {
                    return 1
                }
                if (!_isDefined(b)) {
                    return -1
                }
                return 0
            }
            return result
        }

        function sortByArgument(data, argumentField) {
            return data.slice().sort(function(a, b) {
                return sort(a[argumentField], b[argumentField])
            })
        }

        function sortByCallback(data, callback) {
            return data.slice().sort(callback)
        }

        function checkValueTypeOfGroup(group, cell) {
            group.series.forEach(function(series) {
                series.getValueFields().forEach(function(field) {
                    group.valueType = getType(cell[field], group.valueType)
                })
            });
            return group.valueType
        }

        function getSortByCategories(categories) {
            var hash = {};
            categories.forEach(function(value, i) {
                hash[value] = i
            });
            return function(data, argumentField) {
                return sortValues(data.slice(), true, function(a) {
                    return hash[a[argumentField]]
                })
            }
        }

        function sortData(data, groupsData, options, uniqueArgumentFields) {
            var dataByArguments = {};
            var isDiscrete = groupsData.argumentAxisType === DISCRETE;
            var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;
            var sortFunction = function(data) {
                return data
            };
            var sortingMethodOption = options.sortingMethod;
            var reSortCategories;
            if (!userCategories && _isFunction(sortingMethodOption)) {
                data = sortByCallback(data, sortingMethodOption)
            }
            if (isDiscrete) {
                groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories)
            }
            if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {
                sortFunction = getSortByCategories(groupsData.categories)
            } else {
                if (true === sortingMethodOption && groupsData.argumentType !== STRING) {
                    sortFunction = sortByArgument;
                    reSortCategories = isDiscrete
                }
            }
            uniqueArgumentFields.forEach(function(field) {
                dataByArguments[field] = sortFunction(data, field)
            });
            if (reSortCategories) {
                groupsData.categories = groupsData.categories.sort(sort)
            }
            return dataByArguments
        }

        function checkItemExistence(collection, item) {
            return collection.map(function(collectionItem) {
                return collectionItem.valueOf()
            }).indexOf(item.valueOf()) === -1
        }

        function getCategories(data, uniqueArgumentFields, userCategories) {
            var categories = userCategories ? userCategories.slice() : [];
            uniqueArgumentFields.forEach(function(field) {
                data.forEach(function(item) {
                    var dataItem = item[field];
                    _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem)
                })
            });
            return categories
        }

        function checkArgumentTypeOfGroup(series, cell, groupsData) {
            series.forEach(function(currentSeries) {
                groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType)
            });
            return groupsData.argumentType
        }

        function checkType(data, groupsData, checkTypeForAllData) {
            var groupsWithUndefinedValueType = [];
            var groupsWithUndefinedArgumentType = [];
            var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);
            var groupsIndexes;
            groupsData.groups.forEach(function(group) {
                if (!group.series.length) {
                    return
                }
                var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);
                group.valueType = valueTypeGroup;
                groupsData.argumentType = argumentTypeGroup;
                !valueTypeGroup && groupsWithUndefinedValueType.push(group);
                !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group)
            });
            if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {
                groupsIndexes = groupsWithUndefinedValueType.map(function(_, index) {
                    return index
                });
                data.some(function(cell) {
                    var defineArg;
                    groupsWithUndefinedValueType.forEach(function(group, groupIndex) {
                        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {
                            groupsIndexes.splice(groupIndex, 1)
                        }
                    });
                    if (!defineArg) {
                        groupsWithUndefinedArgumentType.forEach(function(group) {
                            defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData)
                        })
                    }
                    if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {
                        return true
                    }
                })
            }
        }

        function checkAxisType(groupsData, incidentOccurred) {
            var argumentOptions = groupsData.argumentOptions || {};
            var userArgumentCategories = argumentOptions && argumentOptions.categories || [];
            var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);
            groupsData.groups.forEach(function(group) {
                var valueOptions = group.valueOptions || {};
                var valueCategories = valueOptions.categories || [];
                var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);
                group.series.forEach(function(series) {
                    var optionsSeries = {};
                    optionsSeries.argumentAxisType = argumentAxisType;
                    optionsSeries.valueAxisType = valueAxisType;
                    groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;
                    group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;
                    optionsSeries.argumentType = groupsData.argumentType;
                    optionsSeries.valueType = group.valueType;
                    optionsSeries.showZero = valueOptions.showZero;
                    series.updateDataType(optionsSeries)
                });
                group.valueAxisType = group.valueAxisType || valueAxisType;
                if (group.valueAxis) {
                    group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);
                    group.valueAxis.validate()
                }
            });
            groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;
            if (groupsData.argumentAxes) {
                groupsData.argumentAxes.forEach(function(axis) {
                    axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);
                    axis.validate()
                })
            }
        }

        function verifyData(source, incidentOccurred) {
            var data = [];
            var sourceIsDefined = _isDefined(source);
            var hasError = sourceIsDefined && !_isArray(source);
            var i;
            var ii;
            var k;
            var item;
            if (sourceIsDefined && !hasError) {
                for (i = 0, ii = source.length, k = 0; i < ii; ++i) {
                    item = source[i];
                    if (_isObject(item)) {
                        data[k++] = item
                    } else {
                        if (item) {
                            hasError = true
                        }
                    }
                }
            }
            if (hasError) {
                incidentOccurred("E2001")
            }
            return data
        }

        function validateData(data, groupsData, incidentOccurred, options) {
            data = verifyData(data, incidentOccurred);
            groupsData.argumentType = groupsData.argumentAxisType = null;
            processGroups(groupsData.groups);
            resetArgumentAxes(groupsData.argumentAxes);
            checkType(data, groupsData, options.checkTypeForAllData);
            checkAxisType(groupsData, incidentOccurred);
            if (options.convertToAxisDataType) {
                data = parse(data, prepareParsers(groupsData, incidentOccurred))
            }
            groupPieData(data, groupsData);
            var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));
            return dataByArgumentFields
        }
        exports.validateData = validateData
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/viz/components/parse_utils.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var dateSerialization = __webpack_require__( /*! ../../core/utils/date_serialization */ 54);
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var parsers = {
            string: function(val) {
                return isDefined(val) ? "" + val : val
            },
            numeric: function(val) {
                if (!isDefined(val)) {
                    return val
                }
                var parsedVal = Number(val);
                if (isNaN(parsedVal)) {
                    parsedVal = void 0
                }
                return parsedVal
            },
            datetime: function(val) {
                if (!isDefined(val)) {
                    return val
                }
                var parsedVal;
                var numVal = Number(val);
                if (!isNaN(numVal)) {
                    parsedVal = new Date(numVal)
                } else {
                    parsedVal = dateSerialization.deserializeDate(val)
                }
                if (isNaN(Number(parsedVal))) {
                    parsedVal = void 0
                }
                return parsedVal
            }
        };

        function correctValueType(type) {
            return "numeric" === type || "datetime" === type || "string" === type ? type : ""
        }
        module.exports = {
            correctValueType: correctValueType,
            getParser: function(valueType) {
                return parsers[correctValueType(valueType)] || noop
            }
        };
        module.exports.parsers = parsers
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/series/base_series.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend2 = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _base_point = __webpack_require__( /*! ./points/base_point */ 817);
        var _base_point2 = _interopRequireDefault(_base_point);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _consts = __webpack_require__( /*! ../components/consts */ 125);
        var _range_data_calculator = __webpack_require__( /*! ./helpers/range_data_calculator */ 209);
        var _range_data_calculator2 = _interopRequireDefault(_range_data_calculator);
        var _scatter_series = __webpack_require__( /*! ./scatter_series */ 110);
        var _scatter_series2 = _interopRequireDefault(_scatter_series);
        var _line_series = __webpack_require__( /*! ./line_series */ 210);
        var _line_series2 = _interopRequireDefault(_line_series);
        var _area_series = __webpack_require__( /*! ./area_series */ 174);
        var _area_series2 = _interopRequireDefault(_area_series);
        var _bar_series = __webpack_require__( /*! ./bar_series */ 151);
        var _bar_series2 = _interopRequireDefault(_bar_series);
        var _range_series = __webpack_require__( /*! ./range_series */ 822);
        var _range_series2 = _interopRequireDefault(_range_series);
        var _bubble_series = __webpack_require__( /*! ./bubble_series */ 823);
        var _bubble_series2 = _interopRequireDefault(_bubble_series);
        var _pie_series = __webpack_require__( /*! ./pie_series */ 824);
        var _pie_series2 = _interopRequireDefault(_pie_series);
        var _financial_series = __webpack_require__( /*! ./financial_series */ 825);
        var _financial_series2 = _interopRequireDefault(_financial_series);
        var _stacked_series = __webpack_require__( /*! ./stacked_series */ 826);
        var _stacked_series2 = _interopRequireDefault(_stacked_series);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var seriesNS = {};
        var DISCRETE = "discrete";
        var SELECTED_STATE = _consts.states.selectedMark;
        var HOVER_STATE = _consts.states.hoverMark;
        var HOVER = _consts.states.hover;
        var NORMAL = _consts.states.normal;
        var SELECTION = _consts.states.selection;
        var APPLY_SELECTED = _consts.states.applySelected;
        var APPLY_HOVER = _consts.states.applyHover;
        var RESET_ITEM = _consts.states.resetItem;
        var NONE_MODE = "none";
        var INCLUDE_POINTS = "includepoints";
        var NEAREST_POINT = "nearestpoint";
        var SERIES_SELECTION_CHANGED = "seriesSelectionChanged";
        var POINT_SELECTION_CHANGED = "pointSelectionChanged";
        var SERIES_HOVER_CHANGED = "seriesHoverChanged";
        var POINT_HOVER_CHANGED = "pointHoverChanged";
        var ALL_SERIES_POINTS = "allseriespoints";
        var ALL_ARGUMENT_POINTS = "allargumentpoints";
        var POINT_HOVER = "pointHover";
        var CLEAR_POINT_HOVER = "clearPointHover";
        var SERIES_SELECT = "seriesSelect";
        var POINT_SELECT = "pointSelect";
        var POINT_DESELECT = "pointDeselect";
        var getEmptyBusinessRange = function() {
            return {
                arg: {},
                val: {}
            }
        };

        function triggerEvent(element, event, point) {
            element && element.trigger(event, point)
        }
        seriesNS.mixins = {
            chart: {},
            pie: {},
            polar: {}
        };
        seriesNS.mixins.chart.scatter = _scatter_series2.default.chart;
        seriesNS.mixins.polar.scatter = _scatter_series2.default.polar;
        (0, _extend2.extend)(seriesNS.mixins.pie, _pie_series2.default);
        (0, _extend2.extend)(seriesNS.mixins.chart, _line_series2.default.chart, _area_series2.default.chart, _bar_series2.default.chart, _range_series2.default.chart, _bubble_series2.default.chart, _financial_series2.default, _stacked_series2.default.chart);
        (0, _extend2.extend)(seriesNS.mixins.polar, _line_series2.default.polar, _area_series2.default.polar, _bar_series2.default.polar, _range_series2.default.polar, _bubble_series2.default.polar, _stacked_series2.default.polar);

        function includePointsMode(mode) {
            mode = (0, _utils.normalizeEnum)(mode);
            return mode === INCLUDE_POINTS || mode === ALL_SERIES_POINTS
        }

        function getLabelOptions(labelOptions, defaultColor) {
            var opt = labelOptions || {};
            var labelFont = (0, _extend2.extend)({}, opt.font) || {};
            var labelBorder = opt.border || {};
            var labelConnector = opt.connector || {};
            var backgroundAttr = {
                fill: opt.backgroundColor || defaultColor,
                "stroke-width": labelBorder.visible ? labelBorder.width || 0 : 0,
                stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : "none",
                dashStyle: labelBorder.dashStyle
            };
            var connectorAttr = {
                stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : "none",
                "stroke-width": labelConnector.visible ? labelConnector.width || 0 : 0
            };
            labelFont.color = "none" === opt.backgroundColor && "#ffffff" === (0, _utils.normalizeEnum)(labelFont.color) && "inside" !== opt.position ? defaultColor : labelFont.color;
            return {
                alignment: opt.alignment,
                format: opt.format,
                argumentFormat: opt.argumentFormat,
                customizeText: (0, _type.isFunction)(opt.customizeText) ? opt.customizeText : void 0,
                attributes: {
                    font: labelFont
                },
                visible: 0 !== labelFont.size ? opt.visible : false,
                showForZeroValues: opt.showForZeroValues,
                horizontalOffset: opt.horizontalOffset,
                verticalOffset: opt.verticalOffset,
                radialOffset: opt.radialOffset,
                background: backgroundAttr,
                position: opt.position,
                connector: connectorAttr,
                rotationAngle: opt.rotationAngle,
                wordWrap: opt.wordWrap,
                textOverflow: opt.textOverflow,
                cssClass: opt.cssClass
            }
        }

        function setPointHoverState(point, legendCallback) {
            point.fullState |= HOVER_STATE;
            point.applyView(legendCallback)
        }

        function releasePointHoverState(point, legendCallback) {
            point.fullState &= ~HOVER_STATE;
            point.applyView(legendCallback);
            point.releaseHoverState()
        }

        function setPointSelectedState(point, legendCallback) {
            point.fullState |= SELECTED_STATE;
            point.applyView(legendCallback)
        }

        function releasePointSelectedState(point, legendCallback) {
            point.fullState &= ~SELECTED_STATE;
            point.applyView(legendCallback)
        }

        function mergePointOptionsCore(base, extra) {
            var options = (0, _extend2.extend)({}, base, extra);
            options.border = (0, _extend2.extend)({}, base && base.border, extra && extra.border);
            return options
        }

        function mergePointOptions(base, extra) {
            var options = mergePointOptionsCore(base, extra);
            options.image = (0, _extend2.extend)(true, {}, base.image, extra.image);
            options.selectionStyle = mergePointOptionsCore(base.selectionStyle, extra.selectionStyle);
            options.hoverStyle = mergePointOptionsCore(base.hoverStyle, extra.hoverStyle);
            return options
        }

        function Series(settings, options) {
            var that = this;
            that.fullState = 0;
            that._extGroups = settings;
            that._renderer = settings.renderer;
            that._group = settings.renderer.g().attr({
                "class": "dxc-series"
            });
            that._eventTrigger = settings.eventTrigger;
            that._eventPipe = settings.eventPipe;
            that._incidentOccurred = settings.incidentOccurred;
            that._legendCallback = _common.noop;
            that.updateOptions(options, settings)
        }

        function getData(pointData) {
            return pointData.data
        }
        exports.Series = Series;
        exports.mixins = seriesNS.mixins;

        function getValueChecker(axisType, axis) {
            if (!axis || "logarithmic" !== axisType || false !== axis.getOptions().allowNegatives) {
                return function() {
                    return true
                }
            } else {
                return function(value) {
                    return value > 0
                }
            }
        }
        Series.prototype = {
            constructor: Series,
            _createLegendState: _common.noop,
            getLegendStyles: function() {
                return this._styles.legendStyles
            },
            _createStyles: function(options) {
                var that = this;
                var mainSeriesColor = options.mainSeriesColor;
                that._styles = {
                    normal: that._parseStyle(options, mainSeriesColor, mainSeriesColor),
                    hover: that._parseStyle(options.hoverStyle || {}, mainSeriesColor, mainSeriesColor),
                    selection: that._parseStyle(options.selectionStyle || {}, mainSeriesColor, mainSeriesColor),
                    legendStyles: {
                        normal: that._createLegendState(options, mainSeriesColor),
                        hover: that._createLegendState(options.hoverStyle || {}, mainSeriesColor),
                        selection: that._createLegendState(options.selectionStyle || {}, mainSeriesColor)
                    }
                }
            },
            setClippingParams: function(baseId, wideId, forceClipping) {
                var clipLabels = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;
                this._paneClipRectID = baseId;
                this._widePaneClipRectID = wideId;
                this._forceClipping = forceClipping;
                this._clipLabels = clipLabels
            },
            applyClip: function() {
                this._group.attr({
                    "clip-path": this._paneClipRectID
                })
            },
            resetClip: function() {
                this._group.attr({
                    "clip-path": null
                })
            },
            getTagField: function() {
                return this._options.tagField || "tag"
            },
            getValueFields: _common.noop,
            getSizeField: _common.noop,
            getArgumentField: _common.noop,
            getPoints: function() {
                return this._points
            },
            getPointsInViewPort: function() {
                return _range_data_calculator2.default.getPointsInViewPort(this)
            },
            _createPoint: function(data, index, oldPoint) {
                data.index = index;
                var that = this;
                var pointsByArgument = that.pointsByArgument;
                var options = that._getCreatingPointOptions(data);
                var arg = data.argument.valueOf();
                var point = oldPoint;
                if (point) {
                    point.update(data, options)
                } else {
                    point = new _base_point2.default.Point(that, data, options);
                    if (that.isSelected() && includePointsMode(that.lastSelectionMode)) {
                        point.setView(SELECTION)
                    }
                }
                var pointByArgument = pointsByArgument[arg];
                if (pointByArgument) {
                    pointByArgument.push(point)
                } else {
                    pointsByArgument[arg] = [point]
                }
                if (point.hasValue()) {
                    that.customizePoint(point, data)
                }
                return point
            },
            getRangeData: function() {
                return this._visible ? this._getRangeData() : getEmptyBusinessRange()
            },
            getArgumentRange: function() {
                return this._visible ? _range_data_calculator2.default.getArgumentRange(this) : getEmptyBusinessRange()
            },
            getViewport: function() {
                return _range_data_calculator2.default.getViewport(this)
            },
            _deleteGroup: function(groupName) {
                var group = this[groupName];
                if (group) {
                    group.dispose();
                    this[groupName] = null
                }
            },
            updateOptions: function(newOptions, settings) {
                var that = this;
                var widgetType = newOptions.widgetType;
                var oldType = that.type;
                var newType = newOptions.type;
                that.type = newType && (0, _utils.normalizeEnum)(newType.toString());
                if (!that._checkType(widgetType) || that._checkPolarBarType(widgetType, newOptions)) {
                    that.dispose();
                    that.isUpdated = false;
                    return
                }
                if (oldType !== that.type) {
                    that._firstDrawing = true;
                    that._resetType(oldType, widgetType);
                    that._setType(that.type, widgetType)
                } else {
                    that._defineDrawingState()
                }
                that._options = newOptions;
                that._pointOptions = null;
                that.name = newOptions.name;
                that.pane = newOptions.pane;
                that.tag = newOptions.tag;
                if (settings) {
                    that._seriesModes = settings.commonSeriesModes || that._seriesModes;
                    that._valueAxis = settings.valueAxis || that._valueAxis;
                    that.axis = that._valueAxis && that._valueAxis.name;
                    that._argumentAxis = settings.argumentAxis || that._argumentAxis
                }
                that._createStyles(newOptions);
                that._stackName = null;
                that._updateOptions(newOptions);
                that._visible = newOptions.visible;
                that.isUpdated = true;
                that.stack = newOptions.stack;
                that.barOverlapGroup = newOptions.barOverlapGroup;
                that._createGroups();
                that._processEmptyValue = newOptions.ignoreEmptyPoints ? function(x) {
                    return null === x ? void 0 : x
                } : function(x) {
                    return x
                }
            },
            _defineDrawingState: function() {
                this._firstDrawing = true
            },
            _disposePoints: function(points) {
                (0, _iterator.each)(points || [], function(_, p) {
                    p.dispose()
                })
            },
            updateDataType: function(settings) {
                var that = this;
                that.argumentType = settings.argumentType;
                that.valueType = settings.valueType;
                that.argumentAxisType = settings.argumentAxisType;
                that.valueAxisType = settings.valueAxisType;
                that.showZero = settings.showZero;
                this._argumentChecker = getValueChecker(settings.argumentAxisType, that.getArgumentAxis());
                this._valueChecker = getValueChecker(settings.valueAxisType, that.getValueAxis());
                return that
            },
            _argumentChecker: function() {
                return true
            },
            _valueChecker: function() {
                return true
            },
            getOptions: function() {
                return this._options
            },
            _getOldPoint: function(data, oldPointsByArgument, index) {
                var arg = data.argument && data.argument.valueOf();
                var point = (oldPointsByArgument[arg] || [])[0];
                if (point) {
                    oldPointsByArgument[arg].splice(0, 1)
                }
                return point
            },
            updateData: function(data) {
                var that = this;
                var options = that._options;
                var nameField = options.nameField;
                data = data || [];
                if (data.length) {
                    that._canRenderCompleteHandle = true
                }
                var dataSelector = this._getPointDataSelector();
                var itemsWithoutArgument = 0;
                that._data = data.reduce(function(data, dataItem, index) {
                    var pointDataItem = dataSelector(dataItem);
                    if ((0, _type.isDefined)(pointDataItem.argument)) {
                        if (!nameField || dataItem[nameField] === options.nameFieldValue) {
                            pointDataItem.index = index;
                            data.push(pointDataItem)
                        }
                    } else {
                        itemsWithoutArgument++
                    }
                    return data
                }, []);
                if (itemsWithoutArgument && itemsWithoutArgument === data.length) {
                    that._incidentOccurred("W2002", [that.name, that.getArgumentField()])
                }
                that._endUpdateData()
            },
            _getData: function() {
                var data = this._data || [];
                if (this.useAggregation()) {
                    data = this._resample(this.getArgumentAxis().getAggregationInfo(this._useAllAggregatedPoints, this.argumentAxisType !== DISCRETE ? this.getArgumentRange() : {}), data)
                }
                return data
            },
            useAggregation: function() {
                var aggregation = this.getOptions().aggregation;
                return aggregation && aggregation.enabled
            },
            autoHidePointMarkersEnabled: _common.noop,
            usePointsToDefineAutoHiding: _common.noop,
            createPoints: function(useAllAggregatedPoints) {
                this._normalizeUsingAllAggregatedPoints(useAllAggregatedPoints);
                this._createPoints()
            },
            _normalizeUsingAllAggregatedPoints: function(useAllAggregatedPoints) {
                this._useAllAggregatedPoints = this.useAggregation() && (this.argumentAxisType === DISCRETE || (this._data || []).length > 1 && !!useAllAggregatedPoints)
            },
            _createPoints: function() {
                var that = this;
                var oldPointsByArgument = that.pointsByArgument || {};
                var data = that._getData();
                that.pointsByArgument = {};
                that._calculateErrorBars(data);
                var skippedFields = {};
                var points = data.reduce(function(points, pointDataItem) {
                    if (that._checkData(pointDataItem, skippedFields)) {
                        var pointIndex = points.length;
                        var oldPoint = that._getOldPoint(pointDataItem, oldPointsByArgument, pointIndex);
                        var point = that._createPoint(pointDataItem, pointIndex, oldPoint);
                        points.push(point)
                    }
                    return points
                }, []);
                for (var field in skippedFields) {
                    if (skippedFields[field] === data.length) {
                        that._incidentOccurred("W2002", [that.name, field])
                    }
                }
                Object.keys(oldPointsByArgument).forEach(function(key) {
                    return that._disposePoints(oldPointsByArgument[key])
                });
                that._points = points
            },
            _removeOldSegments: function() {
                var that = this;
                var startIndex = that._segments.length;
                (0, _iterator.each)(that._graphics.splice(startIndex, that._graphics.length) || [], function(_, elem) {
                    that._removeElement(elem)
                });
                if (that._trackers) {
                    (0, _iterator.each)(that._trackers.splice(startIndex, that._trackers.length) || [], function(_, elem) {
                        elem.remove()
                    })
                }
            },
            _drawElements: function(animationEnabled, firstDrawing, translateAllPoints) {
                var that = this;
                var points = that._points || [];
                var closeSegment = points[0] && points[0].hasValue() && that._options.closed;
                var groupForPoint = {
                    markers: that._markersGroup,
                    errorBars: that._errorBarGroup
                };
                that._drawnPoints = [];
                that._graphics = that._graphics || [];
                that._segments = [];
                var segments = points.reduce(function(segments, p) {
                    var segment = segments[segments.length - 1];
                    if (!p.translated || translateAllPoints) {
                        p.translate();
                        !translateAllPoints && p.setDefaultCoords()
                    }
                    if (p.hasValue() && p.hasCoords()) {
                        translateAllPoints && that._drawPoint({
                            point: p,
                            groups: groupForPoint,
                            hasAnimation: animationEnabled,
                            firstDrawing: firstDrawing
                        });
                        segment.push(p)
                    } else {
                        if (!p.hasValue()) {
                            segment.length && segments.push([])
                        } else {
                            p.setInvisibility()
                        }
                    }
                    return segments
                }, [
                    []
                ]);
                segments.forEach(function(segment, index) {
                    if (segment.length) {
                        that._drawSegment(segment, animationEnabled, index, closeSegment && index === this.length - 1)
                    }
                }, segments);
                that._firstDrawing = !points.length;
                that._removeOldSegments();
                animationEnabled && that._animate(firstDrawing)
            },
            draw: function(animationEnabled, hideLayoutLabels, legendCallback) {
                var that = this;
                var firstDrawing = that._firstDrawing;
                that._legendCallback = legendCallback || that._legendCallback;
                if (!that._visible) {
                    animationEnabled = false;
                    that._group.remove();
                    return
                }
                that._appendInGroup();
                that._applyVisibleArea();
                that._setGroupsSettings(animationEnabled, firstDrawing);
                !firstDrawing && that._drawElements(false, firstDrawing, false);
                that._drawElements(animationEnabled, firstDrawing, true);
                hideLayoutLabels && that.hideLabels();
                if (that.isSelected()) {
                    that._changeStyle(that.lastSelectionMode, void 0, true)
                } else {
                    if (that.isHovered()) {
                        that._changeStyle(that.lastHoverMode, void 0, true)
                    } else {
                        that._applyStyle(that._styles.normal)
                    }
                }
            },
            _setLabelGroupSettings: function(animationEnabled) {
                var settings = {
                    "class": "dxc-labels",
                    "pointer-events": "none"
                };
                this._clipLabels && this._applyElementsClipRect(settings);
                this._applyClearingSettings(settings);
                animationEnabled && (settings.opacity = .001);
                this._labelsGroup.attr(settings).append(this._extGroups.labelsGroup)
            },
            _checkType: function(widgetType) {
                return !!seriesNS.mixins[widgetType][this.type]
            },
            _checkPolarBarType: function(widgetType, options) {
                return "polar" === widgetType && options.spiderWidget && this.type.indexOf("bar") !== -1
            },
            _resetType: function(seriesType, widgetType) {
                var methodName;
                var methods;
                if (seriesType) {
                    methods = seriesNS.mixins[widgetType][seriesType];
                    for (methodName in methods) {
                        delete this[methodName]
                    }
                }
            },
            _setType: function(seriesType, widgetType) {
                var methodName;
                var methods = seriesNS.mixins[widgetType][seriesType];
                for (methodName in methods) {
                    this[methodName] = methods[methodName]
                }
            },
            _setPointsView: function(view, target) {
                this.getPoints().forEach(function(point) {
                    if (target !== point) {
                        point.setView(view)
                    }
                })
            },
            _resetPointsView: function(view, target) {
                this.getPoints().forEach(function(point) {
                    if (target !== point) {
                        point.resetView(view)
                    }
                })
            },
            _resetNearestPoint: function() {
                var that = this;
                that._nearestPoint && null !== that._nearestPoint.series && that._nearestPoint.resetView(HOVER);
                that._nearestPoint = null
            },
            _setSelectedState: function(mode) {
                var that = this;
                that.lastSelectionMode = (0, _utils.normalizeEnum)(mode || that._options.selectionMode);
                that.fullState = that.fullState | SELECTED_STATE;
                that._resetNearestPoint();
                that._changeStyle(that.lastSelectionMode);
                if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {
                    that._resetPointsView(HOVER)
                }
            },
            _releaseSelectedState: function() {
                var that = this;
                that.fullState = that.fullState & ~SELECTED_STATE;
                that._changeStyle(that.lastSelectionMode, SELECTION);
                if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {
                    that._setPointsView(HOVER)
                }
            },
            isFullStackedSeries: function() {
                return 0 === this.type.indexOf("fullstacked")
            },
            isStackedSeries: function() {
                return 0 === this.type.indexOf("stacked")
            },
            isFinancialSeries: function() {
                return "stock" === this.type || "candlestick" === this.type
            },
            _canChangeView: function() {
                return !this.isSelected() && (0, _utils.normalizeEnum)(this._options.hoverMode) !== NONE_MODE
            },
            _changeStyle: function(mode, resetView, skipPoints) {
                var that = this;
                var state = that.fullState;
                var styles = [NORMAL, HOVER, SELECTION, SELECTION];
                if ("none" === that.lastHoverMode) {
                    state &= ~HOVER_STATE
                }
                if ("none" === that.lastSelectionMode) {
                    state &= ~SELECTED_STATE
                }
                if (includePointsMode(mode) && !skipPoints) {
                    if (!resetView) {
                        that._setPointsView(styles[state])
                    } else {
                        that._resetPointsView(resetView)
                    }
                }
                that._legendCallback([RESET_ITEM, APPLY_HOVER, APPLY_SELECTED, APPLY_SELECTED][state]);
                that._applyStyle(that._styles[styles[state]])
            },
            updateHover: function(x, y) {
                var that = this;
                var currentNearestPoint = that._nearestPoint;
                var point = that.isHovered() && that.lastHoverMode === NEAREST_POINT && that.getNeighborPoint(x, y);
                if (point !== currentNearestPoint && !(that.isSelected() && that.lastSelectionMode !== NONE_MODE)) {
                    that._resetNearestPoint();
                    if (point) {
                        point.setView(HOVER);
                        that._nearestPoint = point
                    }
                }
            },
            _getMainAxisName: function() {
                return this._options.rotated ? "X" : "Y"
            },
            areLabelsVisible: function() {
                return !(0, _type.isDefined)(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount
            },
            getLabelVisibility: function() {
                return this.areLabelsVisible() && this._options.label && this._options.label.visible
            },
            customizePoint: function customizePoint(point, pointData) {
                var that = this;
                var options = that._options;
                var customizePoint = options.customizePoint;
                var customizeObject;
                var pointOptions;
                var customLabelOptions;
                var customOptions;
                var customizeLabel = options.customizeLabel;
                var useLabelCustomOptions;
                var usePointCustomOptions;
                if (customizeLabel && customizeLabel.call) {
                    customizeObject = (0, _extend2.extend)({
                        seriesName: that.name
                    }, pointData);
                    customizeObject.series = that;
                    customLabelOptions = customizeLabel.call(customizeObject, customizeObject);
                    useLabelCustomOptions = customLabelOptions && !(0, _type.isEmptyObject)(customLabelOptions);
                    customLabelOptions = useLabelCustomOptions ? (0, _extend2.extend)(true, {}, options.label, customLabelOptions) : null
                }
                if (customizePoint && customizePoint.call) {
                    customizeObject = customizeObject || (0, _extend2.extend)({
                        seriesName: that.name
                    }, pointData);
                    customizeObject.series = that;
                    customOptions = customizePoint.call(customizeObject, customizeObject);
                    usePointCustomOptions = customOptions && !(0, _type.isEmptyObject)(customOptions)
                }
                if (useLabelCustomOptions || usePointCustomOptions) {
                    pointOptions = that._parsePointOptions(that._preparePointOptions(customOptions), customLabelOptions || options.label, pointData, point);
                    pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;
                    pointOptions.styles.usePointCustomOptions = usePointCustomOptions;
                    point.updateOptions(pointOptions)
                }
            },
            show: function() {
                if (!this._visible) {
                    this._changeVisibility(true)
                }
            },
            hide: function() {
                if (this._visible) {
                    this._changeVisibility(false)
                }
            },
            _changeVisibility: function(visibility) {
                var that = this;
                that._visible = that._options.visible = visibility;
                that._updatePointsVisibility();
                that.hidePointTooltip();
                that._options.visibilityChanged(that)
            },
            _updatePointsVisibility: _common.noop,
            hideLabels: function() {
                (0, _iterator.each)(this._points, function(_, point) {
                    point._label.draw(false)
                })
            },
            _parsePointOptions: function(pointOptions, labelOptions, data, point) {
                var that = this;
                var options = that._options;
                var styles = that._createPointStyles(pointOptions, data, point);
                var parsedOptions = (0, _extend2.extend)({}, pointOptions, {
                    type: options.type,
                    rotated: options.rotated,
                    styles: styles,
                    widgetType: options.widgetType,
                    visibilityChanged: options.visibilityChanged
                });
                parsedOptions.label = getLabelOptions(labelOptions, styles.normal.fill);
                if (that.areErrorBarsVisible()) {
                    parsedOptions.errorBars = options.valueErrorBar
                }
                return parsedOptions
            },
            _preparePointOptions: function(customOptions) {
                var pointOptions = this._getOptionsForPoint();
                return customOptions ? mergePointOptions(pointOptions, customOptions) : pointOptions
            },
            _getMarkerGroupOptions: function() {
                return (0, _extend2.extend)(false, {}, this._getOptionsForPoint(), {
                    hoverStyle: {},
                    selectionStyle: {}
                })
            },
            _getAggregationMethod: function(isDiscrete, aggregateByCategory) {
                var options = this.getOptions().aggregation;
                var method = (0, _utils.normalizeEnum)(options.method);
                var customAggregator = "custom" === method && options.calculate;
                var aggregator;
                if (isDiscrete && !aggregateByCategory) {
                    aggregator = function(_ref) {
                        var data = _ref.data;
                        return data[0]
                    }
                } else {
                    aggregator = this._aggregators[method] || this._aggregators[this._defaultAggregator]
                }
                return customAggregator || aggregator
            },
            _resample: function(_ref2, data) {
                var interval = _ref2.interval,
                    ticks = _ref2.ticks,
                    aggregateByCategory = _ref2.aggregateByCategory;
                var that = this;
                var isDiscrete = that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE;
                var dataIndex = 0;
                var dataSelector = this._getPointDataSelector();
                var options = that.getOptions();
                var addAggregatedData = function(target, data, aggregationInfo) {
                    if (!data) {
                        return
                    }
                    var processData = function(d) {
                        var pointData = d && dataSelector(d, options);
                        if (pointData && that._checkData(pointData)) {
                            pointData.aggregationInfo = aggregationInfo;
                            target.push(pointData)
                        }
                    };
                    if (data.length) {
                        data.forEach(processData)
                    } else {
                        processData(data)
                    }
                };
                var aggregationMethod = this._getAggregationMethod(isDiscrete, aggregateByCategory);
                if (isDiscrete) {
                    if (aggregateByCategory) {
                        var categories = this.getArgumentAxis().getTranslator().getBusinessRange().categories;
                        var groups = categories.reduce(function(g, category) {
                            g[category.valueOf()] = [];
                            return g
                        }, {});
                        data.forEach(function(dataItem) {
                            groups[dataItem.argument].push(dataItem)
                        });
                        return categories.reduce(function(result, c) {
                            addAggregatedData(result, aggregationMethod({
                                aggregationInterval: null,
                                intervalStart: c,
                                intervalEnd: c,
                                data: groups[c].map(getData)
                            }, that));
                            return result
                        }, [])
                    } else {
                        return data.reduce(function(result, dataItem, index, data) {
                            result[1].push(dataItem);
                            if (index === data.length - 1 || (index + 1) % interval === 0) {
                                var dataInInterval = result[1];
                                var aggregationInfo = {
                                    aggregationInterval: interval,
                                    data: dataInInterval.map(getData)
                                };
                                addAggregatedData(result[0], aggregationMethod(aggregationInfo, that));
                                result[1] = []
                            }
                            return result
                        }, [
                            [],
                            []
                        ])[0]
                    }
                }
                var aggregatedData = [];
                for (var i = 1; i < ticks.length; i++) {
                    var intervalEnd = ticks[i];
                    var intervalStart = ticks[i - 1];
                    var dataInInterval = [];
                    while (data[dataIndex] && data[dataIndex].argument < intervalEnd) {
                        if (data[dataIndex].argument >= intervalStart) {
                            dataInInterval.push(data[dataIndex])
                        }
                        dataIndex++
                    }
                    var aggregationInfo = {
                        intervalStart: intervalStart,
                        intervalEnd: intervalEnd,
                        aggregationInterval: interval,
                        data: dataInInterval.map(getData)
                    };
                    addAggregatedData(aggregatedData, aggregationMethod(aggregationInfo, that), aggregationInfo)
                }
                that._endUpdateData();
                return aggregatedData
            },
            canRenderCompleteHandle: function() {
                var result = this._canRenderCompleteHandle;
                delete this._canRenderCompleteHandle;
                return !!result
            },
            isHovered: function() {
                return !!(1 & this.fullState)
            },
            isSelected: function() {
                return !!(2 & this.fullState)
            },
            isVisible: function() {
                return this._visible
            },
            getAllPoints: function() {
                this._createAllAggregatedPoints();
                return (this._points || []).slice()
            },
            getPointByPos: function(pos) {
                this._createAllAggregatedPoints();
                return (this._points || [])[pos]
            },
            getVisiblePoints: function() {
                return (this._drawnPoints || []).slice()
            },
            selectPoint: function(point) {
                if (!point.isSelected()) {
                    setPointSelectedState(point, this._legendCallback);
                    this._eventPipe({
                        action: POINT_SELECT,
                        target: point
                    });
                    this._eventTrigger(POINT_SELECTION_CHANGED, {
                        target: point
                    })
                }
            },
            deselectPoint: function(point) {
                if (point.isSelected()) {
                    releasePointSelectedState(point, this._legendCallback);
                    this._eventPipe({
                        action: POINT_DESELECT,
                        target: point
                    });
                    this._eventTrigger(POINT_SELECTION_CHANGED, {
                        target: point
                    })
                }
            },
            hover: function(mode) {
                var that = this;
                var eventTrigger = that._eventTrigger;
                if (that.isHovered()) {
                    return
                }
                that.lastHoverMode = (0, _utils.normalizeEnum)(mode || that._options.hoverMode);
                that.fullState = that.fullState | HOVER_STATE;
                that._changeStyle(that.lastHoverMode, void 0, that.isSelected() && that.lastSelectionMode !== NONE_MODE);
                eventTrigger(SERIES_HOVER_CHANGED, {
                    target: that
                })
            },
            clearHover: function() {
                var that = this;
                var eventTrigger = that._eventTrigger;
                if (!that.isHovered()) {
                    return
                }
                that._resetNearestPoint();
                that.fullState = that.fullState & ~HOVER_STATE;
                that._changeStyle(that.lastHoverMode, HOVER, that.isSelected() && that.lastSelectionMode !== NONE_MODE);
                eventTrigger(SERIES_HOVER_CHANGED, {
                    target: that
                })
            },
            hoverPoint: function(point) {
                var that = this;
                if (!point.isHovered()) {
                    point.clearHover();
                    setPointHoverState(point, that._legendCallback);
                    that._canChangeView() && that._applyStyle(that._styles.hover);
                    that._eventPipe({
                        action: POINT_HOVER,
                        target: point
                    });
                    that._eventTrigger(POINT_HOVER_CHANGED, {
                        target: point
                    })
                }
            },
            clearPointHover: function() {
                var that = this;
                that.getPoints().some(function(currentPoint) {
                    if (currentPoint.isHovered()) {
                        releasePointHoverState(currentPoint, that._legendCallback);
                        that._canChangeView() && that._applyStyle(that._styles.normal);
                        that._eventPipe({
                            action: CLEAR_POINT_HOVER,
                            target: currentPoint
                        });
                        that._eventTrigger(POINT_HOVER_CHANGED, {
                            target: currentPoint
                        });
                        return true
                    }
                    return false
                })
            },
            showPointTooltip: function(point) {
                triggerEvent(this._extGroups.seriesGroup, "showpointtooltip", point)
            },
            hidePointTooltip: function(point) {
                triggerEvent(this._extGroups.seriesGroup, "hidepointtooltip", point)
            },
            select: function() {
                var that = this;
                if (!that.isSelected()) {
                    that._setSelectedState(that._options.selectionMode);
                    that._eventPipe({
                        action: SERIES_SELECT,
                        target: that
                    });
                    that._group.toForeground();
                    that._eventTrigger(SERIES_SELECTION_CHANGED, {
                        target: that
                    })
                }
            },
            clearSelection: function() {
                var that = this;
                if (that.isSelected()) {
                    that._releaseSelectedState();
                    that._eventTrigger(SERIES_SELECTION_CHANGED, {
                        target: that
                    })
                }
            },
            getPointsByArg: function(arg, skipPointsCreation) {
                var that = this;
                var argValue = arg.valueOf();
                var points = that.pointsByArgument[argValue];
                if (!points && !skipPointsCreation && that._createAllAggregatedPoints()) {
                    points = that.pointsByArgument[argValue]
                }
                return points || []
            },
            _createAllAggregatedPoints: function() {
                if (this.useAggregation() && !this._useAllAggregatedPoints) {
                    this.createPoints(true);
                    return true
                }
                return false
            },
            getPointsByKeys: function(arg) {
                return this.getPointsByArg(arg)
            },
            notify: function(data) {
                var that = this;
                var action = data.action;
                var seriesModes = that._seriesModes;
                var target = data.target;
                var targetOptions = target.getOptions();
                var pointHoverMode = (0, _utils.normalizeEnum)(targetOptions.hoverMode);
                var selectionModeOfPoint = (0, _utils.normalizeEnum)(targetOptions.selectionMode);
                if (action === POINT_HOVER) {
                    that._hoverPointHandler(target, pointHoverMode, data.notifyLegend)
                } else {
                    if (action === CLEAR_POINT_HOVER) {
                        that._clearPointHoverHandler(target, pointHoverMode, data.notifyLegend)
                    } else {
                        if (action === SERIES_SELECT) {
                            target !== that && "single" === seriesModes.seriesSelectionMode && that.clearSelection()
                        } else {
                            if (action === POINT_SELECT) {
                                if ("single" === seriesModes.pointSelectionMode) {
                                    that.getPoints().some(function(currentPoint) {
                                        if (currentPoint !== target && currentPoint.isSelected()) {
                                            that.deselectPoint(currentPoint);
                                            return true
                                        }
                                        return false
                                    })
                                }
                                that._selectPointHandler(target, selectionModeOfPoint)
                            } else {
                                if (action === POINT_DESELECT) {
                                    that._deselectPointHandler(target, selectionModeOfPoint)
                                }
                            }
                        }
                    }
                }
            },
            _selectPointHandler: function(target, mode) {
                var that = this;
                if (mode === ALL_SERIES_POINTS) {
                    target.series === that && that._setPointsView(SELECTION, target)
                } else {
                    if (mode === ALL_ARGUMENT_POINTS) {
                        that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function(currentPoint) {
                            currentPoint !== target && currentPoint.setView(SELECTION)
                        })
                    }
                }
            },
            _deselectPointHandler: function(target, mode) {
                if (mode === ALL_SERIES_POINTS) {
                    target.series === this && this._resetPointsView(SELECTION, target)
                } else {
                    if (mode === ALL_ARGUMENT_POINTS) {
                        this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function(currentPoint) {
                            currentPoint !== target && currentPoint.resetView(SELECTION)
                        })
                    }
                }
            },
            _hoverPointHandler: function(target, mode, notifyLegend) {
                var that = this;
                if (target.series !== that && mode === ALL_ARGUMENT_POINTS) {
                    that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function(currentPoint) {
                        currentPoint.setView(HOVER)
                    });
                    notifyLegend && that._legendCallback(target)
                } else {
                    if (mode === ALL_SERIES_POINTS && target.series === that) {
                        that._setPointsView(HOVER, target)
                    }
                }
            },
            _clearPointHoverHandler: function(target, mode, notifyLegend) {
                var that = this;
                if (mode === ALL_ARGUMENT_POINTS) {
                    target.series !== that && that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function(currentPoint) {
                        currentPoint.resetView(HOVER)
                    });
                    notifyLegend && that._legendCallback(target)
                } else {
                    if (mode === ALL_SERIES_POINTS && target.series === that) {
                        that._resetPointsView(HOVER, target)
                    }
                }
            },
            _deletePoints: function() {
                var that = this;
                that._disposePoints(that._points);
                that._points = that._drawnPoints = null
            },
            _deleteTrackers: function() {
                var that = this;
                (0, _iterator.each)(that._trackers || [], function(_, tracker) {
                    tracker.remove()
                });
                that._trackersGroup && that._trackersGroup.dispose();
                that._trackers = that._trackersGroup = null
            },
            dispose: function() {
                var that = this;
                that._deletePoints();
                that._group.dispose();
                that._labelsGroup && that._labelsGroup.dispose();
                that._errorBarGroup && that._errorBarGroup.dispose();
                that._deleteTrackers();
                that._group = that._extGroups = that._markersGroup = that._elementsGroup = that._bordersGroup = that._labelsGroup = that._errorBarGroup = that._graphics = that._rangeData = that._renderer = that._styles = that._options = that._pointOptions = that._drawnPoints = that.pointsByArgument = that._segments = that._prevSeries = null
            },
            correctPosition: _common.noop,
            drawTrackers: _common.noop,
            getNeighborPoint: _common.noop,
            areErrorBarsVisible: _common.noop,
            getMarginOptions: function() {
                return this._patchMarginOptions({
                    percentStick: this.isFullStackedSeries()
                })
            },
            getColor: function() {
                return this.getLegendStyles().normal.fill
            },
            getOpacity: function() {
                return this._options.opacity
            },
            getStackName: function() {
                return this._stackName
            },
            getBarOverlapGroup: function() {
                return this._options.barOverlapGroup
            },
            getPointByCoord: function(x, y) {
                var point = this.getNeighborPoint(x, y);
                return (null === point || void 0 === point ? void 0 : point.coordsIn(x, y)) ? point : null
            },
            getValueAxis: function() {
                return this._valueAxis
            },
            getArgumentAxis: function() {
                return this._argumentAxis
            },
            getMarkersGroup: function() {
                return this._markersGroup
            },
            getRenderer: function() {
                return this._renderer
            }
        }
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/label.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _format_helper = __webpack_require__( /*! ../../../format_helper */ 63);
        var _utils = __webpack_require__( /*! ../../core/utils */ 13);
        var _iterator = __webpack_require__( /*! ../../../core/utils/iterator */ 4);
        var _extend = __webpack_require__( /*! ../../../core/utils/extend */ 0);
        var _math = Math;
        var _round = _math.round;
        var _floor = _math.floor;
        var _abs = _math.abs;
        var CONNECTOR_LENGTH = 12;
        var LABEL_BACKGROUND_PADDING_X = 8;
        var LABEL_BACKGROUND_PADDING_Y = 4;

        function getClosestCoord(point, coords) {
            var closestDistance = 1 / 0;
            var closestCoord;
            (0, _iterator.each)(coords, function(_, coord) {
                var x = point[0] - coord[0];
                var y = point[1] - coord[1];
                var distance = x * x + y * y;
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestCoord = coord
                }
            });
            return [_floor(closestCoord[0]), _floor(closestCoord[1])]
        }

        function getCrossCoord(rect, coord, indexOffset) {
            return (coord - rect[0 + indexOffset]) / (rect[2 + indexOffset] - rect[0 + indexOffset]) * (rect[3 - indexOffset] - rect[1 - indexOffset]) + rect[1 - indexOffset]
        }
        var barPointStrategy = {
            isLabelInside: function(labelPoint, figure) {
                var xc = labelPoint.x + labelPoint.width / 2;
                var yc = labelPoint.y + labelPoint.height / 2;
                return figure.x <= xc && xc <= figure.x + figure.width && figure.y <= yc && yc <= figure.y + figure.height
            },
            prepareLabelPoints: function(bBox, rotatedBBox, isHorizontal, angle, figureCenter) {
                var x1 = rotatedBBox.x;
                var xc = x1 + rotatedBBox.width / 2;
                var x2 = x1 + rotatedBBox.width - 1;
                var y1 = rotatedBBox.y;
                var yc = y1 + rotatedBBox.height / 2;
                var y2 = y1 + rotatedBBox.height - 1;
                var labelPoints;
                var isRectangular = _abs(angle) % 90 === 0;
                if (figureCenter[0] > x1 && figureCenter[0] < x2) {
                    if (isRectangular) {
                        labelPoints = [
                            [figureCenter[0], _abs(figureCenter[1] - y1) < _abs(figureCenter[1] - y2) ? y1 : y2]
                        ]
                    } else {
                        labelPoints = [
                            [figureCenter[0], getCrossCoord([x1, y1, x2, y2], figureCenter[0], 0)]
                        ]
                    }
                } else {
                    if (figureCenter[1] > y1 && figureCenter[1] < y2) {
                        if (isRectangular) {
                            labelPoints = [
                                [_abs(figureCenter[0] - x1) < _abs(figureCenter[0] - x2) ? x1 : x2, figureCenter[1]]
                            ]
                        } else {
                            labelPoints = [
                                [getCrossCoord([x1, y1, x2, y2], figureCenter[1], 1), figureCenter[1]]
                            ]
                        }
                    } else {
                        if (isRectangular) {
                            labelPoints = [
                                [x1, y1],
                                [isHorizontal ? x1 : xc, isHorizontal ? yc : y1],
                                [x2, y1],
                                [x1, y2],
                                [isHorizontal ? x2 : xc, isHorizontal ? yc : y2],
                                [x2, y2]
                            ]
                        } else {
                            labelPoints = [
                                [xc, yc]
                            ]
                        }
                    }
                }
                return labelPoints
            },
            isHorizontal: function(bBox, figure) {
                return bBox.x > figure.x + figure.width || bBox.x + bBox.width < figure.x
            },
            getFigureCenter: function(figure) {
                return [_floor(figure.x + figure.width / 2), _floor(figure.y + figure.height / 2)]
            },
            findFigurePoint: function(figure, labelPoint) {
                var figureCenter = barPointStrategy.getFigureCenter(figure);
                var point = getClosestCoord(labelPoint, [
                    [figure.x, figureCenter[1]],
                    [figureCenter[0], figure.y + figure.height],
                    [figure.x + figure.width, figureCenter[1]],
                    [figureCenter[0], figure.y]
                ]);
                return point
            },
            adjustPoints: function(points) {
                var lineIsVertical = _abs(points[1] - points[3]) <= 1;
                var lineIsHorizontal = _abs(points[0] - points[2]) <= 1;
                if (lineIsHorizontal) {
                    points[0] = points[2]
                }
                if (lineIsVertical) {
                    points[1] = points[3]
                }
                return points
            }
        };
        var symbolPointStrategy = {
            isLabelInside: function() {
                return false
            },
            prepareLabelPoints: barPointStrategy.prepareLabelPoints,
            isHorizontal: function(bBox, figure) {
                return bBox.x > figure.x + figure.r || bBox.x + bBox.width < figure.x - figure.r
            },
            getFigureCenter: function(figure) {
                return [figure.x, figure.y]
            },
            findFigurePoint: function(figure, labelPoint) {
                var angle = Math.atan2(figure.y - labelPoint[1], labelPoint[0] - figure.x);
                return [_round(figure.x + figure.r * Math.cos(angle)), _round(figure.y - figure.r * Math.sin(angle))]
            },
            adjustPoints: barPointStrategy.adjustPoints
        };
        var piePointStrategy = {
            isLabelInside: function(_0, _1, isOutside) {
                return !isOutside
            },
            prepareLabelPoints: function(bBox, rotatedBBox, isHorizontal, angle) {
                var xl = bBox.x;
                var xr = xl + bBox.width;
                var xc = xl + _round(bBox.width / 2);
                var yt = bBox.y;
                var yb = yt + bBox.height;
                var yc = yt + _round(bBox.height / 2);
                var points = [
                    [
                        [xl, yt],
                        [xr, yt]
                    ],
                    [
                        [xr, yt],
                        [xr, yb]
                    ],
                    [
                        [xr, yb],
                        [xl, yb]
                    ],
                    [
                        [xl, yb],
                        [xl, yt]
                    ]
                ];
                var cosSin = (0, _utils.getCosAndSin)(angle);
                if (0 === angle) {
                    points = isHorizontal ? [
                        [xl, yc],
                        [xr, yc]
                    ] : [
                        [xc, yt],
                        [xc, yb]
                    ]
                } else {
                    points = points.map(function(pair) {
                        return pair.map(function(point) {
                            return [_round((point[0] - xc) * cosSin.cos + (point[1] - yc) * cosSin.sin + xc), _round(-(point[0] - xc) * cosSin.sin + (point[1] - yc) * cosSin.cos + yc)]
                        })
                    }).reduce(function(r, pair) {
                        var point1x = pair[0][0];
                        var point1y = pair[0][1];
                        var point2x = pair[1][0];
                        var point2y = pair[1][1];
                        if (isHorizontal) {
                            if (point1y >= yc && yc >= point2y || point1y <= yc && yc <= point2y) {
                                r.push([(yc - point1y) * (point2x - point1x) / (point2y - point1y) + point1x, yc])
                            }
                        } else {
                            if (point1x >= xc && xc >= point2x || point1x <= xc && xc <= point2x) {
                                r.push([xc, (xc - point1x) * (point2y - point1y) / (point2x - point1x) + point1y])
                            }
                        }
                        return r
                    }, [])
                }
                return points
            },
            isHorizontal: function(bBox, figure) {
                return bBox.x > figure.x || figure.x > bBox.x + bBox.width
            },
            getFigureCenter: symbolPointStrategy.getFigureCenter,
            findFigurePoint: function(figure, labelPoint, isHorizontal) {
                if (!isHorizontal) {
                    return [figure.x, figure.y]
                }
                var labelX = labelPoint[0];
                var x = _round(figure.x + (figure.y - labelPoint[1]) / Math.tan((0, _utils.degreesToRadians)(figure.angle)));
                var points = [figure.x, figure.y, x, labelPoint[1]];
                if (!(figure.x <= x && x <= labelX) && !(labelX <= x && x <= figure.x)) {
                    if (_abs(figure.x - labelX) < CONNECTOR_LENGTH) {
                        points = [figure.x, figure.y]
                    } else {
                        if (figure.x <= labelX) {
                            points[2] = figure.x + CONNECTOR_LENGTH
                        } else {
                            points[2] = figure.x - CONNECTOR_LENGTH
                        }
                    }
                }
                return points
            },
            adjustPoints: function(points) {
                return points
            }
        };

        function selectStrategy(figure) {
            return void 0 !== figure.angle && piePointStrategy || void 0 !== figure.r && symbolPointStrategy || barPointStrategy
        }

        function disposeItem(obj, field) {
            obj[field] && obj[field].dispose();
            obj[field] = null
        }

        function checkBackground(background) {
            return background && (background.fill && "none" !== background.fill || background["stroke-width"] > 0 && background.stroke && "none" !== background.stroke)
        }

        function checkConnector(connector) {
            return connector && connector["stroke-width"] > 0 && connector.stroke && "none" !== connector.stroke
        }

        function formatText(data, options) {
            var format = options.format;
            data.valueText = (0, _format_helper.format)(data.value, format);
            data.argumentText = (0, _format_helper.format)(data.argument, options.argumentFormat);
            if (void 0 !== data.percent) {
                data.percentText = (0, _format_helper.format)(data.percent, {
                    type: "percent",
                    precision: format && format.percentPrecision
                })
            }
            if (void 0 !== data.total) {
                data.totalText = (0, _format_helper.format)(data.total, format)
            }
            if (void 0 !== data.openValue) {
                data.openValueText = (0, _format_helper.format)(data.openValue, format)
            }
            if (void 0 !== data.closeValue) {
                data.closeValueText = (0, _format_helper.format)(data.closeValue, format)
            }
            if (void 0 !== data.lowValue) {
                data.lowValueText = (0, _format_helper.format)(data.lowValue, format)
            }
            if (void 0 !== data.highValue) {
                data.highValueText = (0, _format_helper.format)(data.highValue, format)
            }
            if (void 0 !== data.reductionValue) {
                data.reductionValueText = (0, _format_helper.format)(data.reductionValue, format)
            }
            return options.customizeText ? options.customizeText.call(data, data) : data.valueText
        }

        function Label(renderSettings) {
            this._renderer = renderSettings.renderer;
            this._container = renderSettings.labelsGroup;
            this._point = renderSettings.point;
            this._strategy = renderSettings.strategy;
            this._rowCount = 1
        }
        Label.prototype = {
            constructor: Label,
            setColor: function(color) {
                this._color = color
            },
            setOptions: function(options) {
                this._options = options
            },
            setData: function(data) {
                this._data = data
            },
            setDataField: function(fieldName, fieldValue) {
                this._data = this._data || {};
                this._data[fieldName] = fieldValue
            },
            getData: function() {
                return this._data
            },
            setFigureToDrawConnector: function(figure) {
                this._figure = figure
            },
            dispose: function() {
                var that = this;
                disposeItem(that, "_group");
                that._data = that._options = that._textContent = that._visible = that._insideGroup = that._text = that._background = that._connector = that._figure = null
            },
            _setVisibility: function(value, state) {
                this._group && this._group.attr({
                    visibility: value
                });
                this._visible = state
            },
            isVisible: function() {
                return this._visible
            },
            hide: function(holdInvisible) {
                this._holdVisibility = !!holdInvisible;
                this._hide()
            },
            _hide: function() {
                this._setVisibility("hidden", false)
            },
            show: function(holdVisible) {
                var correctPosition = !this._drawn;
                if (this._point.hasValue()) {
                    this._holdVisibility = !!holdVisible;
                    this._show();
                    correctPosition && this._point.correctLabelPosition(this)
                }
            },
            _show: function() {
                var that = this;
                var renderer = that._renderer;
                var container = that._container;
                var options = that._options || {};
                var text = that._textContent = formatText(that._data, that._options) || null;
                if (text) {
                    if (!that._group) {
                        that._group = renderer.g().append(container);
                        that._insideGroup = renderer.g().append(that._group);
                        that._text = renderer.text("", 0, 0).append(that._insideGroup)
                    }
                    that._text.css(options.attributes ? (0, _utils.patchFontOptions)(options.attributes.font) : {});
                    if (checkBackground(options.background)) {
                        that._background = that._background || renderer.rect().append(that._insideGroup).toBackground();
                        that._background.attr(options.background);
                        that._color && that._background.attr({
                            fill: that._color
                        })
                    } else {
                        disposeItem(that, "_background")
                    }
                    if (checkConnector(options.connector)) {
                        that._connector = that._connector || renderer.path([], "line").sharp().append(that._group).toBackground();
                        that._connector.attr(options.connector);
                        that._color && that._connector.attr({
                            stroke: that._color
                        })
                    } else {
                        disposeItem(that, "_connector")
                    }
                    that._text.attr({
                        text: text,
                        align: options.textAlignment,
                        "class": options.cssClass
                    });
                    that._updateBackground(that._text.getBBox());
                    that._setVisibility("visible", true);
                    that._drawn = true
                } else {
                    that._hide()
                }
            },
            _getLabelVisibility: function(isVisible) {
                return this._holdVisibility ? this.isVisible() : isVisible
            },
            draw: function(isVisible) {
                if (this._getLabelVisibility(isVisible)) {
                    this._show();
                    this._point && this._point.correctLabelPosition(this)
                } else {
                    this._drawn = false;
                    this._hide()
                }
                return this
            },
            _updateBackground: function(bBox) {
                var that = this;
                if (that._background) {
                    bBox.x -= LABEL_BACKGROUND_PADDING_X;
                    bBox.y -= LABEL_BACKGROUND_PADDING_Y;
                    bBox.width += 2 * LABEL_BACKGROUND_PADDING_X;
                    bBox.height += 2 * LABEL_BACKGROUND_PADDING_Y;
                    that._background.attr(bBox)
                }
                that._bBoxWithoutRotation = (0, _extend.extend)({}, bBox);
                var rotationAngle = that._options.rotationAngle || 0;
                that._insideGroup.rotate(rotationAngle, bBox.x + bBox.width / 2, bBox.y + bBox.height / 2);
                bBox = (0, _utils.rotateBBox)(bBox, [bBox.x + bBox.width / 2, bBox.y + bBox.height / 2], -rotationAngle);
                that._bBox = bBox
            },
            getFigureCenter: function() {
                var figure = this._figure;
                var strategy = this._strategy || selectStrategy(figure);
                return strategy.getFigureCenter(figure)
            },
            _getConnectorPoints: function() {
                var that = this;
                var figure = that._figure;
                var options = that._options;
                var strategy = that._strategy || selectStrategy(figure);
                var bBox = that._shiftBBox(that._bBoxWithoutRotation);
                var rotatedBBox = that.getBoundingRect();
                var labelPoint;
                var points = [];
                var isHorizontal;
                if (!strategy.isLabelInside(bBox, figure, "inside" !== options.position)) {
                    isHorizontal = strategy.isHorizontal(bBox, figure);
                    var figureCenter = that.getFigureCenter();
                    points = strategy.prepareLabelPoints(bBox, rotatedBBox, isHorizontal, -options.rotationAngle || 0, figureCenter);
                    labelPoint = getClosestCoord(figureCenter, points);
                    points = strategy.findFigurePoint(figure, labelPoint, isHorizontal);
                    points = points.concat(labelPoint)
                }
                return strategy.adjustPoints(points)
            },
            fit: function(maxWidth) {
                var padding = this._background ? 2 * LABEL_BACKGROUND_PADDING_X : 0;
                var rowCountChanged = false;
                if (this._text) {
                    var result = this._text.setMaxSize(maxWidth - padding, void 0, this._options);
                    var rowCount = result.rowCount;
                    if (0 === rowCount) {
                        rowCount = 1
                    }
                    if (rowCount !== this._rowCount) {
                        rowCountChanged = true;
                        this._rowCount = rowCount
                    }
                    result.textIsEmpty && disposeItem(this, "_background")
                }
                this._updateBackground(this._text.getBBox());
                return rowCountChanged
            },
            resetEllipsis: function() {
                this._text && this._text.restoreText();
                this._updateBackground(this._text.getBBox())
            },
            setTrackerData: function(point) {
                this._text.data({
                    "chart-data-point": point
                });
                this._background && this._background.data({
                    "chart-data-point": point
                })
            },
            hideInsideLabel: function(coords) {
                return this._point.hideInsideLabel(this, coords)
            },
            getPoint: function() {
                return this._point
            },
            shift: function(x, y) {
                var that = this;
                if (that._textContent) {
                    that._insideGroup.attr({
                        translateX: that._x = _round(x - that._bBox.x),
                        translateY: that._y = _round(y - that._bBox.y)
                    });
                    if (that._connector) {
                        that._connector.attr({
                            points: that._getConnectorPoints()
                        })
                    }
                }
                return that
            },
            getBoundingRect: function() {
                return this._shiftBBox(this._bBox)
            },
            _shiftBBox: function(bBox) {
                return this._textContent ? {
                    x: bBox.x + this._x,
                    y: bBox.y + this._y,
                    width: bBox.width,
                    height: bBox.height
                } : {}
            },
            getLayoutOptions: function() {
                var options = this._options;
                return {
                    alignment: options.alignment,
                    background: checkBackground(options.background),
                    horizontalOffset: options.horizontalOffset,
                    verticalOffset: options.verticalOffset,
                    radialOffset: options.radialOffset,
                    position: options.position,
                    connectorOffset: (checkConnector(options.connector) ? CONNECTOR_LENGTH : 0) + (checkBackground(options.background) ? LABEL_BACKGROUND_PADDING_X : 0)
                }
            }
        };
        exports.Label = Label;
        Label._DEBUG_formatText = formatText
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/axes_constants.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        module.exports = {
            logarithmic: "logarithmic",
            discrete: "discrete",
            numeric: "numeric",
            left: "left",
            right: "right",
            top: "top",
            bottom: "bottom",
            center: "center",
            horizontal: "horizontal",
            vertical: "vertical",
            convertTicksToValues: function(ticks) {
                return (0, _utils.map)(ticks || [], function(item) {
                    return item.value
                })
            },
            validateOverlappingMode: function(mode) {
                return "ignore" === mode || "none" === mode ? mode : "hide"
            },
            getTicksCountInRange: function(ticks, valueKey, range) {
                var i = 1;
                if (ticks.length > 1) {
                    for (; i < ticks.length; i++) {
                        if (Math.abs(ticks[i].coords[valueKey] - ticks[0].coords[valueKey]) >= range) {
                            break
                        }
                    }
                }
                return i
            },
            areLabelsOverlap: function(bBox1, bBox2, spacing, alignment) {
                var horizontalInverted = bBox1.x > bBox2.x;
                var verticalInverted = bBox1.y > bBox2.y;
                var x1 = bBox1.x;
                var x2 = bBox2.x;
                var width1 = bBox1.width;
                var width2 = bBox2.width;
                if ("left" === alignment) {
                    x1 += width1 / 2;
                    x2 += width2 / 2
                } else {
                    if ("right" === alignment) {
                        x1 -= width1 / 2;
                        x2 -= width2 / 2
                    }
                }
                var hasHorizontalOverlapping = horizontalInverted ? x2 + width2 + spacing > x1 : x1 + width1 + spacing > x2;
                var hasVerticalOverlapping = verticalInverted ? bBox2.y + bBox2.height > bBox1.y : bBox1.y + bBox1.height > bBox2.y;
                return hasHorizontalOverlapping && hasVerticalOverlapping
            }
        }
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/viz/translators/translator2d.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _range = __webpack_require__( /*! ./range */ 112);
        var _category_translator = __webpack_require__( /*! ./category_translator */ 829);
        var _category_translator2 = _interopRequireDefault(_category_translator);
        var _interval_translator = __webpack_require__( /*! ./interval_translator */ 830);
        var _interval_translator2 = _interopRequireDefault(_interval_translator);
        var _datetime_translator = __webpack_require__( /*! ./datetime_translator */ 831);
        var _datetime_translator2 = _interopRequireDefault(_datetime_translator);
        var _logarithmic_translator = __webpack_require__( /*! ./logarithmic_translator */ 832);
        var _logarithmic_translator2 = _interopRequireDefault(_logarithmic_translator);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _math = __webpack_require__( /*! ../../core/utils/math */ 31);
        var _date = __webpack_require__( /*! ../../core/utils/date */ 24);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _abs = Math.abs;
        var CANVAS_PROP = ["width", "height", "left", "top", "bottom", "right"];
        var _Translator2d;
        var dummyTranslator = {
            to: function(value) {
                var coord = this._canvasOptions.startPoint + (this._options.conversionValue ? value : Math.round(value));
                return coord > this._canvasOptions.endPoint ? this._canvasOptions.endPoint : coord
            },
            from: function(value) {
                return value - this._canvasOptions.startPoint
            }
        };
        var validateCanvas = function(canvas) {
            (0, _iterator.each)(CANVAS_PROP, function(_, prop) {
                canvas[prop] = parseInt(canvas[prop]) || 0
            });
            return canvas
        };
        var makeCategoriesToPoints = function(categories) {
            var categoriesToPoints = {};
            categories.forEach(function(item, i) {
                categoriesToPoints[item.valueOf()] = i
            });
            return categoriesToPoints
        };
        var validateBusinessRange = function(businessRange) {
            if (!(businessRange instanceof _range.Range)) {
                businessRange = new _range.Range(businessRange)
            }

            function validate(valueSelector, baseValueSelector) {
                if (!(0, _type.isDefined)(businessRange[valueSelector]) && (0, _type.isDefined)(businessRange[baseValueSelector])) {
                    businessRange[valueSelector] = businessRange[baseValueSelector]
                }
            }
            validate("minVisible", "min");
            validate("maxVisible", "max");
            return businessRange
        };

        function prepareBreaks(breaks, range) {
            var transform = "logarithmic" === range.axisType ? function(value) {
                return (0, _utils.getLogExt)(value, range.base)
            } : function(value) {
                return value
            };
            var array = [];
            var br;
            var transformFrom;
            var transformTo;
            var i;
            var length = breaks.length;
            var sum = 0;
            for (i = 0; i < length; i++) {
                br = breaks[i];
                transformFrom = transform(br.from);
                transformTo = transform(br.to);
                sum += transformTo - transformFrom;
                array.push({
                    trFrom: transformFrom,
                    trTo: transformTo,
                    from: br.from,
                    to: br.to,
                    length: sum,
                    cumulativeWidth: br.cumulativeWidth
                })
            }
            return array
        }

        function getCanvasBounds(range) {
            var min = range.min;
            var max = range.max;
            var minVisible = range.minVisible;
            var maxVisible = range.maxVisible;
            var isLogarithmic = "logarithmic" === range.axisType;
            if (isLogarithmic) {
                maxVisible = (0, _utils.getLogExt)(maxVisible, range.base, range.allowNegatives, range.linearThreshold);
                minVisible = (0, _utils.getLogExt)(minVisible, range.base, range.allowNegatives, range.linearThreshold);
                min = (0, _utils.getLogExt)(min, range.base, range.allowNegatives, range.linearThreshold);
                max = (0, _utils.getLogExt)(max, range.base, range.allowNegatives, range.linearThreshold)
            }
            return {
                base: range.base,
                rangeMin: min,
                rangeMax: max,
                rangeMinVisible: minVisible,
                rangeMaxVisible: maxVisible
            }
        }

        function getCheckingMethodsAboutBreaks(inverted) {
            return {
                isStartSide: !inverted ? function(pos, breaks, start, end) {
                    return pos < breaks[0][start]
                } : function(pos, breaks, start, end) {
                    return pos <= breaks[breaks.length - 1][end]
                },
                isEndSide: !inverted ? function(pos, breaks, start, end) {
                    return pos >= breaks[breaks.length - 1][end]
                } : function(pos, breaks, start, end) {
                    return pos > breaks[0][start]
                },
                isInBreak: !inverted ? function(pos, br, start, end) {
                    return pos >= br[start] && pos < br[end]
                } : function(pos, br, start, end) {
                    return pos > br[end] && pos <= br[start]
                },
                isBetweenBreaks: !inverted ? function(pos, br, prevBreak, start, end) {
                    return pos < br[start] && pos >= prevBreak[end]
                } : function(pos, br, prevBreak, start, end) {
                    return pos >= br[end] && pos < prevBreak[start]
                },
                getLength: !inverted ? function(br) {
                    return br.length
                } : function(br, lastBreak) {
                    return lastBreak.length - br.length
                },
                getBreaksSize: !inverted ? function(br) {
                    return br.cumulativeWidth
                } : function(br, lastBreak) {
                    return lastBreak.cumulativeWidth - br.cumulativeWidth
                }
            }
        }
        exports.Translator2D = _Translator2d = function(businessRange, canvas, options) {
            this.update(businessRange, canvas, options)
        };
        _Translator2d.prototype = {
            constructor: _Translator2d,
            reinit: function() {
                var that = this;
                var options = that._options;
                var range = that._businessRange;
                var categories = range.categories || [];
                var script = {};
                var canvasOptions = that._prepareCanvasOptions();
                var visibleCategories = (0, _utils.getCategoriesInfo)(categories, range.minVisible, range.maxVisible).categories;
                var categoriesLength = visibleCategories.length;
                if (range.isEmpty()) {
                    script = dummyTranslator
                } else {
                    switch (range.axisType) {
                        case "logarithmic":
                            script = _logarithmic_translator2.default;
                            break;
                        case "semidiscrete":
                            script = _interval_translator2.default;
                            canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / ((0, _date.addInterval)(canvasOptions.rangeMaxVisible, options.interval) - canvasOptions.rangeMinVisible);
                            break;
                        case "discrete":
                            script = _category_translator2.default;
                            that._categories = categories;
                            canvasOptions.interval = that._getDiscreteInterval(options.addSpiderCategory ? categoriesLength + 1 : categoriesLength, canvasOptions);
                            that._categoriesToPoints = makeCategoriesToPoints(categories, canvasOptions.invert);
                            if (categoriesLength) {
                                canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[0].valueOf()];
                                that.visibleCategories = visibleCategories
                            }
                            break;
                        default:
                            if ("datetime" === range.dataType) {
                                script = _datetime_translator2.default
                            }
                    }
                }(that._oldMethods || []).forEach(function(methodName) {
                    delete that[methodName]
                });
                that._oldMethods = Object.keys(script);
                (0, _extend.extend)(that, script);
                that._conversionValue = options.conversionValue ? function(value) {
                    return value
                } : function(value) {
                    return Math.round(value)
                };
                that.sc = {};
                that._checkingMethodsAboutBreaks = [getCheckingMethodsAboutBreaks(false), getCheckingMethodsAboutBreaks(that.isInverted())];
                that._translateBreaks();
                that._calculateSpecialValues()
            },
            _translateBreaks: function() {
                var breaks = this._breaks;
                var size = this._options.breaksSize;
                var i;
                var b;
                var end;
                var length;
                if (void 0 === breaks) {
                    return
                }
                for (i = 0, length = breaks.length; i < length; i++) {
                    b = breaks[i];
                    end = this.translate(b.to);
                    b.end = end;
                    b.start = !b.gapSize ? !this.isInverted() ? end - size : end + size : end
                }
            },
            _checkValueAboutBreaks: function(breaks, pos, start, end, methods) {
                var i;
                var length;
                var prop = {
                    length: 0,
                    breaksSize: void 0,
                    inBreak: false
                };
                var br;
                var prevBreak;
                var lastBreak = breaks[breaks.length - 1];
                if (methods.isStartSide(pos, breaks, start, end)) {
                    return prop
                } else {
                    if (methods.isEndSide(pos, breaks, start, end)) {
                        return {
                            length: lastBreak.length,
                            breaksSize: lastBreak.cumulativeWidth,
                            inBreak: false
                        }
                    }
                }
                for (i = 0, length = breaks.length; i < length; i++) {
                    br = breaks[i];
                    prevBreak = breaks[i - 1];
                    if (methods.isInBreak(pos, br, start, end)) {
                        prop.inBreak = true;
                        prop.break = br;
                        break
                    }
                    if (prevBreak && methods.isBetweenBreaks(pos, br, prevBreak, start, end)) {
                        prop = {
                            length: methods.getLength(prevBreak, lastBreak),
                            breaksSize: methods.getBreaksSize(prevBreak, lastBreak),
                            inBreak: false
                        };
                        break
                    }
                }
                return prop
            },
            isInverted: function() {
                return !(this._options.isHorizontal ^ this._businessRange.invert)
            },
            _getDiscreteInterval: function(categoriesLength, canvasOptions) {
                var correctedCategoriesCount = categoriesLength - (this._options.stick ? 1 : 0);
                return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength
            },
            _prepareCanvasOptions: function() {
                var that = this;
                var businessRange = that._businessRange;
                var canvasOptions = that._canvasOptions = getCanvasBounds(businessRange);
                var canvas = that._canvas;
                var breaks = that._breaks;
                var length;
                canvasOptions.startPadding = canvas.startPadding || 0;
                canvasOptions.endPadding = canvas.endPadding || 0;
                if (that._options.isHorizontal) {
                    canvasOptions.startPoint = canvas.left + canvasOptions.startPadding;
                    length = canvas.width;
                    canvasOptions.endPoint = canvas.width - canvas.right - canvasOptions.endPadding;
                    canvasOptions.invert = businessRange.invert
                } else {
                    canvasOptions.startPoint = canvas.top + canvasOptions.startPadding;
                    length = canvas.height;
                    canvasOptions.endPoint = canvas.height - canvas.bottom - canvasOptions.endPadding;
                    canvasOptions.invert = !businessRange.invert
                }
                that.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;
                canvasOptions.rangeDoubleError = Math.pow(10, (0, _utils.getPower)(canvasOptions.rangeMax - canvasOptions.rangeMin) - (0, _utils.getPower)(length) - 2);
                canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);
                if (void 0 !== breaks) {
                    canvasOptions.ratioOfCanvasRange = (canvasOptions.canvasLength - breaks[breaks.length - 1].cumulativeWidth) / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible - breaks[breaks.length - 1].length)
                }
                return canvasOptions
            },
            updateCanvas: function(canvas) {
                this._canvas = validateCanvas(canvas);
                this.reinit()
            },
            updateBusinessRange: function(businessRange) {
                var that = this;
                var breaks = businessRange.breaks || [];
                that._businessRange = validateBusinessRange(businessRange);
                that._breaks = breaks.length ? prepareBreaks(breaks, that._businessRange) : void 0;
                that.reinit()
            },
            update: function(businessRange, canvas, options) {
                var that = this;
                that._options = (0, _extend.extend)(that._options || {}, options);
                that._canvas = validateCanvas(canvas);
                that.updateBusinessRange(businessRange)
            },
            getBusinessRange: function() {
                return this._businessRange
            },
            getEventScale: function(zoomEvent) {
                return zoomEvent.deltaScale || 1
            },
            getCanvasVisibleArea: function() {
                return {
                    min: this._canvasOptions.startPoint,
                    max: this._canvasOptions.endPoint
                }
            },
            _calculateSpecialValues: function() {
                var that = this;
                var canvasOptions = that._canvasOptions;
                var startPoint = canvasOptions.startPoint - canvasOptions.startPadding;
                var endPoint = canvasOptions.endPoint + canvasOptions.endPadding;
                var range = that._businessRange;
                var minVisible = range.minVisible;
                var maxVisible = range.maxVisible;
                var canvas_position_center_middle = startPoint + canvasOptions.canvasLength / 2;
                var canvas_position_default;
                if (minVisible < 0 && maxVisible > 0 && minVisible !== maxVisible) {
                    canvas_position_default = that.translate(0, 1)
                }
                if (!(0, _type.isDefined)(canvas_position_default)) {
                    var invert = range.invert ^ (minVisible < 0 && maxVisible <= 0);
                    if (that._options.isHorizontal) {
                        canvas_position_default = invert ? endPoint : startPoint
                    } else {
                        canvas_position_default = invert ? startPoint : endPoint
                    }
                }
                that.sc = {
                    canvas_position_default: canvas_position_default,
                    canvas_position_left: startPoint,
                    canvas_position_top: startPoint,
                    canvas_position_center: canvas_position_center_middle,
                    canvas_position_middle: canvas_position_center_middle,
                    canvas_position_right: endPoint,
                    canvas_position_bottom: endPoint,
                    canvas_position_start: canvasOptions.invert ? endPoint : startPoint,
                    canvas_position_end: canvasOptions.invert ? startPoint : endPoint
                }
            },
            translateSpecialCase: function(value) {
                return this.sc[value]
            },
            _calculateProjection: function(distance) {
                var canvasOptions = this._canvasOptions;
                return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance
            },
            _calculateUnProjection: function(distance) {
                var canvasOptions = this._canvasOptions;
                return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance
            },
            getMinBarSize: function(minBarSize) {
                var visibleArea = this.getCanvasVisibleArea();
                var minValue = this.from(visibleArea.min + minBarSize);
                return _abs(this.from(visibleArea.min) - (!(0, _type.isDefined)(minValue) ? this.from(visibleArea.max) : minValue))
            },
            checkMinBarSize: function(value, minShownValue, stackValue) {
                return _abs(value) < minShownValue ? value >= 0 ? minShownValue : -minShownValue : value
            },
            translate: function(bp, direction) {
                var specialValue = this.translateSpecialCase(bp);
                if ((0, _type.isDefined)(specialValue)) {
                    return Math.round(specialValue)
                }
                if (isNaN(bp)) {
                    return null
                }
                return this.to(bp, direction)
            },
            getInterval: function(interval) {
                var _interval;
                var canvasOptions = this._canvasOptions;
                interval = null !== (_interval = interval) && void 0 !== _interval ? _interval : this._businessRange.interval;
                if (interval) {
                    return Math.round(canvasOptions.ratioOfCanvasRange * interval)
                }
                return Math.round(canvasOptions.endPoint - canvasOptions.startPoint)
            },
            zoom: function(translate, scale, wholeRange) {
                var canvasOptions = this._canvasOptions;
                if (canvasOptions.rangeMinVisible.valueOf() === canvasOptions.rangeMaxVisible.valueOf() && 0 !== translate) {
                    return this.zoomZeroLengthRange(translate, scale)
                }
                var startPoint = canvasOptions.startPoint;
                var endPoint = canvasOptions.endPoint;
                var isInverted = this.isInverted();
                var newStart = (startPoint + translate) / scale;
                var newEnd = (endPoint + translate) / scale;
                wholeRange = wholeRange || {};
                var minPoint = this.to(isInverted ? wholeRange.endValue : wholeRange.startValue);
                var maxPoint = this.to(isInverted ? wholeRange.startValue : wholeRange.endValue);
                var min;
                var max;
                if (minPoint > newStart) {
                    newEnd -= newStart - minPoint;
                    newStart = minPoint;
                    min = isInverted ? wholeRange.endValue : wholeRange.startValue
                }
                if (maxPoint < newEnd) {
                    newStart -= newEnd - maxPoint;
                    newEnd = maxPoint;
                    max = isInverted ? wholeRange.startValue : wholeRange.endValue
                }
                if (maxPoint - minPoint < newEnd - newStart) {
                    newStart = minPoint;
                    newEnd = maxPoint
                }
                translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;
                scale = (startPoint + translate) / newStart || 1;
                min = (0, _type.isDefined)(min) ? min : (0, _math.adjust)(this.from(newStart, 1));
                max = (0, _type.isDefined)(max) ? max : (0, _math.adjust)(this.from(newEnd, -1));
                if (min > max) {
                    min = min > wholeRange.endValue ? wholeRange.endValue : min;
                    max = max < wholeRange.startValue ? wholeRange.startValue : max
                } else {
                    min = min < wholeRange.startValue ? wholeRange.startValue : min;
                    max = max > wholeRange.endValue ? wholeRange.endValue : max
                }
                return {
                    min: min,
                    max: max,
                    translate: (0, _math.adjust)(translate),
                    scale: (0, _math.adjust)(scale)
                }
            },
            zoomZeroLengthRange: function(translate, scale) {
                var canvasOptions = this._canvasOptions;
                var min = canvasOptions.rangeMin;
                var max = canvasOptions.rangeMax;
                var correction = (max.valueOf() !== min.valueOf() ? max.valueOf() - min.valueOf() : _abs(canvasOptions.rangeMinVisible.valueOf() - min.valueOf())) / canvasOptions.canvasLength;
                var isDateTime = (0, _type.isDate)(max) || (0, _type.isDate)(min);
                var isLogarithmic = "logarithmic" === this._businessRange.axisType;
                var newMin = canvasOptions.rangeMinVisible.valueOf() - correction;
                var newMax = canvasOptions.rangeMaxVisible.valueOf() + correction;
                newMin = isLogarithmic ? (0, _math.adjust)((0, _utils.raiseToExt)(newMin, canvasOptions.base)) : isDateTime ? new Date(newMin) : newMin;
                newMax = isLogarithmic ? (0, _math.adjust)((0, _utils.raiseToExt)(newMax, canvasOptions.base)) : isDateTime ? new Date(newMax) : newMax;
                return {
                    min: newMin,
                    max: newMax,
                    translate: translate,
                    scale: scale
                }
            },
            getMinScale: function(zoom) {
                return zoom ? 1.1 : .9
            },
            getScale: function(val1, val2) {
                var canvasOptions = this._canvasOptions;
                if (canvasOptions.rangeMax === canvasOptions.rangeMin) {
                    return 1
                }
                val1 = (0, _type.isDefined)(val1) ? this._fromValue(val1) : canvasOptions.rangeMin;
                val2 = (0, _type.isDefined)(val2) ? this._fromValue(val2) : canvasOptions.rangeMax;
                return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2)
            },
            isValid: function(value) {
                var co = this._canvasOptions;
                value = this._fromValue(value);
                return null !== value && !isNaN(value) && value.valueOf() + co.rangeDoubleError >= co.rangeMin && value.valueOf() - co.rangeDoubleError <= co.rangeMax
            },
            getCorrectValue: function(value, direction) {
                var that = this;
                var breaks = that._breaks;
                var prop;
                value = that._fromValue(value);
                if (that._breaks) {
                    prop = that._checkValueAboutBreaks(breaks, value, "trFrom", "trTo", that._checkingMethodsAboutBreaks[0]);
                    if (true === prop.inBreak) {
                        return that._toValue(direction > 0 ? prop.break.trTo : prop.break.trFrom)
                    }
                }
                return that._toValue(value)
            },
            to: function(bp, direction) {
                var range = this.getBusinessRange();
                if ((0, _type.isDefined)(range.maxVisible) && (0, _type.isDefined)(range.minVisible) && range.maxVisible.valueOf() === range.minVisible.valueOf()) {
                    if (!(0, _type.isDefined)(bp) || range.maxVisible.valueOf() !== bp.valueOf()) {
                        return null
                    }
                    return this.translateSpecialCase(0 === bp && this._options.shiftZeroValue ? "canvas_position_default" : "canvas_position_middle")
                }
                bp = this._fromValue(bp);
                var that = this;
                var canvasOptions = that._canvasOptions;
                var breaks = that._breaks;
                var prop = {
                    length: 0
                };
                var commonBreakSize = 0;
                if (void 0 !== breaks) {
                    prop = that._checkValueAboutBreaks(breaks, bp, "trFrom", "trTo", that._checkingMethodsAboutBreaks[0]);
                    commonBreakSize = (0, _type.isDefined)(prop.breaksSize) ? prop.breaksSize : 0
                }
                if (true === prop.inBreak) {
                    if (direction > 0) {
                        return prop.break.start
                    } else {
                        if (direction < 0) {
                            return prop.break.end
                        } else {
                            return null
                        }
                    }
                }
                return that._conversionValue(that._calculateProjection((bp - canvasOptions.rangeMinVisible - prop.length) * canvasOptions.ratioOfCanvasRange + commonBreakSize))
            },
            from: function(pos, direction) {
                var that = this;
                var breaks = that._breaks;
                var prop = {
                    length: 0
                };
                var canvasOptions = that._canvasOptions;
                var startPoint = canvasOptions.startPoint;
                var commonBreakSize = 0;
                if (void 0 !== breaks) {
                    prop = that._checkValueAboutBreaks(breaks, pos, "start", "end", that._checkingMethodsAboutBreaks[1]);
                    commonBreakSize = (0, _type.isDefined)(prop.breaksSize) ? prop.breaksSize : 0
                }
                if (true === prop.inBreak) {
                    if (direction > 0) {
                        return that._toValue(prop.break.trTo)
                    } else {
                        if (direction < 0) {
                            return that._toValue(prop.break.trFrom)
                        } else {
                            return null
                        }
                    }
                }
                return that._toValue(that._calculateUnProjection((pos - startPoint - commonBreakSize) / canvasOptions.ratioOfCanvasRange + prop.length))
            },
            isValueProlonged: false,
            getRange: function() {
                return [this._toValue(this._canvasOptions.rangeMin), this._toValue(this._canvasOptions.rangeMax)]
            },
            getScreenRange: function() {
                return [this._canvasOptions.startPoint, this._canvasOptions.endPoint]
            },
            add: function(value, diff, dir) {
                return this._add(value, diff, (this._businessRange.invert ? -1 : 1) * dir)
            },
            _add: function(value, diff, coeff) {
                return this._toValue(this._fromValue(value) + diff * coeff)
            },
            _fromValue: function(value) {
                return null !== value ? Number(value) : null
            },
            _toValue: function(value) {
                return null !== value ? Number(value) : null
            },
            ratioOfCanvasRange: function() {
                return this._canvasOptions.ratioOfCanvasRange
            }
        }
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/base_indicators.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var _isFinite = isFinite;
        var _Number = Number;
        var _round = Math.round;
        var baseGaugeModule = __webpack_require__( /*! ./base_gauge */ 153);
        var _formatValue = baseGaugeModule.formatValue;
        var _getSampleText = baseGaugeModule.getSampleText;
        var _patchFontOptions = __webpack_require__( /*! ../core/utils */ 13).patchFontOptions;
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var BaseElement = Class.inherit({
            ctor: function(parameters) {
                var that = this;
                each(parameters, function(name, value) {
                    that["_" + name] = value
                });
                that._init()
            },
            dispose: function() {
                var that = this;
                that._dispose();
                each(that, function(name) {
                    that[name] = null
                });
                return that
            },
            getOffset: function() {
                return _Number(this._options.offset) || 0
            }
        });
        var BaseIndicator = BaseElement.inherit({
            _init: function() {
                var that = this;
                that._rootElement = that._createRoot().linkOn(that._owner, {
                    name: "value-indicator",
                    after: "core"
                });
                that._trackerElement = that._createTracker()
            },
            _dispose: function() {
                this._rootElement.linkOff()
            },
            _setupAnimation: function() {
                var that = this;
                if (that._options.animation) {
                    that._animation = {
                        step: function(pos) {
                            that._actualValue = that._animation.start + that._animation.delta * pos;
                            that._actualPosition = that._translator.translate(that._actualValue);
                            that._move()
                        },
                        duration: that._options.animation.duration > 0 ? _Number(that._options.animation.duration) : 0,
                        easing: that._options.animation.easing
                    }
                }
            },
            _runAnimation: function(value) {
                var that = this;
                var animation = that._animation;
                animation.start = that._actualValue;
                animation.delta = value - that._actualValue;
                that._rootElement.animate({
                    _: 0
                }, {
                    step: animation.step,
                    duration: animation.duration,
                    easing: animation.easing
                })
            },
            _createRoot: function() {
                return this._renderer.g().attr({
                    "class": this._className
                })
            },
            _createTracker: function() {
                return this._renderer.path([], "area")
            },
            _getTrackerSettings: noop,
            clean: function() {
                var that = this;
                that._animation && that._rootElement.stopAnimation();
                that._rootElement.linkRemove().clear();
                that._clear();
                that._tracker.detach(that._trackerElement);
                that._options = that.enabled = that._animation = null;
                return that
            },
            render: function(options) {
                var that = this;
                that.type = options.type;
                that._options = options;
                that._actualValue = that._currentValue = that._translator.adjust(that._options.currentValue);
                that.enabled = that._isEnabled();
                if (that.enabled) {
                    that._setupAnimation();
                    that._rootElement.attr({
                        fill: that._options.color
                    }).linkAppend();
                    that._tracker.attach(that._trackerElement, that, that._trackerInfo)
                }
                return that
            },
            resize: function(layout) {
                var that = this;
                that._rootElement.clear();
                that._clear();
                that.visible = that._isVisible(layout);
                if (that.visible) {
                    extend(that._options, layout);
                    that._actualPosition = that._translator.translate(that._actualValue);
                    that._render();
                    that._trackerElement.attr(that._getTrackerSettings());
                    that._move()
                }
                return that
            },
            value: function(arg, _noAnimation) {
                var that = this;
                var val;
                var rootElement = this._rootElement;
                var visibility = null;
                if (void 0 === arg) {
                    return that._currentValue
                }
                if (null === arg) {
                    visibility = "hidden";
                    that._currentValue = arg
                } else {
                    val = that._translator.adjust(arg);
                    if (that._currentValue !== val && _isFinite(val)) {
                        that._currentValue = val;
                        if (that.visible) {
                            if (that._animation && !_noAnimation) {
                                that._runAnimation(val)
                            } else {
                                that._actualValue = val;
                                that._actualPosition = that._translator.translate(val);
                                that._move()
                            }
                        }
                    }
                }
                rootElement.attr({
                    visibility: visibility
                });
                return that
            },
            _isEnabled: null,
            _isVisible: null,
            _render: null,
            _clear: null,
            _move: null
        });
        var COEFFICIENTS_MAP = {};
        COEFFICIENTS_MAP["right-bottom"] = COEFFICIENTS_MAP.rb = [0, -1, -1, 0, 0, 1, 1, 0];
        COEFFICIENTS_MAP["bottom-right"] = COEFFICIENTS_MAP.br = [-1, 0, 0, -1, 1, 0, 0, 1];
        COEFFICIENTS_MAP["left-bottom"] = COEFFICIENTS_MAP.lb = [0, -1, 1, 0, 0, 1, -1, 0];
        COEFFICIENTS_MAP["bottom-left"] = COEFFICIENTS_MAP.bl = [1, 0, 0, -1, -1, 0, 0, 1];
        COEFFICIENTS_MAP["left-top"] = COEFFICIENTS_MAP.lt = [0, 1, 1, 0, 0, -1, -1, 0];
        COEFFICIENTS_MAP["top-left"] = COEFFICIENTS_MAP.tl = [1, 0, 0, 1, -1, 0, 0, -1];
        COEFFICIENTS_MAP["right-top"] = COEFFICIENTS_MAP.rt = [0, 1, -1, 0, 0, -1, 1, 0];
        COEFFICIENTS_MAP["top-right"] = COEFFICIENTS_MAP.tr = [-1, 0, 0, 1, 1, 0, 0, -1];

        function getTextCloudInfo(options) {
            var x = options.x;
            var y = options.y;
            var type = COEFFICIENTS_MAP[options.type];
            var cloudWidth = options.textWidth + 2 * options.horMargin;
            var cloudHeight = options.textHeight + 2 * options.verMargin;
            var tailWidth;
            var tailHeight;
            var cx = x;
            var cy = y;
            tailWidth = tailHeight = options.tailLength;
            if (1 & type[0]) {
                tailHeight = Math.min(tailHeight, cloudHeight / 3)
            } else {
                tailWidth = Math.min(tailWidth, cloudWidth / 3)
            }
            return {
                cx: _round(cx + type[0] * tailWidth + (type[0] + type[2]) * cloudWidth / 2),
                cy: _round(cy + type[1] * tailHeight + (type[1] + type[3]) * cloudHeight / 2),
                points: [_round(x), _round(y), _round(x += type[0] * (cloudWidth + tailWidth)), _round(y += type[1] * (cloudHeight + tailHeight)), _round(x += type[2] * cloudWidth), _round(y += type[3] * cloudHeight), _round(x += type[4] * cloudWidth), _round(y += type[5] * cloudHeight), _round(x += type[6] * (cloudWidth - tailWidth)), _round(y += type[7] * (cloudHeight - tailHeight))]
            }
        }
        var BaseTextCloudMarker = BaseIndicator.inherit({
            _move: function() {
                var that = this;
                var textCloudOptions = that._getTextCloudOptions();
                var text = _formatValue(that._actualValue, that._options.text);
                that._text.attr({
                    text: text
                });
                var bBox = that._text.getBBox();
                var info = getTextCloudInfo({
                    x: textCloudOptions.x,
                    y: textCloudOptions.y,
                    textWidth: bBox.width || text.length * that._textUnitWidth,
                    textHeight: bBox.height || that._textHeight,
                    horMargin: that._options.horizontalOffset,
                    verMargin: that._options.verticalOffset,
                    tailLength: that._options.arrowLength,
                    type: textCloudOptions.type
                });
                that._text.attr({
                    x: info.cx,
                    y: info.cy + that._textVerticalOffset
                });
                that._cloud.attr({
                    points: info.points
                });
                that._trackerElement && that._trackerElement.attr({
                    points: info.points
                })
            },
            _measureText: function() {
                var that = this;
                var root;
                var text;
                var bBox;
                var sampleText;
                if (!that._textVerticalOffset) {
                    root = that._createRoot().append(that._owner);
                    sampleText = _getSampleText(that._translator, that._options.text);
                    text = that._renderer.text(sampleText, 0, 0).attr({
                        align: "center"
                    }).css(_patchFontOptions(that._options.text.font)).append(root);
                    bBox = text.getBBox();
                    root.remove();
                    that._textVerticalOffset = -bBox.y - bBox.height / 2;
                    that._textWidth = bBox.width;
                    that._textHeight = bBox.height;
                    that._textUnitWidth = that._textWidth / sampleText.length;
                    that._textFullWidth = that._textWidth + 2 * that._options.horizontalOffset;
                    that._textFullHeight = that._textHeight + 2 * that._options.verticalOffset
                }
            },
            _render: function() {
                var that = this;
                that._measureText();
                that._cloud = that._cloud || that._renderer.path([], "area").append(that._rootElement);
                that._text = that._text || that._renderer.text().append(that._rootElement);
                that._text.attr({
                    align: "center"
                }).css(_patchFontOptions(that._options.text.font))
            },
            _clear: function() {
                delete this._cloud;
                delete this._text
            },
            getTooltipParameters: function() {
                var position = this._getTextCloudOptions();
                return {
                    x: position.x,
                    y: position.y,
                    value: this._currentValue,
                    color: this._options.color
                }
            }
        });
        var BaseRangeBar = BaseIndicator.inherit({
            _measureText: function() {
                var that = this;
                var root;
                var text;
                var bBox;
                that._hasText = that._isTextVisible();
                if (that._hasText && !that._textVerticalOffset) {
                    root = that._createRoot().append(that._owner);
                    text = that._renderer.text(_getSampleText(that._translator, that._options.text), 0, 0).attr({
                        "class": "dxg-text",
                        align: "center"
                    }).css(_patchFontOptions(that._options.text.font)).append(root);
                    bBox = text.getBBox();
                    root.remove();
                    that._textVerticalOffset = -bBox.y - bBox.height / 2;
                    that._textWidth = bBox.width;
                    that._textHeight = bBox.height
                }
            },
            _move: function() {
                var that = this;
                that._updateBarItemsPositions();
                if (that._hasText) {
                    that._text.attr({
                        text: _formatValue(that._actualValue, that._options.text)
                    });
                    that._updateTextPosition();
                    that._updateLinePosition()
                }
            },
            _updateBarItems: function() {
                var that = this;
                var options = that._options;
                var spaceColor;
                var translator = that._translator;
                that._setBarSides();
                that._startPosition = translator.translate(translator.getDomainStart());
                that._endPosition = translator.translate(translator.getDomainEnd());
                that._basePosition = translator.translate(options.baseValue);
                that._space = that._getSpace();
                var backgroundColor = options.backgroundColor || "none";
                if ("none" !== backgroundColor && that._space > 0) {
                    spaceColor = options.containerBackgroundColor || "none"
                } else {
                    that._space = 0;
                    spaceColor = "none"
                }
                that._backItem1.attr({
                    fill: backgroundColor
                });
                that._backItem2.attr({
                    fill: backgroundColor
                });
                that._spaceItem1.attr({
                    fill: spaceColor
                });
                that._spaceItem2.attr({
                    fill: spaceColor
                })
            },
            _getSpace: function() {
                return 0
            },
            _updateTextItems: function() {
                var that = this;
                if (that._hasText) {
                    that._line = that._line || that._renderer.path([], "line").attr({
                        "class": "dxg-main-bar",
                        "stroke-linecap": "square"
                    }).append(that._rootElement);
                    that._text = that._text || that._renderer.text("", 0, 0).attr({
                        "class": "dxg-text"
                    }).append(that._rootElement);
                    that._text.attr({
                        align: that._getTextAlign()
                    }).css(that._getFontOptions());
                    that._setTextItemsSides()
                } else {
                    if (that._line) {
                        that._line.remove();
                        delete that._line
                    }
                    if (that._text) {
                        that._text.remove();
                        delete that._text
                    }
                }
            },
            _isTextVisible: function() {
                return false
            },
            _getTextAlign: function() {
                return "center"
            },
            _getFontOptions: function() {
                var options = this._options;
                var font = options.text.font;
                if (!font || !font.color) {
                    font = extend({}, font, {
                        color: options.color
                    })
                }
                return _patchFontOptions(font)
            },
            _updateBarItemsPositions: function() {
                var that = this;
                var positions = that._getPositions();
                that._backItem1.attr(that._buildItemSettings(positions.start, positions.back1));
                that._backItem2.attr(that._buildItemSettings(positions.back2, positions.end));
                that._spaceItem1.attr(that._buildItemSettings(positions.back1, positions.main1));
                that._spaceItem2.attr(that._buildItemSettings(positions.main2, positions.back2));
                that._mainItem.attr(that._buildItemSettings(positions.main1, positions.main2));
                that._trackerElement && that._trackerElement.attr(that._buildItemSettings(positions.main1, positions.main2))
            },
            _render: function() {
                var that = this;
                that._measureText();
                if (!that._backItem1) {
                    that._backItem1 = that._createBarItem();
                    that._backItem1.attr({
                        "class": "dxg-back-bar"
                    })
                }
                if (!that._backItem2) {
                    that._backItem2 = that._createBarItem();
                    that._backItem2.attr({
                        "class": "dxg-back-bar"
                    })
                }
                if (!that._spaceItem1) {
                    that._spaceItem1 = that._createBarItem();
                    that._spaceItem1.attr({
                        "class": "dxg-space-bar"
                    })
                }
                if (!that._spaceItem2) {
                    that._spaceItem2 = that._createBarItem();
                    that._spaceItem2.attr({
                        "class": "dxg-space-bar"
                    })
                }
                if (!that._mainItem) {
                    that._mainItem = that._createBarItem();
                    that._mainItem.attr({
                        "class": "dxg-main-bar"
                    })
                }
                that._updateBarItems();
                that._updateTextItems()
            },
            _clear: function() {
                var that = this;
                delete that._backItem1;
                delete that._backItem2;
                delete that._spaceItem1;
                delete that._spaceItem2;
                delete that._mainItem;
                delete that._hasText;
                delete that._line;
                delete that._text
            },
            getTooltipParameters: function() {
                var position = this._getTooltipPosition();
                return {
                    x: position.x,
                    y: position.y,
                    value: this._currentValue,
                    color: this._options.color,
                    offset: 0
                }
            }
        });
        exports.BaseElement = BaseElement;
        exports.BaseIndicator = BaseIndicator;
        exports.BaseTextCloudMarker = BaseTextCloudMarker;
        exports.BaseRangeBar = BaseRangeBar;
        exports.getTextCloudInfo = getTextCloudInfo
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/common.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _patchFontOptions = __webpack_require__( /*! ../core/utils */ 13).patchFontOptions;
        exports.buildRectAppearance = function(option) {
            var border = option.border || {};
            return {
                fill: option.color,
                opacity: option.opacity,
                stroke: border.color,
                "stroke-width": border.width,
                "stroke-opacity": border.opacity,
                hatching: option.hatching
            }
        };
        exports.buildTextAppearance = function(options, filter) {
            return {
                attr: {
                    filter: filter
                },
                css: _patchFontOptions(options.font)
            }
        }
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/components/tracker.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _eventData = __webpack_require__( /*! ../../events/utils */ 8).eventData;
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var clickEventName = __webpack_require__( /*! ../../events/click */ 19).name;
        var downPointerEventName = __webpack_require__( /*! ../../events/pointer */ 23).down;
        var movePointerEventName = __webpack_require__( /*! ../../events/pointer */ 23).move;
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);

        function Tracker(parameters) {
            this._initHandlers(parameters)
        }
        Tracker.prototype = {
            constructor: Tracker,
            _initHandlers: function(parameters) {
                var document = domAdapter.getDocument();
                parameters.getCoords = function(e) {
                    var data = _eventData(e);
                    var offset = parameters.widget._renderer.getRootOffset();
                    return [data.x - offset.left, data.y - offset.top]
                };
                parameters.root.on(clickEventName, clickHandler);
                parameters.root.on(downPointerEventName, downHandler);
                eventsEngine.on(document, downPointerEventName, downHandler);
                eventsEngine.on(document, movePointerEventName, moveHandler);
                this._disposeHandlers = function() {
                    parameters.root.off(clickEventName, clickHandler);
                    parameters.root.off(downPointerEventName, downHandler);
                    eventsEngine.off(document, downPointerEventName, downHandler);
                    eventsEngine.off(document, movePointerEventName, moveHandler)
                };

                function clickHandler(e) {
                    processClick(e, parameters)
                }
                var isRootDown = false;

                function downHandler(e) {
                    if (isRootDown) {
                        isRootDown = false
                    } else {
                        if (void 0 !== parameters.getData(e)) {
                            isRootDown = true
                        }
                        moveHandler(e)
                    }
                }

                function moveHandler(e) {
                    processHover(e, parameters);
                    parameters.widget._getOption("tooltip").enabled && processTooltip(e, parameters)
                }
            },
            dispose: function() {
                this._disposeHandlers()
            }
        };

        function processClick(e, params) {
            var id = params.getData(e);
            if (id >= 0) {
                params.click({
                    node: params.getNode(id),
                    coords: params.getCoords(e),
                    event: e
                })
            }
        }

        function processHover(e, params) {
            var id = params.getData(e);
            if (id >= 0) {
                params.getNode(id).setHover()
            } else {
                params.widget.clearHover()
            }
        }

        function processTooltip(e, params) {
            var id = params.getData(e, true);
            var coords;
            if (id >= 0) {
                coords = _eventData(e);
                params.getNode(id).showTooltip([coords.x, coords.y])
            } else {
                params.widget.hideTooltip()
            }
        }
        module.exports.Tracker = Tracker
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/renderer_base.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dataUtils = __webpack_require__( /*! ./element_data */ 41);
        var domAdapter = __webpack_require__( /*! ./dom_adapter */ 12);
        var windowUtils = __webpack_require__( /*! ./utils/window */ 7);
        var window = windowUtils.getWindow();
        var typeUtils = __webpack_require__( /*! ./utils/type */ 1);
        var styleUtils = __webpack_require__( /*! ./utils/style */ 93);
        var sizeUtils = __webpack_require__( /*! ./utils/size */ 180);
        var htmlParser = __webpack_require__( /*! ./utils/html_parser */ 270);
        var renderer;
        var initRender = function(selector, context) {
            if (!selector) {
                this.length = 0;
                return this
            }
            if ("string" === typeof selector) {
                if ("body" === selector) {
                    this[0] = context ? context.body : domAdapter.getBody();
                    this.length = 1;
                    return this
                }
                context = context || domAdapter.getDocument();
                if ("<" === selector[0]) {
                    this[0] = domAdapter.createElement(selector.slice(1, -1), context);
                    this.length = 1;
                    return this
                } [].push.apply(this, domAdapter.querySelectorAll(context, selector));
                return this
            } else {
                if (domAdapter.isNode(selector) || typeUtils.isWindow(selector)) {
                    this[0] = selector;
                    this.length = 1;
                    return this
                } else {
                    if (Array.isArray(selector)) {
                        [].push.apply(this, selector);
                        return this
                    }
                }
            }
            return renderer(selector.toArray ? selector.toArray() : [selector])
        };
        renderer = function(selector, context) {
            return new initRender(selector, context)
        };
        renderer.fn = {
            dxRenderer: true
        };
        initRender.prototype = renderer.fn;
        var repeatMethod = function(methodName, args) {
            for (var i = 0; i < this.length; i++) {
                var item = renderer(this[i]);
                item[methodName].apply(item, args)
            }
            return this
        };
        var setAttributeValue = function(element, attrName, value) {
            if (void 0 !== value && null !== value) {
                domAdapter.setAttribute(element, attrName, value)
            } else {
                domAdapter.removeAttribute(element, attrName)
            }
        };
        initRender.prototype.show = function() {
            return this.toggle(true)
        };
        initRender.prototype.hide = function() {
            return this.toggle(false)
        };
        initRender.prototype.toggle = function(value) {
            if (this[0]) {
                this.toggleClass("dx-state-invisible", !value)
            }
            return this
        };
        initRender.prototype.attr = function(attrName, value) {
            if (this.length > 1 && arguments.length > 1) {
                return repeatMethod.call(this, "attr", arguments)
            }
            if (!this[0]) {
                if (typeUtils.isObject(attrName) || void 0 !== value) {
                    return this
                } else {
                    return
                }
            }
            if (!this[0].getAttribute) {
                return this.prop(attrName, value)
            }
            if ("string" === typeof attrName && 1 === arguments.length) {
                var result = this[0].getAttribute(attrName);
                return null == result ? void 0 : result
            } else {
                if (typeUtils.isPlainObject(attrName)) {
                    for (var key in attrName) {
                        this.attr(key, attrName[key])
                    }
                } else {
                    setAttributeValue(this[0], attrName, value)
                }
            }
            return this
        };
        initRender.prototype.removeAttr = function(attrName) {
            this[0] && domAdapter.removeAttribute(this[0], attrName);
            return this
        };
        initRender.prototype.prop = function(propName, value) {
            if (!this[0]) {
                return this
            }
            if ("string" === typeof propName && 1 === arguments.length) {
                return this[0][propName]
            } else {
                if (typeUtils.isPlainObject(propName)) {
                    for (var key in propName) {
                        this.prop(key, propName[key])
                    }
                } else {
                    domAdapter.setProperty(this[0], propName, value)
                }
            }
            return this
        };
        initRender.prototype.addClass = function(className) {
            return this.toggleClass(className, true)
        };
        initRender.prototype.removeClass = function(className) {
            return this.toggleClass(className, false)
        };
        initRender.prototype.hasClass = function(className) {
            if (!this[0] || void 0 === this[0].className) {
                return false
            }
            var classNames = className.split(" ");
            for (var i = 0; i < classNames.length; i++) {
                if (this[0].classList) {
                    if (this[0].classList.contains(classNames[i])) {
                        return true
                    }
                } else {
                    var _className = typeUtils.isString(this[0].className) ? this[0].className : domAdapter.getAttribute(this[0], "class");
                    if ((_className || "").split(" ").indexOf(classNames[i]) >= 0) {
                        return true
                    }
                }
            }
            return false
        };
        initRender.prototype.toggleClass = function(className, value) {
            if (this.length > 1) {
                return repeatMethod.call(this, "toggleClass", arguments)
            }
            if (!this[0] || !className) {
                return this
            }
            value = void 0 === value ? !this.hasClass(className) : value;
            var classNames = className.split(" ");
            for (var i = 0; i < classNames.length; i++) {
                domAdapter.setClass(this[0], classNames[i], value)
            }
            return this
        };
        ["width", "height", "outerWidth", "outerHeight", "innerWidth", "innerHeight"].forEach(function(methodName) {
            var partialName = methodName.toLowerCase().indexOf("width") >= 0 ? "Width" : "Height";
            var propName = partialName.toLowerCase();
            var isOuter = 0 === methodName.indexOf("outer");
            var isInner = 0 === methodName.indexOf("inner");
            initRender.prototype[methodName] = function(value) {
                if (this.length > 1 && arguments.length > 0) {
                    return repeatMethod.call(this, methodName, arguments)
                }
                var element = this[0];
                if (!element) {
                    return
                }
                if (typeUtils.isWindow(element)) {
                    return isOuter ? element["inner" + partialName] : domAdapter.getDocumentElement()["client" + partialName]
                }
                if (domAdapter.isDocument(element)) {
                    var documentElement = domAdapter.getDocumentElement();
                    var body = domAdapter.getBody();
                    return Math.max(body["scroll" + partialName], body["offset" + partialName], documentElement["scroll" + partialName], documentElement["offset" + partialName], documentElement["client" + partialName])
                }
                if (0 === arguments.length || "boolean" === typeof value) {
                    var include = {
                        paddings: isInner || isOuter,
                        borders: isOuter,
                        margins: value
                    };
                    return sizeUtils.getSize(element, propName, include)
                }
                if (void 0 === value || null === value) {
                    return this
                }
                if (typeUtils.isNumeric(value)) {
                    var elementStyles = window.getComputedStyle(element);
                    var sizeAdjustment = sizeUtils.getElementBoxParams(propName, elementStyles);
                    var isBorderBox = "border-box" === elementStyles.boxSizing;
                    value = Number(value);
                    if (isOuter) {
                        value -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding
                    } else {
                        if (isInner) {
                            value += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding
                        } else {
                            if (isBorderBox) {
                                value += sizeAdjustment.border + sizeAdjustment.padding
                            }
                        }
                    }
                }
                value += typeUtils.isNumeric(value) ? "px" : "";
                domAdapter.setStyle(element, propName, value);
                return this
            }
        });
        initRender.prototype.html = function(value) {
            if (!arguments.length) {
                return this[0].innerHTML
            }
            this.empty();
            if ("string" === typeof value && !htmlParser.isTablePart(value) || "number" === typeof value) {
                this[0].innerHTML = value;
                return this
            }
            return this.append(htmlParser.parseHTML(value))
        };
        var appendElements = function(element, nextSibling) {
            if (!this[0] || !element) {
                return
            }
            if ("string" === typeof element) {
                element = htmlParser.parseHTML(element)
            } else {
                if (element.nodeType) {
                    element = [element]
                } else {
                    if (typeUtils.isNumeric(element)) {
                        element = [domAdapter.createTextNode(element)]
                    }
                }
            }
            for (var i = 0; i < element.length; i++) {
                var item = element[i];
                var container = this[0];
                var wrapTR = "TABLE" === container.tagName && "TR" === item.tagName;
                if (wrapTR && container.tBodies && container.tBodies.length) {
                    container = container.tBodies[0]
                }
                domAdapter.insertElement(container, item.nodeType ? item : item[0], nextSibling)
            }
        };
        var setCss = function(name, value) {
            if (!this[0] || !this[0].style) {
                return
            }
            if (null === value || "number" === typeof value && isNaN(value)) {
                return
            }
            name = styleUtils.styleProp(name);
            for (var i = 0; i < this.length; i++) {
                this[i].style[name] = styleUtils.normalizeStyleProp(name, value)
            }
        };
        initRender.prototype.css = function(name, value) {
            if (typeUtils.isString(name)) {
                if (2 === arguments.length) {
                    setCss.call(this, name, value)
                } else {
                    if (!this[0]) {
                        return
                    }
                    name = styleUtils.styleProp(name);
                    var result = window.getComputedStyle(this[0])[name] || this[0].style[name];
                    return typeUtils.isNumeric(result) ? result.toString() : result
                }
            } else {
                if (typeUtils.isPlainObject(name)) {
                    for (var key in name) {
                        setCss.call(this, key, name[key])
                    }
                }
            }
            return this
        };
        initRender.prototype.prepend = function(element) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.prepend(arguments[i])
                }
                return this
            }
            appendElements.apply(this, [element, this[0].firstChild]);
            return this
        };
        initRender.prototype.append = function(element) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.append(arguments[i])
                }
                return this
            }
            appendElements.apply(this, [element]);
            return this
        };
        initRender.prototype.prependTo = function(element) {
            if (this.length > 1) {
                for (var i = this.length - 1; i >= 0; i--) {
                    renderer(this[i]).prependTo(element)
                }
                return this
            }
            element = renderer(element);
            if (element[0]) {
                domAdapter.insertElement(element[0], this[0], element[0].firstChild)
            }
            return this
        };
        initRender.prototype.appendTo = function(element) {
            if (this.length > 1) {
                return repeatMethod.call(this, "appendTo", arguments)
            }
            domAdapter.insertElement(renderer(element)[0], this[0]);
            return this
        };
        initRender.prototype.insertBefore = function(element) {
            if (element && element[0]) {
                domAdapter.insertElement(element[0].parentNode, this[0], element[0])
            }
            return this
        };
        initRender.prototype.insertAfter = function(element) {
            if (element && element[0]) {
                domAdapter.insertElement(element[0].parentNode, this[0], element[0].nextSibling)
            }
            return this
        };
        initRender.prototype.before = function(element) {
            if (this[0]) {
                domAdapter.insertElement(this[0].parentNode, element[0], this[0])
            }
            return this
        };
        initRender.prototype.after = function(element) {
            if (this[0]) {
                domAdapter.insertElement(this[0].parentNode, element[0], this[0].nextSibling)
            }
            return this
        };
        initRender.prototype.wrap = function(wrapper) {
            if (this[0]) {
                var wrap = renderer(wrapper);
                wrap.insertBefore(this);
                wrap.append(this)
            }
            return this
        };
        initRender.prototype.wrapInner = function(wrapper) {
            var contents = this.contents();
            if (contents.length) {
                contents.wrap(wrapper)
            } else {
                this.append(wrapper)
            }
            return this
        };
        initRender.prototype.replaceWith = function(element) {
            if (!(element && element[0])) {
                return
            }
            if (element.is(this)) {
                return this
            }
            element.insertBefore(this);
            this.remove();
            return element
        };
        initRender.prototype.remove = function() {
            if (this.length > 1) {
                return repeatMethod.call(this, "remove", arguments)
            }
            dataUtils.cleanDataRecursive(this[0], true);
            domAdapter.removeElement(this[0]);
            return this
        };
        initRender.prototype.detach = function() {
            if (this.length > 1) {
                return repeatMethod.call(this, "detach", arguments)
            }
            domAdapter.removeElement(this[0]);
            return this
        };
        initRender.prototype.empty = function() {
            if (this.length > 1) {
                return repeatMethod.call(this, "empty", arguments)
            }
            dataUtils.cleanDataRecursive(this[0]);
            domAdapter.setText(this[0], "");
            return this
        };
        initRender.prototype.clone = function() {
            var result = [];
            for (var i = 0; i < this.length; i++) {
                result.push(this[i].cloneNode(true))
            }
            return renderer(result)
        };
        initRender.prototype.text = function(value) {
            if (!arguments.length) {
                var result = "";
                for (var i = 0; i < this.length; i++) {
                    result += this[i] && this[i].textContent || ""
                }
                return result
            }
            var text = typeUtils.isFunction(value) ? value() : value;
            dataUtils.cleanDataRecursive(this[0], false);
            domAdapter.setText(this[0], typeUtils.isDefined(text) ? text : "");
            return this
        };
        initRender.prototype.val = function(value) {
            if (1 === arguments.length) {
                return this.prop("value", typeUtils.isDefined(value) ? value : "")
            }
            return this.prop("value")
        };
        initRender.prototype.contents = function() {
            if (!this[0]) {
                return renderer()
            }
            var result = [];
            result.push.apply(result, this[0].childNodes);
            return renderer(result)
        };
        initRender.prototype.find = function(selector) {
            var result = renderer();
            if (!selector) {
                return result
            }
            var nodes = [];
            var i;
            if ("string" === typeof selector) {
                selector = selector.trim();
                for (i = 0; i < this.length; i++) {
                    var element = this[i];
                    if (domAdapter.isElementNode(element)) {
                        var elementId = element.getAttribute("id");
                        var queryId = elementId || "dx-query-children";
                        if (!elementId) {
                            setAttributeValue(element, "id", queryId)
                        }
                        queryId = "[id='" + queryId + "'] ";
                        var querySelector = queryId + selector.replace(/([^\\])(,)/g, "$1, " + queryId);
                        nodes.push.apply(nodes, domAdapter.querySelectorAll(element, querySelector));
                        setAttributeValue(element, "id", elementId)
                    } else {
                        if (domAdapter.isDocument(element)) {
                            nodes.push.apply(nodes, domAdapter.querySelectorAll(element, selector))
                        }
                    }
                }
            } else {
                for (i = 0; i < this.length; i++) {
                    selector = domAdapter.isNode(selector) ? selector : selector[0];
                    if (this[i] !== selector && this[i].contains(selector)) {
                        nodes.push(selector)
                    }
                }
            }
            return result.add(nodes)
        };
        var isVisible = function(_, element) {
            if (!element.nodeType) {
                return true
            }
            return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length)
        };
        initRender.prototype.filter = function(selector) {
            if (!selector) {
                return renderer()
            }
            if (":visible" === selector) {
                return this.filter(isVisible)
            } else {
                if (":hidden" === selector) {
                    return this.filter(function(_, element) {
                        return !isVisible(_, element)
                    })
                }
            }
            var result = [];
            for (var i = 0; i < this.length; i++) {
                var item = this[i];
                if (domAdapter.isElementNode(item) && "string" === typeUtils.type(selector)) {
                    domAdapter.elementMatches(item, selector) && result.push(item)
                } else {
                    if (domAdapter.isNode(selector) || typeUtils.isWindow(selector)) {
                        selector === item && result.push(item)
                    } else {
                        if (typeUtils.isFunction(selector)) {
                            selector.call(item, i, item) && result.push(item)
                        } else {
                            for (var j = 0; j < selector.length; j++) {
                                selector[j] === item && result.push(item)
                            }
                        }
                    }
                }
            }
            return renderer(result)
        };
        initRender.prototype.not = function(selector) {
            var result = [];
            var nodes = this.filter(selector).toArray();
            for (var i = 0; i < this.length; i++) {
                if (nodes.indexOf(this[i]) === -1) {
                    result.push(this[i])
                }
            }
            return renderer(result)
        };
        initRender.prototype.is = function(selector) {
            return !!this.filter(selector).length
        };
        initRender.prototype.children = function(selector) {
            var result = [];
            for (var i = 0; i < this.length; i++) {
                var nodes = this[i] ? this[i].childNodes : [];
                for (var j = 0; j < nodes.length; j++) {
                    if (domAdapter.isElementNode(nodes[j])) {
                        result.push(nodes[j])
                    }
                }
            }
            result = renderer(result);
            return selector ? result.filter(selector) : result
        };
        initRender.prototype.siblings = function() {
            var element = this[0];
            if (!element || !element.parentNode) {
                return renderer()
            }
            var result = [];
            var parentChildNodes = element.parentNode.childNodes || [];
            for (var i = 0; i < parentChildNodes.length; i++) {
                var node = parentChildNodes[i];
                if (domAdapter.isElementNode(node) && node !== element) {
                    result.push(node)
                }
            }
            return renderer(result)
        };
        initRender.prototype.each = function(callback) {
            for (var i = 0; i < this.length; i++) {
                if (false === callback.call(this[i], i, this[i])) {
                    break
                }
            }
        };
        initRender.prototype.index = function(element) {
            if (!element) {
                return this.parent().children().index(this)
            }
            element = renderer(element);
            return this.toArray().indexOf(element[0])
        };
        initRender.prototype.get = function(index) {
            return this[index < 0 ? this.length + index : index]
        };
        initRender.prototype.eq = function(index) {
            index = index < 0 ? this.length + index : index;
            return renderer(this[index])
        };
        initRender.prototype.first = function() {
            return this.eq(0)
        };
        initRender.prototype.last = function() {
            return this.eq(-1)
        };
        initRender.prototype.parent = function(selector) {
            if (!this[0]) {
                return renderer()
            }
            var result = renderer(this[0].parentNode);
            return !selector || result.is(selector) ? result : renderer()
        };
        initRender.prototype.parents = function(selector) {
            var result = [];
            var parent = this.parent();
            while (parent && parent[0] && !domAdapter.isDocument(parent[0])) {
                if (domAdapter.isElementNode(parent[0])) {
                    if (!selector || selector && parent.is(selector)) {
                        result.push(parent.get(0))
                    }
                }
                parent = parent.parent()
            }
            return renderer(result)
        };
        initRender.prototype.closest = function(selector) {
            if (this.is(selector)) {
                return this
            }
            var parent = this.parent();
            while (parent && parent.length) {
                if (parent.is(selector)) {
                    return parent
                }
                parent = parent.parent()
            }
            return renderer()
        };
        initRender.prototype.next = function(selector) {
            if (!this[0]) {
                return renderer()
            }
            var next = renderer(this[0].nextSibling);
            if (!arguments.length) {
                return next
            }
            while (next && next.length) {
                if (next.is(selector)) {
                    return next
                }
                next = next.next()
            }
            return renderer()
        };
        initRender.prototype.prev = function() {
            if (!this[0]) {
                return renderer()
            }
            return renderer(this[0].previousSibling)
        };
        initRender.prototype.add = function(selector) {
            var targets = renderer(selector);
            var result = this.toArray();
            for (var i = 0; i < targets.length; i++) {
                var target = targets[i];
                if (result.indexOf(target) === -1) {
                    result.push(target)
                }
            }
            return renderer(result)
        };
        var emptyArray = [];
        initRender.prototype.splice = function() {
            return renderer(emptyArray.splice.apply(this, arguments))
        };
        initRender.prototype.slice = function() {
            return renderer(emptyArray.slice.apply(this, arguments))
        };
        initRender.prototype.toArray = function() {
            return emptyArray.slice.call(this)
        };
        var getWindowByElement = function(element) {
            return typeUtils.isWindow(element) ? element : element.defaultView
        };
        initRender.prototype.offset = function() {
            if (!this[0]) {
                return
            }
            if (!this[0].getClientRects().length) {
                return {
                    top: 0,
                    left: 0
                }
            }
            var rect = this[0].getBoundingClientRect();
            var win = getWindowByElement(this[0].ownerDocument);
            var docElem = this[0].ownerDocument.documentElement;
            return {
                top: rect.top + win.pageYOffset - docElem.clientTop,
                left: rect.left + win.pageXOffset - docElem.clientLeft
            }
        };
        initRender.prototype.offsetParent = function() {
            if (!this[0]) {
                return renderer()
            }
            var offsetParent = renderer(this[0].offsetParent);
            while (offsetParent[0] && "static" === offsetParent.css("position")) {
                offsetParent = renderer(offsetParent[0].offsetParent)
            }
            offsetParent = offsetParent[0] ? offsetParent : renderer(domAdapter.getDocumentElement());
            return offsetParent
        };
        initRender.prototype.position = function() {
            if (!this[0]) {
                return
            }
            var offset;
            var marginTop = parseFloat(this.css("marginTop"));
            var marginLeft = parseFloat(this.css("marginLeft"));
            if ("fixed" === this.css("position")) {
                offset = this[0].getBoundingClientRect();
                return {
                    top: offset.top - marginTop,
                    left: offset.left - marginLeft
                }
            }
            offset = this.offset();
            var offsetParent = this.offsetParent();
            var parentOffset = {
                top: 0,
                left: 0
            };
            if ("HTML" !== offsetParent[0].nodeName) {
                parentOffset = offsetParent.offset()
            }
            parentOffset = {
                top: parentOffset.top + parseFloat(offsetParent.css("borderTopWidth")),
                left: parentOffset.left + parseFloat(offsetParent.css("borderLeftWidth"))
            };
            return {
                top: offset.top - parentOffset.top - marginTop,
                left: offset.left - parentOffset.left - marginLeft
            }
        };
        [{
            name: "scrollLeft",
            offsetProp: "pageXOffset",
            scrollWindow: function(win, value) {
                win.scrollTo(value, win.pageYOffset)
            }
        }, {
            name: "scrollTop",
            offsetProp: "pageYOffset",
            scrollWindow: function(win, value) {
                win.scrollTo(win.pageXOffset, value)
            }
        }].forEach(function(directionStrategy) {
            var propName = directionStrategy.name;
            initRender.prototype[propName] = function(value) {
                if (!this[0]) {
                    return
                }
                var window = getWindowByElement(this[0]);
                if (void 0 === value) {
                    return window ? window[directionStrategy.offsetProp] : this[0][propName]
                }
                if (window) {
                    directionStrategy.scrollWindow(window, value)
                } else {
                    this[0][propName] = value
                }
                return this
            }
        });
        initRender.prototype.data = function(key, value) {
            if (!this[0]) {
                return
            }
            if (arguments.length < 2) {
                return dataUtils.data.call(renderer, this[0], key)
            }
            dataUtils.data.call(renderer, this[0], key, value);
            return this
        };
        initRender.prototype.removeData = function(key) {
            this[0] && dataUtils.removeData(this[0], key);
            return this
        };
        var rendererWrapper = function() {
            return renderer.apply(this, arguments)
        };
        Object.defineProperty(rendererWrapper, "fn", {
            enumerable: true,
            configurable: true,
            get: function() {
                return renderer.fn
            },
            set: function(value) {
                renderer.fn = value
            }
        });
        module.exports = {
            set: function(strategy) {
                renderer = strategy
            },
            get: function() {
                return rendererWrapper
            }
        }
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/events/core/hook_touch_props.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
        var touchPropHook = function(name, event) {
            if (event[name] && !event.touches || !event.touches) {
                return event[name]
            }
            var touches = event.touches.length ? event.touches : event.changedTouches;
            if (!touches.length) {
                return
            }
            return touches[0][name]
        };
        module.exports = function(callback) {
            touchPropsToHook.forEach(function(name) {
                callback(name, function(event) {
                    return touchPropHook(name, event)
                })
            }, this)
        }
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/core/utils/html_parser.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var merge = __webpack_require__( /*! ./array */ 14).merge;
        var domAdapter = __webpack_require__( /*! ../dom_adapter */ 12);
        var isTagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
        var tagWrappers = {
            "default": {
                tagsCount: 0,
                startTags: "",
                endTags: ""
            },
            thead: {
                tagsCount: 1,
                startTags: "<table>",
                endTags: "</table>"
            },
            td: {
                tagsCount: 3,
                startTags: "<table><tbody><tr>",
                endTags: "</tr></tbody></table>"
            },
            col: {
                tagsCount: 2,
                startTags: "<table><colgroup>",
                endTags: "</colgroup></table>"
            },
            tr: {
                tagsCount: 2,
                startTags: "<table><tbody>",
                endTags: "</tbody></table>"
            }
        };
        tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
        tagWrappers.th = tagWrappers.td;
        var parseHTML = function(html) {
            if ("string" !== typeof html) {
                return null
            }
            var fragment = domAdapter.createDocumentFragment();
            var container = fragment.appendChild(domAdapter.createElement("div"));
            var tags = isTagName.exec(html);
            var firstRootTag = tags && tags[1].toLowerCase();
            var tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
            container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
            for (var i = 0; i < tagWrapper.tagsCount; i++) {
                container = container.lastChild
            }
            return merge([], container.childNodes)
        };
        var isTablePart = function(html) {
            var tags = isTagName.exec(html);
            return tags && tags[1] in tagWrappers
        };
        exports.parseHTML = parseHTML;
        exports.isTablePart = isTablePart
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/localization/utils.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.toFixed = void 0;
        var _math = __webpack_require__( /*! ../core/utils/math */ 31);
        var DECIMAL_BASE = 10;

        function roundByAbs(value) {
            var valueSign = (0, _math.sign)(value);
            return valueSign * Math.round(Math.abs(value))
        }

        function adjustValue(value, precision) {
            var precisionMultiplier = Math.pow(DECIMAL_BASE, precision);
            var roundMultiplier = precisionMultiplier * DECIMAL_BASE;
            var intermediateValue = value * roundMultiplier / DECIMAL_BASE;
            return roundByAbs(intermediateValue) / precisionMultiplier
        }

        function toFixed(value, precision) {
            var valuePrecision = precision || 0;
            var adjustedValue = valuePrecision > 0 ? adjustValue.apply(void 0, arguments) : value;
            return adjustedValue.toFixed(valuePrecision)
        }
        exports.toFixed = toFixed
    },
    /*!***********************************************************************!*\
      !*** ./artifacts/transpiled/localization/open_xml_currency_format.js ***!
      \***********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = function(currencySymbol, accountingFormat) {
            if (!accountingFormat) {
                return
            }
            var encodedCurrencySymbol = currencySymbol;
            if ("string" === typeof currencySymbol) {
                encodedCurrencySymbol = "";
                for (var i = 0; i < currencySymbol.length; i++) {
                    if ("$" !== currencySymbol[i]) {
                        encodedCurrencySymbol += "\\"
                    }
                    encodedCurrencySymbol += currencySymbol[i]
                }
            }
            var encodeSymbols = {
                ".00": "{0}",
                "'": "\\'",
                "\\(": "\\(",
                "\\)": "\\)",
                " ": "\\ ",
                '"': "&quot;",
                "\\\xa4": encodedCurrencySymbol
            };
            var result = accountingFormat.split(";");
            for (var _i = 0; _i < result.length; _i++) {
                for (var symbol in encodeSymbols) {
                    if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
                        result[_i] = result[_i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol])
                    }
                }
            }
            return 2 === result.length ? result[0] + "_);" + result[1] : result[0]
        }
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/localization/ldml/date.formatter.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function leftPad(text, length) {
            while (text.length < length) {
                text = "0" + text
            }
            return text
        }
        var FORMAT_TYPES = {
            3: "abbreviated",
            4: "wide",
            5: "narrow"
        };
        var LDML_FORMATTERS = {
            y: function(date, count, useUtc) {
                var year = date[useUtc ? "getUTCFullYear" : "getFullYear"]();
                if (2 === count) {
                    year %= 100
                }
                return leftPad(year.toString(), count)
            },
            M: function(date, count, useUtc, dateParts) {
                var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
                var formatType = FORMAT_TYPES[count];
                if (formatType) {
                    return dateParts.getMonthNames(formatType, "format")[month]
                }
                return leftPad((month + 1).toString(), Math.min(count, 2))
            },
            L: function(date, count, useUtc, dateParts) {
                var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
                var formatType = FORMAT_TYPES[count];
                if (formatType) {
                    return dateParts.getMonthNames(formatType, "standalone")[month]
                }
                return leftPad((month + 1).toString(), Math.min(count, 2))
            },
            Q: function(date, count, useUtc, dateParts) {
                var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
                var quarter = Math.floor(month / 3);
                var formatType = FORMAT_TYPES[count];
                if (formatType) {
                    return dateParts.getQuarterNames(formatType)[quarter]
                }
                return leftPad((quarter + 1).toString(), Math.min(count, 2))
            },
            E: function(date, count, useUtc, dateParts) {
                var day = date[useUtc ? "getUTCDay" : "getDay"]();
                var formatType = FORMAT_TYPES[count < 3 ? 3 : count];
                return dateParts.getDayNames(formatType)[day]
            },
            a: function(date, count, useUtc, dateParts) {
                var hours = date[useUtc ? "getUTCHours" : "getHours"]();
                var period = hours < 12 ? 0 : 1;
                var formatType = FORMAT_TYPES[count];
                return dateParts.getPeriodNames(formatType)[period]
            },
            d: function(date, count, useUtc) {
                return leftPad(date[useUtc ? "getUTCDate" : "getDate"]().toString(), Math.min(count, 2))
            },
            H: function(date, count, useUtc) {
                return leftPad(date[useUtc ? "getUTCHours" : "getHours"]().toString(), Math.min(count, 2))
            },
            h: function(date, count, useUtc) {
                var hours = date[useUtc ? "getUTCHours" : "getHours"]();
                return leftPad((hours % 12 || 12).toString(), Math.min(count, 2))
            },
            m: function(date, count, useUtc) {
                return leftPad(date[useUtc ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(count, 2))
            },
            s: function(date, count, useUtc) {
                return leftPad(date[useUtc ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(count, 2))
            },
            S: function(date, count, useUtc) {
                return leftPad(date[useUtc ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, count)
            },
            x: function(date, count, useUtc) {
                var timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
                var signPart = timezoneOffset > 0 ? "-" : "+";
                var timezoneOffsetAbs = Math.abs(timezoneOffset);
                var hours = Math.floor(timezoneOffsetAbs / 60);
                var minutes = timezoneOffsetAbs % 60;
                var hoursPart = leftPad(hours.toString(), 2);
                var minutesPart = leftPad(minutes.toString(), 2);
                return signPart + hoursPart + (count >= 3 ? ":" : "") + (count > 1 || minutes ? minutesPart : "")
            },
            X: function(date, count, useUtc) {
                if (useUtc || !date.getTimezoneOffset()) {
                    return "Z"
                }
                return LDML_FORMATTERS.x(date, count, useUtc)
            },
            Z: function(date, count, useUtc) {
                return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc)
            }
        };
        var getFormatter = function(format, dateParts) {
            return function(date) {
                var charIndex;
                var formatter;
                var char;
                var charCount = 0;
                var separator = "'";
                var isEscaping = false;
                var isCurrentCharEqualsNext;
                var result = "";
                if (!date) {
                    return null
                }
                if (!format) {
                    return date
                }
                var useUtc = "Z" === format[format.length - 1] || "'Z'" === format.slice(-3);
                for (charIndex = 0; charIndex < format.length; charIndex++) {
                    char = format[charIndex];
                    formatter = LDML_FORMATTERS[char];
                    isCurrentCharEqualsNext = char === format[charIndex + 1];
                    charCount++;
                    if (!isCurrentCharEqualsNext) {
                        if (formatter && !isEscaping) {
                            result += formatter(date, charCount, useUtc, dateParts)
                        }
                        charCount = 0
                    }
                    if (char === separator && !isCurrentCharEqualsNext) {
                        isEscaping = !isEscaping
                    } else {
                        if (isEscaping || !formatter) {
                            result += char
                        }
                    }
                    if (char === separator && isCurrentCharEqualsNext) {
                        charIndex++
                    }
                }
                return result
            }
        };
        module.exports.getFormatter = getFormatter
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/localization/default_date_names.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _iterator2 = _interopRequireDefault(_iterator);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        var DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var PERIODS = ["AM", "PM"];
        var QUARTERS = ["Q1", "Q2", "Q3", "Q4"];
        var cutCaptions = function(captions, format) {
            var lengthByFormat = {
                abbreviated: 3,
                "short": 2,
                narrow: 1
            };
            return _iterator2.default.map(captions, function(caption) {
                return caption.substr(0, lengthByFormat[format])
            })
        };
        module.exports = {
            getMonthNames: function(format) {
                return cutCaptions(MONTHS, format)
            },
            getDayNames: function(format) {
                return cutCaptions(DAYS, format)
            },
            getQuarterNames: function(format) {
                return QUARTERS
            },
            getPeriodNames: function(format) {
                return PERIODS
            }
        }
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.fill_helper.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel = __webpack_require__( /*! ./excel.tag_helper */ 84);
        var _excel2 = _interopRequireDefault(_excel);
        var _excel3 = __webpack_require__( /*! ./excel.pattern_fill_helper */ 460);
        var _excel4 = _interopRequireDefault(_excel3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var fillHelper = {
            tryCreateTag: function(sourceObj) {
                var result = null;
                if ((0, _type.isDefined)(sourceObj)) {
                    result = {
                        patternFill: _excel4.default.tryCreateTag(sourceObj.patternFill)
                    };
                    if (fillHelper.isEmpty(result)) {
                        result = null
                    }
                }
                return result
            },
            tryCreateFillFromSimpleFormat: function() {
                var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    backgroundColor = _ref.backgroundColor,
                    fillPatternType = _ref.fillPatternType,
                    fillPatternColor = _ref.fillPatternColor;
                if ((0, _type.isDefined)(backgroundColor) && !((0, _type.isDefined)(fillPatternType) && (0, _type.isDefined)(fillPatternColor))) {
                    return {
                        patternFill: {
                            patternType: "solid",
                            foregroundColor: {
                                rgb: backgroundColor
                            }
                        }
                    }
                } else {
                    if ((0, _type.isDefined)(fillPatternType) && (0, _type.isDefined)(fillPatternColor)) {
                        return {
                            patternFill: {
                                patternType: fillPatternType,
                                foregroundColor: {
                                    rgb: fillPatternColor
                                },
                                backgroundColor: {
                                    rgb: backgroundColor
                                }
                            }
                        }
                    }
                }
            },
            copySimpleFormat: function(source, target) {
                if (void 0 !== source.backgroundColor) {
                    target.backgroundColor = source.backgroundColor
                }
                if (void 0 !== source.fillPatternType) {
                    target.fillPatternType = source.fillPatternType
                }
                if (void 0 !== source.fillPatternColor) {
                    target.fillPatternColor = source.fillPatternColor
                }
            },
            copy: function(source) {
                var result = null;
                if ((0, _type.isDefined)(source)) {
                    result = {};
                    if (void 0 !== source.patternFill) {
                        result.patternFill = _excel4.default.copy(source.patternFill)
                    }
                }
                return result
            },
            areEqual: function(leftTag, rightTag) {
                return fillHelper.isEmpty(leftTag) && fillHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && _excel4.default.areEqual(leftTag.patternFill, rightTag.patternFill)
            },
            isEmpty: function(tag) {
                return !(0, _type.isDefined)(tag) || _excel4.default.isEmpty(tag.patternFill)
            },
            toXml: function(tag) {
                return _excel2.default.toXml("fill", {}, _excel4.default.toXml(tag.patternFill))
            }
        };
        exports.default = fillHelper
    },
    /*!*******************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.color_helper.js ***!
      \*******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel = __webpack_require__( /*! ./excel.tag_helper */ 84);
        var _excel2 = _interopRequireDefault(_excel);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var colorHelper = {
            _tryConvertColor: function(source) {
                if ("string" !== typeof source) {
                    return source
                }
                var result;
                if (source.length > 0 && "#" === source[0]) {
                    var colorCode = source.substr(1, source.length);
                    if (6 === colorCode.length) {
                        result = "FF" + colorCode
                    } else {
                        if (8 === colorCode.length) {
                            result = colorCode[6] + colorCode[7] + colorCode.substr(0, 6)
                        } else {
                            result = colorCode
                        }
                    }
                } else {
                    result = source
                }
                return result
            },
            tryCreateTag: function(sourceObj) {
                var result = null;
                if ((0, _type.isDefined)(sourceObj)) {
                    if ("string" === typeof sourceObj) {
                        result = {
                            rgb: this._tryConvertColor(sourceObj)
                        }
                    } else {
                        result = {
                            rgb: this._tryConvertColor(sourceObj.rgb),
                            theme: sourceObj.theme
                        }
                    }
                    if (colorHelper.isEmpty(result)) {
                        result = null
                    }
                }
                return result
            },
            copy: function(source) {
                var result = null;
                if ((0, _type.isDefined)(source)) {
                    if ("string" === typeof source) {
                        result = source
                    } else {
                        result = {};
                        if (void 0 !== source.rgb) {
                            result.rgb = source.rgb
                        }
                        if (void 0 !== source.theme) {
                            result.theme = source.theme
                        }
                    }
                }
                return result
            },
            isEmpty: function(tag) {
                return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.rgb) && !(0, _type.isDefined)(tag.theme)
            },
            areEqual: function(leftTag, rightTag) {
                return colorHelper.isEmpty(leftTag) && colorHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.rgb === rightTag.rgb && leftTag.theme === rightTag.theme
            },
            toXml: function(tagName, tag) {
                return _excel2.default.toXml(tagName, {
                    rgb: tag.rgb,
                    theme: tag.theme
                })
            }
        };
        exports.default = colorHelper
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.font_helper.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel = __webpack_require__( /*! ./excel.tag_helper */ 84);
        var _excel2 = _interopRequireDefault(_excel);
        var _excel3 = __webpack_require__( /*! ./excel.color_helper */ 276);
        var _excel4 = _interopRequireDefault(_excel3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var fontHelper = {
            tryCreateTag: function(sourceObj) {
                var result = null;
                if ((0, _type.isDefined)(sourceObj)) {
                    result = {
                        size: sourceObj.size,
                        name: sourceObj.name,
                        family: sourceObj.family,
                        scheme: sourceObj.scheme,
                        bold: sourceObj.bold,
                        italic: sourceObj.italic,
                        underline: sourceObj.underline,
                        color: _excel4.default.tryCreateTag(sourceObj.color)
                    };
                    if (fontHelper.isEmpty(result)) {
                        result = null
                    }
                }
                return result
            },
            copy: function(source) {
                var result = null;
                if ((0, _type.isDefined)(source)) {
                    result = {};
                    if (void 0 !== source.size) {
                        result.size = source.size
                    }
                    if (void 0 !== source.name) {
                        result.name = source.name
                    }
                    if (void 0 !== source.family) {
                        result.family = source.family
                    }
                    if (void 0 !== source.scheme) {
                        result.scheme = source.scheme
                    }
                    if (void 0 !== source.bold) {
                        result.bold = source.bold
                    }
                    if (void 0 !== source.italic) {
                        result.italic = source.italic
                    }
                    if (void 0 !== source.underline) {
                        result.underline = source.underline
                    }
                    if (void 0 !== source.color) {
                        result.color = _excel4.default.copy(source.color)
                    }
                }
                return result
            },
            areEqual: function(leftTag, rightTag) {
                return fontHelper.isEmpty(leftTag) && fontHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.size === rightTag.size && leftTag.name === rightTag.name && leftTag.family === rightTag.family && leftTag.scheme === rightTag.scheme && (leftTag.bold === rightTag.bold || !leftTag.bold === !rightTag.bold) && (leftTag.italic === rightTag.italic || !leftTag.italic === !rightTag.italic) && leftTag.underline === rightTag.underline && _excel4.default.areEqual(leftTag.color, rightTag.color)
            },
            isEmpty: function(tag) {
                return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.size) && !(0, _type.isDefined)(tag.name) && !(0, _type.isDefined)(tag.family) && !(0, _type.isDefined)(tag.scheme) && (!(0, _type.isDefined)(tag.bold) || !tag.bold) && (!(0, _type.isDefined)(tag.italic) || !tag.italic) && !(0, _type.isDefined)(tag.underline) && _excel4.default.isEmpty(tag.color)
            },
            toXml: function(tag) {
                var content = [(0, _type.isDefined)(tag.bold) && tag.bold ? _excel2.default.toXml("b", {}) : "", (0, _type.isDefined)(tag.size) ? _excel2.default.toXml("sz", {
                    val: tag.size
                }) : "", (0, _type.isDefined)(tag.color) ? _excel4.default.toXml("color", tag.color) : "", (0, _type.isDefined)(tag.name) ? _excel2.default.toXml("name", {
                    val: tag.name
                }) : "", (0, _type.isDefined)(tag.family) ? _excel2.default.toXml("family", {
                    val: tag.family
                }) : "", (0, _type.isDefined)(tag.scheme) ? _excel2.default.toXml("scheme", {
                    val: tag.scheme
                }) : "", (0, _type.isDefined)(tag.italic) && tag.italic ? _excel2.default.toXml("i", {}) : "", (0, _type.isDefined)(tag.underline) ? _excel2.default.toXml("u", {
                    val: tag.underline
                }) : ""].join("");
                return _excel2.default.toXml("font", {}, content)
            }
        };
        exports.default = fontHelper
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/exporter/image_creator.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _color = __webpack_require__( /*! ../color */ 91);
        var _color2 = _interopRequireDefault(_color);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _svg = __webpack_require__( /*! ../core/utils/svg */ 216);
        var _svg2 = _interopRequireDefault(_svg);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _dom_adapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _dom = __webpack_require__( /*! ../core/utils/dom */ 11);
        var _dom2 = _interopRequireDefault(_dom);
        var _window = __webpack_require__( /*! ../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _inflector = __webpack_require__( /*! ../core/utils/inflector */ 34);
        var _deferred = __webpack_require__( /*! ../core/utils/deferred */ 6);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var window = _window2.default.getWindow();
        var _math = Math;
        var PI = _math.PI;
        var _min = _math.min;
        var _abs = _math.abs;
        var _sqrt = _math.sqrt;
        var _pow = _math.pow;
        var _atan2 = _math.atan2;
        var _cos = _math.cos;
        var _sin = _math.sin;
        var _number = Number;
        var IMAGE_QUALITY = 1;
        var TEXT_DECORATION_LINE_WIDTH_COEFF = .05;
        var DEFAULT_FONT_SIZE = "10px";
        var DEFAULT_FONT_FAMILY = "sans-serif";
        var DEFAULT_TEXT_COLOR = "#000";
        var parseAttributes;

        function createCanvas(width, height, margin) {
            var canvas = (0, _renderer2.default)("<canvas>")[0];
            canvas.width = width + 2 * margin;
            canvas.height = height + 2 * margin;
            canvas.hidden = true;
            return canvas
        }

        function getStringFromCanvas(canvas, mimeType) {
            var dataURL = canvas.toDataURL(mimeType, IMAGE_QUALITY);
            var imageData = window.atob(dataURL.substring(("data:" + mimeType + ";base64,").length));
            return imageData
        }

        function arcTo(x1, y1, x2, y2, radius, largeArcFlag, clockwise, context) {
            var cBx = (x1 + x2) / 2;
            var cBy = (y1 + y2) / 2;
            var aB = _atan2(y1 - y2, x1 - x2);
            var k = largeArcFlag ? 1 : -1;
            aB += 90 * (PI / 180) * (clockwise ? 1 : -1);
            var opSide = _sqrt(_pow(x2 - x1, 2) + _pow(y2 - y1, 2)) / 2;
            var adjSide = _sqrt(_abs(_pow(radius, 2) - _pow(opSide, 2)));
            var centerX = cBx + k * (adjSide * _cos(aB));
            var centerY = cBy + k * (adjSide * _sin(aB));
            var startAngle = _atan2(y1 - centerY, x1 - centerX);
            var endAngle = _atan2(y2 - centerY, x2 - centerX);
            context.arc(centerX, centerY, radius, startAngle, endAngle, !clockwise)
        }

        function getElementOptions(element, rootAppended) {
            var attr = parseAttributes(element.attributes || {});
            var options = (0, _extend.extend)({}, attr, {
                text: element.textContent.replace(/\s+/g, " "),
                textAlign: "middle" === attr["text-anchor"] ? "center" : attr["text-anchor"]
            });
            var transform = attr.transform;
            var coords;
            if (transform) {
                coords = transform.match(/translate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
                if (coords) {
                    coords = coords[0].match(/-*\d+([.]\d+)*/g);
                    options.translateX = _number(coords[0]);
                    options.translateY = coords[1] ? _number(coords[1]) : 0
                }
                coords = transform.match(/rotate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*,*\s*-*\d+([.]\d+)*)*/);
                if (coords) {
                    coords = coords[0].match(/-*\d+([.]\d+)*/g);
                    options.rotationAngle = _number(coords[0]);
                    options.rotationX = coords[1] && _number(coords[1]);
                    options.rotationY = coords[2] && _number(coords[2])
                }
                coords = transform.match(/scale\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
                if (coords) {
                    coords = coords[0].match(/-*\d+([.]\d+)*/g);
                    options.scaleX = _number(coords[0]);
                    if (coords.length > 1) {
                        options.scaleY = _number(coords[1])
                    } else {
                        options.scaleY = options.scaleX
                    }
                }
            }
            parseStyles(element, options, rootAppended);
            return options
        }

        function drawRect(context, options) {
            var x = options.x;
            var y = options.y;
            var width = options.width;
            var height = options.height;
            var cornerRadius = options.rx;
            if (!cornerRadius) {
                context.rect(x, y, width, height)
            } else {
                cornerRadius = _min(cornerRadius, width / 2, height / 2);
                context.save();
                context.translate(x, y);
                context.moveTo(width / 2, 0);
                context.arcTo(width, 0, width, height, cornerRadius);
                context.arcTo(width, height, 0, height, cornerRadius);
                context.arcTo(0, height, 0, 0, cornerRadius);
                context.arcTo(0, 0, cornerRadius, 0, cornerRadius);
                context.lineTo(width / 2, 0);
                context.restore()
            }
        }

        function drawImage(context, options, shared) {
            var d = new _deferred.Deferred;
            var image = new window.Image;
            image.onload = function() {
                context.save();
                context.globalAlpha = options.globalAlpha;
                transformElement(context, options);
                clipElement(context, options, shared);
                context.drawImage(image, options.x, options.y, options.width, options.height);
                context.restore();
                d.resolve()
            };
            image.onerror = function() {
                d.resolve()
            };
            image.setAttribute("crossOrigin", "anonymous");
            image.src = options.href || options["xlink:href"];
            return d
        }

        function drawPath(context, dAttr) {
            var dArray = dAttr.replace(/,/g, " ").split(/([A-Z])/i).filter(function(item) {
                return "" !== item.trim()
            });
            var i = 0;
            var params;
            var prevParams;
            var prevParamsLen;
            do {
                params = (dArray[i + 1] || "").trim().split(" ");
                switch (dArray[i]) {
                    case "M":
                        context.moveTo(_number(params[0]), _number(params[1]));
                        i += 2;
                        break;
                    case "L":
                        for (var j = 0; j < params.length / 2; j++) {
                            context.lineTo(_number(params[2 * j]), _number(params[2 * j + 1]))
                        }
                        i += 2;
                        break;
                    case "C":
                        context.bezierCurveTo(_number(params[0]), _number(params[1]), _number(params[2]), _number(params[3]), _number(params[4]), _number(params[5]));
                        i += 2;
                        break;
                    case "a":
                        prevParams = dArray[i - 1].trim().split(" ");
                        prevParamsLen = prevParams.length - 1;
                        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(prevParams[prevParamsLen - 1]) + _number(params[5]), _number(prevParams[prevParamsLen]) + _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);
                        i += 2;
                        break;
                    case "A":
                        prevParams = dArray[i - 1].trim().split(" ");
                        prevParamsLen = prevParams.length - 1;
                        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(params[5]), _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);
                        i += 2;
                        break;
                    case "Z":
                        context.closePath();
                        i += 1;
                        break;
                    default:
                        i++
                }
            } while (i < dArray.length)
        }

        function parseStyles(element, options, rootAppended) {
            var style = element.style || {};
            var field;
            for (field in style) {
                if ("" !== style[field]) {
                    options[(0, _inflector.camelize)(field)] = style[field]
                }
            }
            if (rootAppended && _dom_adapter2.default.isElementNode(element)) {
                style = window.getComputedStyle(element);
                ["fill", "stroke", "stroke-width", "font-family", "font-size", "font-style", "font-weight"].forEach(function(prop) {
                    if (prop in style && "" !== style[prop]) {
                        options[(0, _inflector.camelize)(prop)] = style[prop]
                    }
                });
                ["opacity", "fill-opacity", "stroke-opacity"].forEach(function(prop) {
                    if (prop in style && "" !== style[prop] && "1" !== style[prop]) {
                        options[prop] = _number(style[prop])
                    }
                })
            }
            options.textDecoration = options.textDecoration || options.textDecorationLine;
            options.globalAlpha = (0, _type.isDefined)(options.opacity) ? options.opacity : options.globalAlpha
        }

        function parseUrl(urlString) {
            var matches = urlString && urlString.match(/url\(.*#(.*?)["']?\)/i);
            return matches && matches[1]
        }

        function setFontStyle(context, options) {
            var fontParams = [];
            options.fontSize = options.fontSize || DEFAULT_FONT_SIZE;
            options.fontFamily || DEFAULT_FONT_FAMILY;
            options.fill = options.fill || DEFAULT_TEXT_COLOR;
            options.fontStyle && fontParams.push(options.fontStyle);
            options.fontWeight && fontParams.push(options.fontWeight);
            fontParams.push(options.fontSize);
            fontParams.push(options.fontFamily);
            context.font = fontParams.join(" ");
            context.textAlign = options.textAlign;
            context.fillStyle = options.fill;
            context.globalAlpha = options.globalAlpha
        }

        function drawText(context, options, shared) {
            setFontStyle(context, options);
            applyFilter(context, options, shared);
            options.text && context.fillText(options.text, options.x || 0, options.y || 0);
            strokeElement(context, options, true);
            drawTextDecoration(context, options, shared)
        }

        function drawTextDecoration(context, options, shared) {
            if (!options.textDecoration || "none" === options.textDecoration) {
                return
            }
            var x = options.x;
            var textWidth = context.measureText(options.text).width;
            var textHeight = parseInt(options.fontSize, 10);
            var lineHeight = textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF < 1 ? 1 : textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF;
            var y = options.y;
            switch (options.textDecoration) {
                case "line-through":
                    y -= textHeight / 3 + lineHeight / 2;
                    break;
                case "overline":
                    y -= textHeight - lineHeight;
                    break;
                case "underline":
                    y += lineHeight
            }
            context.rect(x, y, textWidth, lineHeight);
            fillElement(context, options, shared);
            strokeElement(context, options)
        }

        function aggregateOpacity(options) {
            options.strokeOpacity = void 0 !== options["stroke-opacity"] ? options["stroke-opacity"] : 1;
            options.fillOpacity = void 0 !== options["fill-opacity"] ? options["fill-opacity"] : 1;
            if (void 0 !== options.opacity) {
                options.strokeOpacity *= options.opacity;
                options.fillOpacity *= options.opacity
            }
        }

        function hasTspan(element) {
            var nodes = element.childNodes;
            for (var i = 0; i < nodes.length; i++) {
                if ("tspan" === nodes[i].tagName) {
                    return true
                }
            }
            return false
        }

        function drawTextElement(childNodes, context, options, shared) {
            var lines = [];
            var line;
            var offset = 0;
            for (var i = 0; i < childNodes.length; i++) {
                var element = childNodes[i];
                if (void 0 === element.tagName) {
                    drawElement(element, context, options, shared)
                } else {
                    if ("tspan" === element.tagName || "text" === element.tagName) {
                        var elementOptions = getElementOptions(element, shared.rootAppended);
                        var mergedOptions = (0, _extend.extend)({}, options, elementOptions);
                        if ("tspan" === element.tagName && hasTspan(element)) {
                            drawTextElement(element.childNodes, context, mergedOptions, shared);
                            continue
                        }
                        mergedOptions.textAlign = "start";
                        if (!line || void 0 !== elementOptions.x) {
                            line = {
                                elements: [],
                                options: [],
                                widths: [],
                                offsets: []
                            };
                            lines.push(line)
                        }
                        if (void 0 !== elementOptions.y) {
                            offset = 0
                        }
                        if (void 0 !== elementOptions.dy) {
                            offset += parseFloat(elementOptions.dy)
                        }
                        line.elements.push(element);
                        line.options.push(mergedOptions);
                        line.offsets.push(offset);
                        setFontStyle(context, mergedOptions);
                        line.widths.push(context.measureText(mergedOptions.text).width)
                    }
                }
            }
            lines.forEach(function(line) {
                var commonWidth = line.widths.reduce(function(commonWidth, width) {
                    return commonWidth + width
                }, 0);
                var xDiff = 0;
                var currentOffset = 0;
                if ("center" === options.textAlign) {
                    xDiff = commonWidth / 2
                }
                if ("end" === options.textAlign) {
                    xDiff = commonWidth
                }
                line.options.forEach(function(o, index) {
                    var width = line.widths[index];
                    o.x = o.x - xDiff + currentOffset;
                    o.y += line.offsets[index];
                    currentOffset += width
                });
                line.elements.forEach(function(element, index) {
                    drawTextElement(element.childNodes, context, line.options[index], shared)
                })
            })
        }

        function drawElement(element, context, parentOptions, shared) {
            var tagName = element.tagName;
            var isText = "text" === tagName || "tspan" === tagName || void 0 === tagName;
            var isImage = "image" === tagName;
            var options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));
            if ("hidden" === options.visibility || options["hidden-for-export"]) {
                return
            }
            context.save();
            !isImage && transformElement(context, options);
            clipElement(context, options, shared);
            aggregateOpacity(options);
            var promise;
            context.beginPath();
            switch (element.tagName) {
                case void 0:
                    drawText(context, options, shared);
                    break;
                case "text":
                case "tspan":
                    drawTextElement(element.childNodes, context, options, shared);
                    break;
                case "image":
                    promise = drawImage(context, options, shared);
                    break;
                case "path":
                    drawPath(context, options.d);
                    break;
                case "rect":
                    drawRect(context, options);
                    context.closePath();
                    break;
                case "circle":
                    context.arc(options.cx, options.cy, options.r, 0, 2 * PI, 1)
            }
            if (!isText) {
                applyFilter(context, options, shared);
                fillElement(context, options, shared);
                strokeElement(context, options)
            }
            applyGradient(context, options, shared, element);
            context.restore();
            return promise
        }

        function applyGradient(context, options, _ref, element) {
            var gradients = _ref.gradients;
            if (0 === gradients.length) {
                return
            }
            var id = parseUrl(options.fill);
            if (id && gradients[id]) {
                var box = element.getBBox();
                var gradient = context.createLinearGradient(box.x, 0, box.x + box.width, 0);
                gradients[id].forEach(function(opt) {
                    var offset = parseInt(opt.offset.replace(/%/, ""));
                    gradient.addColorStop(offset / 100, opt.stopColor)
                });
                context.globalAlpha = options.opacity;
                context.fillStyle = gradient;
                context.fill()
            }
        }

        function applyFilter(context, options, shared) {
            var filterOptions;
            var id = parseUrl(options.filter);
            if (id) {
                filterOptions = shared.filters[id];
                if (!filterOptions) {
                    filterOptions = {
                        offsetX: 0,
                        offsetY: 0,
                        blur: 0,
                        color: "#000"
                    }
                }
                context.shadowOffsetX = filterOptions.offsetX;
                context.shadowOffsetY = filterOptions.offsetY;
                context.shadowColor = filterOptions.color;
                context.shadowBlur = filterOptions.blur
            }
        }

        function transformElement(context, options) {
            context.translate(options.translateX || 0, options.translateY || 0);
            options.translateX = void 0;
            options.translateY = void 0;
            if (options.rotationAngle) {
                context.translate(options.rotationX || 0, options.rotationY || 0);
                context.rotate(options.rotationAngle * PI / 180);
                context.translate(-(options.rotationX || 0), -(options.rotationY || 0));
                options.rotationAngle = void 0;
                options.rotationX = void 0;
                options.rotationY = void 0
            }
            if (isFinite(options.scaleX)) {
                context.scale(options.scaleX, options.scaleY);
                options.scaleX = void 0;
                options.scaleY = void 0
            }
        }

        function clipElement(context, options, shared) {
            if (options["clip-path"]) {
                drawElement(shared.clipPaths[parseUrl(options["clip-path"])], context, {}, shared);
                context.clip();
                options["clip-path"] = void 0
            }
        }

        function hex2rgba(hexColor, alpha) {
            var color = new _color2.default(hexColor);
            return "rgba(" + color.r + "," + color.g + "," + color.b + "," + alpha + ")"
        }

        function createGradient(element) {
            var options = [];
            (0, _iterator.each)(element.childNodes, function(_, _ref2) {
                var attributes = _ref2.attributes;
                options.push({
                    offset: attributes.offset.value,
                    stopColor: attributes["stop-color"].value
                })
            });
            return options
        }

        function createFilter(element) {
            var color;
            var opacity;
            var filterOptions = {};
            (0, _iterator.each)(element.childNodes, function(_, node) {
                var attr = node.attributes;
                if (!attr.result) {
                    return
                }
                switch (attr.result.value) {
                    case "gaussianBlurResult":
                        filterOptions.blur = _number(attr.stdDeviation.value);
                        break;
                    case "offsetResult":
                        filterOptions.offsetX = _number(attr.dx.value);
                        filterOptions.offsetY = _number(attr.dy.value);
                        break;
                    case "floodResult":
                        color = attr["flood-color"] ? attr["flood-color"].value : "#000";
                        opacity = attr["flood-opacity"] ? attr["flood-opacity"].value : 1;
                        filterOptions.color = hex2rgba(color, opacity)
                }
            });
            return filterOptions
        }

        function asyncEach(array, callback) {
            var d = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new _deferred.Deferred;
            if (0 === array.length) {
                return d.resolve()
            }
            var result = callback(array[0]);

            function next() {
                asyncEach(Array.prototype.slice.call(array, 1), callback, d)
            }
            if ((0, _type.isPromise)(result)) {
                result.then(next)
            } else {
                next()
            }
            return d
        }

        function drawCanvasElements(elements, context, parentOptions, shared) {
            return asyncEach(elements, function(element) {
                switch (element.tagName && element.tagName.toLowerCase()) {
                    case "g":
                    case "svg":
                        var options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));
                        context.save();
                        transformElement(context, options);
                        clipElement(context, options, shared);
                        var onDone = function() {
                            context.restore()
                        };
                        var d = drawCanvasElements(element.childNodes, context, options, shared);
                        if ((0, _type.isPromise)(d)) {
                            d.then(onDone)
                        } else {
                            onDone()
                        }
                        return d;
                    case "defs":
                        return drawCanvasElements(element.childNodes, context, {}, shared);
                    case "clippath":
                        shared.clipPaths[element.attributes.id.textContent] = element.childNodes[0];
                        break;
                    case "pattern":
                        shared.patterns[element.attributes.id.textContent] = element;
                        break;
                    case "filter":
                        shared.filters[element.id] = createFilter(element);
                        break;
                    case "lineargradient":
                        shared.gradients[element.attributes.id.textContent] = createGradient(element);
                        break;
                    default:
                        return drawElement(element, context, parentOptions, shared)
                }
            })
        }

        function setLineDash(context, options) {
            var matches = options["stroke-dasharray"] && options["stroke-dasharray"].match(/(\d+)/g);
            if (matches && matches.length) {
                matches = (0, _iterator.map)(matches, function(item) {
                    return _number(item)
                });
                context.setLineDash(matches)
            }
        }

        function strokeElement(context, options, isText) {
            var stroke = options.stroke;
            if (stroke && "none" !== stroke && 0 !== options["stroke-width"]) {
                setLineDash(context, options);
                context.lineJoin = options["stroke-linejoin"];
                context.lineWidth = options["stroke-width"];
                context.globalAlpha = options.strokeOpacity;
                context.strokeStyle = stroke;
                isText ? context.strokeText(options.text, options.x, options.y) : context.stroke();
                context.globalAlpha = 1
            }
        }

        function getPattern(context, pattern, shared) {
            var options = getElementOptions(pattern, shared.rootAppended);
            var patternCanvas = createCanvas(options.width, options.height, 0);
            var patternContext = patternCanvas.getContext("2d");
            drawCanvasElements(pattern.childNodes, patternContext, options, shared);
            return context.createPattern(patternCanvas, "repeat")
        }

        function fillElement(context, options, shared) {
            var fill = options.fill;
            if (fill && "none" !== fill) {
                if (fill.search(/url/) === -1) {
                    context.fillStyle = fill
                } else {
                    var pattern = shared.patterns[parseUrl(fill)];
                    if (!pattern) {
                        return
                    }
                    context.fillStyle = getPattern(context, pattern, shared)
                }
                context.globalAlpha = options.fillOpacity;
                context.fill();
                context.globalAlpha = 1
            }
        }
        parseAttributes = function(attributes) {
            var newAttributes = {};
            var attr;
            (0, _iterator.each)(attributes, function(index, item) {
                attr = item.textContent;
                if (isFinite(attr)) {
                    attr = _number(attr)
                }
                newAttributes[item.name.toLowerCase()] = attr
            });
            return newAttributes
        };

        function drawBackground(context, width, height, backgroundColor, margin) {
            context.fillStyle = backgroundColor || "#ffffff";
            context.fillRect(-margin, -margin, width + 2 * margin, height + 2 * margin)
        }

        function createInvisibleDiv() {
            var invisibleDiv = _dom_adapter2.default.createElement("div");
            invisibleDiv.style.left = "-9999px";
            invisibleDiv.style.position = "absolute";
            return invisibleDiv
        }

        function convertSvgToCanvas(svg, canvas, rootAppended) {
            return drawCanvasElements(svg.childNodes, canvas.getContext("2d"), {}, {
                clipPaths: {},
                patterns: {},
                filters: {},
                gradients: {},
                rootAppended: rootAppended
            })
        }

        function getCanvasFromSvg(markup, width, height, backgroundColor, margin) {
            var svgToCanvas = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : convertSvgToCanvas;
            var canvas = createCanvas(width, height, margin);
            var context = canvas.getContext("2d");
            var svgElem = _svg2.default.getSvgElement(markup);
            var invisibleDiv;
            var markupIsDomElement = _dom_adapter2.default.isElementNode(markup);
            context.translate(margin, margin);
            _dom_adapter2.default.getBody().appendChild(canvas);
            if (!markupIsDomElement) {
                invisibleDiv = createInvisibleDiv();
                invisibleDiv.appendChild(svgElem);
                _dom_adapter2.default.getBody().appendChild(invisibleDiv)
            }
            if (svgElem.attributes.direction) {
                canvas.dir = svgElem.attributes.direction.textContent
            }
            drawBackground(context, width, height, backgroundColor, margin);
            return (0, _deferred.fromPromise)(svgToCanvas(svgElem, canvas, markupIsDomElement && _dom2.default.contains(_dom_adapter2.default.getBody(), markup))).then(function() {
                return canvas
            }).always(function() {
                invisibleDiv && _dom_adapter2.default.getBody().removeChild(invisibleDiv);
                _dom_adapter2.default.getBody().removeChild(canvas)
            })
        }
        exports.imageCreator = {
            getImageData: function(markup, options) {
                var mimeType = "image/" + options.format;
                var width = options.width;
                var height = options.height;
                var backgroundColor = options.backgroundColor;
                if ((0, _type.isFunction)(options.__parseAttributesFn)) {
                    parseAttributes = options.__parseAttributesFn
                }
                return getCanvasFromSvg(markup, width, height, backgroundColor, options.margin, options.svgToCanvas).then(function(canvas) {
                    return getStringFromCanvas(canvas, mimeType)
                })
            },
            getData: function(markup, options) {
                var that = this;
                return exports.imageCreator.getImageData(markup, options).then(function(binaryData) {
                    var mimeType = "image/" + options.format;
                    var data = (0, _type.isFunction)(window.Blob) && !options.forceProxy ? that._getBlob(binaryData, mimeType) : that._getBase64(binaryData);
                    return data
                })
            },
            _getBlob: function(binaryData, mimeType) {
                var i;
                var dataArray = new Uint8Array(binaryData.length);
                for (i = 0; i < binaryData.length; i++) {
                    dataArray[i] = binaryData.charCodeAt(i)
                }
                return new window.Blob([dataArray.buffer], {
                    type: mimeType
                })
            },
            _getBase64: function(binaryData) {
                return window.btoa(binaryData)
            }
        };
        exports.getData = function(data, options) {
            return exports.imageCreator.getData(data, options)
        };
        exports.testFormats = function(formats) {
            var canvas = createCanvas(100, 100, 0);
            return formats.reduce(function(r, f) {
                var mimeType = ("image/" + f).toLowerCase();
                if (canvas.toDataURL(mimeType).indexOf(mimeType) !== -1) {
                    r.supported.push(f)
                } else {
                    r.unsupported.push(f)
                }
                return r
            }, {
                supported: [],
                unsupported: []
            })
        }
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/core/utils/comparator.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _dom_adapter = __webpack_require__( /*! ../dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _data = __webpack_require__( /*! ./data */ 20);
        var _type = __webpack_require__( /*! ./type */ 1);
        var _type2 = _interopRequireDefault(_type);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var hasNegation = function(oldValue, newValue) {
            return 1 / oldValue === 1 / newValue
        };
        var equals = function(oldValue, newValue) {
            oldValue = (0, _data.toComparable)(oldValue, true);
            newValue = (0, _data.toComparable)(newValue, true);
            if (oldValue && newValue && _type2.default.isRenderer(oldValue) && _type2.default.isRenderer(newValue)) {
                return newValue.is(oldValue)
            }
            var oldValueIsNaN = oldValue !== oldValue;
            var newValueIsNaN = newValue !== newValue;
            if (oldValueIsNaN && newValueIsNaN) {
                return true
            }
            if (0 === oldValue && 0 === newValue) {
                return hasNegation(oldValue, newValue)
            }
            if (null === oldValue || "object" !== _typeof(oldValue) || _dom_adapter2.default.isElementNode(oldValue)) {
                return oldValue === newValue
            }
            return false
        };
        exports.equals = equals
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/core/utils/queue.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errors = __webpack_require__( /*! ../errors */ 22);
        var when = __webpack_require__( /*! ../../core/utils/deferred */ 6).when;

        function createQueue(discardPendingTasks) {
            var _tasks = [];
            var _busy = false;

            function exec() {
                while (_tasks.length) {
                    _busy = true;
                    var task = _tasks.shift();
                    var result = task();
                    if (void 0 === result) {
                        continue
                    }
                    if (result.then) {
                        when(result).always(exec);
                        return
                    }
                    throw errors.Error("E0015")
                }
                _busy = false
            }

            function add(task, removeTaskCallback) {
                if (!discardPendingTasks) {
                    _tasks.push(task)
                } else {
                    if (_tasks[0] && removeTaskCallback) {
                        removeTaskCallback(_tasks[0])
                    }
                    _tasks = [task]
                }
                if (!_busy) {
                    exec()
                }
            }

            function busy() {
                return _busy
            }
            return {
                add: add,
                busy: busy
            }
        }
        exports.create = createQueue;
        exports.enqueue = createQueue().add
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/animation/easing.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var isFunction = __webpack_require__( /*! ../core/utils/type */ 1).isFunction;
        var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
        var TransitionTimingFuncMap = {
            linear: "cubic-bezier(0, 0, 1, 1)",
            swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
            ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
            "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
            "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
            "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
        };
        var polynomBezier = function(x1, y1, x2, y2) {
            var Cx = 3 * x1;
            var Bx = 3 * (x2 - x1) - Cx;
            var Ax = 1 - Cx - Bx;
            var Cy = 3 * y1;
            var By = 3 * (y2 - y1) - Cy;
            var Ay = 1 - Cy - By;
            var bezierX = function(t) {
                return t * (Cx + t * (Bx + t * Ax))
            };
            var bezierY = function(t) {
                return t * (Cy + t * (By + t * Ay))
            };
            var derivativeX = function(t) {
                return Cx + t * (2 * Bx + 3 * t * Ax)
            };
            var findXFor = function(t) {
                var x = t;
                var i = 0;
                var z;
                while (i < 14) {
                    z = bezierX(x) - t;
                    if (Math.abs(z) < .001) {
                        break
                    }
                    x -= z / derivativeX(x);
                    i++
                }
                return x
            };
            return function(t) {
                return bezierY(findXFor(t))
            }
        };
        var easing = {};
        var convertTransitionTimingFuncToEasing = function(cssTransitionEasing) {
            cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
            var coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
            var forceName;
            if (!coeffs) {
                forceName = "linear";
                coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX)
            }
            coeffs = coeffs.slice(1, 5);
            for (var i = 0; i < coeffs.length; i++) {
                coeffs[i] = parseFloat(coeffs[i])
            }
            var easingName = forceName || "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
            if (!isFunction(easing[easingName])) {
                easing[easingName] = function(x, t, b, c, d) {
                    return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b
                }
            }
            return easingName
        };
        exports.setEasing = function(value) {
            easing = value
        };
        exports.getEasing = function(name) {
            return easing[name]
        };
        exports.convertTransitionTimingFuncToEasing = convertTransitionTimingFuncToEasing
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/events/pointer/touch.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var devices = __webpack_require__( /*! ../../core/devices */ 15);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var BaseStrategy = __webpack_require__( /*! ./base */ 160);
        var eventMap = {
            dxpointerdown: "touchstart",
            dxpointermove: "touchmove",
            dxpointerup: "touchend",
            dxpointercancel: "touchcancel",
            dxpointerover: "",
            dxpointerout: "",
            dxpointerenter: "",
            dxpointerleave: ""
        };
        var normalizeTouchEvent = function(e) {
            var pointers = [];
            each(e.touches, function(_, touch) {
                pointers.push(extend({
                    pointerId: touch.identifier
                }, touch))
            });
            return {
                pointers: pointers,
                pointerId: e.changedTouches[0].identifier
            }
        };
        var skipTouchWithSameIdentifier = function(pointerEvent) {
            return "ios" === devices.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent)
        };
        var TouchStrategy = BaseStrategy.inherit({
            ctor: function() {
                this.callBase.apply(this, arguments);
                this._pointerId = 0
            },
            _handler: function(e) {
                if (skipTouchWithSameIdentifier(this._eventName)) {
                    var touch = e.changedTouches[0];
                    if (this._pointerId === touch.identifier && 0 !== this._pointerId) {
                        return
                    }
                    this._pointerId = touch.identifier
                }
                return this.callBase.apply(this, arguments)
            },
            _fireEvent: function(args) {
                return this.callBase(extend(normalizeTouchEvent(args.originalEvent), args))
            }
        });
        TouchStrategy.map = eventMap;
        TouchStrategy.normalize = normalizeTouchEvent;
        module.exports = TouchStrategy
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/events/pointer/observer.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var readyCallbacks = __webpack_require__( /*! ../../core/utils/ready_callbacks */ 51);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var addEventsListener = function(events, handler) {
            readyCallbacks.add(function() {
                events.split(" ").forEach(function(event) {
                    domAdapter.listen(domAdapter.getDocument(), event, handler, true)
                })
            })
        };
        var Observer = function(eventMap, pointerEquals, onPointerAdding) {
            onPointerAdding = onPointerAdding || function() {};
            var pointers = [];
            var getPointerIndex = function(e) {
                var index = -1;
                each(pointers, function(i, pointer) {
                    if (!pointerEquals(e, pointer)) {
                        return true
                    }
                    index = i;
                    return false
                });
                return index
            };
            var addPointer = function(e) {
                if (getPointerIndex(e) === -1) {
                    onPointerAdding(e);
                    pointers.push(e)
                }
            };
            var removePointer = function(e) {
                var index = getPointerIndex(e);
                if (index > -1) {
                    pointers.splice(index, 1)
                }
            };
            var updatePointer = function(e) {
                pointers[getPointerIndex(e)] = e
            };
            addEventsListener(eventMap.dxpointerdown, addPointer);
            addEventsListener(eventMap.dxpointermove, updatePointer);
            addEventsListener(eventMap.dxpointerup, removePointer);
            addEventsListener(eventMap.dxpointercancel, removePointer);
            this.pointers = function() {
                return pointers
            };
            this.reset = function() {
                pointers = []
            }
        };
        module.exports = Observer
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/events/pointer/mouse.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var BaseStrategy = __webpack_require__( /*! ./base */ 160);
        var Observer = __webpack_require__( /*! ./observer */ 283);
        var eventMap = {
            dxpointerdown: "mousedown",
            dxpointermove: "mousemove",
            dxpointerup: "mouseup",
            dxpointercancel: "",
            dxpointerover: "mouseover",
            dxpointerout: "mouseout",
            dxpointerenter: "mouseenter",
            dxpointerleave: "mouseleave"
        };
        var normalizeMouseEvent = function(e) {
            e.pointerId = 1;
            return {
                pointers: observer.pointers(),
                pointerId: 1
            }
        };
        var observer;
        var activated = false;
        var activateStrategy = function() {
            if (activated) {
                return
            }
            observer = new Observer(eventMap, function() {
                return true
            });
            activated = true
        };
        var MouseStrategy = BaseStrategy.inherit({
            ctor: function() {
                this.callBase.apply(this, arguments);
                activateStrategy()
            },
            _fireEvent: function(args) {
                return this.callBase(extend(normalizeMouseEvent(args.originalEvent), args))
            }
        });
        MouseStrategy.map = eventMap;
        MouseStrategy.normalize = normalizeMouseEvent;
        MouseStrategy.activate = activateStrategy;
        MouseStrategy.resetObserver = function() {
            observer.reset()
        };
        module.exports = MouseStrategy
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _jquery = __webpack_require__( /*! jquery */ 57);
        var _jquery2 = _interopRequireDefault(_jquery);
        var _version = __webpack_require__( /*! ../core/utils/version */ 60);
        var _error = __webpack_require__( /*! ../core/utils/error */ 138);
        var _error2 = _interopRequireDefault(_error);
        var _use_jquery = __webpack_require__( /*! ./jquery/use_jquery */ 85);
        var _use_jquery2 = _interopRequireDefault(_use_jquery);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var useJQuery = (0, _use_jquery2.default)();
        if (useJQuery && (0, _version.compare)(_jquery2.default.fn.jquery, [1, 10]) < 0) {
            throw _error2.default.Error("E0012")
        }
        __webpack_require__( /*! ./jquery/renderer */ 482);
        __webpack_require__( /*! ./jquery/hooks */ 483);
        __webpack_require__( /*! ./jquery/deferred */ 484);
        __webpack_require__( /*! ./jquery/hold_ready */ 485);
        __webpack_require__( /*! ./jquery/events */ 486);
        __webpack_require__( /*! ./jquery/easing */ 487);
        __webpack_require__( /*! ./jquery/element_data */ 488);
        __webpack_require__( /*! ./jquery/element */ 489);
        __webpack_require__( /*! ./jquery/component_registrator */ 490);
        __webpack_require__( /*! ./jquery/ajax */ 491)
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/ui/themes_callback.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Callbacks = __webpack_require__( /*! ../core/utils/callbacks */ 27);
        module.exports = new Callbacks
    },
    /*!*********************************!*\
      !*** external "window.angular" ***!
      \*********************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports) {
        module.exports = window.angular
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/utils/locker.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errors = __webpack_require__( /*! ../errors */ 22);
        var Locker = function() {
            var info = {};
            var currentCount = function(lockName) {
                return info[lockName] || 0
            };
            return {
                obtain: function(lockName) {
                    info[lockName] = currentCount(lockName) + 1
                },
                release: function(lockName) {
                    var count = currentCount(lockName);
                    if (count < 1) {
                        throw errors.Error("E0014")
                    }
                    if (1 === count) {
                        delete info[lockName]
                    } else {
                        info[lockName] = count - 1
                    }
                },
                locked: function(lockName) {
                    return currentCount(lockName) > 0
                }
            }
        };
        module.exports = Locker
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/ui/selection/selection.strategy.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dataQuery = __webpack_require__( /*! ../../data/query */ 45);
        var commonUtils = __webpack_require__( /*! ../../core/utils/common */ 3);
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var getKeyHash = commonUtils.getKeyHash;
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var Deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6).Deferred;
        module.exports = Class.inherit({
            ctor: function(options) {
                this.options = options;
                this._setOption("disabledItemKeys", []);
                this._clearItemKeys()
            },
            _clearItemKeys: function() {
                this._setOption("addedItemKeys", []);
                this._setOption("removedItemKeys", []);
                this._setOption("removedItems", []);
                this._setOption("addedItems", [])
            },
            validate: commonUtils.noop,
            _setOption: function(name, value) {
                this.options[name] = value
            },
            onSelectionChanged: function onSelectionChanged() {
                var addedItemKeys = this.options.addedItemKeys;
                var removedItemKeys = this.options.removedItemKeys;
                var addedItems = this.options.addedItems;
                var removedItems = this.options.removedItems;
                var selectedItems = this.options.selectedItems;
                var selectedItemKeys = this.options.selectedItemKeys;
                var onSelectionChanged = this.options.onSelectionChanged || commonUtils.noop;
                this._clearItemKeys();
                onSelectionChanged({
                    selectedItems: selectedItems,
                    selectedItemKeys: selectedItemKeys,
                    addedItemKeys: addedItemKeys,
                    removedItemKeys: removedItemKeys,
                    addedItems: addedItems,
                    removedItems: removedItems
                })
            },
            equalKeys: function(key1, key2) {
                if (this.options.equalByReference) {
                    if (typeUtils.isObject(key1) && typeUtils.isObject(key2)) {
                        return key1 === key2
                    }
                }
                return commonUtils.equalByValue(key1, key2)
            },
            getSelectableItems: function(items) {
                return items.filter(function(item) {
                    return !item.disabled
                })
            },
            _clearSelection: function(keys, preserve, isDeselect, isSelectAll) {
                keys = keys || [];
                keys = Array.isArray(keys) ? keys : [keys];
                this.validate();
                return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll)
            },
            _loadFilteredData: function(remoteFilter, localFilter, select, isSelectAll) {
                var filterLength = encodeURI(JSON.stringify(remoteFilter)).length;
                var needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
                var deferred = new Deferred;
                var loadOptions = {
                    filter: needLoadAllData ? void 0 : remoteFilter,
                    select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
                };
                if (remoteFilter && 0 === remoteFilter.length) {
                    deferred.resolve([])
                } else {
                    this.options.load(loadOptions).done(function(items) {
                        var filteredItems = typeUtils.isPlainObject(items) ? items.data : items;
                        if (localFilter && !isSelectAll) {
                            filteredItems = filteredItems.filter(localFilter)
                        } else {
                            if (needLoadAllData) {
                                filteredItems = dataQuery(filteredItems).filter(remoteFilter).toArray()
                            }
                        }
                        deferred.resolve(filteredItems)
                    }).fail(deferred.reject.bind(deferred))
                }
                return deferred
            },
            updateSelectedItemKeyHash: function(keys) {
                for (var i = 0; i < keys.length; i++) {
                    var keyHash = getKeyHash(keys[i]);
                    if (!typeUtils.isObject(keyHash)) {
                        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
                        var keyIndices = this.options.keyHashIndices[keyHash];
                        keyIndices.push(i)
                    }
                }
            },
            _isAnyItemSelected: function(items) {
                for (var i = 0; i < items.length; i++) {
                    if (this.options.isItemSelected(items[i])) {
                        return
                    }
                }
                return false
            },
            _getFullSelectAllState: function() {
                var items = this.options.plainItems();
                var dataFilter = this.options.filter();
                var selectedItems = this.options.selectedItems;
                if (dataFilter) {
                    selectedItems = dataQuery(selectedItems).filter(dataFilter).toArray()
                }
                var selectedItemsLength = selectedItems.length;
                if (!selectedItemsLength) {
                    return this._isAnyItemSelected(items)
                }
                if (selectedItemsLength >= this.options.totalCount() - this.options.disabledItemKeys.length) {
                    return true
                }
                return
            },
            _getVisibleSelectAllState: function() {
                var items = this.getSelectableItems(this.options.plainItems());
                var hasSelectedItems = false;
                var hasUnselectedItems = false;
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var itemData = this.options.getItemData(item);
                    var key = this.options.keyOf(itemData);
                    if (this.options.isSelectableItem(item)) {
                        if (this.isItemKeySelected(key)) {
                            hasSelectedItems = true
                        } else {
                            hasUnselectedItems = true
                        }
                    }
                }
                if (hasSelectedItems) {
                    return !hasUnselectedItems ? true : void 0
                } else {
                    return false
                }
            }
        })
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/utils.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var ko = __webpack_require__( /*! knockout */ 62);
        var getClosestNodeWithContext = function getClosestNodeWithContext(node) {
            var context = ko.contextFor(node);
            if (!context && node.parentNode) {
                return getClosestNodeWithContext(node.parentNode)
            }
            return node
        };
        module.exports.getClosestNodeWithContext = getClosestNodeWithContext
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/bundles/modules/data.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var DevExpress = __webpack_require__( /*! ./core */ 155);
        module.exports = DevExpress.data = DevExpress.data || {};
        Object.defineProperty(DevExpress.data, "errorHandler", {
            get: function() {
                /*! ../../data/errors */
                return __webpack_require__(38).errorHandler
            },
            set: function(value) {
                __webpack_require__( /*! ../../data/errors */ 38).errorHandler = value
            }
        });
        Object.defineProperty(DevExpress.data, "_errorHandler", {
            get: function() {
                /*! ../../data/errors */
                return __webpack_require__(38)._errorHandler
            },
            set: function(value) {
                __webpack_require__( /*! ../../data/errors */ 38)._errorHandler = value
            }
        });
        DevExpress.data.DataSource = __webpack_require__( /*! ../../data/data_source */ 516);
        DevExpress.data.query = __webpack_require__( /*! ../../data/query */ 45);
        DevExpress.data.Store = __webpack_require__( /*! ../../data/abstract_store */ 103);
        DevExpress.data.ArrayStore = __webpack_require__( /*! ../../data/array_store */ 70);
        DevExpress.data.CustomStore = __webpack_require__( /*! ../../data/custom_store */ 118);
        DevExpress.data.LocalStore = __webpack_require__( /*! ../../data/local_store */ 517);
        DevExpress.data.base64_encode = __webpack_require__( /*! ../../data/utils */ 42).base64_encode;
        DevExpress.data.Guid = __webpack_require__( /*! ../../core/guid */ 36);
        DevExpress.data.utils = {};
        DevExpress.data.utils.compileGetter = __webpack_require__( /*! ../../core/utils/data */ 20).compileGetter;
        DevExpress.data.utils.compileSetter = __webpack_require__( /*! ../../core/utils/data */ 20).compileSetter;
        DevExpress.EndpointSelector = __webpack_require__( /*! ../../data/endpoint_selector */ 518);
        DevExpress.data.queryImpl = __webpack_require__( /*! ../../data/query */ 45).queryImpl;
        DevExpress.data.queryAdapters = __webpack_require__( /*! ../../data/query_adapters */ 190);
        var dataUtils = __webpack_require__( /*! ../../data/utils */ 42);
        DevExpress.data.utils.normalizeBinaryCriterion = dataUtils.normalizeBinaryCriterion;
        DevExpress.data.utils.normalizeSortingInfo = dataUtils.normalizeSortingInfo;
        DevExpress.data.utils.errorMessageFromXhr = dataUtils.errorMessageFromXhr;
        DevExpress.data.utils.aggregators = dataUtils.aggregators;
        DevExpress.data.utils.keysEqual = dataUtils.keysEqual;
        DevExpress.data.utils.isDisjunctiveOperator = dataUtils.isDisjunctiveOperator;
        DevExpress.data.utils.isConjunctiveOperator = dataUtils.isConjunctiveOperator;
        DevExpress.data.utils.processRequestResultLock = dataUtils.processRequestResultLock;
        DevExpress.data.utils.toComparable = __webpack_require__( /*! ../../core/utils/data */ 20).toComparable;
        DevExpress.data.utils.multiLevelGroup = __webpack_require__( /*! ../../data/store_helper */ 86).multiLevelGroup;
        DevExpress.data.utils.arrangeSortingInfo = __webpack_require__( /*! ../../data/store_helper */ 86).arrangeSortingInfo;
        DevExpress.data.utils.normalizeDataSourceOptions = __webpack_require__( /*! ../../data/data_source/utils */ 64).normalizeDataSourceOptions
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/data/proxy_url_formatter.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var each = __webpack_require__( /*! ../core/utils/iterator */ 4).each;
        var domAdapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var window = __webpack_require__( /*! ../core/utils/window */ 7).getWindow();
        var callOnce = __webpack_require__( /*! ../core/utils/call_once */ 80);
        var DXPROXY_HOST = "dxproxy.devexpress.com:8000";
        var urlMapping = {};
        var getUrlParser = callOnce(function() {
            var a = domAdapter.createElement("a");
            var props = ["protocol", "hostname", "port", "pathname", "search", "hash"];
            var normalizePath = function(value) {
                if ("/" !== value.charAt(0)) {
                    value = "/" + value
                }
                return value
            };
            return function(url) {
                a.href = url;
                var result = {};
                each(props, function() {
                    result[this] = a[this]
                });
                result.pathname = normalizePath(result.pathname);
                return result
            }
        });
        var parseUrl = function(url) {
            var urlParser = getUrlParser();
            return urlParser(url)
        };
        var extractProxyAppId = function() {
            return window.location.pathname.split("/")[1]
        };
        module.exports = {
            parseUrl: parseUrl,
            isProxyUsed: function() {
                return window.location.host === DXPROXY_HOST
            },
            formatProxyUrl: function(localUrl) {
                var urlData = parseUrl(localUrl);
                if (!/^(localhost$|127\.)/i.test(urlData.hostname)) {
                    return localUrl
                }
                var proxyUrlPart = DXPROXY_HOST + "/" + extractProxyAppId() + "_" + urlData.port;
                urlMapping[proxyUrlPart] = urlData.hostname + ":" + urlData.port;
                var resultUrl = "http://" + proxyUrlPart + urlData.pathname + urlData.search;
                return resultUrl
            },
            formatLocalUrl: function(proxyUrl) {
                if (proxyUrl.indexOf(DXPROXY_HOST) < 0) {
                    return proxyUrl
                }
                var resultUrl = proxyUrl;
                for (var proxyUrlPart in urlMapping) {
                    if (Object.prototype.hasOwnProperty.call(urlMapping, proxyUrlPart)) {
                        if (proxyUrl.indexOf(proxyUrlPart) >= 0) {
                            resultUrl = proxyUrl.replace(proxyUrlPart, urlMapping[proxyUrlPart]);
                            break
                        }
                    }
                }
                return resultUrl
            }
        }
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/data/odata/store.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _config = __webpack_require__( /*! ../../core/config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _utils = __webpack_require__( /*! ./utils */ 96);
        var _proxy_url_formatter = __webpack_require__( /*! ../proxy_url_formatter */ 292);
        var _proxy_url_formatter2 = _interopRequireDefault(_proxy_url_formatter);
        var _errors = __webpack_require__( /*! ../errors */ 38);
        var _query = __webpack_require__( /*! ../query */ 45);
        var _query2 = _interopRequireDefault(_query);
        var _abstract_store = __webpack_require__( /*! ../abstract_store */ 103);
        var _abstract_store2 = _interopRequireDefault(_abstract_store);
        var _request_dispatcher = __webpack_require__( /*! ./request_dispatcher */ 294);
        var _request_dispatcher2 = _interopRequireDefault(_request_dispatcher);
        var _deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        __webpack_require__( /*! ./query_adapter */ 162);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var ANONYMOUS_KEY_NAME = "5d46402c-7899-4ea9-bd81-8b73c47c7683";
        var expandKeyType = function(key, keyType) {
            return _defineProperty({}, key, keyType)
        };
        var mergeFieldTypesWithKeyType = function(fieldTypes, keyType) {
            var result = {};
            for (var field in fieldTypes) {
                result[field] = fieldTypes[field]
            }
            for (var keyName in keyType) {
                if (keyName in result) {
                    if (result[keyName] !== keyType[keyName]) {
                        _errors.errors.log("W4001", keyName)
                    }
                } else {
                    result[keyName] = keyType[keyName]
                }
            }
            return result
        };
        var ODataStore = _abstract_store2.default.inherit({
            ctor: function(options) {
                this.callBase(options);
                this._requestDispatcher = new _request_dispatcher2.default(options);
                var key = this.key();
                var fieldTypes = options.fieldTypes;
                var keyType = options.keyType;
                if (keyType) {
                    var keyTypeIsString = "string" === typeof keyType;
                    if (!key) {
                        key = keyTypeIsString ? ANONYMOUS_KEY_NAME : Object.keys(keyType);
                        this._legacyAnonymousKey = key
                    }
                    if (keyTypeIsString) {
                        keyType = expandKeyType(key, keyType)
                    }
                    fieldTypes = mergeFieldTypesWithKeyType(fieldTypes, keyType)
                }
                this._fieldTypes = fieldTypes || {};
                if (2 === this.version()) {
                    this._updateMethod = "MERGE"
                } else {
                    this._updateMethod = "PATCH"
                }
            },
            _customLoadOptions: function() {
                return ["expand", "customQueryParams"]
            },
            _byKeyImpl: function(key, extraOptions) {
                var params = {};
                if (extraOptions) {
                    params.$expand = (0, _utils.generateExpand)(this.version(), extraOptions.expand, extraOptions.select) || void 0;
                    params.$select = (0, _utils.generateSelect)(this.version(), extraOptions.select) || void 0
                }
                return this._requestDispatcher.sendRequest(this._byKeyUrl(key), "GET", params)
            },
            createQuery: function(loadOptions) {
                var _loadOptions$urlOverr;
                var url;
                var queryOptions = {
                    adapter: "odata",
                    beforeSend: this._requestDispatcher.beforeSend,
                    errorHandler: this._errorHandler,
                    jsonp: this._requestDispatcher.jsonp,
                    version: this._requestDispatcher.version,
                    withCredentials: this._requestDispatcher._withCredentials,
                    expand: null === loadOptions || void 0 === loadOptions ? void 0 : loadOptions.expand,
                    requireTotalCount: null === loadOptions || void 0 === loadOptions ? void 0 : loadOptions.requireTotalCount,
                    deserializeDates: this._requestDispatcher._deserializeDates,
                    fieldTypes: this._fieldTypes
                };
                url = null !== (_loadOptions$urlOverr = null === loadOptions || void 0 === loadOptions ? void 0 : loadOptions.urlOverride) && void 0 !== _loadOptions$urlOverr ? _loadOptions$urlOverr : this._requestDispatcher.url;
                if ((0, _type.isDefined)(this._requestDispatcher.filterToLower)) {
                    queryOptions.filterToLower = this._requestDispatcher.filterToLower
                }
                if (null === loadOptions || void 0 === loadOptions ? void 0 : loadOptions.customQueryParams) {
                    var params = (0, _utils.escapeServiceOperationParams)(null === loadOptions || void 0 === loadOptions ? void 0 : loadOptions.customQueryParams, this.version());
                    if (4 === this.version()) {
                        url = (0, _utils.formatFunctionInvocationUrl)(url, params)
                    } else {
                        queryOptions.params = params
                    }
                }
                return (0, _query2.default)(url, queryOptions)
            },
            _insertImpl: function(values) {
                var _this = this;
                this._requireKey();
                var d = new _deferred.Deferred;
                (0, _deferred.when)(this._requestDispatcher.sendRequest(this._requestDispatcher.url, "POST", null, values)).done(function(serverResponse) {
                    return d.resolve(serverResponse && !(0, _config2.default)().useLegacyStoreResult ? serverResponse : values, _this.keyOf(serverResponse))
                }).fail(d.reject);
                return d.promise()
            },
            _updateImpl: function(key, values) {
                var d = new _deferred.Deferred;
                (0, _deferred.when)(this._requestDispatcher.sendRequest(this._byKeyUrl(key), this._updateMethod, null, values)).done(function(serverResponse) {
                    return (0, _config2.default)().useLegacyStoreResult ? d.resolve(key, values) : d.resolve(serverResponse || values, key)
                }).fail(d.reject);
                return d.promise()
            },
            _removeImpl: function(key) {
                var d = new _deferred.Deferred;
                (0, _deferred.when)(this._requestDispatcher.sendRequest(this._byKeyUrl(key), "DELETE")).done(function() {
                    return d.resolve(key)
                }).fail(d.reject);
                return d.promise()
            },
            _convertKey: function(value) {
                var result = value;
                var fieldTypes = this._fieldTypes;
                var key = this.key() || this._legacyAnonymousKey;
                if (Array.isArray(key)) {
                    result = {};
                    for (var i = 0; i < key.length; i++) {
                        var keyName = key[i];
                        result[keyName] = (0, _utils.convertPrimitiveValue)(fieldTypes[keyName], value[keyName])
                    }
                } else {
                    if (fieldTypes[key]) {
                        result = (0, _utils.convertPrimitiveValue)(fieldTypes[key], value)
                    }
                }
                return result
            },
            _byKeyUrl: function(value, useOriginalHost) {
                var baseUrl = useOriginalHost ? _proxy_url_formatter2.default.formatLocalUrl(this._requestDispatcher.url) : this._requestDispatcher.url;
                var convertedKey = this._convertKey(value);
                return "".concat(baseUrl, "(").concat(encodeURIComponent((0, _utils.serializeKey)(convertedKey, this.version())), ")")
            },
            version: function() {
                return this._requestDispatcher.version
            }
        }, "odata");
        module.exports = ODataStore
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/data/odata/request_dispatcher.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _utils = __webpack_require__( /*! ./utils */ 96);
        __webpack_require__( /*! ./query_adapter */ 162);

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var DEFAULT_PROTOCOL_VERSION = 2;
        var RequestDispatcher = function() {
            function RequestDispatcher(options) {
                _classCallCheck(this, RequestDispatcher);
                options = options || {};
                this._url = String(options.url).replace(/\/+$/, "");
                this._beforeSend = options.beforeSend;
                this._jsonp = options.jsonp;
                this._version = options.version || DEFAULT_PROTOCOL_VERSION;
                this._withCredentials = options.withCredentials;
                this._deserializeDates = options.deserializeDates;
                this._filterToLower = options.filterToLower
            }
            _createClass(RequestDispatcher, [{
                key: "sendRequest",
                value: function(url, method, params, payload) {
                    return (0, _utils.sendRequest)(this.version, {
                        url: url,
                        method: method,
                        params: params || {},
                        payload: payload
                    }, {
                        beforeSend: this._beforeSend,
                        jsonp: this._jsonp,
                        withCredentials: this._withCredentials,
                        deserializeDates: this._deserializeDates
                    })
                }
            }, {
                key: "version",
                get: function() {
                    return this._version
                }
            }, {
                key: "beforeSend",
                get: function() {
                    return this._beforeSend
                }
            }, {
                key: "url",
                get: function() {
                    return this._url
                }
            }, {
                key: "jsonp",
                get: function() {
                    return this._jsonp
                }
            }, {
                key: "filterToLower",
                get: function() {
                    return this._filterToLower
                }
            }]);
            return RequestDispatcher
        }();
        exports.default = RequestDispatcher
    }, ,
    /*!*******************************!*\
      !*** external "window.JSZip" ***!
      \*******************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports) {
        module.exports = window.JSZip
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/localization/ldml/number.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var fitIntoRange = __webpack_require__( /*! ../../core/utils/math */ 31).fitIntoRange;
        var toFixed = __webpack_require__( /*! ../utils */ 271).toFixed;
        var DEFAULT_CONFIG = {
            thousandsSeparator: ",",
            decimalSeparator: "."
        };
        var ESCAPING_CHAR = "'";
        var MAXIMUM_NUMBER_LENGTH = 15;

        function getGroupSizes(formatString) {
            return formatString.split(",").slice(1).map(function(str) {
                return str.split("").filter(function(char) {
                    return "#" === char || "0" === char
                }).length
            })
        }

        function getSignParts(format) {
            var signParts = format.split(";");
            if (1 === signParts.length) {
                signParts.push("-" + signParts[0])
            }
            return signParts
        }

        function reverseString(str) {
            return str.toString().split("").reverse().join("")
        }

        function isPercentFormat(format) {
            return format.indexOf("%") !== -1 && !format.match(/'[^']*%[^']*'/g)
        }

        function getNonRequiredDigitCount(floatFormat) {
            if (!floatFormat) {
                return 0
            }
            return floatFormat.length - floatFormat.replace(/[#]/g, "").length
        }

        function getRequiredDigitCount(floatFormat) {
            if (!floatFormat) {
                return 0
            }
            return floatFormat.length - floatFormat.replace(/[0]/g, "").length
        }

        function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
            if (!valuePart) {
                return ""
            }
            if (valuePart.length > maxDigitCount) {
                valuePart = valuePart.substr(0, maxDigitCount)
            }
            while (valuePart.length > minDigitCount && "0" === valuePart.slice(-1)) {
                valuePart = valuePart.substr(0, valuePart.length - 1)
            }
            while (valuePart.length < minDigitCount) {
                valuePart += "0"
            }
            return valuePart
        }

        function applyGroups(valueString, groupSizes, thousandsSeparator) {
            if (!groupSizes.length) {
                return valueString
            }
            var groups = [];
            var index = 0;
            while (valueString) {
                var groupSize = groupSizes[index];
                if (!groupSize) {
                    break
                }
                groups.push(valueString.slice(0, groupSize));
                valueString = valueString.slice(groupSize);
                if (index < groupSizes.length - 1) {
                    index++
                }
            }
            return groups.join(thousandsSeparator)
        }

        function formatNumberPart(format, valueString) {
            return format.split(ESCAPING_CHAR).map(function(formatPart, escapeIndex) {
                var isEscape = escapeIndex % 2;
                if (!formatPart && isEscape) {
                    return ESCAPING_CHAR
                }
                return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString)
            }).join("")
        }

        function getFloatPointIndex(format) {
            var isEscape = false;
            for (var index = 0; index < format.length; index++) {
                if ("'" === format[index]) {
                    isEscape = !isEscape
                }
                if ("." === format[index] && !isEscape) {
                    return index
                }
            }
            return format.length
        }

        function getFormatter(format, config) {
            config = config || DEFAULT_CONFIG;
            return function(value) {
                if ("number" !== typeof value || isNaN(value)) {
                    return ""
                }
                var signFormatParts = getSignParts(format);
                var isPositiveZero = 1 / value === 1 / 0;
                var isPositive = value > 0 || isPositiveZero;
                var numberFormat = signFormatParts[isPositive ? 0 : 1];
                if (isPercentFormat(numberFormat)) {
                    value = 100 * value
                }
                if (!isPositive) {
                    value = -value
                }
                var floatPointIndex = getFloatPointIndex(numberFormat);
                var floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
                var minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
                var maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
                var minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
                var maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;
                var integerLength = Math.floor(value).toString().length;
                var floatPrecision = fitIntoRange(maxFloatPrecision, 0, MAXIMUM_NUMBER_LENGTH - integerLength);
                var groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
                var valueParts = toFixed(value, floatPrecision < 0 ? 0 : floatPrecision).split(".");
                var valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
                var valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
                valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config.thousandsSeparator);
                var integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
                var floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : "";
                var result = integerString + (floatString.match(/\d/) ? config.decimalSeparator : "") + floatString;
                return result
            }
        }

        function parseValue(text, isPercent, isNegative) {
            var value = (isPercent ? .01 : 1) * parseFloat(text) || 0;
            return isNegative ? -value : value
        }

        function prepareValueText(valueText, formatter, isPercent, isIntegerPart) {
            var nextValueText = valueText;
            var char;
            var text;
            var nextText;
            do {
                if (nextText) {
                    char = text.length === nextText.length ? "0" : "1";
                    valueText = isIntegerPart ? char + valueText : valueText + char
                }
                text = nextText || formatter(parseValue(nextValueText, isPercent));
                nextValueText = isIntegerPart ? "1" + nextValueText : nextValueText + "1";
                nextText = formatter(parseValue(nextValueText, isPercent))
            } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));
            if (isIntegerPart && nextText.length > text.length) {
                var hasGroups = formatter(12345).indexOf("12345") === -1;
                do {
                    valueText = "1" + valueText
                } while (hasGroups && parseValue(valueText, isPercent) < 1e5)
            }
            return valueText
        }

        function getFormatByValueText(valueText, formatter, isPercent, isNegative) {
            var format = formatter(parseValue(valueText, isPercent, isNegative));
            var valueTextParts = valueText.split(".");
            var valueTextWithModifiedFloat = valueTextParts[0] + ".3" + valueTextParts[1].slice(1);
            var valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);
            var decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf("3") - 1;
            format = format.replace(/(\d)\D(\d)/g, "$1,$2");
            if (decimalSeparatorIndex >= 0) {
                format = format.slice(0, decimalSeparatorIndex) + "." + format.slice(decimalSeparatorIndex + 1)
            }
            format = format.replace(/1+/, "1").replace(/1/g, "#");
            if (!isPercent) {
                format = format.replace("%", "'%'")
            }
            return format
        }

        function getFormat(formatter) {
            var valueText = ".";
            var isPercent = formatter(1).indexOf("100") >= 0;
            valueText = prepareValueText(valueText, formatter, isPercent, true);
            valueText = prepareValueText(valueText, formatter, isPercent, false);
            var positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);
            var negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);
            return negativeFormat === "-" + positiveFormat ? positiveFormat : positiveFormat + ";" + negativeFormat
        }
        exports.getFormatter = getFormatter;
        exports.getFormat = getFormat
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/localization/language_codes.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var locale = __webpack_require__( /*! ./core */ 83).locale;
        var LANGUAGE_CODES = {
            ar: 1,
            bg: 2,
            ca: 3,
            "zh-Hans": 4,
            cs: 5,
            da: 6,
            de: 7,
            el: 8,
            en: 9,
            es: 10,
            fi: 11,
            fr: 12,
            he: 13,
            hu: 14,
            is: 15,
            it: 16,
            ja: 17,
            ko: 18,
            nl: 19,
            no: 20,
            pl: 21,
            pt: 22,
            rm: 23,
            ro: 24,
            ru: 25,
            hr: 26,
            sk: 27,
            sq: 28,
            sv: 29,
            th: 30,
            tr: 31,
            ur: 32,
            id: 33,
            uk: 34,
            be: 35,
            sl: 36,
            et: 37,
            lv: 38,
            lt: 39,
            tg: 40,
            fa: 41,
            vi: 42,
            hy: 43,
            az: 44,
            eu: 45,
            hsb: 46,
            mk: 47,
            tn: 50,
            xh: 52,
            zu: 53,
            af: 54,
            ka: 55,
            fo: 56,
            hi: 57,
            mt: 58,
            se: 59,
            ga: 60,
            ms: 62,
            kk: 63,
            ky: 64,
            sw: 65,
            tk: 66,
            uz: 67,
            tt: 68,
            bn: 69,
            pa: 70,
            gu: 71,
            or: 72,
            ta: 73,
            te: 74,
            kn: 75,
            ml: 76,
            as: 77,
            mr: 78,
            sa: 79,
            mn: 80,
            bo: 81,
            cy: 82,
            km: 83,
            lo: 84,
            gl: 86,
            kok: 87,
            syr: 90,
            si: 91,
            iu: 93,
            am: 94,
            tzm: 95,
            ne: 97,
            fy: 98,
            ps: 99,
            fil: 100,
            dv: 101,
            ha: 104,
            yo: 106,
            quz: 107,
            nso: 108,
            ba: 109,
            lb: 110,
            kl: 111,
            ig: 112,
            ii: 120,
            arn: 122,
            moh: 124,
            br: 126,
            ug: 128,
            mi: 129,
            oc: 130,
            co: 131,
            gsw: 132,
            sah: 133,
            qut: 134,
            rw: 135,
            wo: 136,
            prs: 140,
            gd: 145,
            "ar-SA": 1025,
            "bg-BG": 1026,
            "ca-ES": 1027,
            "zh-TW": 1028,
            "cs-CZ": 1029,
            "da-DK": 1030,
            "de-DE": 1031,
            "el-GR": 1032,
            "en-US": 1033,
            "fi-FI": 1035,
            "fr-FR": 1036,
            "he-IL": 1037,
            "hu-HU": 1038,
            "is-IS": 1039,
            "it-IT": 1040,
            "ja-JP": 1041,
            "ko-KR": 1042,
            "nl-NL": 1043,
            "nb-NO": 1044,
            "pl-PL": 1045,
            "pt-BR": 1046,
            "rm-CH": 1047,
            "ro-RO": 1048,
            "ru-RU": 1049,
            "hr-HR": 1050,
            "sk-SK": 1051,
            "sq-AL": 1052,
            "sv-SE": 1053,
            "th-TH": 1054,
            "tr-TR": 1055,
            "ur-PK": 1056,
            "id-ID": 1057,
            "uk-UA": 1058,
            "be-BY": 1059,
            "sl-SI": 1060,
            "et-EE": 1061,
            "lv-LV": 1062,
            "lt-LT": 1063,
            "tg-Cyrl-TJ": 1064,
            "fa-IR": 1065,
            "vi-VN": 1066,
            "hy-AM": 1067,
            "az-Latn-AZ": 1068,
            "eu-ES": 1069,
            "hsb-DE": 1070,
            "mk-MK": 1071,
            "tn-ZA": 1074,
            "xh-ZA": 1076,
            "zu-ZA": 1077,
            "af-ZA": 1078,
            "ka-GE": 1079,
            "fo-FO": 1080,
            "hi-IN": 1081,
            "mt-MT": 1082,
            "se-NO": 1083,
            "ms-MY": 1086,
            "kk-KZ": 1087,
            "ky-KG": 1088,
            "sw-KE": 1089,
            "tk-TM": 1090,
            "uz-Latn-UZ": 1091,
            "tt-RU": 1092,
            "bn-IN": 1093,
            "pa-IN": 1094,
            "gu-IN": 1095,
            "or-IN": 1096,
            "ta-IN": 1097,
            "te-IN": 1098,
            "kn-IN": 1099,
            "ml-IN": 1100,
            "as-IN": 1101,
            "mr-IN": 1102,
            "sa-IN": 1103,
            "mn-MN": 1104,
            "bo-CN": 1105,
            "cy-GB": 1106,
            "km-KH": 1107,
            "lo-LA": 1108,
            "gl-ES": 1110,
            "kok-IN": 1111,
            "syr-SY": 1114,
            "si-LK": 1115,
            "iu-Cans-CA": 1117,
            "am-ET": 1118,
            "ne-NP": 1121,
            "fy-NL": 1122,
            "ps-AF": 1123,
            "fil-PH": 1124,
            "dv-MV": 1125,
            "ha-Latn-NG": 1128,
            "yo-NG": 1130,
            "quz-BO": 1131,
            "nso-ZA": 1132,
            "ba-RU": 1133,
            "lb-LU": 1134,
            "kl-GL": 1135,
            "ig-NG": 1136,
            "ii-CN": 1144,
            "arn-CL": 1146,
            "moh-CA": 1148,
            "br-FR": 1150,
            "ug-CN": 1152,
            "mi-NZ": 1153,
            "oc-FR": 1154,
            "co-FR": 1155,
            "gsw-FR": 1156,
            "sah-RU": 1157,
            "qut-GT": 1158,
            "rw-RW": 1159,
            "wo-SN": 1160,
            "prs-AF": 1164,
            "gd-GB": 1169,
            "ar-IQ": 2049,
            "zh-CN": 2052,
            "de-CH": 2055,
            "en-GB": 2057,
            "es-MX": 2058,
            "fr-BE": 2060,
            "it-CH": 2064,
            "nl-BE": 2067,
            "nn-NO": 2068,
            "pt-PT": 2070,
            "sr-Latn-CS": 2074,
            "sv-FI": 2077,
            "az-Cyrl-AZ": 2092,
            "dsb-DE": 2094,
            "se-SE": 2107,
            "ga-IE": 2108,
            "ms-BN": 2110,
            "uz-Cyrl-UZ": 2115,
            "bn-BD": 2117,
            "mn-Mong-CN": 2128,
            "iu-Latn-CA": 2141,
            "tzm-Latn-DZ": 2143,
            "quz-EC": 2155,
            "ar-EG": 3073,
            "zh-HK": 3076,
            "de-AT": 3079,
            "en-AU": 3081,
            "es-ES": 3082,
            "fr-CA": 3084,
            "sr-Cyrl-CS": 3098,
            "se-FI": 3131,
            "quz-PE": 3179,
            "ar-LY": 4097,
            "zh-SG": 4100,
            "de-LU": 4103,
            "en-CA": 4105,
            "es-GT": 4106,
            "fr-CH": 4108,
            "hr-BA": 4122,
            "smj-NO": 4155,
            "ar-DZ": 5121,
            "zh-MO": 5124,
            "de-LI": 5127,
            "en-NZ": 5129,
            "es-CR": 5130,
            "fr-LU": 5132,
            "bs-Latn-BA": 5146,
            "smj-SE": 5179,
            "ar-MA": 6145,
            "en-IE": 6153,
            "es-PA": 6154,
            "fr-MC": 6156,
            "sr-Latn-BA": 6170,
            "sma-NO": 6203,
            "ar-TN": 7169,
            "en-ZA": 7177,
            "es-DO": 7178,
            "sr-Cyrl-BA": 7194,
            "sma-SE": 7227,
            "ar-OM": 8193,
            "en-JM": 8201,
            "es-VE": 8202,
            "bs-Cyrl-BA": 8218,
            "sms-FI": 8251,
            "ar-YE": 9217,
            "en-029": 9225,
            "es-CO": 9226,
            "sr-Latn-RS": 9242,
            "smn-FI": 9275,
            "ar-SY": 10241,
            "en-BZ": 10249,
            "es-PE": 10250,
            "sr-Cyrl-RS": 10266,
            "ar-JO": 11265,
            "en-TT": 11273,
            "es-AR": 11274,
            "sr-Latn-ME": 11290,
            "ar-LB": 12289,
            "en-ZW": 12297,
            "es-EC": 12298,
            "sr-Cyrl-ME": 12314,
            "ar-KW": 13313,
            "en-PH": 13321,
            "es-CL": 13322,
            "ar-AE": 14337,
            "es-UY": 14346,
            "ar-BH": 15361,
            "es-PY": 15370,
            "ar-QA": 16385,
            "en-IN": 16393,
            "es-BO": 16394,
            "en-MY": 17417,
            "es-SV": 17418,
            "en-SG": 18441,
            "es-HN": 18442,
            "es-NI": 19466,
            "es-PR": 20490,
            "es-US": 21514,
            "bs-Cyrl": 25626,
            "bs-Latn": 26650,
            "sr-Cyrl": 27674,
            "sr-Latn": 28698,
            smn: 28731,
            "az-Cyrl": 29740,
            sms: 29755,
            zh: 30724,
            nn: 30740,
            bs: 30746,
            "az-Latn": 30764,
            sma: 30779,
            "uz-Cyrl": 30787,
            "mn-Cyrl": 30800,
            "iu-Cans": 30813,
            "zh-Hant": 31748,
            nb: 31764,
            sr: 31770,
            "tg-Cyrl": 31784,
            dsb: 31790,
            smj: 31803,
            "uz-Latn": 31811,
            "mn-Mong": 31824,
            "iu-Latn": 31837,
            "tzm-Latn": 31839,
            "ha-Latn": 31848
        };
        exports.getLanguageId = function() {
            return LANGUAGE_CODES[locale()]
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/utils/storage.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var window = __webpack_require__( /*! ../../core/utils/window */ 7).getWindow();
        var getSessionStorage = function() {
            var sessionStorage;
            try {
                sessionStorage = window.sessionStorage
            } catch (e) {}
            return sessionStorage
        };
        exports.sessionStorage = getSessionStorage
    },
    /*!***********************************************************************************!*\
      !*** ./artifacts/transpiled/animation/transition_executor/transition_executor.js ***!
      \***********************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var commonUtils = __webpack_require__( /*! ../../core/utils/common */ 3);
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var iteratorUtils = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var fx = __webpack_require__( /*! ../fx */ 40);
        var animationPresetsModule = __webpack_require__( /*! ../presets/presets */ 188);
        var deferredUtils = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var when = deferredUtils.when;
        var Deferred = deferredUtils.Deferred;
        var directionPostfixes = {
            forward: " dx-forward",
            backward: " dx-backward",
            none: " dx-no-direction",
            undefined: " dx-no-direction"
        };
        var DX_ANIMATING_CLASS = "dx-animating";
        var TransitionExecutor = Class.inherit({
            ctor: function() {
                this._accumulatedDelays = {
                    enter: 0,
                    leave: 0
                };
                this._animations = [];
                this.reset()
            },
            _createAnimations: function($elements, initialConfig, configModifier, type) {
                var that = this;
                var result = [];
                configModifier = configModifier || {};
                var animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);
                if (animationConfig) {
                    $elements.each(function() {
                        var animation = that._createAnimation($(this), animationConfig, configModifier);
                        if (animation) {
                            animation.element.addClass(DX_ANIMATING_CLASS);
                            animation.setup();
                            result.push(animation)
                        }
                    })
                }
                return result
            },
            _prepareElementAnimationConfig: function(config, configModifier, type) {
                var result;
                if ("string" === typeof config) {
                    var presetName = config;
                    config = animationPresetsModule.presets.getPreset(presetName)
                }
                if (!config) {
                    result = void 0
                } else {
                    if (typeUtils.isFunction(config[type])) {
                        result = config[type]
                    } else {
                        result = extend({
                            skipElementInitialStyles: true,
                            cleanupWhen: this._completePromise
                        }, config, configModifier);
                        if (!result.type || "css" === result.type) {
                            var cssClass = "dx-" + type;
                            var extraCssClasses = (result.extraCssClasses ? " " + result.extraCssClasses : "") + directionPostfixes[result.direction];
                            result.type = "css";
                            result.from = (result.from || cssClass) + extraCssClasses;
                            result.to = result.to || cssClass + "-active"
                        }
                        result.staggerDelay = result.staggerDelay || 0;
                        result.delay = result.delay || 0;
                        if (result.staggerDelay) {
                            result.delay += this._accumulatedDelays[type];
                            this._accumulatedDelays[type] += result.staggerDelay
                        }
                    }
                }
                return result
            },
            _createAnimation: function($element, animationConfig, configModifier) {
                var result;
                if (typeUtils.isPlainObject(animationConfig)) {
                    result = fx.createAnimation($element, animationConfig)
                } else {
                    if (typeUtils.isFunction(animationConfig)) {
                        result = animationConfig($element, configModifier)
                    }
                }
                return result
            },
            _startAnimations: function() {
                var animations = this._animations;
                for (var i = 0; i < animations.length; i++) {
                    animations[i].start()
                }
            },
            _stopAnimations: function(jumpToEnd) {
                var animations = this._animations;
                for (var i = 0; i < animations.length; i++) {
                    animations[i].stop(jumpToEnd)
                }
            },
            _clearAnimations: function() {
                var animations = this._animations;
                for (var i = 0; i < animations.length; i++) {
                    animations[i].element.removeClass(DX_ANIMATING_CLASS)
                }
                this._animations.length = 0
            },
            reset: function() {
                this._accumulatedDelays.enter = 0;
                this._accumulatedDelays.leave = 0;
                this._clearAnimations();
                this._completeDeferred = new Deferred;
                this._completePromise = this._completeDeferred.promise()
            },
            enter: function($elements, animationConfig, configModifier) {
                var animations = this._createAnimations($elements, animationConfig, configModifier, "enter");
                this._animations.push.apply(this._animations, animations)
            },
            leave: function($elements, animationConfig, configModifier) {
                var animations = this._createAnimations($elements, animationConfig, configModifier, "leave");
                this._animations.push.apply(this._animations, animations)
            },
            start: function() {
                var that = this;
                var result;
                if (!this._animations.length) {
                    that.reset();
                    result = (new Deferred).resolve().promise()
                } else {
                    var animationDeferreds = iteratorUtils.map(this._animations, function(animation) {
                        var result = new Deferred;
                        animation.deferred.always(function() {
                            result.resolve()
                        });
                        return result.promise()
                    });
                    result = when.apply($, animationDeferreds).always(function() {
                        that._completeDeferred.resolve();
                        that.reset()
                    });
                    commonUtils.executeAsync(function() {
                        that._startAnimations()
                    })
                }
                return result
            },
            stop: function(jumpToEnd) {
                this._stopAnimations(jumpToEnd)
            }
        });
        exports.TransitionExecutor = TransitionExecutor
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/ui/overlay/ui.overlay.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var windowUtils = __webpack_require__( /*! ../../core/utils/window */ 7);
        var ready = __webpack_require__( /*! ../../core/utils/ready_callbacks */ 51).add;
        var window = windowUtils.getWindow();
        var navigator = windowUtils.getNavigator();
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var fx = __webpack_require__( /*! ../../animation/fx */ 40);
        var translator = __webpack_require__( /*! ../../animation/translator */ 28);
        var compareVersions = __webpack_require__( /*! ../../core/utils/version */ 60).compare;
        var viewPortUtils = __webpack_require__( /*! ../../core/utils/view_port */ 76);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var inArray = __webpack_require__( /*! ../../core/utils/array */ 14).inArray;
        var getPublicElement = __webpack_require__( /*! ../../core/utils/dom */ 11).getPublicElement;
        var viewPortChanged = viewPortUtils.changeCallback;
        var hideTopOverlayCallback = __webpack_require__( /*! ../../mobile/hide_top_overlay */ 220).hideCallback;
        var positionUtils = __webpack_require__( /*! ../../animation/position */ 74);
        var fitIntoRange = __webpack_require__( /*! ../../core/utils/math */ 31).fitIntoRange;
        var domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11);
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var devices = __webpack_require__( /*! ../../core/devices */ 15);
        var browser = __webpack_require__( /*! ../../core/utils/browser */ 26);
        var registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 9);
        var Widget = __webpack_require__( /*! ../widget/ui.widget */ 17);
        var keyboard = __webpack_require__( /*! ../../events/short */ 116).keyboard;
        var selectors = __webpack_require__( /*! ../widget/selectors */ 66);
        var dragEvents = __webpack_require__( /*! ../../events/drag */ 69);
        var eventUtils = __webpack_require__( /*! ../../events/utils */ 8);
        var pointerEvents = __webpack_require__( /*! ../../events/pointer */ 23);
        var Resizable = __webpack_require__( /*! ../resizable */ 181);
        var EmptyTemplate = __webpack_require__( /*! ../../core/templates/empty_template */ 87).EmptyTemplate;
        var Deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6).Deferred;
        var zIndexPool = __webpack_require__( /*! ./z_index */ 182);
        var swatch = __webpack_require__( /*! ../widget/swatch_container */ 157);
        var OVERLAY_CLASS = "dx-overlay";
        var OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper";
        var OVERLAY_CONTENT_CLASS = "dx-overlay-content";
        var OVERLAY_SHADER_CLASS = "dx-overlay-shader";
        var OVERLAY_MODAL_CLASS = "dx-overlay-modal";
        var INNER_OVERLAY_CLASS = "dx-inner-overlay";
        var INVISIBLE_STATE_CLASS = "dx-state-invisible";
        var ANONYMOUS_TEMPLATE_NAME = "content";
        var RTL_DIRECTION_CLASS = "dx-rtl";
        var ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onPositioned", "onResizeStart", "onResize", "onResizeEnd"];
        var OVERLAY_STACK = [];
        var DISABLED_STATE_CLASS = "dx-state-disabled";
        var PREVENT_SAFARI_SCROLLING_CLASS = "dx-prevent-safari-scrolling";
        var TAB_KEY = "tab";
        var POSITION_ALIASES = {
            top: {
                my: "top center",
                at: "top center"
            },
            bottom: {
                my: "bottom center",
                at: "bottom center"
            },
            right: {
                my: "right center",
                at: "right center"
            },
            left: {
                my: "left center",
                at: "left center"
            },
            center: {
                my: "center",
                at: "center"
            },
            "right bottom": {
                my: "right bottom",
                at: "right bottom"
            },
            "right top": {
                my: "right top",
                at: "right top"
            },
            "left bottom": {
                my: "left bottom",
                at: "left bottom"
            },
            "left top": {
                my: "left top",
                at: "left top"
            }
        };
        var realDevice = devices.real();
        var realVersion = realDevice.version;
        var firefoxDesktop = browser.mozilla && "desktop" === realDevice.deviceType;
        var iOS = "ios" === realDevice.platform;
        var hasSafariAddressBar = browser.safari && "desktop" !== realDevice.deviceType;
        var android4_0nativeBrowser = "android" === realDevice.platform && 0 === compareVersions(realVersion, [4, 0], 2) && navigator.userAgent.indexOf("Chrome") === -1;
        var forceRepaint = function($element) {
            if (firefoxDesktop) {
                $element.width()
            }
            if (android4_0nativeBrowser) {
                var $parents = $element.parents();
                var inScrollView = $parents.is(".dx-scrollable-native");
                if (!inScrollView) {
                    $parents.css("backfaceVisibility", "hidden");
                    $parents.css("backfaceVisibility");
                    $parents.css("backfaceVisibility", "visible")
                }
            }
        };
        var getElement = function(value) {
            return value && $(value.target || value)
        };
        ready(function() {
            eventsEngine.subscribeGlobal(domAdapter.getDocument(), pointerEvents.down, function(e) {
                for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
                    if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
                        return
                    }
                }
            })
        });
        var Overlay = Widget.inherit({
            _supportedKeys: function() {
                var offsetSize = 5;
                var move = function(top, left, e) {
                    if (!this.option("dragEnabled")) {
                        return
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    var allowedOffsets = this._allowedOffsets();
                    var offset = {
                        top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
                        left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
                    };
                    this._changePosition(offset)
                };
                return extend(this.callBase(), {
                    escape: function() {
                        this.hide()
                    },
                    upArrow: move.bind(this, -offsetSize, 0),
                    downArrow: move.bind(this, offsetSize, 0),
                    leftArrow: move.bind(this, 0, -offsetSize),
                    rightArrow: move.bind(this, 0, offsetSize)
                })
            },
            _getDefaultOptions: function() {
                return extend(this.callBase(), {
                    activeStateEnabled: false,
                    visible: false,
                    deferRendering: true,
                    shading: true,
                    shadingColor: "",
                    position: {
                        my: "center",
                        at: "center"
                    },
                    width: function() {
                        return .8 * $(window).width()
                    },
                    minWidth: null,
                    maxWidth: null,
                    height: function() {
                        return .8 * $(window).height()
                    },
                    minHeight: null,
                    maxHeight: null,
                    animation: {
                        show: {
                            type: "pop",
                            duration: 300,
                            from: {
                                scale: .55
                            }
                        },
                        hide: {
                            type: "pop",
                            duration: 300,
                            to: {
                                opacity: 0,
                                scale: .55
                            },
                            from: {
                                opacity: 1,
                                scale: 1
                            }
                        }
                    },
                    closeOnOutsideClick: false,
                    onShowing: null,
                    onShown: null,
                    onHiding: null,
                    onHidden: null,
                    contentTemplate: "content",
                    dragEnabled: false,
                    resizeEnabled: false,
                    onResizeStart: null,
                    onResize: null,
                    onResizeEnd: null,
                    innerOverlay: false,
                    target: void 0,
                    container: void 0,
                    hideTopOverlayHandler: function() {
                        this.hide()
                    }.bind(this),
                    closeOnTargetScroll: false,
                    onPositioned: null,
                    boundaryOffset: {
                        h: 0,
                        v: 0
                    },
                    propagateOutsideClick: false,
                    ignoreChildEvents: true,
                    _checkParentVisibility: true
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                    device: function() {
                        var realDevice = devices.real();
                        var realPlatform = realDevice.platform;
                        var realVersion = realDevice.version;
                        return "android" === realPlatform && compareVersions(realVersion, [4, 2]) < 0
                    },
                    options: {
                        animation: {
                            show: {
                                type: "fade",
                                duration: 400
                            },
                            hide: {
                                type: "fade",
                                duration: 400,
                                to: {
                                    opacity: 0
                                },
                                from: {
                                    opacity: 1
                                }
                            }
                        }
                    }
                }, {
                    device: function() {
                        return !windowUtils.hasWindow()
                    },
                    options: {
                        width: null,
                        height: null,
                        animation: null,
                        _checkParentVisibility: false
                    }
                }])
            },
            _setOptionsByReference: function() {
                this.callBase();
                extend(this._optionsByReference, {
                    animation: true
                })
            },
            _wrapper: function() {
                return this._$wrapper
            },
            _container: function() {
                return this._$content
            },
            _eventBindingTarget: function() {
                return this._$content
            },
            _init: function() {
                this.callBase();
                this._initActions();
                this._initCloseOnOutsideClickHandler();
                this._initTabTerminatorHandler();
                this._$wrapper = $("<div>").addClass(OVERLAY_WRAPPER_CLASS);
                this._$content = $("<div>").addClass(OVERLAY_CONTENT_CLASS);
                this._initInnerOverlayClass();
                var $element = this.$element();
                this._$wrapper.addClass($element.attr("class"));
                $element.addClass(OVERLAY_CLASS);
                this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
                eventsEngine.on(this._$wrapper, "MSPointerDown", noop);
                eventsEngine.on(this._$wrapper, "focusin", function(e) {
                    e.stopPropagation()
                });
                this._toggleViewPortSubscription(true);
                this._initHideTopOverlayHandler(this.option("hideTopOverlayHandler"))
            },
            _initOptions: function(options) {
                this._initTarget(options.target);
                var container = void 0 === options.container ? this.option("container") : options.container;
                this._initContainer(container);
                this.callBase(options)
            },
            _initInnerOverlayClass: function() {
                this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option("innerOverlay"))
            },
            _initTarget: function(target) {
                if (!typeUtils.isDefined(target)) {
                    return
                }
                var options = this.option();
                each(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], function(_, path) {
                    var pathParts = path.split(".");
                    var option = options;
                    while (option) {
                        if (1 === pathParts.length) {
                            if (typeUtils.isPlainObject(option)) {
                                option[pathParts.shift()] = target
                            }
                            break
                        } else {
                            option = option[pathParts.shift()]
                        }
                    }
                })
            },
            _initContainer: function(container) {
                container = void 0 === container ? viewPortUtils.value() : container;
                var $element = this.$element();
                var $container = $element.closest(container);
                if (!$container.length) {
                    $container = $(container).first()
                }
                this._$container = $container.length ? $container : $element.parent()
            },
            _initHideTopOverlayHandler: function(handler) {
                this._hideTopOverlayHandler = handler
            },
            _initActions: function() {
                this._actions = {};
                each(ACTIONS, function(_, action) {
                    this._actions[action] = this._createActionByOption(action, {
                        excludeValidators: ["disabled", "readOnly"]
                    }) || noop
                }.bind(this))
            },
            _initCloseOnOutsideClickHandler: function() {
                var that = this;
                this._proxiedDocumentDownHandler = function() {
                    return that._documentDownHandler.apply(that, arguments)
                }
            },
            _documentDownHandler: function(e) {
                if (this._showAnimationProcessing) {
                    this._stopAnimation()
                }
                var closeOnOutsideClick = this.option("closeOnOutsideClick");
                if (typeUtils.isFunction(closeOnOutsideClick)) {
                    closeOnOutsideClick = closeOnOutsideClick(e)
                }
                var $container = this._$content;
                var isAttachedTarget = $(window.document).is(e.target) || domUtils.contains(window.document, e.target);
                var isInnerOverlay = $(e.target).closest("." + INNER_OVERLAY_CLASS).length;
                var outsideClick = isAttachedTarget && !isInnerOverlay && !($container.is(e.target) || domUtils.contains($container.get(0), e.target));
                if (outsideClick && closeOnOutsideClick) {
                    this._outsideClickHandler(e)
                }
                return this.option("propagateOutsideClick")
            },
            _outsideClickHandler: function(e) {
                if (this.option("shading")) {
                    e.preventDefault()
                }
                this.hide()
            },
            _getAnonymousTemplateName: function() {
                return ANONYMOUS_TEMPLATE_NAME
            },
            _initTemplates: function() {
                this._templateManager.addDefaultTemplates({
                    content: new EmptyTemplate
                });
                this.callBase()
            },
            _isTopOverlay: function() {
                var overlayStack = this._overlayStack();
                for (var i = overlayStack.length - 1; i >= 0; i--) {
                    var tabbableElements = overlayStack[i]._findTabbableBounds();
                    if (tabbableElements.first || tabbableElements.last) {
                        return overlayStack[i] === this
                    }
                }
                return false
            },
            _overlayStack: function() {
                return OVERLAY_STACK
            },
            _zIndexInitValue: function() {
                return Overlay.baseZIndex()
            },
            _toggleViewPortSubscription: function(toggle) {
                viewPortChanged.remove(this._viewPortChangeHandle);
                if (toggle) {
                    this._viewPortChangeHandle = this._viewPortChangeHandler.bind(this);
                    viewPortChanged.add(this._viewPortChangeHandle)
                }
            },
            _viewPortChangeHandler: function() {
                this._initContainer(this.option("container"));
                this._refresh()
            },
            _renderVisibilityAnimate: function(visible) {
                this._stopAnimation();
                return visible ? this._show() : this._hide()
            },
            _normalizePosition: function() {
                var position = this.option("position");
                this._position = "function" === typeof position ? position() : position
            },
            _getAnimationConfig: function() {
                var animation = this.option("animation");
                if (typeUtils.isFunction(animation)) {
                    animation = animation.call(this)
                }
                return animation
            },
            _show: function() {
                var that = this;
                var deferred = new Deferred;
                this._parentHidden = this._isParentHidden();
                deferred.done(function() {
                    delete that._parentHidden
                });
                if (this._parentHidden) {
                    this._isHidden = true;
                    return deferred.resolve()
                }
                if (this._currentVisible) {
                    return (new Deferred).resolve().promise()
                }
                this._currentVisible = true;
                this._isShown = false;
                this._normalizePosition();
                var animation = that._getAnimationConfig() || {};
                var showAnimation = this._normalizeAnimation(animation.show, "to");
                var startShowAnimation = showAnimation && showAnimation.start || noop;
                var completeShowAnimation = showAnimation && showAnimation.complete || noop;
                if (this._isHidingActionCanceled) {
                    delete this._isHidingActionCanceled;
                    deferred.resolve()
                } else {
                    var show = function() {
                        this._renderVisibility(true);
                        if (this._isShowingActionCanceled) {
                            delete this._isShowingActionCanceled;
                            deferred.resolve();
                            return
                        }
                        this._animate(showAnimation, function() {
                            if (that.option("focusStateEnabled")) {
                                eventsEngine.trigger(that._focusTarget(), "focus")
                            }
                            completeShowAnimation.apply(this, arguments);
                            that._showAnimationProcessing = false;
                            that._isShown = true;
                            that._actions.onShown();
                            that._toggleSafariScrolling(false);
                            deferred.resolve()
                        }, function() {
                            startShowAnimation.apply(this, arguments);
                            that._showAnimationProcessing = true
                        })
                    }.bind(this);
                    if (this.option("templatesRenderAsynchronously")) {
                        this._stopShowTimer();
                        this._asyncShowTimeout = setTimeout(show)
                    } else {
                        show()
                    }
                }
                return deferred.promise()
            },
            _normalizeAnimation: function(animation, prop) {
                if (animation) {
                    animation = extend({
                        type: "slide"
                    }, animation);
                    if (animation[prop] && "object" === _typeof(animation[prop])) {
                        extend(animation[prop], {
                            position: this._position
                        })
                    }
                }
                return animation
            },
            _hide: function() {
                if (!this._currentVisible) {
                    return (new Deferred).resolve().promise()
                }
                this._currentVisible = false;
                var that = this;
                var deferred = new Deferred;
                var animation = that._getAnimationConfig() || {};
                var hideAnimation = this._normalizeAnimation(animation.hide, "from");
                var startHideAnimation = hideAnimation && hideAnimation.start || noop;
                var completeHideAnimation = hideAnimation && hideAnimation.complete || noop;
                var hidingArgs = {
                    cancel: false
                };
                if (this._isShowingActionCanceled) {
                    deferred.resolve()
                } else {
                    this._actions.onHiding(hidingArgs);
                    that._toggleSafariScrolling(true);
                    if (hidingArgs.cancel) {
                        this._isHidingActionCanceled = true;
                        this.option("visible", true);
                        deferred.resolve()
                    } else {
                        this._forceFocusLost();
                        this._toggleShading(false);
                        this._toggleSubscriptions(false);
                        this._stopShowTimer();
                        this._animate(hideAnimation, function() {
                            that._$content.css("pointerEvents", "");
                            that._renderVisibility(false);
                            completeHideAnimation.apply(this, arguments);
                            that._actions.onHidden();
                            deferred.resolve()
                        }, function() {
                            that._$content.css("pointerEvents", "none");
                            startHideAnimation.apply(this, arguments)
                        })
                    }
                }
                return deferred.promise()
            },
            _forceFocusLost: function() {
                var activeElement = domAdapter.getActiveElement();
                var shouldResetActiveElement = !!this._$content.find(activeElement).length;
                if (shouldResetActiveElement) {
                    domUtils.resetActiveElement()
                }
            },
            _animate: function(animation, completeCallback, startCallback) {
                if (animation) {
                    startCallback = startCallback || animation.start || noop;
                    fx.animate(this._$content, extend({}, animation, {
                        start: startCallback,
                        complete: completeCallback
                    }))
                } else {
                    completeCallback()
                }
            },
            _stopAnimation: function() {
                fx.stop(this._$content, true)
            },
            _renderVisibility: function(visible) {
                if (visible && this._isParentHidden()) {
                    return
                }
                this._currentVisible = visible;
                this._stopAnimation();
                if (!visible) {
                    domUtils.triggerHidingEvent(this._$content)
                }
                this._toggleVisibility(visible);
                this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);
                this._updateZIndexStackPosition(visible);
                if (visible) {
                    this._renderContent();
                    var showingArgs = {
                        cancel: false
                    };
                    this._actions.onShowing(showingArgs);
                    if (showingArgs.cancel) {
                        this._toggleVisibility(false);
                        this._$content.toggleClass(INVISIBLE_STATE_CLASS, true);
                        this._updateZIndexStackPosition(false);
                        this._moveFromContainer();
                        this._isShowingActionCanceled = true;
                        this.option("visible", false);
                        return
                    }
                    this._moveToContainer();
                    this._renderGeometry();
                    domUtils.triggerShownEvent(this._$content);
                    domUtils.triggerResizeEvent(this._$content)
                } else {
                    this._moveFromContainer()
                }
                this._toggleShading(visible);
                this._toggleSubscriptions(visible)
            },
            _updateZIndexStackPosition: function(pushToStack) {
                var overlayStack = this._overlayStack();
                var index = inArray(this, overlayStack);
                if (pushToStack) {
                    if (index === -1) {
                        this._zIndex = zIndexPool.create(this._zIndexInitValue());
                        overlayStack.push(this)
                    }
                    this._$wrapper.css("zIndex", this._zIndex);
                    this._$content.css("zIndex", this._zIndex)
                } else {
                    if (index !== -1) {
                        overlayStack.splice(index, 1);
                        zIndexPool.remove(this._zIndex)
                    }
                }
            },
            _toggleShading: function(visible) {
                this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
                this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option("shading"));
                this._$wrapper.css("backgroundColor", this.option("shading") ? this.option("shadingColor") : "");
                this._toggleTabTerminator(visible && this.option("shading"))
            },
            _initTabTerminatorHandler: function() {
                var that = this;
                this._proxiedTabTerminatorHandler = function() {
                    that._tabKeyHandler.apply(that, arguments)
                }
            },
            _toggleTabTerminator: function(enabled) {
                var eventName = eventUtils.addNamespace("keydown", this.NAME);
                if (enabled) {
                    eventsEngine.on(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler)
                } else {
                    eventsEngine.off(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler)
                }
            },
            _findTabbableBounds: function() {
                var $elements = this._$wrapper.find("*");
                var elementsCount = $elements.length - 1;
                var result = {
                    first: null,
                    last: null
                };
                for (var i = 0; i <= elementsCount; i++) {
                    if (!result.first && $elements.eq(i).is(selectors.tabbable)) {
                        result.first = $elements.eq(i)
                    }
                    if (!result.last && $elements.eq(elementsCount - i).is(selectors.tabbable)) {
                        result.last = $elements.eq(elementsCount - i)
                    }
                    if (result.first && result.last) {
                        break
                    }
                }
                return result
            },
            _tabKeyHandler: function(e) {
                if (eventUtils.normalizeKeyName(e) !== TAB_KEY || !this._isTopOverlay()) {
                    return
                }
                var tabbableElements = this._findTabbableBounds();
                var $firstTabbable = tabbableElements.first;
                var $lastTabbable = tabbableElements.last;
                var isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
                var isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
                var isEmptyTabList = 0 === tabbableElements.length;
                var isOutsideTarget = !domUtils.contains(this._$wrapper.get(0), e.target);
                if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
                    e.preventDefault();
                    var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
                    eventsEngine.trigger($focusElement, "focusin");
                    eventsEngine.trigger($focusElement, "focus")
                }
            },
            _toggleSubscriptions: function(enabled) {
                if (windowUtils.hasWindow()) {
                    this._toggleHideTopOverlayCallback(enabled);
                    this._toggleParentsScrollSubscription(enabled)
                }
            },
            _toggleHideTopOverlayCallback: function(subscribe) {
                if (!this._hideTopOverlayHandler) {
                    return
                }
                if (subscribe) {
                    hideTopOverlayCallback.add(this._hideTopOverlayHandler)
                } else {
                    hideTopOverlayCallback.remove(this._hideTopOverlayHandler)
                }
            },
            _toggleParentsScrollSubscription: function(subscribe) {
                if (!this._position) {
                    return
                }
                var target = this._position.of || $();
                var closeOnScroll = this.option("closeOnTargetScroll");
                var $parents = getElement(target).parents();
                var scrollEvent = eventUtils.addNamespace("scroll", this.NAME);
                if ("desktop" === devices.real().deviceType) {
                    $parents = $parents.add(window)
                }
                this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function(e) {
                    this._targetParentsScrollHandler(e)
                }.bind(this);
                eventsEngine.off($().add(this._$prevTargetParents), scrollEvent, this._proxiedTargetParentsScrollHandler);
                if (subscribe && closeOnScroll) {
                    eventsEngine.on($parents, scrollEvent, this._proxiedTargetParentsScrollHandler);
                    this._$prevTargetParents = $parents
                }
            },
            _targetParentsScrollHandler: function(e) {
                var closeHandled = false;
                var closeOnScroll = this.option("closeOnTargetScroll");
                if (typeUtils.isFunction(closeOnScroll)) {
                    closeHandled = closeOnScroll(e)
                }
                if (!closeHandled && !this._showAnimationProcessing) {
                    this.hide()
                }
            },
            _render: function() {
                this.callBase();
                this._appendContentToElement();
                this._renderVisibilityAnimate(this.option("visible"))
            },
            _appendContentToElement: function() {
                if (!this._$content.parent().is(this.$element())) {
                    this._$content.appendTo(this.$element())
                }
            },
            _renderContent: function() {
                var shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
                var isParentHidden = this.option("visible") && this._isParentHidden();
                if (isParentHidden) {
                    this._isHidden = true;
                    return
                }
                if (this._contentAlreadyRendered || shouldDeferRendering) {
                    return
                }
                this._contentAlreadyRendered = true;
                this._appendContentToElement();
                this.callBase()
            },
            _isParentHidden: function() {
                if (!this.option("_checkParentVisibility")) {
                    return false
                }
                if (void 0 !== this._parentHidden) {
                    return this._parentHidden
                }
                var $parent = this.$element().parent();
                if ($parent.is(":visible")) {
                    return false
                }
                var isHidden = false;
                $parent.add($parent.parents()).each(function() {
                    var $element = $(this);
                    if ("none" === $element.css("display")) {
                        isHidden = true;
                        return false
                    }
                });
                return isHidden || !domAdapter.getBody().contains($parent.get(0))
            },
            _renderContentImpl: function() {
                var _this = this;
                var whenContentRendered = new Deferred;
                var contentTemplateOption = this.option("contentTemplate");
                var contentTemplate = this._getTemplate(contentTemplateOption);
                var transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
                contentTemplate && contentTemplate.render({
                    container: getPublicElement(this.$content()),
                    noModel: true,
                    transclude: transclude,
                    onRendered: function() {
                        whenContentRendered.resolve()
                    }
                });
                this._renderDrag();
                this._renderResize();
                this._renderScrollTerminator();
                whenContentRendered.done(function() {
                    if (_this.option("visible")) {
                        _this._moveToContainer()
                    }
                });
                return whenContentRendered.promise()
            },
            _renderDrag: function() {
                var $dragTarget = this._getDragTarget();
                if (!$dragTarget) {
                    return
                }
                var startEventName = eventUtils.addNamespace(dragEvents.start, this.NAME);
                var updateEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);
                eventsEngine.off($dragTarget, startEventName);
                eventsEngine.off($dragTarget, updateEventName);
                if (!this.option("dragEnabled")) {
                    return
                }
                eventsEngine.on($dragTarget, startEventName, this._dragStartHandler.bind(this));
                eventsEngine.on($dragTarget, updateEventName, this._dragUpdateHandler.bind(this))
            },
            _renderResize: function() {
                this._resizable = this._createComponent(this._$content, Resizable, {
                    handles: this.option("resizeEnabled") ? "all" : "none",
                    onResizeEnd: this._resizeEndHandler.bind(this),
                    onResize: this._actions.onResize.bind(this),
                    onResizeStart: this._actions.onResizeStart.bind(this),
                    minHeight: 100,
                    minWidth: 100,
                    area: this._getDragResizeContainer()
                })
            },
            _resizeEndHandler: function() {
                this._positionChangeHandled = true;
                var width = this._resizable.option("width");
                var height = this._resizable.option("height");
                width && this.option("width", width);
                height && this.option("height", height);
                this._actions.onResizeEnd()
            },
            _renderScrollTerminator: function() {
                var $scrollTerminator = this._wrapper();
                var terminatorEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);
                eventsEngine.off($scrollTerminator, terminatorEventName);
                eventsEngine.on($scrollTerminator, terminatorEventName, {
                    validate: function() {
                        return true
                    },
                    getDirection: function() {
                        return "both"
                    },
                    _toggleGestureCover: function(toggle) {
                        if (!toggle) {
                            this._toggleGestureCoverImpl(toggle)
                        }
                    },
                    _clearSelection: noop,
                    isNative: true
                }, function(e) {
                    var originalEvent = e.originalEvent.originalEvent;
                    e._cancelPreventDefault = true;
                    if (originalEvent && "mousemove" !== originalEvent.type && false !== e.cancelable) {
                        e.preventDefault()
                    }
                })
            },
            _getDragTarget: function() {
                return this.$content()
            },
            _dragStartHandler: function(e) {
                e.targetElements = [];
                this._prevOffset = {
                    x: 0,
                    y: 0
                };
                var allowedOffsets = this._allowedOffsets();
                e.maxTopOffset = allowedOffsets.top;
                e.maxBottomOffset = allowedOffsets.bottom;
                e.maxLeftOffset = allowedOffsets.left;
                e.maxRightOffset = allowedOffsets.right
            },
            _getDragResizeContainer: function() {
                var isContainerDefined = viewPortUtils.originalViewPort().get(0) || this.option("container");
                var $container = !isContainerDefined ? $(window) : this._$container;
                return $container
            },
            _deltaSize: function() {
                var $content = this._$content;
                var $container = this._getDragResizeContainer();
                var contentWidth = $content.outerWidth();
                var contentHeight = $content.outerHeight();
                var containerWidth = $container.outerWidth();
                var containerHeight = $container.outerHeight();
                if (this._isWindow($container)) {
                    var document = domAdapter.getDocument();
                    var fullPageHeight = Math.max($(document).outerHeight(), containerHeight);
                    var fullPageWidth = Math.max($(document).outerWidth(), containerWidth);
                    containerHeight = fullPageHeight;
                    containerWidth = fullPageWidth
                }
                return {
                    width: containerWidth - contentWidth,
                    height: containerHeight - contentHeight
                }
            },
            _dragUpdateHandler: function(e) {
                var offset = e.offset;
                var prevOffset = this._prevOffset;
                var targetOffset = {
                    top: offset.y - prevOffset.y,
                    left: offset.x - prevOffset.x
                };
                this._changePosition(targetOffset);
                this._prevOffset = offset
            },
            _changePosition: function(offset) {
                var position = translator.locate(this._$content);
                translator.move(this._$content, {
                    left: position.left + offset.left,
                    top: position.top + offset.top
                });
                this._positionChangeHandled = true
            },
            _allowedOffsets: function() {
                var position = translator.locate(this._$content);
                var deltaSize = this._deltaSize();
                var isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0;
                var shaderOffset = this.option("shading") && !this.option("container") && !this._isWindow(this._getContainer()) ? translator.locate(this._$wrapper) : {
                    top: 0,
                    left: 0
                };
                var boundaryOffset = this.option("boundaryOffset");
                return {
                    top: isAllowedDrag ? position.top + shaderOffset.top + boundaryOffset.v : 0,
                    bottom: isAllowedDrag ? -position.top - shaderOffset.top + deltaSize.height - boundaryOffset.v : 0,
                    left: isAllowedDrag ? position.left + shaderOffset.left + boundaryOffset.h : 0,
                    right: isAllowedDrag ? -position.left - shaderOffset.left + deltaSize.width - boundaryOffset.h : 0
                }
            },
            _moveFromContainer: function() {
                this._$content.appendTo(this.$element());
                this._detachWrapperToContainer()
            },
            _detachWrapperToContainer: function() {
                this._$wrapper.detach()
            },
            _moveToContainer: function() {
                this._attachWrapperToContainer();
                this._$content.appendTo(this._$wrapper)
            },
            _attachWrapperToContainer: function() {
                var $element = this.$element();
                var containerDefined = void 0 !== this.option("container");
                var renderContainer = containerDefined ? this._$container : swatch.getSwatchContainer($element);
                if (renderContainer && renderContainer[0] === $element.parent()[0]) {
                    renderContainer = $element
                }
                this._$wrapper.appendTo(renderContainer)
            },
            _fixHeightAfterSafariAddressBarResizing: function() {
                if (this._isWindow(this._getContainer()) && hasSafariAddressBar) {
                    this._$wrapper.css("minHeight", window.innerHeight)
                }
            },
            _renderGeometry: function(isDimensionChanged) {
                if (this.option("visible") && windowUtils.hasWindow()) {
                    this._renderGeometryImpl(isDimensionChanged)
                }
            },
            _renderGeometryImpl: function(isDimensionChanged) {
                this._stopAnimation();
                this._normalizePosition();
                this._renderWrapper();
                this._fixHeightAfterSafariAddressBarResizing();
                this._renderDimensions();
                var resultPosition = this._renderPosition();
                this._actions.onPositioned({
                    position: resultPosition
                })
            },
            _fixWrapperPosition: function() {
                this._$wrapper.css("position", this._useFixedPosition() ? "fixed" : "absolute")
            },
            _useFixedPosition: function() {
                var $container = this._getContainer();
                return this._isWindow($container) && (!iOS || void 0 !== this._bodyScrollTop)
            },
            _toggleSafariScrolling: function(scrollingEnabled) {
                if (iOS && this._useFixedPosition()) {
                    var body = domAdapter.getBody();
                    if (scrollingEnabled) {
                        $(body).removeClass(PREVENT_SAFARI_SCROLLING_CLASS);
                        window.scrollTo(0, this._bodyScrollTop);
                        this._bodyScrollTop = void 0
                    } else {
                        if (this.option("visible")) {
                            this._bodyScrollTop = window.pageYOffset;
                            $(body).addClass(PREVENT_SAFARI_SCROLLING_CLASS)
                        }
                    }
                }
            },
            _renderWrapper: function() {
                this._fixWrapperPosition();
                this._renderWrapperDimensions();
                this._renderWrapperPosition()
            },
            _renderWrapperDimensions: function() {
                var wrapperWidth;
                var wrapperHeight;
                var $container = this._getContainer();
                if (!$container) {
                    return
                }
                var isWindow = this._isWindow($container);
                wrapperWidth = isWindow ? null : $container.outerWidth(), wrapperHeight = isWindow ? null : $container.outerHeight();
                this._$wrapper.css({
                    width: wrapperWidth,
                    height: wrapperHeight
                })
            },
            _isWindow: function($element) {
                return !!$element && typeUtils.isWindow($element.get(0))
            },
            _renderWrapperPosition: function() {
                var $container = this._getContainer();
                if ($container) {
                    positionUtils.setup(this._$wrapper, {
                        my: "top left",
                        at: "top left",
                        of: $container
                    })
                }
            },
            _getContainer: function() {
                var position = this._position;
                var container = this.option("container");
                var positionOf = null;
                if (!container && position) {
                    var isEvent = !!(position.of && position.of.preventDefault);
                    positionOf = isEvent ? window : position.of || window
                }
                return getElement(container || positionOf)
            },
            _renderDimensions: function() {
                var content = this._$content.get(0);
                this._$content.css({
                    minWidth: this._getOptionValue("minWidth", content),
                    maxWidth: this._getOptionValue("maxWidth", content),
                    minHeight: this._getOptionValue("minHeight", content),
                    maxHeight: this._getOptionValue("maxHeight", content),
                    width: this._getOptionValue("width", content),
                    height: this._getOptionValue("height", content)
                })
            },
            _renderPosition: function() {
                if (this._positionChangeHandled) {
                    var allowedOffsets = this._allowedOffsets();
                    this._changePosition({
                        top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),
                        left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)
                    })
                } else {
                    this._renderOverlayBoundaryOffset();
                    translator.resetPosition(this._$content);
                    var position = this._transformStringPosition(this._position, POSITION_ALIASES);
                    var resultPosition = positionUtils.setup(this._$content, position);
                    forceRepaint(this._$content);
                    this._actions.onPositioning();
                    return resultPosition
                }
            },
            _transformStringPosition: function(position, positionAliases) {
                if (typeUtils.isString(position)) {
                    position = extend({}, positionAliases[position])
                }
                return position
            },
            _renderOverlayBoundaryOffset: function() {
                var boundaryOffset = this.option("boundaryOffset");
                this._$content.css("margin", boundaryOffset.v + "px " + boundaryOffset.h + "px")
            },
            _focusTarget: function() {
                return this._$content
            },
            _attachKeyboardEvents: function() {
                var _this2 = this;
                this._keyboardListenerId = keyboard.on(this._$content, null, function(opts) {
                    return _this2._keyboardHandler(opts)
                })
            },
            _keyboardHandler: function(options) {
                var e = options.originalEvent;
                var $target = $(e.target);
                if ($target.is(this._$content) || !this.option("ignoreChildEvents")) {
                    this.callBase.apply(this, arguments)
                }
            },
            _isVisible: function() {
                return this.option("visible")
            },
            _visibilityChanged: function(visible) {
                if (visible) {
                    if (this.option("visible")) {
                        this._renderVisibilityAnimate(visible)
                    }
                } else {
                    this._renderVisibilityAnimate(visible)
                }
            },
            _dimensionChanged: function() {
                this._renderGeometry(true)
            },
            _clean: function() {
                if (!this._contentAlreadyRendered) {
                    this.$content().empty()
                }
                this._renderVisibility(false);
                this._stopShowTimer();
                this._cleanFocusState()
            },
            _stopShowTimer: function() {
                if (this._asyncShowTimeout) {
                    clearTimeout(this._asyncShowTimeout)
                }
                this._asyncShowTimeout = null
            },
            _dispose: function() {
                fx.stop(this._$content, false);
                clearTimeout(this._deferShowTimer);
                this._toggleViewPortSubscription(false);
                this._toggleSubscriptions(false);
                this._updateZIndexStackPosition(false);
                this._toggleTabTerminator(false);
                this._toggleSafariScrolling(true);
                this._actions = null;
                this.callBase();
                zIndexPool.remove(this._zIndex);
                this._$wrapper.remove();
                this._$content.remove()
            },
            _toggleDisabledState: function(value) {
                this.callBase.apply(this, arguments);
                this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value))
            },
            _toggleRTLDirection: function(rtl) {
                this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl)
            },
            _optionChanged: function(args) {
                var value = args.value;
                if (inArray(args.name, ACTIONS) > -1) {
                    this._initActions();
                    return
                }
                switch (args.name) {
                    case "dragEnabled":
                        this._renderDrag();
                        this._renderGeometry();
                        break;
                    case "resizeEnabled":
                        this._renderResize();
                        this._renderGeometry();
                        break;
                    case "shading":
                    case "shadingColor":
                        this._toggleShading(this.option("visible"));
                        break;
                    case "width":
                    case "height":
                    case "minWidth":
                    case "maxWidth":
                    case "minHeight":
                    case "maxHeight":
                    case "boundaryOffset":
                        this._renderGeometry();
                        break;
                    case "position":
                        this._positionChangeHandled = false;
                        this._renderGeometry();
                        break;
                    case "visible":
                        this._renderVisibilityAnimate(value).done(function() {
                            if (!this._animateDeferred) {
                                return
                            }
                            this._animateDeferred.resolveWith(this)
                        }.bind(this));
                        break;
                    case "target":
                        this._initTarget(value);
                        this._invalidate();
                        break;
                    case "container":
                        this._initContainer(value);
                        this._invalidate();
                        break;
                    case "innerOverlay":
                        this._initInnerOverlayClass();
                        break;
                    case "deferRendering":
                    case "contentTemplate":
                        this._contentAlreadyRendered = false;
                        this._clean();
                        this._invalidate();
                        break;
                    case "hideTopOverlayHandler":
                        this._toggleHideTopOverlayCallback(false);
                        this._initHideTopOverlayHandler(args.value);
                        this._toggleHideTopOverlayCallback(this.option("visible"));
                        break;
                    case "closeOnTargetScroll":
                        this._toggleParentsScrollSubscription(this.option("visible"));
                        break;
                    case "closeOnOutsideClick":
                    case "animation":
                    case "propagateOutsideClick":
                        break;
                    case "rtlEnabled":
                        this._contentAlreadyRendered = false;
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            toggle: function(showing) {
                showing = void 0 === showing ? !this.option("visible") : showing;
                var result = new Deferred;
                if (showing === this.option("visible")) {
                    return result.resolveWith(this, [showing]).promise()
                }
                var animateDeferred = new Deferred;
                this._animateDeferred = animateDeferred;
                this.option("visible", showing);
                animateDeferred.promise().done(function() {
                    delete this._animateDeferred;
                    result.resolveWith(this, [this.option("visible")])
                }.bind(this));
                return result.promise()
            },
            $content: function() {
                return this._$content
            },
            show: function() {
                return this.toggle(true)
            },
            hide: function() {
                return this.toggle(false)
            },
            content: function() {
                return getPublicElement(this._$content)
            },
            repaint: function() {
                if (this._contentAlreadyRendered) {
                    this._renderGeometry();
                    domUtils.triggerResizeEvent(this._$content)
                } else {
                    this.callBase()
                }
            }
        });
        Overlay.baseZIndex = function(zIndex) {
            return zIndexPool.base(zIndex)
        };
        registerComponent("dxOverlay", Overlay);
        module.exports = Overlay
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/core/utils/selection_filter.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var getKeyHash = __webpack_require__( /*! ./common */ 3).getKeyHash;
        var equalByValue = __webpack_require__( /*! ./common */ 3).equalByValue;
        var typeUtils = __webpack_require__( /*! ./type */ 1);
        var SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
            this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
                equalKeys = void 0 === equalKeys ? equalByValue : equalKeys;
                return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr)
            };
            this.getExpr = function(keyExpr) {
                if (!keyExpr) {
                    return
                }
                var filterExpr;
                selectedItemKeys.forEach(function(key, index) {
                    filterExpr = filterExpr || [];
                    var filterExprPart;
                    if (index > 0) {
                        filterExpr.push(isSelectAll ? "and" : "or")
                    }
                    if (typeUtils.isString(keyExpr)) {
                        filterExprPart = getFilterForPlainKey(keyExpr, key)
                    } else {
                        filterExprPart = getFilterForCompositeKey(keyExpr, key)
                    }
                    filterExpr.push(filterExprPart)
                });
                if (filterExpr && 1 === filterExpr.length) {
                    filterExpr = filterExpr[0]
                }
                return filterExpr
            };
            this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
                var filterExpr = this.getExpr(keyExpr);
                var combinedFilter = filterExpr;
                if (isSelectAll && dataSourceFilter) {
                    if (filterExpr) {
                        combinedFilter = [];
                        combinedFilter.push(filterExpr);
                        combinedFilter.push(dataSourceFilter)
                    } else {
                        combinedFilter = dataSourceFilter
                    }
                }
                return combinedFilter
            };
            var selectedItemKeyHashesMap;
            var getSelectedItemKeyHashesMap = function(selectedItemKeys) {
                if (!selectedItemKeyHashesMap) {
                    selectedItemKeyHashesMap = {};
                    for (var i = 0; i < selectedItemKeys.length; i++) {
                        selectedItemKeyHashesMap[getKeyHash(selectedItemKeys[i])] = true
                    }
                }
                return selectedItemKeyHashesMap
            };
            var normalizeKeys = function(keys, keyOf, keyExpr) {
                return Array.isArray(keyExpr) ? keys.map(function(key) {
                    return keyOf(key)
                }) : keys
            };

            function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
                var key = keyOf(item);
                var keyHash;
                var i;
                if (!equalByReference) {
                    keyHash = getKeyHash(key);
                    if (!typeUtils.isObject(keyHash)) {
                        var selectedKeyHashesMap = getSelectedItemKeyHashesMap(normalizeKeys(selectedItemKeys, keyOf, keyExpr));
                        if (selectedKeyHashesMap[keyHash]) {
                            return !isSelectAll
                        }
                        return !!isSelectAll
                    }
                }
                for (i = 0; i < selectedItemKeys.length; i++) {
                    if (equalKeys(selectedItemKeys[i], key)) {
                        return !isSelectAll
                    }
                }
                return !!isSelectAll
            }

            function getFilterForPlainKey(keyExpr, keyValue) {
                if (void 0 === keyValue) {
                    return
                }
                return [keyExpr, isSelectAll ? "<>" : "=", keyValue]
            }

            function getFilterForCompositeKey(keyExpr, itemKeyValue) {
                var filterExpr = [];
                for (var i = 0, length = keyExpr.length; i < length; i++) {
                    var currentKeyExpr = keyExpr[i];
                    var currentKeyValue = itemKeyValue && itemKeyValue[currentKeyExpr];
                    var filterExprPart = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
                    if (!filterExprPart) {
                        break
                    }
                    if (i > 0) {
                        filterExpr.push(isSelectAll ? "or" : "and")
                    }
                    filterExpr.push(filterExprPart)
                }
                return filterExpr
            }
        };
        exports.SelectionFilterCreator = SelectionFilterCreator
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/events/transform.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var mathUtils = __webpack_require__( /*! ../core/utils/math */ 31);
        var iteratorUtils = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var errors = __webpack_require__( /*! ../core/errors */ 22);
        var eventUtils = __webpack_require__( /*! ./utils */ 8);
        var Emitter = __webpack_require__( /*! ./core/emitter */ 132);
        var registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 101);
        var DX_PREFIX = "dx";
        var TRANSFORM = "transform";
        var TRANSLATE = "translate";
        var ZOOM = "zoom";
        var PINCH = "pinch";
        var ROTATE = "rotate";
        var START_POSTFIX = "start";
        var UPDATE_POSTFIX = "";
        var END_POSTFIX = "end";
        var eventAliases = [];
        var addAlias = function(eventName, eventArgs) {
            eventAliases.push({
                name: eventName,
                args: eventArgs
            })
        };
        addAlias(TRANSFORM, {
            scale: true,
            deltaScale: true,
            rotation: true,
            deltaRotation: true,
            translation: true,
            deltaTranslation: true
        });
        addAlias(TRANSLATE, {
            translation: true,
            deltaTranslation: true
        });
        addAlias(ZOOM, {
            scale: true,
            deltaScale: true
        });
        addAlias(PINCH, {
            scale: true,
            deltaScale: true
        });
        addAlias(ROTATE, {
            rotation: true,
            deltaRotation: true
        });
        var getVector = function(first, second) {
            return {
                x: second.pageX - first.pageX,
                y: -second.pageY + first.pageY,
                centerX: .5 * (second.pageX + first.pageX),
                centerY: .5 * (second.pageY + first.pageY)
            }
        };
        var getEventVector = function(e) {
            var pointers = e.pointers;
            return getVector(pointers[0], pointers[1])
        };
        var getDistance = function(vector) {
            return Math.sqrt(vector.x * vector.x + vector.y * vector.y)
        };
        var getScale = function(firstVector, secondVector) {
            return getDistance(firstVector) / getDistance(secondVector)
        };
        var getRotation = function(firstVector, secondVector) {
            var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;
            var distanceProduct = getDistance(firstVector) * getDistance(secondVector);
            if (0 === distanceProduct) {
                return 0
            }
            var sign = mathUtils.sign(firstVector.x * secondVector.y - secondVector.x * firstVector.y);
            var angle = Math.acos(mathUtils.fitIntoRange(scalarProduct / distanceProduct, -1, 1));
            return sign * angle
        };
        var getTranslation = function(firstVector, secondVector) {
            return {
                x: firstVector.centerX - secondVector.centerX,
                y: firstVector.centerY - secondVector.centerY
            }
        };
        var TransformEmitter = Emitter.inherit({
            configure: function(data, eventName) {
                if (eventName.indexOf(ZOOM) > -1) {
                    errors.log("W0005", eventName, "15.1", "Use '" + eventName.replace(ZOOM, PINCH) + "' event instead")
                }
                this.callBase(data)
            },
            validatePointers: function(e) {
                return eventUtils.hasTouches(e) > 1
            },
            start: function(e) {
                this._accept(e);
                var startVector = getEventVector(e);
                this._startVector = startVector;
                this._prevVector = startVector;
                this._fireEventAliases(START_POSTFIX, e)
            },
            move: function(e) {
                var currentVector = getEventVector(e);
                var eventArgs = this._getEventArgs(currentVector);
                this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);
                this._prevVector = currentVector
            },
            end: function(e) {
                var eventArgs = this._getEventArgs(this._prevVector);
                this._fireEventAliases(END_POSTFIX, e, eventArgs)
            },
            _getEventArgs: function(vector) {
                return {
                    scale: getScale(vector, this._startVector),
                    deltaScale: getScale(vector, this._prevVector),
                    rotation: getRotation(vector, this._startVector),
                    deltaRotation: getRotation(vector, this._prevVector),
                    translation: getTranslation(vector, this._startVector),
                    deltaTranslation: getTranslation(vector, this._prevVector)
                }
            },
            _fireEventAliases: function(eventPostfix, originalEvent, eventArgs) {
                eventArgs = eventArgs || {};
                iteratorUtils.each(eventAliases, function(_, eventAlias) {
                    var args = {};
                    iteratorUtils.each(eventAlias.args, function(name) {
                        if (name in eventArgs) {
                            args[name] = eventArgs[name]
                        }
                    });
                    this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args)
                }.bind(this))
            }
        });
        var eventNames = eventAliases.reduce(function(result, eventAlias) {
            [START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX].forEach(function(eventPostfix) {
                result.push(DX_PREFIX + eventAlias.name + eventPostfix)
            });
            return result
        }, []);
        registerEmitter({
            emitter: TransformEmitter,
            events: eventNames
        });
        iteratorUtils.each(eventNames, function(_, eventName) {
            exports[eventName.substring(DX_PREFIX.length)] = eventName
        })
    }, ,
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/bundles/modules/parts/data.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var DevExpress = __webpack_require__( /*! ./core */ 219);
        var data = DevExpress.data = __webpack_require__( /*! ../../../bundles/modules/data */ 291);
        data.odata = __webpack_require__( /*! ../../../bundles/modules/data.odata */ 519);
        module.exports = data
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/pie_point.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var symbolPoint = __webpack_require__( /*! ./symbol_point */ 126);
        var _extend = extend;
        var _round = Math.round;
        var _sqrt = Math.sqrt;
        var _acos = Math.acos;
        var DEG = 180 / Math.PI;
        var _abs = Math.abs;
        var vizUtils = __webpack_require__( /*! ../../core/utils */ 13);
        var _normalizeAngle = vizUtils.normalizeAngle;
        var _getCosAndSin = vizUtils.getCosAndSin;
        var _isDefined = __webpack_require__( /*! ../../../core/utils/type */ 1).isDefined;
        var getVerticallyShiftedAngularCoords = vizUtils.getVerticallyShiftedAngularCoords;
        var RADIAL_LABEL_INDENT = __webpack_require__( /*! ../../components/consts */ 125).radialLabelIndent;
        module.exports = _extend({}, symbolPoint, {
            _updateData: function(data, argumentChanged) {
                var that = this;
                symbolPoint._updateData.call(this, data);
                if (argumentChanged || !_isDefined(that._visible)) {
                    that._visible = true
                }
                that.minValue = that.initialMinValue = that.originalMinValue = _isDefined(data.minValue) ? data.minValue : 0
            },
            animate: function(complete, duration, delay) {
                var that = this;
                that.graphic.animate({
                    x: that.centerX,
                    y: that.centerY,
                    outerRadius: that.radiusOuter,
                    innerRadius: that.radiusInner,
                    startAngle: that.toAngle,
                    endAngle: that.fromAngle
                }, {
                    delay: delay,
                    partitionDuration: duration
                }, complete)
            },
            correctPosition: function(correction) {
                var that = this;
                that.correctRadius(correction);
                that.correctLabelRadius(correction.radiusOuter + RADIAL_LABEL_INDENT);
                that.centerX = correction.centerX;
                that.centerY = correction.centerY
            },
            correctRadius: function(correction) {
                this.radiusInner = correction.radiusInner;
                this.radiusOuter = correction.radiusOuter
            },
            correctLabelRadius: function(radiusLabels) {
                this.radiusLabels = radiusLabels
            },
            correctValue: function(correction, percent, base) {
                var that = this;
                that.value = (base || that.normalInitialValue) + correction;
                that.minValue = correction;
                that.percent = percent;
                that._label.setDataField("percent", percent)
            },
            _updateLabelData: function() {
                this._label.setData(this._getLabelFormatObject())
            },
            _getShiftLabelCoords: function() {
                var that = this;
                var bBox = that._label.getBoundingRect();
                var coord = that._getLabelCoords(that._label);
                var visibleArea = that._getVisibleArea();
                if (that._isLabelDrawingWithoutPoints) {
                    return that._checkLabelPosition(coord, bBox, visibleArea)
                } else {
                    return that._getLabelExtraCoord(coord, that._checkVerticalLabelPosition(coord, bBox, visibleArea), bBox)
                }
            },
            _getLabelPosition: function(options) {
                return options.position
            },
            _getLabelCoords: function(label) {
                var that = this;
                var bBox = label.getBoundingRect();
                var options = label.getLayoutOptions();
                var angleFunctions = _getCosAndSin(that.middleAngle);
                var position = that._getLabelPosition(options);
                var radiusInner = that.radiusInner;
                var radiusOuter = that.radiusOuter;
                var radiusLabels = that.radiusLabels;
                var columnsPosition = "columns" === position;
                var rad;
                var x;
                if ("inside" === position) {
                    rad = radiusInner + (radiusOuter - radiusInner) / 2 + options.radialOffset;
                    x = that.centerX + rad * angleFunctions.cos - bBox.width / 2
                } else {
                    rad = radiusLabels + options.radialOffset;
                    if (angleFunctions.cos > .1 || columnsPosition && angleFunctions.cos >= 0) {
                        x = that.centerX + rad * angleFunctions.cos
                    } else {
                        if (angleFunctions.cos < -.1 || columnsPosition && angleFunctions.cos < 0) {
                            x = that.centerX + rad * angleFunctions.cos - bBox.width
                        } else {
                            x = that.centerX + rad * angleFunctions.cos - bBox.width / 2
                        }
                    }
                }
                return {
                    x: x,
                    y: _round(that.centerY - rad * angleFunctions.sin - bBox.height / 2)
                }
            },
            _correctLabelCoord: function(coord, moveLabelsFromCenter) {
                var that = this;
                var label = that._label;
                var bBox = label.getBoundingRect();
                var labelWidth = bBox.width;
                var options = label.getLayoutOptions();
                var visibleArea = that._getVisibleArea();
                var rightBorderX = visibleArea.maxX - labelWidth;
                var leftBorderX = visibleArea.minX;
                var angleOfPoint = _normalizeAngle(that.middleAngle);
                var centerX = that.centerX;
                var connectorOffset = options.connectorOffset;
                var x = coord.x;
                if ("columns" === options.position) {
                    if (angleOfPoint <= 90 || angleOfPoint >= 270) {
                        x = rightBorderX
                    } else {
                        x = leftBorderX
                    }
                    coord.x = x
                } else {
                    if ("inside" !== options.position && moveLabelsFromCenter) {
                        if (angleOfPoint <= 90 || angleOfPoint >= 270) {
                            if (x - connectorOffset < centerX) {
                                x = centerX + connectorOffset
                            }
                        } else {
                            if (x + labelWidth + connectorOffset > centerX) {
                                x = centerX - labelWidth - connectorOffset
                            }
                        }
                        coord.x = x
                    }
                }
                return coord
            },
            drawLabel: function() {
                this.translate();
                this._isLabelDrawingWithoutPoints = true;
                this._drawLabel();
                this._isLabelDrawingWithoutPoints = false
            },
            updateLabelCoord: function(moveLabelsFromCenter) {
                var that = this;
                var bBox = that._label.getBoundingRect();
                var coord = that._correctLabelCoord(bBox, moveLabelsFromCenter);
                coord = that._checkHorizontalLabelPosition(coord, bBox, that._getVisibleArea());
                that._label.shift(_round(coord.x), _round(bBox.y))
            },
            _checkVerticalLabelPosition: function(coord, box, visibleArea) {
                var x = coord.x;
                var y = coord.y;
                if (coord.y + box.height > visibleArea.maxY) {
                    y = visibleArea.maxY - box.height
                } else {
                    if (coord.y < visibleArea.minY) {
                        y = visibleArea.minY
                    }
                }
                return {
                    x: x,
                    y: y
                }
            },
            _getLabelExtraCoord: function(coord, shiftCoord, box) {
                return coord.y !== shiftCoord.y ? getVerticallyShiftedAngularCoords({
                    x: coord.x,
                    y: coord.y,
                    width: box.width,
                    height: box.height
                }, shiftCoord.y - coord.y, {
                    x: this.centerX,
                    y: this.centerY
                }) : coord
            },
            _checkHorizontalLabelPosition: function(coord, box, visibleArea) {
                var x = coord.x;
                var y = coord.y;
                if (coord.x + box.width > visibleArea.maxX) {
                    x = visibleArea.maxX - box.width
                } else {
                    if (coord.x < visibleArea.minX) {
                        x = visibleArea.minX
                    }
                }
                return {
                    x: x,
                    y: y
                }
            },
            applyWordWrap: function(moveLabelsFromCenter) {
                var that = this;
                var label = that._label;
                var box = label.getBoundingRect();
                var visibleArea = that._getVisibleArea();
                var position = label.getLayoutOptions().position;
                var width = box.width;
                var rowCountChanged = false;
                if ("columns" === position && that.series.index > 0) {
                    width = visibleArea.maxX - that.centerX - that.radiusLabels
                } else {
                    if ("inside" === position) {
                        if (width > visibleArea.maxX - visibleArea.minX) {
                            width = visibleArea.maxX - visibleArea.minX
                        }
                    } else {
                        if (moveLabelsFromCenter && box.x < that.centerX && box.width + box.x > that.centerX) {
                            width = Math.floor((visibleArea.maxX - visibleArea.minX) / 2)
                        } else {
                            if (box.x + width > visibleArea.maxX) {
                                width = visibleArea.maxX - box.x
                            } else {
                                if (box.x < visibleArea.minX) {
                                    width = box.x + width - visibleArea.minX
                                }
                            }
                        }
                    }
                }
                if (width < box.width) {
                    rowCountChanged = label.fit(width)
                }
                return rowCountChanged
            },
            setLabelTrackerData: function() {
                this._label.setTrackerData(this)
            },
            _checkLabelPosition: function(coord, bBox, visibleArea) {
                coord = this._checkHorizontalLabelPosition(coord, bBox, visibleArea);
                return this._checkVerticalLabelPosition(coord, bBox, visibleArea)
            },
            _getLabelConnector: function() {
                var that = this;
                var rad = that.radiusOuter;
                var seriesStyle = that._options.styles.normal;
                var strokeWidthBy2 = seriesStyle["stroke-width"] / 2;
                var borderWidth = that.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2);
                var angleFunctions = _getCosAndSin(_round(that.middleAngle));
                return {
                    x: _round(that.centerX + (rad - borderWidth) * angleFunctions.cos),
                    y: _round(that.centerY - (rad - borderWidth) * angleFunctions.sin),
                    angle: that.middleAngle
                }
            },
            _drawMarker: function(renderer, group, animationEnabled, firstDrawing) {
                var that = this;
                var radiusOuter = that.radiusOuter;
                var radiusInner = that.radiusInner;
                var fromAngle = that.fromAngle;
                var toAngle = that.toAngle;
                if (animationEnabled) {
                    radiusInner = radiusOuter = 0;
                    if (!firstDrawing) {
                        fromAngle = toAngle = that.shiftedAngle
                    }
                }
                that.graphic = renderer.arc(that.centerX, that.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({
                    "stroke-linejoin": "round"
                }).smartAttr(that._getStyle()).data({
                    "chart-data-point": that
                }).sharp().append(group)
            },
            getTooltipParams: function() {
                var that = this;
                var angleFunctions = _getCosAndSin(that.middleAngle);
                var radiusInner = that.radiusInner;
                var radiusOuter = that.radiusOuter;
                return {
                    x: that.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,
                    y: that.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,
                    offset: 0
                }
            },
            _translate: function() {
                var that = this;
                var angle = that.shiftedAngle || 0;
                var value = that.value;
                var minValue = that.minValue;
                var translator = that._getValTranslator();
                that.fromAngle = translator.translate(minValue) + angle;
                that.toAngle = translator.translate(value) + angle;
                that.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;
                if (!that.isVisible()) {
                    that.middleAngle = that.toAngle = that.fromAngle = that.fromAngle || angle
                }
            },
            getMarkerVisibility: function() {
                return true
            },
            _updateMarker: function(animationEnabled, style, _, callback) {
                var that = this;
                if (!animationEnabled) {
                    style = _extend({
                        x: that.centerX,
                        y: that.centerY,
                        outerRadius: that.radiusOuter,
                        innerRadius: that.radiusInner,
                        startAngle: that.toAngle,
                        endAngle: that.fromAngle
                    }, style)
                }
                that.graphic.smartAttr(style).sharp();
                callback && callback()
            },
            getLegendStyles: function() {
                return this._styles.legendStyles
            },
            isInVisibleArea: function() {
                return true
            },
            hide: function() {
                var that = this;
                if (that._visible) {
                    that._visible = false;
                    that.hideTooltip();
                    that._options.visibilityChanged()
                }
            },
            show: function() {
                var that = this;
                if (!that._visible) {
                    that._visible = true;
                    that._options.visibilityChanged()
                }
            },
            setInvisibility: function() {
                this._label.draw(false)
            },
            isVisible: function() {
                return this._visible
            },
            _getFormatObject: function(tooltip) {
                var formatObject = symbolPoint._getFormatObject.call(this, tooltip);
                var percent = this.percent;
                formatObject.percent = percent;
                formatObject.percentText = tooltip.formatValue(percent, "percent");
                return formatObject
            },
            getColor: function() {
                return this._styles.normal.fill
            },
            coordsIn: function(x, y) {
                var that = this;
                var lx = x - that.centerX;
                var ly = y - that.centerY;
                var r = _sqrt(lx * lx + ly * ly);
                var fromAngle = that.fromAngle % 360;
                var toAngle = that.toAngle % 360;
                var angle;
                if (r < that.radiusInner || r > that.radiusOuter || 0 === r) {
                    return false
                }
                angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);
                if (angle < 0) {
                    angle += 360
                }
                if (fromAngle === toAngle && _abs(that.toAngle - that.fromAngle) > 1e-4) {
                    return true
                } else {
                    return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle)
                }
            }
        })
    },
    /*!**********************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/range_symbol_point.js ***!
      \**********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var each = __webpack_require__( /*! ../../../core/utils/iterator */ 4).each;
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var noop = __webpack_require__( /*! ../../../core/utils/common */ 3).noop;
        var labelModule = __webpack_require__( /*! ./label */ 262);
        var symbolPoint = __webpack_require__( /*! ./symbol_point */ 126);
        var _extend = extend;
        var _isDefined = __webpack_require__( /*! ../../../core/utils/type */ 1).isDefined;
        var _math = Math;
        var _abs = _math.abs;
        var _min = _math.min;
        var _max = _math.max;
        var _round = _math.round;
        var DEFAULT_IMAGE_WIDTH = 20;
        var DEFAULT_IMAGE_HEIGHT = 20;
        module.exports = _extend({}, symbolPoint, {
            deleteLabel: function() {
                var that = this;
                that._topLabel.dispose();
                that._topLabel = null;
                that._bottomLabel.dispose();
                that._bottomLabel = null
            },
            hideMarker: function(type) {
                var graphic = this.graphic;
                var marker = graphic && graphic[type + "Marker"];
                var label = this["_" + type + "Label"];
                if (marker && "hidden" !== marker.attr("visibility")) {
                    marker.attr({
                        visibility: "hidden"
                    })
                }
                label.draw(false)
            },
            setInvisibility: function() {
                this.hideMarker("top");
                this.hideMarker("bottom")
            },
            clearVisibility: function() {
                var that = this;
                var graphic = that.graphic;
                var topMarker = graphic && graphic.topMarker;
                var bottomMarker = graphic && graphic.bottomMarker;
                if (topMarker && topMarker.attr("visibility")) {
                    topMarker.attr({
                        visibility: null
                    })
                }
                if (bottomMarker && bottomMarker.attr("visibility")) {
                    bottomMarker.attr({
                        visibility: null
                    })
                }
            },
            clearMarker: function() {
                var that = this;
                var graphic = that.graphic;
                var topMarker = graphic && graphic.topMarker;
                var bottomMarker = graphic && graphic.bottomMarker;
                var emptySettings = that._emptySettings;
                topMarker && topMarker.attr(emptySettings);
                bottomMarker && bottomMarker.attr(emptySettings)
            },
            _getLabelPosition: function(markerType) {
                var position;
                var labelsInside = "inside" === this._options.label.position;
                if (!this._options.rotated) {
                    position = "top" === markerType ^ labelsInside ? "top" : "bottom"
                } else {
                    position = "top" === markerType ^ labelsInside ? "right" : "left"
                }
                return position
            },
            _getLabelMinFormatObject: function() {
                var that = this;
                return {
                    index: 0,
                    argument: that.initialArgument,
                    value: that.initialMinValue,
                    seriesName: that.series.name,
                    originalValue: that.originalMinValue,
                    originalArgument: that.originalArgument,
                    point: that
                }
            },
            _updateLabelData: function() {
                var maxFormatObject = this._getLabelFormatObject();
                maxFormatObject.index = 1;
                this._topLabel.setData(maxFormatObject);
                this._bottomLabel.setData(this._getLabelMinFormatObject())
            },
            _updateLabelOptions: function() {
                var that = this;
                var options = this._options.label;
                (!that._topLabel || !that._bottomLabel) && that._createLabel();
                that._topLabel.setOptions(options);
                that._bottomLabel.setOptions(options)
            },
            _createLabel: function() {
                var options = {
                    renderer: this.series._renderer,
                    labelsGroup: this.series._labelsGroup,
                    point: this
                };
                this._topLabel = new labelModule.Label(options);
                this._bottomLabel = new labelModule.Label(options)
            },
            _getGraphicBBox: function(location) {
                var options = this._options;
                var images = this._getImage(options.image);
                var image = "top" === location ? this._checkImage(images.top) : this._checkImage(images.bottom);
                var bBox;
                var coord = this._getPositionFromLocation(location);
                if (options.visible) {
                    bBox = image ? this._getImageBBox(coord.x, coord.y) : this._getSymbolBBox(coord.x, coord.y, options.styles.normal.r)
                } else {
                    bBox = {
                        x: coord.x,
                        y: coord.y,
                        width: 0,
                        height: 0
                    }
                }
                return bBox
            },
            _getPositionFromLocation: function(location) {
                var x;
                var y;
                var isTop = "top" === location;
                if (!this._options.rotated) {
                    x = this.x;
                    y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY)
                } else {
                    x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);
                    y = this.y
                }
                return {
                    x: x,
                    y: y
                }
            },
            _checkOverlay: function(bottomCoord, topCoord, topValue) {
                return bottomCoord < topCoord + topValue
            },
            _getOverlayCorrections: function(topCoords, bottomCoords) {
                var rotated = this._options.rotated;
                var coordSelector = !rotated ? "y" : "x";
                var valueSelector = !rotated ? "height" : "width";
                var visibleArea = this.series.getValueAxis().getVisibleArea();
                var minBound = visibleArea[0];
                var maxBound = visibleArea[1];
                var delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2);
                var coord1 = topCoords[coordSelector] - delta;
                var coord2 = bottomCoords[coordSelector] + delta;
                if (coord1 < minBound) {
                    delta = minBound - coord1;
                    coord1 += delta;
                    coord2 += delta
                } else {
                    if (coord2 + bottomCoords[valueSelector] > maxBound) {
                        delta = maxBound - coord2 - bottomCoords[valueSelector];
                        coord1 += delta;
                        coord2 += delta
                    }
                }
                return {
                    coord1: coord1,
                    coord2: coord2
                }
            },
            _checkLabelsOverlay: function(topLocation) {
                var that = this;
                var topCoords = that._topLabel.getBoundingRect();
                var bottomCoords = that._bottomLabel.getBoundingRect();
                var corrections = {};
                if (!that._options.rotated) {
                    if ("top" === topLocation) {
                        if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {
                            corrections = this._getOverlayCorrections(topCoords, bottomCoords);
                            that._topLabel.shift(topCoords.x, corrections.coord1);
                            that._bottomLabel.shift(bottomCoords.x, corrections.coord2)
                        }
                    } else {
                        if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {
                            corrections = this._getOverlayCorrections(bottomCoords, topCoords);
                            that._topLabel.shift(topCoords.x, corrections.coord2);
                            that._bottomLabel.shift(bottomCoords.x, corrections.coord1)
                        }
                    }
                } else {
                    if ("top" === topLocation) {
                        if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {
                            corrections = this._getOverlayCorrections(bottomCoords, topCoords);
                            that._topLabel.shift(corrections.coord2, topCoords.y);
                            that._bottomLabel.shift(corrections.coord1, bottomCoords.y)
                        }
                    } else {
                        if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {
                            corrections = this._getOverlayCorrections(topCoords, bottomCoords);
                            that._topLabel.shift(corrections.coord1, topCoords.y);
                            that._bottomLabel.shift(corrections.coord2, bottomCoords.y)
                        }
                    }
                }
            },
            _drawLabel: function() {
                var that = this;
                var labels = [];
                var notInverted = that._options.rotated ? that.x >= that.minX : that.y < that.minY;
                var customVisibility = that._getCustomLabelVisibility();
                var topLabel = that._topLabel;
                var bottomLabel = that._bottomLabel;
                topLabel.pointPosition = notInverted ? "top" : "bottom";
                bottomLabel.pointPosition = notInverted ? "bottom" : "top";
                if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue() && false !== customVisibility) {
                    false !== that.visibleTopMarker && labels.push(topLabel);
                    false !== that.visibleBottomMarker && labels.push(bottomLabel);
                    each(labels, function(_, label) {
                        label.draw(true)
                    });
                    that._checkLabelsOverlay(that._topLabel.pointPosition)
                } else {
                    topLabel.draw(false);
                    bottomLabel.draw(false)
                }
            },
            _getImage: function(imageOption) {
                var image = {};
                if (_isDefined(imageOption)) {
                    if ("string" === typeof imageOption) {
                        image.top = image.bottom = imageOption
                    } else {
                        image.top = {
                            url: "string" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,
                            width: "number" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,
                            height: "number" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint
                        };
                        image.bottom = {
                            url: "string" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,
                            width: "number" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,
                            height: "number" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint
                        }
                    }
                }
                return image
            },
            _checkSymbol: function(oldOptions, newOptions) {
                var that = this;
                var oldSymbol = oldOptions.symbol;
                var newSymbol = newOptions.symbol;
                var symbolChanged = "circle" === oldSymbol && "circle" !== newSymbol || "circle" !== oldSymbol && "circle" === newSymbol;
                var oldImages = that._getImage(oldOptions.image);
                var newImages = that._getImage(newOptions.image);
                var topImageChanged = that._checkImage(oldImages.top) !== that._checkImage(newImages.top);
                var bottomImageChanged = that._checkImage(oldImages.bottom) !== that._checkImage(newImages.bottom);
                return symbolChanged || topImageChanged || bottomImageChanged
            },
            _getSettingsForTwoMarkers: function(style) {
                var that = this;
                var options = that._options;
                var settings = {};
                var x = options.rotated ? _min(that.x, that.minX) : that.x;
                var y = options.rotated ? that.y : _min(that.y, that.minY);
                var radius = style.r;
                var points = that._populatePointShape(options.symbol, radius);
                settings.top = _extend({
                    translateX: x + that.width,
                    translateY: y,
                    r: radius
                }, style);
                settings.bottom = _extend({
                    translateX: x,
                    translateY: y + that.height,
                    r: radius
                }, style);
                if (points) {
                    settings.top.points = settings.bottom.points = points
                }
                return settings
            },
            _hasGraphic: function() {
                return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker
            },
            _drawOneMarker: function(renderer, markerType, imageSettings, settings) {
                var that = this;
                var graphic = that.graphic;
                if (graphic[markerType]) {
                    that._updateOneMarker(markerType, settings)
                } else {
                    graphic[markerType] = that._createMarker(renderer, graphic, imageSettings, settings)
                }
            },
            _drawMarker: function(renderer, group, animationEnabled, firstDrawing, style) {
                var that = this;
                var settings = that._getSettingsForTwoMarkers(style || that._getStyle());
                var image = that._getImage(that._options.image);
                if (that._checkImage(image.top)) {
                    settings.top = that._getImageSettings(settings.top, image.top)
                }
                if (that._checkImage(image.bottom)) {
                    settings.bottom = that._getImageSettings(settings.bottom, image.bottom)
                }
                that.graphic = that.graphic || renderer.g().append(group);
                that.visibleTopMarker && that._drawOneMarker(renderer, "topMarker", image.top, settings.top);
                that.visibleBottomMarker && that._drawOneMarker(renderer, "bottomMarker", image.bottom, settings.bottom)
            },
            _getSettingsForTracker: function(radius) {
                var that = this;
                var rotated = that._options.rotated;
                return {
                    translateX: rotated ? _min(that.x, that.minX) - radius : that.x - radius,
                    translateY: rotated ? that.y - radius : _min(that.y, that.minY) - radius,
                    width: that.width + 2 * radius,
                    height: that.height + 2 * radius
                }
            },
            isInVisibleArea: function() {
                var that = this;
                var rotated = that._options.rotated;
                var argument = !rotated ? that.x : that.y;
                var maxValue = !rotated ? _max(that.minY, that.y) : _max(that.minX, that.x);
                var minValue = !rotated ? _min(that.minY, that.y) : _min(that.minX, that.x);
                var tmp;
                var visibleTopMarker = true;
                var visibleBottomMarker = true;
                var visibleRangeArea = true;
                var visibleArgArea = that.series.getArgumentAxis().getVisibleArea();
                var visibleValArea = that.series.getValueAxis().getVisibleArea();
                var notVisibleByArg = visibleArgArea[1] < argument || visibleArgArea[0] > argument;
                var notVisibleByVal = visibleValArea[0] > minValue && visibleValArea[0] > maxValue || visibleValArea[1] < minValue && visibleValArea[1] < maxValue;
                if (notVisibleByArg || notVisibleByVal) {
                    visibleTopMarker = visibleBottomMarker = visibleRangeArea = false
                } else {
                    visibleTopMarker = visibleValArea[0] <= minValue && visibleValArea[1] > minValue;
                    visibleBottomMarker = visibleValArea[0] < maxValue && visibleValArea[1] >= maxValue;
                    if (rotated) {
                        tmp = visibleTopMarker;
                        visibleTopMarker = visibleBottomMarker;
                        visibleBottomMarker = tmp
                    }
                }
                that.visibleTopMarker = visibleTopMarker;
                that.visibleBottomMarker = visibleBottomMarker;
                return visibleRangeArea
            },
            getTooltipParams: function() {
                var that = this;
                var x;
                var y;
                var rotated = that._options.rotated;
                var minValue = !rotated ? _min(that.y, that.minY) : _min(that.x, that.minX);
                var side = !rotated ? "height" : "width";
                var visibleArea = that._getVisibleArea();
                var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
                var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
                var min = _max(minVisible, minValue);
                var max = _min(maxVisible, minValue + that[side]);
                if (!rotated) {
                    x = that.x;
                    y = min + (max - min) / 2
                } else {
                    y = that.y;
                    x = min + (max - min) / 2
                }
                return {
                    x: x,
                    y: y,
                    offset: 0
                }
            },
            _translate: function() {
                var that = this;
                var rotated = that._options.rotated;
                symbolPoint._translate.call(that);
                that.height = rotated ? 0 : _abs(that.minY - that.y);
                that.width = rotated ? _abs(that.x - that.minX) : 0
            },
            hasCoords: function() {
                return symbolPoint.hasCoords.call(this) && !(null === this.minX || null === this.minY)
            },
            _updateData: function(data) {
                var that = this;
                symbolPoint._updateData.call(that, data);
                that.minValue = that.initialMinValue = that.originalMinValue = data.minValue
            },
            _getImageSettings: function(settings, image) {
                return {
                    href: image.url || image.toString(),
                    width: image.width || DEFAULT_IMAGE_WIDTH,
                    height: image.height || DEFAULT_IMAGE_HEIGHT,
                    translateX: settings.translateX,
                    translateY: settings.translateY
                }
            },
            getCrosshairData: function(x, y) {
                var that = this;
                var rotated = that._options.rotated;
                var minX = that.minX;
                var minY = that.minY;
                var vx = that.vx;
                var vy = that.vy;
                var value = that.value;
                var minValue = that.minValue;
                var argument = that.argument;
                var coords = {
                    axis: that.series.axis,
                    x: vx,
                    y: vy,
                    yValue: value,
                    xValue: argument
                };
                if (rotated) {
                    coords.yValue = argument;
                    if (_abs(vx - x) < _abs(minX - x)) {
                        coords.xValue = value
                    } else {
                        coords.x = minX;
                        coords.xValue = minValue
                    }
                } else {
                    if (_abs(vy - y) >= _abs(minY - y)) {
                        coords.y = minY;
                        coords.yValue = minValue
                    }
                }
                return coords
            },
            _updateOneMarker: function(markerType, settings) {
                this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings)
            },
            _updateMarker: function(animationEnabled, style) {
                this._drawMarker(void 0, void 0, false, false, style)
            },
            _getFormatObject: function(tooltip) {
                var that = this;
                var initialMinValue = that.initialMinValue;
                var initialValue = that.initialValue;
                var initialArgument = that.initialArgument;
                var minValue = tooltip.formatValue(initialMinValue);
                var value = tooltip.formatValue(initialValue);
                return {
                    argument: initialArgument,
                    argumentText: tooltip.formatValue(initialArgument, "argument"),
                    valueText: minValue + " - " + value,
                    rangeValue1Text: minValue,
                    rangeValue2Text: value,
                    rangeValue1: initialMinValue,
                    rangeValue2: initialValue,
                    seriesName: that.series.name,
                    point: that,
                    originalMinValue: that.originalMinValue,
                    originalValue: that.originalValue,
                    originalArgument: that.originalArgument
                }
            },
            getLabel: function() {
                return [this._topLabel, this._bottomLabel]
            },
            getLabels: function() {
                return [this._topLabel, this._bottomLabel]
            },
            getBoundingRect: noop,
            coordsIn: function(x, y) {
                var trackerRadius = this._storeTrackerR();
                var xCond = x >= this.x - trackerRadius && x <= this.x + trackerRadius;
                var yCond = y >= this.y - trackerRadius && y <= this.y + trackerRadius;
                if (this._options.rotated) {
                    return yCond && (xCond || x >= this.minX - trackerRadius && x <= this.minX + trackerRadius)
                } else {
                    return xCond && (yCond || y >= this.minY - trackerRadius && y <= this.minY + trackerRadius)
                }
            },
            getMaxValue: function() {
                if ("discrete" !== this.series.valueAxisType) {
                    return this.minValue > this.value ? this.minValue : this.value
                }
                return this.value
            },
            getMinValue: function() {
                if ("discrete" !== this.series.valueAxisType) {
                    return this.minValue < this.value ? this.minValue : this.value
                }
                return this.minValue
            }
        })
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/candlestick_point.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var symbolPoint = __webpack_require__( /*! ./symbol_point */ 126);
        var barPoint = __webpack_require__( /*! ./bar_point */ 208);
        var _math = Math;
        var _abs = _math.abs;
        var _min = _math.min;
        var _max = _math.max;
        var _round = _math.round;
        var DEFAULT_FINANCIAL_TRACKER_MARGIN = 2;
        module.exports = _extend({}, barPoint, {
            _getContinuousPoints: function(openCoord, closeCoord) {
                var that = this;
                var x = that.x;
                var createPoint = that._options.rotated ? function(x, y) {
                    return [y, x]
                } : function(x, y) {
                    return [x, y]
                };
                var width = that.width;
                var highCoord = that.highY;
                var max = _abs(highCoord - openCoord) < _abs(highCoord - closeCoord) ? openCoord : closeCoord;
                var min = max === closeCoord ? openCoord : closeCoord;
                var points;
                if (min === max) {
                    points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, that.closeY)).concat(createPoint(x - width / 2, that.closeY)).concat(createPoint(x + width / 2, that.closeY)).concat(createPoint(x, that.closeY))
                } else {
                    points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, max)).concat(createPoint(x + width / 2, max)).concat(createPoint(x + width / 2, min)).concat(createPoint(x, min)).concat(createPoint(x, that.lowY)).concat(createPoint(x, min)).concat(createPoint(x - width / 2, min)).concat(createPoint(x - width / 2, max)).concat(createPoint(x, max))
                }
                return points
            },
            _getCrockPoints: function(y) {
                var that = this;
                var x = that.x;
                var createPoint = that._options.rotated ? function(x, y) {
                    return [y, x]
                } : function(x, y) {
                    return [x, y]
                };
                return [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, y)).concat(createPoint(x - that.width / 2, y)).concat(createPoint(x + that.width / 2, y)).concat(createPoint(x, y))
            },
            _getPoints: function() {
                var that = this;
                var points;
                var closeCoord = that.closeY;
                var openCoord = that.openY;
                if (null !== closeCoord && null !== openCoord) {
                    points = that._getContinuousPoints(openCoord, closeCoord)
                } else {
                    if (openCoord === closeCoord) {
                        points = [that.x, that.highY, that.x, that.lowY]
                    } else {
                        points = that._getCrockPoints(null !== openCoord ? openCoord : closeCoord)
                    }
                }
                return points
            },
            getColor: function() {
                var that = this;
                return that._isReduction ? that._options.reduction.color : that._styles.normal.stroke || that.series.getColor()
            },
            _drawMarkerInGroup: function(group, attributes, renderer) {
                var that = this;
                that.graphic = renderer.path(that._getPoints(), "area").attr({
                    "stroke-linecap": "square"
                }).attr(attributes).data({
                    "chart-data-point": that
                }).sharp().append(group)
            },
            _fillStyle: function() {
                var that = this;
                var styles = that._options.styles;
                if (that._isReduction && that._isPositive) {
                    that._styles = styles.reductionPositive
                } else {
                    if (that._isReduction) {
                        that._styles = styles.reduction
                    } else {
                        if (that._isPositive) {
                            that._styles = styles.positive
                        } else {
                            that._styles = styles
                        }
                    }
                }
            },
            _getMinTrackerWidth: function() {
                return 2 + 2 * this._styles.normal["stroke-width"]
            },
            correctCoordinates: function(correctOptions) {
                var minWidth = this._getMinTrackerWidth();
                var maxWidth = 10;
                var width = correctOptions.width;
                width = width < minWidth ? minWidth : width > maxWidth ? maxWidth : width;
                this.width = width + width % 2;
                this.xCorrection = correctOptions.offset
            },
            _getMarkerGroup: function(group) {
                var that = this;
                var markerGroup;
                if (that._isReduction && that._isPositive) {
                    markerGroup = group.reductionPositiveMarkersGroup
                } else {
                    if (that._isReduction) {
                        markerGroup = group.reductionMarkersGroup
                    } else {
                        if (that._isPositive) {
                            markerGroup = group.defaultPositiveMarkersGroup
                        } else {
                            markerGroup = group.defaultMarkersGroup
                        }
                    }
                }
                return markerGroup
            },
            _drawMarker: function(renderer, group) {
                this._drawMarkerInGroup(this._getMarkerGroup(group), this._getStyle(), renderer)
            },
            _getSettingsForTracker: function() {
                var that = this;
                var highY = that.highY;
                var lowY = that.lowY;
                var rotated = that._options.rotated;
                var x;
                var y;
                var width;
                var height;
                if (highY === lowY) {
                    highY = rotated ? highY + DEFAULT_FINANCIAL_TRACKER_MARGIN : highY - DEFAULT_FINANCIAL_TRACKER_MARGIN;
                    lowY = rotated ? lowY - DEFAULT_FINANCIAL_TRACKER_MARGIN : lowY + DEFAULT_FINANCIAL_TRACKER_MARGIN
                }
                if (rotated) {
                    x = _min(lowY, highY);
                    y = that.x - that.width / 2;
                    width = _abs(lowY - highY);
                    height = that.width
                } else {
                    x = that.x - that.width / 2;
                    y = _min(lowY, highY);
                    width = that.width;
                    height = _abs(lowY - highY)
                }
                return {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                }
            },
            _getGraphicBBox: function(location) {
                var that = this;
                var rotated = that._options.rotated;
                var x = that.x;
                var width = that.width;
                var lowY = that.lowY;
                var highY = that.highY;
                if (location) {
                    var valVisibleArea = that.series.getValueAxis().getVisibleArea();
                    highY = that._truncateCoord(highY, valVisibleArea);
                    lowY = that._truncateCoord(lowY, valVisibleArea)
                }
                var bBox = {
                    x: !rotated ? x - _round(width / 2) : lowY,
                    y: !rotated ? highY : x - _round(width / 2),
                    width: !rotated ? width : highY - lowY,
                    height: !rotated ? lowY - highY : width
                };
                if (location) {
                    var isTop = "top" === location;
                    if (!this._options.rotated) {
                        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
                        bBox.height = 0
                    } else {
                        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
                        bBox.width = 0
                    }
                }
                return bBox
            },
            getTooltipParams: function(location) {
                var that = this;
                if (that.graphic) {
                    var minValue = _min(that.lowY, that.highY);
                    var maxValue = _max(that.lowY, that.highY);
                    var visibleArea = that._getVisibleArea();
                    var rotated = that._options.rotated;
                    var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
                    var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
                    var min = _max(minVisible, minValue);
                    var max = _min(maxVisible, maxValue);
                    var centerCoord = that.getCenterCoord();
                    if ("edge" === location) {
                        centerCoord[rotated ? "x" : "y"] = rotated ? max : min
                    }
                    centerCoord.offset = 0;
                    return centerCoord
                }
            },
            getCenterCoord: function() {
                if (this.graphic) {
                    var that = this;
                    var x;
                    var y;
                    var minValue = _min(that.lowY, that.highY);
                    var maxValue = _max(that.lowY, that.highY);
                    var visibleArea = that._getVisibleArea();
                    var rotated = that._options.rotated;
                    var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
                    var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
                    var min = _max(minVisible, minValue);
                    var max = _min(maxVisible, maxValue);
                    var center = min + (max - min) / 2;
                    if (rotated) {
                        y = that.x;
                        x = center
                    } else {
                        x = that.x;
                        y = center
                    }
                    return {
                        x: x,
                        y: y
                    }
                }
            },
            hasValue: function() {
                return null !== this.highValue && null !== this.lowValue
            },
            hasCoords: function() {
                return null !== this.x && null !== this.lowY && null !== this.highY
            },
            _translate: function() {
                var that = this;
                var rotated = that._options.rotated;
                var valTranslator = that._getValTranslator();
                var x = that._getArgTranslator().translate(that.argument);
                that.vx = that.vy = that.x = null === x ? x : x + (that.xCorrection || 0);
                that.openY = null !== that.openValue ? valTranslator.translate(that.openValue) : null;
                that.highY = valTranslator.translate(that.highValue);
                that.lowY = valTranslator.translate(that.lowValue);
                that.closeY = null !== that.closeValue ? valTranslator.translate(that.closeValue) : null;
                var centerValue = _min(that.lowY, that.highY) + _abs(that.lowY - that.highY) / 2;
                that._calculateVisibility(!rotated ? that.x : centerValue, !rotated ? centerValue : that.x)
            },
            getCrosshairData: function(x, y) {
                var that = this;
                var rotated = that._options.rotated;
                var origY = rotated ? x : y;
                var yValue;
                var argument = that.argument;
                var coords;
                var coord = "low";
                if (_abs(that.lowY - origY) < _abs(that.closeY - origY)) {
                    yValue = that.lowY
                } else {
                    yValue = that.closeY;
                    coord = "close"
                }
                if (_abs(yValue - origY) >= _abs(that.openY - origY)) {
                    yValue = that.openY;
                    coord = "open"
                }
                if (_abs(yValue - origY) >= _abs(that.highY - origY)) {
                    yValue = that.highY;
                    coord = "high"
                }
                if (rotated) {
                    coords = {
                        y: that.vy,
                        x: yValue,
                        xValue: that[coord + "Value"],
                        yValue: argument
                    }
                } else {
                    coords = {
                        x: that.vx,
                        y: yValue,
                        xValue: argument,
                        yValue: that[coord + "Value"]
                    }
                }
                coords.axis = that.series.axis;
                return coords
            },
            _updateData: function(data) {
                var that = this;
                var label = that._label;
                var reductionColor = this._options.reduction.color;
                that.value = that.initialValue = data.reductionValue;
                that.originalValue = data.value;
                that.lowValue = that.originalLowValue = data.lowValue;
                that.highValue = that.originalHighValue = data.highValue;
                that.openValue = that.originalOpenValue = data.openValue;
                that.closeValue = that.originalCloseValue = data.closeValue;
                that._isPositive = data.openValue < data.closeValue;
                that._isReduction = data.isReduction;
                if (that._isReduction) {
                    label.setColor(reductionColor)
                }
            },
            _updateMarker: function(animationEnabled, style, group) {
                var that = this;
                var graphic = that.graphic;
                graphic.attr({
                    points: that._getPoints()
                }).smartAttr(style).sharp();
                group && graphic.append(that._getMarkerGroup(group))
            },
            _getLabelFormatObject: function() {
                var that = this;
                return {
                    openValue: that.openValue,
                    highValue: that.highValue,
                    lowValue: that.lowValue,
                    closeValue: that.closeValue,
                    reductionValue: that.initialValue,
                    argument: that.initialArgument,
                    value: that.initialValue,
                    seriesName: that.series.name,
                    originalOpenValue: that.originalOpenValue,
                    originalCloseValue: that.originalCloseValue,
                    originalLowValue: that.originalLowValue,
                    originalHighValue: that.originalHighValue,
                    originalArgument: that.originalArgument,
                    point: that
                }
            },
            _getFormatObject: function(tooltip) {
                var that = this;
                var highValue = tooltip.formatValue(that.highValue);
                var openValue = tooltip.formatValue(that.openValue);
                var closeValue = tooltip.formatValue(that.closeValue);
                var lowValue = tooltip.formatValue(that.lowValue);
                var symbolMethods = symbolPoint;
                var formatObject = symbolMethods._getFormatObject.call(that, tooltip);
                return _extend({}, formatObject, {
                    valueText: "h: " + highValue + ("" !== openValue ? " o: " + openValue : "") + ("" !== closeValue ? " c: " + closeValue : "") + " l: " + lowValue,
                    highValueText: highValue,
                    openValueText: openValue,
                    closeValueText: closeValue,
                    lowValueText: lowValue
                })
            },
            getMaxValue: function() {
                return this.highValue
            },
            getMinValue: function() {
                return this.lowValue
            }
        })
    },
    /*!********************************************************************!*\
      !*** ./artifacts/transpiled/viz/components/chart_theme_manager.js ***!
      \********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var BaseThemeManager = __webpack_require__( /*! ../core/base_theme_manager */ 257).BaseThemeManager;
        var _isString = typeUtils.isString;
        var _isDefined = typeUtils.isDefined;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var ThemeManager = BaseThemeManager.inherit(function() {
            var ctor = function(params) {
                var that = this;
                that.callBase.apply(that, arguments);
                var options = params.options || {};
                that._userOptions = options;
                that._mergeAxisTitleOptions = [];
                that._multiPieColors = {};
                that._callback = noop
            };
            var dispose = function() {
                var that = this;
                that.palette && that.palette.dispose();
                that.palette = that._userOptions = that._mergedSettings = that._multiPieColors = null;
                return that.callBase.apply(that, arguments)
            };
            var resetPalette = function() {
                this.palette.reset();
                this._multiPieColors = {}
            };
            var processTitleOptions = function(options) {
                return _isString(options) ? {
                    text: options
                } : options
            };
            var processAxisOptions = function(axisOptions) {
                if (!axisOptions) {
                    return {}
                }
                axisOptions = extend(true, {}, axisOptions);
                axisOptions.title = processTitleOptions(axisOptions.title);
                if ("logarithmic" === axisOptions.type && axisOptions.logarithmBase <= 0 || axisOptions.logarithmBase && !typeUtils.isNumeric(axisOptions.logarithmBase)) {
                    axisOptions.logarithmBase = void 0;
                    axisOptions.logarithmBaseError = true
                }
                if (axisOptions.label) {
                    if (axisOptions.label.alignment) {
                        axisOptions.label.userAlignment = true
                    }
                }
                return axisOptions
            };
            var applyParticularAxisOptions = function(name, userOptions, rotated) {
                var theme = this._theme;
                var position = !(rotated ^ "valueAxis" === name) ? "horizontalAxis" : "verticalAxis";
                var processedUserOptions = processAxisOptions(userOptions, name);
                var commonAxisSettings = processAxisOptions(this._userOptions.commonAxisSettings, name);
                var mergeOptions = extend(true, {}, theme.commonAxisSettings, theme[position], theme[name], commonAxisSettings, processedUserOptions);
                mergeOptions.workWeek = processedUserOptions.workWeek || theme[name].workWeek;
                mergeOptions.forceUserTickInterval |= _isDefined(processedUserOptions.tickInterval) && !_isDefined(processedUserOptions.axisDivisionFactor);
                return mergeOptions
            };
            var mergeOptions = function(name, userOptions) {
                userOptions = userOptions || this._userOptions[name];
                var theme = this._theme[name];
                var result = this._mergedSettings[name];
                if (result) {
                    return result
                }
                if (typeUtils.isPlainObject(theme) && typeUtils.isPlainObject(userOptions)) {
                    result = extend(true, {}, theme, userOptions)
                } else {
                    result = _isDefined(userOptions) ? userOptions : theme
                }
                this._mergedSettings[name] = result;
                return result
            };
            var applyParticularTheme = {
                base: mergeOptions,
                argumentAxis: applyParticularAxisOptions,
                valueAxisRangeSelector: function() {
                    return mergeOptions.call(this, "valueAxis")
                },
                valueAxis: applyParticularAxisOptions,
                series: function(name, userOptions, seriesCount) {
                    var that = this;
                    var theme = that._theme;
                    var userCommonSettings = that._userOptions.commonSeriesSettings || {};
                    var themeCommonSettings = theme.commonSeriesSettings;
                    var widgetType = that._themeSection.split(".").slice(-1)[0];
                    var type = _normalizeEnum(userOptions.type || userCommonSettings.type || themeCommonSettings.type || "pie" === widgetType && theme.type);
                    var palette = that.palette;
                    var isBar = ~type.indexOf("bar");
                    var isLine = ~type.indexOf("line");
                    var isArea = ~type.indexOf("area");
                    var isBubble = "bubble" === type;
                    var mainSeriesColor;
                    var resolveLabelsOverlapping = that.getOptions("resolveLabelsOverlapping");
                    var containerBackgroundColor = that.getOptions("containerBackgroundColor");
                    var seriesTemplate = applyParticularTheme.seriesTemplate.call(this);
                    var seriesVisibility;
                    if (isBar || isBubble) {
                        userOptions = extend(true, {}, userCommonSettings, userCommonSettings[type], userOptions);
                        seriesVisibility = userOptions.visible;
                        userCommonSettings = {
                            type: {}
                        };
                        extend(true, userOptions, userOptions.point);
                        userOptions.visible = seriesVisibility
                    }
                    var settings = extend(true, {
                        aggregation: {}
                    }, themeCommonSettings, themeCommonSettings[type], userCommonSettings, userCommonSettings[type], userOptions);
                    settings.aggregation.enabled = "chart" === widgetType && normalizeAggregationEnabled(settings.aggregation, that.getOptions("useAggregation"));
                    settings.type = type;
                    settings.widgetType = widgetType;
                    settings.containerBackgroundColor = containerBackgroundColor;
                    if ("pie" !== widgetType) {
                        mainSeriesColor = settings.color || palette.getNextColor(seriesCount)
                    } else {
                        mainSeriesColor = function(argument, index, count) {
                            var cat = "".concat(argument, "-").concat(index);
                            if (!that._multiPieColors[cat]) {
                                that._multiPieColors[cat] = palette.getNextColor(count)
                            }
                            return that._multiPieColors[cat]
                        }
                    }
                    settings.mainSeriesColor = mainSeriesColor;
                    settings.resolveLabelsOverlapping = resolveLabelsOverlapping;
                    if (settings.label && (isLine || isArea && "rangearea" !== type || "scatter" === type)) {
                        settings.label.position = "outside"
                    }
                    if (seriesTemplate) {
                        settings.nameField = seriesTemplate.nameField
                    }
                    return settings
                },
                animation: function(name) {
                    var userOptions = this._userOptions[name];
                    userOptions = typeUtils.isPlainObject(userOptions) ? userOptions : _isDefined(userOptions) ? {
                        enabled: !!userOptions
                    } : {};
                    return mergeOptions.call(this, name, userOptions)
                },
                seriesTemplate: function() {
                    var value = mergeOptions.call(this, "seriesTemplate");
                    if (value) {
                        value.nameField = value.nameField || "series"
                    }
                    return value
                },
                zoomAndPan: function() {
                    function parseOption(option) {
                        option = _normalizeEnum(option);
                        var pan = "pan" === option || "both" === option;
                        var zoom = "zoom" === option || "both" === option;
                        return {
                            pan: pan,
                            zoom: zoom,
                            none: !pan && !zoom
                        }
                    }
                    var userOptions = this._userOptions.zoomAndPan;
                    if (!_isDefined(userOptions)) {
                        var zoomingMode = _normalizeEnum(this.getOptions("zoomingMode"));
                        var scrollingMode = _normalizeEnum(this.getOptions("scrollingMode"));
                        var allowZoom = ["all", "mouse", "touch"].indexOf(zoomingMode) !== -1;
                        var allowScroll = ["all", "mouse", "touch"].indexOf(scrollingMode) !== -1;
                        userOptions = {
                            argumentAxis: allowZoom && allowScroll ? "both" : allowZoom ? "zoom" : allowScroll ? "pan" : "none",
                            allowMouseWheel: "all" === zoomingMode || "mouse" === zoomingMode,
                            allowTouchGestures: "all" === zoomingMode || "touch" === zoomingMode || "all" === scrollingMode || "touch" === scrollingMode
                        }
                    }
                    var options = mergeOptions.call(this, "zoomAndPan", userOptions);
                    return {
                        valueAxis: parseOption(options.valueAxis),
                        argumentAxis: parseOption(options.argumentAxis),
                        dragToZoom: !!options.dragToZoom,
                        dragBoxStyle: {
                            "class": "dxc-shutter",
                            fill: options.dragBoxStyle.color,
                            opacity: options.dragBoxStyle.opacity
                        },
                        panKey: options.panKey,
                        allowMouseWheel: !!options.allowMouseWheel,
                        allowTouchGestures: !!options.allowTouchGestures
                    }
                }
            };

            function normalizeAggregationEnabled(aggregation, useAggregation) {
                return !!(!_isDefined(aggregation.enabled) ? useAggregation : aggregation.enabled)
            }
            return {
                _themeSection: "chart",
                ctor: ctor,
                dispose: dispose,
                resetPalette: resetPalette,
                getOptions: function(name) {
                    return (applyParticularTheme[name] || applyParticularTheme.base).apply(this, arguments)
                },
                refresh: function() {
                    this._mergedSettings = {};
                    return this.callBase.apply(this, arguments)
                },
                _initializeTheme: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that.updatePalette()
                },
                resetOptions: function(name) {
                    this._mergedSettings[name] = null
                },
                update: function(options) {
                    this._userOptions = options
                },
                updatePalette: function() {
                    var that = this;
                    that.palette = that.createPalette(that.getOptions("palette"), {
                        useHighlight: true,
                        extensionMode: that.getOptions("paletteExtensionMode")
                    })
                }
            }
        }());
        exports.ThemeManager = ThemeManager
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/layout_manager.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _layout_element = __webpack_require__( /*! ../core/layout_element */ 258);
        var _layout_element2 = _interopRequireDefault(_layout_element);
        var _consts = __webpack_require__( /*! ../components/consts */ 125);
        var _consts2 = _interopRequireDefault(_consts);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var floor = Math.floor,
            sqrt = Math.sqrt;
        var _min = Math.min;
        var _max = Math.max;
        var RADIAL_LABEL_INDENT = _consts2.default.radialLabelIndent;

        function getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {
            var nearestCoord;
            if (pointCenterCoord < firstCoord) {
                nearestCoord = firstCoord
            } else {
                if (secondCoord < pointCenterCoord) {
                    nearestCoord = secondCoord
                } else {
                    nearestCoord = pointCenterCoord
                }
            }
            return nearestCoord
        }

        function getLabelLayout(point) {
            if (point._label.isVisible() && "inside" !== point._label.getLayoutOptions().position) {
                return point._label.getBoundingRect()
            }
        }

        function getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR) {
            series.some(function(singleSeries) {
                return singleSeries.getVisiblePoints().reduce(function(radiusIsFound, point) {
                    var labelBBox = getLabelLayout(point);
                    if (labelBBox) {
                        var xCoords = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX);
                        var yCoords = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY);
                        accessibleRadius = _min(_max(getLengthFromCenter(xCoords, yCoords, paneCenterX, paneCenterY) - RADIAL_LABEL_INDENT, minR), accessibleRadius);
                        radiusIsFound = true
                    }
                    return radiusIsFound
                }, false)
            });
            return accessibleRadius
        }

        function getSizeLabels(series) {
            return series.reduce(function(res, singleSeries) {
                var maxWidth = singleSeries.getVisiblePoints().reduce(function(width, point) {
                    var labelBBox = getLabelLayout(point);
                    if (labelBBox && labelBBox.width > width) {
                        width = labelBBox.width
                    }
                    return width
                }, 0);
                var rWidth = maxWidth;
                if (maxWidth) {
                    res.outerLabelsCount++;
                    if (res.outerLabelsCount > 1) {
                        maxWidth += _consts2.default.pieLabelSpacing
                    }
                    rWidth += _consts2.default.pieLabelSpacing
                }
                res.sizes.push(maxWidth);
                res.rSizes.push(rWidth);
                res.common += maxWidth;
                return res
            }, {
                sizes: [],
                rSizes: [],
                common: 0,
                outerLabelsCount: 0
            })
        }

        function correctLabelRadius(labelSizes, radius, series, canvas, averageWidthLabels, centerX) {
            var curRadius;
            var i;
            var runningWidth = 0;
            var sizes = labelSizes.sizes;
            var rSizes = labelSizes.rSizes;
            for (i = 0; i < series.length; i++) {
                if (0 === sizes[i]) {
                    curRadius && (curRadius += rSizes[i - 1]);
                    continue
                }
                curRadius = floor(curRadius ? curRadius + rSizes[i - 1] : radius);
                series[i].correctLabelRadius(curRadius);
                runningWidth += averageWidthLabels || sizes[i];
                rSizes[i] = averageWidthLabels || rSizes[i];
                series[i].setVisibleArea({
                    left: floor(centerX - radius - runningWidth),
                    right: floor(canvas.width - (centerX + radius + runningWidth)),
                    top: canvas.top,
                    bottom: canvas.bottom,
                    width: canvas.width,
                    height: canvas.height
                })
            }
        }

        function getLengthFromCenter(x, y, paneCenterX, paneCenterY) {
            return sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY))
        }

        function getInnerRadius(series) {
            var innerRadius;
            if ("pie" === series.type) {
                innerRadius = 0
            } else {
                innerRadius = (0, _type.isNumeric)(series.innerRadius) ? Number(series.innerRadius) : .5;
                innerRadius = innerRadius < .2 ? .2 : innerRadius;
                innerRadius = innerRadius > .8 ? .8 : innerRadius
            }
            return innerRadius
        }
        var inverseAlign = {
            left: "right",
            right: "left",
            top: "bottom",
            bottom: "top",
            center: "center"
        };

        function downSize(canvas, layoutOptions) {
            canvas[layoutOptions.cutLayoutSide] += "horizontal" === layoutOptions.cutSide ? layoutOptions.width : layoutOptions.height
        }

        function getOffset(layoutOptions, offsets) {
            var side = layoutOptions.cutLayoutSide;
            var offset = {
                horizontal: 0,
                vertical: 0
            };
            switch (side) {
                case "top":
                case "left":
                    offset[layoutOptions.cutSide] = -offsets[side];
                    break;
                case "bottom":
                case "right":
                    offset[layoutOptions.cutSide] = offsets[side]
            }
            return offset
        }

        function LayoutManager() {}

        function toLayoutElementCoords(canvas) {
            return new _layout_element2.default.WrapperLayoutElement(null, {
                x: canvas.left,
                y: canvas.top,
                width: canvas.width - canvas.left - canvas.right,
                height: canvas.height - canvas.top - canvas.bottom
            })
        }

        function getAverageLabelWidth(centerX, radius, canvas, sizeLabels) {
            return (centerX - radius - RADIAL_LABEL_INDENT - canvas.left) / sizeLabels.outerLabelsCount
        }

        function getFullRadiusWithLabels(centerX, canvas, sizeLabels) {
            return centerX - canvas.left - (sizeLabels.outerLabelsCount > 0 ? sizeLabels.common + RADIAL_LABEL_INDENT : 0)
        }

        function correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY) {
            var sizeLabels = getSizeLabels(series);
            var averageWidthLabels;
            var fullRadiusWithLabels = getFullRadiusWithLabels(paneCenterX, canvas, sizeLabels);
            if (fullRadiusWithLabels < minR) {
                availableRadius = minR;
                averageWidthLabels = getAverageLabelWidth(paneCenterX, availableRadius, canvas, sizeLabels)
            } else {
                availableRadius = _min(getPieRadius(series, paneCenterX, paneCenterY, availableRadius, minR), fullRadiusWithLabels)
            }
            correctLabelRadius(sizeLabels, availableRadius + RADIAL_LABEL_INDENT, series, canvas, averageWidthLabels, paneCenterX);
            return availableRadius
        }
        LayoutManager.prototype = {
            constructor: LayoutManager,
            setOptions: function(options) {
                this._options = options
            },
            applyPieChartSeriesLayout: function(canvas, series, hideLayoutLabels) {
                var paneSpaceHeight = canvas.height - canvas.top - canvas.bottom;
                var paneSpaceWidth = canvas.width - canvas.left - canvas.right;
                var paneCenterX = paneSpaceWidth / 2 + canvas.left;
                var paneCenterY = paneSpaceHeight / 2 + canvas.top;
                var piePercentage = this._options.piePercentage;
                var availableRadius;
                var minR;
                if ((0, _type.isNumeric)(piePercentage)) {
                    availableRadius = minR = piePercentage * _min(canvas.height, canvas.width) / 2
                } else {
                    availableRadius = _min(paneSpaceWidth, paneSpaceHeight) / 2;
                    minR = this._options.minPiePercentage * availableRadius
                }
                if (!hideLayoutLabels) {
                    availableRadius = correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY)
                }
                return {
                    centerX: floor(paneCenterX),
                    centerY: floor(paneCenterY),
                    radiusInner: floor(availableRadius * getInnerRadius(series[0])),
                    radiusOuter: floor(availableRadius)
                }
            },
            applyEqualPieChartLayout: function(series, layout) {
                var radius = layout.radius;
                return {
                    centerX: floor(layout.x),
                    centerY: floor(layout.y),
                    radiusInner: floor(radius * getInnerRadius(series[0])),
                    radiusOuter: floor(radius)
                }
            },
            correctPieLabelRadius: function(series, layout, canvas) {
                var sizeLabels = getSizeLabels(series);
                var averageWidthLabels;
                var radius = layout.radiusOuter + RADIAL_LABEL_INDENT;
                var availableLabelWidth = layout.centerX - canvas.left - radius;
                if (sizeLabels.common + RADIAL_LABEL_INDENT > availableLabelWidth) {
                    averageWidthLabels = getAverageLabelWidth(layout.centerX, layout.radiusOuter, canvas, sizeLabels)
                }
                correctLabelRadius(sizeLabels, radius, series, canvas, averageWidthLabels, layout.centerX)
            },
            needMoreSpaceForPanesCanvas: function(panes, rotated, fixedSizeCallback) {
                var options = this._options;
                var width = options.width;
                var height = options.height;
                var piePercentage = options.piePercentage;
                var percentageIsValid = (0, _type.isNumeric)(piePercentage);
                var needHorizontalSpace = 0;
                var needVerticalSpace = 0;
                panes.forEach(function(pane) {
                    var paneCanvas = pane.canvas;
                    var minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : void 0;
                    var paneSized = fixedSizeCallback ? fixedSizeCallback(pane) : {
                        width: false,
                        height: false
                    };
                    var needPaneHorizontalSpace = !paneSized.width ? (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right) : 0;
                    var needPaneVerticalSpace = !paneSized.height ? (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom) : 0;
                    if (rotated) {
                        needHorizontalSpace += needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0;
                        needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace)
                    } else {
                        needHorizontalSpace = _max(needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0, needHorizontalSpace);
                        needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0
                    }
                });
                return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
                    width: needHorizontalSpace,
                    height: needVerticalSpace
                } : false
            },
            layoutElements: function(elements, canvas, funcAxisDrawer, panes, rotated) {
                this._elements = elements;
                this._probeDrawing(canvas);
                this._drawElements(canvas);
                funcAxisDrawer();
                this._processAdaptiveLayout(panes, rotated, canvas, funcAxisDrawer);
                this._positionElements(canvas)
            },
            _processAdaptiveLayout: function(panes, rotated, canvas, funcAxisDrawer) {
                var that = this;
                var size = that.needMoreSpaceForPanesCanvas(panes, rotated);
                var items = this._elements;
                if (!size) {
                    return
                }

                function processCanvases(item, layoutOptions, side) {
                    if (!item.getLayoutOptions()[side]) {
                        canvas[layoutOptions.cutLayoutSide] -= layoutOptions[side];
                        size[side] = size[side] - layoutOptions[side]
                    }
                }
                items.slice().reverse().forEach(function(item) {
                    var layoutOptions = item.getLayoutOptions();
                    var needRedraw = false;
                    if (!layoutOptions) {
                        return
                    }
                    var sizeObject = (0, _extend.extend)({}, layoutOptions);
                    needRedraw = "vertical" === layoutOptions.cutSide && size.width < 0 || "horizontal" === layoutOptions.cutSide && size.height < 0 || "vertical" === layoutOptions.cutSide && size.height > 0 || "horizontal" === layoutOptions.cutSide && size.width > 0;
                    var cutSide = "horizontal" === layoutOptions.cutSide ? "width" : "height";
                    if (needRedraw) {
                        var width = sizeObject.width - size.width;
                        var height = sizeObject.height - size.height;
                        if ("height" === cutSide && size.width < 0) {
                            width = canvas.width - canvas.left - canvas.right
                        }
                        if ("width" === cutSide && size.height < 0) {
                            height = canvas.height - canvas.top - canvas.bottom
                        }
                        item.draw(width, height)
                    }
                    processCanvases(item, layoutOptions, cutSide)
                });
                funcAxisDrawer(size)
            },
            _probeDrawing: function(canvas) {
                var that = this;
                this._elements.forEach(function(item) {
                    var layoutOptions = item.getLayoutOptions();
                    if (!layoutOptions) {
                        return
                    }
                    var sizeObject = {
                        width: canvas.width - canvas.left - canvas.right,
                        height: canvas.height - canvas.top - canvas.bottom
                    };
                    if ("vertical" === layoutOptions.cutSide) {
                        sizeObject.height -= that._options.height
                    } else {
                        sizeObject.width -= that._options.width
                    }
                    item.probeDraw(sizeObject.width, sizeObject.height);
                    downSize(canvas, item.getLayoutOptions())
                })
            },
            _drawElements: function(canvas) {
                this._elements.slice().reverse().forEach(function(item) {
                    var layoutOptions = item.getLayoutOptions();
                    if (!layoutOptions) {
                        return
                    }
                    var sizeObject = {
                        width: canvas.width - canvas.left - canvas.right,
                        height: canvas.height - canvas.top - canvas.bottom
                    };
                    var cutSide = layoutOptions.cutSide;
                    var length = "horizontal" === cutSide ? "width" : "height";
                    sizeObject[length] = layoutOptions[length];
                    item.draw(sizeObject.width, sizeObject.height)
                })
            },
            _positionElements: function(canvas) {
                var offsets = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                this._elements.slice().reverse().forEach(function(item) {
                    var layoutOptions = item.getLayoutOptions();
                    if (!layoutOptions) {
                        return
                    }
                    var position = layoutOptions.position;
                    var cutSide = layoutOptions.cutSide;
                    var my = {
                        horizontal: position.horizontal,
                        vertical: position.vertical
                    };
                    my[cutSide] = inverseAlign[my[cutSide]];
                    item.position({
                        of: toLayoutElementCoords(canvas),
                        my: my,
                        at: position,
                        offset: getOffset(layoutOptions, offsets)
                    });
                    offsets[layoutOptions.cutLayoutSide] += layoutOptions["horizontal" === layoutOptions.cutSide ? "width" : "height"]
                })
            }
        };
        exports.LayoutManager = LayoutManager
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/viz/core/plaque.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Plaque = void 0;
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var math = Math;
        var round = math.round;
        var max = math.max;
        var min = math.min;
        var sin = math.sin;
        var cos = math.cos;
        var asin = math.asin;
        var PI = math.PI;
        var buildPath = function() {
            for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
                points[_key] = arguments[_key]
            }
            return points.join("")
        };

        function getArc(cornerRadius, xDirection, yDirection) {
            return "a ".concat(cornerRadius, " ").concat(cornerRadius, " 0 0 1 ").concat(xDirection * cornerRadius, " ").concat(yDirection * cornerRadius)
        }

        function getAbsoluteArc(cornerRadius, x, y) {
            return "A ".concat(cornerRadius, " ").concat(cornerRadius, " 0 0 1 ").concat(x, " ").concat(y)
        }

        function rotateX(x, y, angle, x0, y0) {
            return (x - x0) * round(cos(angle)) + (y - y0) * round(sin(angle)) + x0
        }

        function rotateY(x, y, angle, x0, y0) {
            return -(x - x0) * round(sin(angle)) + (y - y0) * round(cos(angle)) + y0
        }

        function rotateSize(options, angle) {
            if (angle % 90 === 0 && angle % 180 !== 0) {
                return {
                    width: options.height,
                    height: options.width
                }
            }
            return options
        }

        function getCloudAngle(_ref, x, y, anchorX, anchorY) {
            var width = _ref.width,
                height = _ref.height;
            var halfWidth = width / 2;
            var halfHeight = height / 2;
            var xr = Math.ceil(x + halfWidth);
            var xl = Math.floor(x - halfWidth);
            var yt = Math.floor(y - halfHeight);
            var yb = Math.ceil(y + halfHeight);
            if (anchorX < xl && anchorY < yt || anchorX >= xl && anchorX <= xr && anchorY < yt) {
                return 270
            }
            if (anchorX > xr && anchorY > yb || anchorX >= xl && anchorX <= xr && anchorY > yb) {
                return 90
            } else {
                if (anchorX < xl && anchorY > yb || anchorX < xl && anchorY >= yt && anchorY <= yb) {
                    return 180
                }
            }
            return 0
        }

        function getCloudPoints(_ref2, x, y, anchorX, anchorY, _ref3, bounded) {
            var width = _ref2.width,
                height = _ref2.height;
            var arrowWidth = _ref3.arrowWidth,
                _ref3$cornerRadius = _ref3.cornerRadius,
                cornerRadius = void 0 === _ref3$cornerRadius ? 0 : _ref3$cornerRadius;
            var halfArrowWidth = arrowWidth / 2;
            var halfWidth = width / 2;
            var halfHeight = height / 2;
            var xr = Math.ceil(x + halfWidth);
            var xl = Math.floor(x - halfWidth);
            var yt = Math.floor(y - halfHeight);
            var yb = Math.ceil(y + halfHeight);
            var leftTopCorner = [xl, yt];
            var rightTopCorner = [xr, yt];
            var rightBottomCorner = [xr, yb];
            var leftBottomCorner = [xl, yb];
            var arrowX = anchorX <= xl ? xl : xr <= anchorX ? xr : anchorX;
            var arrowY = anchorY <= yt ? yt : yb <= anchorY ? yb : anchorY;
            var arrowBaseBottom = min(arrowY + halfArrowWidth, yb);
            var arrowBaseTop = max(arrowY - halfArrowWidth, yt);
            var arrowBaseLeft = max(arrowX - halfArrowWidth, xl);
            cornerRadius = Math.min(width / 2, height / 2, cornerRadius);
            var points;
            leftTopCorner[1] += cornerRadius;
            rightTopCorner[0] -= cornerRadius;
            rightBottomCorner[1] -= cornerRadius;
            leftBottomCorner[0] += cornerRadius;
            if (!bounded || xl <= anchorX && anchorX <= xr && yt <= anchorY && anchorY <= yb) {
                points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), "L", rightTopCorner, getArc(cornerRadius, 1, 1), "L", rightBottomCorner, getArc(cornerRadius, -1, 1), "L", leftBottomCorner, getArc(cornerRadius, -1, -1))
            } else {
                if (anchorX > xr && anchorY < yt) {
                    var arrowAngle = arrowWidth / cornerRadius || 0;
                    var angle = PI / 4 + arrowAngle / 2;
                    var endAngle = PI / 4 - arrowAngle / 2;
                    var arrowEndPointX = rightTopCorner[0] + cos(endAngle) * cornerRadius;
                    var arrowEndPointY = rightTopCorner[1] + (1 - sin(endAngle)) * cornerRadius;
                    var arrowArc = buildPath("L", rightTopCorner, getArc(cornerRadius, cos(angle), 1 - sin(angle)), "L", [anchorX, anchorY, arrowEndPointX, arrowEndPointY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius));
                    if (Math.abs(angle) > PI / 2) {
                        arrowArc = buildPath("L", [arrowBaseLeft, yt, anchorX, anchorY, xr, arrowBaseBottom])
                    }
                    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), arrowArc, "L", rightBottomCorner, getArc(cornerRadius, -1, 1), "L", leftBottomCorner, getArc(cornerRadius, -1, -1))
                } else {
                    if (anchorX > xr && anchorY >= yt && anchorY <= yb) {
                        var _arrowArc;
                        if (arrowBaseTop >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {
                            _arrowArc = buildPath(getArc(cornerRadius, 1, 1), "L", [xr, arrowBaseTop, anchorX, anchorY, xr, arrowBaseBottom], "L", rightBottomCorner, getArc(cornerRadius, -1, 1))
                        } else {
                            if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {
                                var arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;
                                var _angle = arrowWidthRest / cornerRadius;
                                var arrowBaseTopX = rightTopCorner[0] + cos(_angle) * cornerRadius;
                                var arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle)) * cornerRadius;
                                _arrowArc = buildPath(getArc(cornerRadius, cos(_angle), 1 - sin(_angle)), "L", [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, xr, arrowBaseBottom], "L", rightBottomCorner, getArc(cornerRadius, -1, 1))
                            } else {
                                if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom < rightTopCorner[1] + cornerRadius) {
                                    var _arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;
                                    var _arrowAngle = _arrowWidthRest / cornerRadius;
                                    var _angle2 = _arrowAngle;
                                    var _arrowBaseTopX = rightTopCorner[0] + cos(_angle2) * cornerRadius;
                                    var _arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle2)) * cornerRadius;
                                    var bottomAngle = Math.sin((rightTopCorner[1] + cornerRadius - arrowBaseBottom) / cornerRadius);
                                    var arrowBaseBottomX = rightTopCorner[0] + cornerRadius * cos(bottomAngle);
                                    var arrowBaseBottomY = rightTopCorner[1] + cornerRadius * (1 - sin(bottomAngle));
                                    _arrowArc = buildPath(getArc(cornerRadius, cos(_angle2), 1 - sin(_angle2)), "L", [_arrowBaseTopX, _arrowBaseTopY, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius), "L", rightBottomCorner, getArc(cornerRadius, -1, 1))
                                } else {
                                    if (arrowBaseTop <= rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightBottomCorner[1]) {
                                        var topAngle = asin((rightTopCorner[1] + cornerRadius - arrowBaseTop) / cornerRadius);
                                        var _arrowBaseTopX2 = rightTopCorner[0] + cornerRadius * cos(topAngle);
                                        var _arrowBaseTopY2 = rightTopCorner[1] + cornerRadius * (1 - sin(topAngle));
                                        var _bottomAngle = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
                                        var _arrowBaseBottomX = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle) - 1);
                                        var _arrowBaseBottomY = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle);
                                        _arrowArc = buildPath(getArc(cornerRadius, cos(topAngle), 1 - sin(topAngle)), "L", [_arrowBaseTopX2, _arrowBaseTopY2, anchorX, anchorY, _arrowBaseBottomX, _arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius))
                                    } else {
                                        if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseTop <= rightBottomCorner[1] && arrowBaseBottom > rightBottomCorner[1]) {
                                            var _bottomAngle2 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
                                            var _arrowBaseBottomX2 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle2) - 1);
                                            var _arrowBaseBottomY2 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle2);
                                            _arrowArc = buildPath(getArc(cornerRadius, 1, 1), "L", [xr, arrowBaseTop, anchorX, anchorY, _arrowBaseBottomX2, _arrowBaseBottomY2], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius))
                                        } else {
                                            if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseBottom > rightBottomCorner[1]) {
                                                var _bottomAngle3 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
                                                var _arrowBaseBottomX3 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle3) - 1);
                                                var _arrowBaseBottomY3 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle3);
                                                var _topAngle = asin((arrowBaseTop - rightBottomCorner[1]) / cornerRadius);
                                                var _arrowBaseTopX3 = rightBottomCorner[0] + cornerRadius * (cos(_topAngle) - 1);
                                                var _arrowBaseTopY3 = rightBottomCorner[1] + cornerRadius * sin(_topAngle);
                                                _arrowArc = buildPath(getArc(cornerRadius, 1, 1), "L", rightBottomCorner, getArc(cornerRadius, cos(_topAngle) - 1, sin(_topAngle)), "L", [_arrowBaseTopX3, _arrowBaseTopY3, anchorX, anchorY, _arrowBaseBottomX3, _arrowBaseBottomY3], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), "L", rightTopCorner, _arrowArc, "L", leftBottomCorner, getArc(cornerRadius, -1, -1))
                    }
                }
            }
            return buildPath("M", points, "Z")
        }
        exports.Plaque = function() {
            function Plaque(options, widget, root, contentTemplate) {
                var bounded = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : true;
                var measureContent = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : function(_, g) {
                    return g.getBBox()
                };
                var moveContentGroup = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : function(_, g, x, y) {
                    return g.move(x, y)
                };
                _classCallCheck(this, Plaque);
                this.widget = widget;
                this.options = options;
                this.root = root;
                this.contentTemplate = contentTemplate;
                this.bonded = bounded;
                this.measureContent = measureContent;
                this.moveContentGroup = moveContentGroup
            }
            _createClass(Plaque, [{
                key: "draw",
                value: function(_ref4) {
                    var _this = this;
                    var anchorX = _ref4.x,
                        anchorY = _ref4.y,
                        _ref4$canvas = _ref4.canvas,
                        canvas = void 0 === _ref4$canvas ? {} : _ref4$canvas,
                        offsetX = _ref4.offsetX,
                        offsetY = _ref4.offsetY,
                        _ref4$offset = _ref4.offset,
                        offset = void 0 === _ref4$offset ? 0 : _ref4$offset;
                    var options = this.options;
                    var x = options.x,
                        y = options.y;
                    var bounds = {
                        xl: canvas.left,
                        xr: canvas.width - canvas.right,
                        width: canvas.width - canvas.right - canvas.left,
                        yt: canvas.top,
                        yb: canvas.height - canvas.bottom,
                        height: canvas.height - canvas.bottom - canvas.top
                    };
                    if (!((0, _type.isDefined)(anchorX) && (0, _type.isDefined)(anchorY)) && !((0, _type.isDefined)(x) && (0, _type.isDefined)(y))) {
                        return
                    }
                    if ((0, _type.isDefined)(anchorX) && (anchorX < bounds.xl || bounds.xr < anchorX || anchorY < bounds.yt || bounds.yb < anchorY)) {
                        return
                    }
                    if (!this._root) {
                        this._draw()
                    }
                    var shadowSettings = (0, _extend.extend)({
                        x: "-50%",
                        y: "-50%",
                        width: "200%",
                        height: "200%"
                    }, options.shadow);
                    var contentWidth = options.width > 0 ? options.width : null;
                    var contentHeight = options.height > 0 ? options.height : null;
                    var onRender = function() {
                        var _this$_root;
                        var bBox = _this._contentBBox = _this.measureContent(_this.widget, _this._contentGroup);
                        var size = _this._size = {
                            width: max(contentWidth, bBox.width) + 2 * options.paddingLeftRight,
                            height: max(contentHeight, bBox.height) + 2 * options.paddingTopBottom,
                            offset: offset
                        };
                        var xOff = shadowSettings.offsetX;
                        var yOff = shadowSettings.offsetY;
                        var blur = 2 * shadowSettings.blur + 1;
                        var lm = max(blur - xOff, 0);
                        var rm = max(blur + xOff, 0);
                        var tm = max(blur - yOff, 0);
                        var bm = max(blur + yOff, 0);
                        _this.margins = {
                            lm: lm,
                            rm: rm,
                            tm: tm,
                            bm: bm
                        };
                        if (!(0, _type.isDefined)(x)) {
                            if ((0, _type.isDefined)(offsetX)) {
                                x = anchorX + offsetX
                            } else {
                                if (bounds.width < size.width) {
                                    x = round(bounds.xl + bounds.width / 2)
                                } else {
                                    x = min(max(anchorX, Math.ceil(bounds.xl + size.width / 2 + lm)), Math.floor(bounds.xr - size.width / 2 - rm))
                                }
                            }
                        } else {
                            x += offsetX || 0;
                            if (!(0, _type.isDefined)(anchorX)) {
                                anchorX = x
                            }
                        }
                        if (!(0, _type.isDefined)(y)) {
                            if ((0, _type.isDefined)(offsetY)) {
                                y = anchorY + offsetY
                            } else {
                                var y_top = anchorY - options.arrowLength - size.height / 2 - offset;
                                var y_bottom = anchorY + options.arrowLength + size.height / 2 + offset;
                                if (bounds.height < size.height + options.arrowLength) {
                                    y = round(bounds.yt + size.height / 2)
                                } else {
                                    if (y_top - size.height / 2 - tm < bounds.yt) {
                                        if (y_bottom + size.height / 2 + bm < bounds.yb) {
                                            y = y_bottom;
                                            anchorY += offset
                                        } else {
                                            y = round(bounds.yt + size.height / 2)
                                        }
                                    } else {
                                        y = y_top;
                                        anchorY -= offset
                                    }
                                }
                            }
                        } else {
                            y += offsetY || 0;
                            if (!(0, _type.isDefined)(anchorY)) {
                                anchorY = y + size.height / 2
                            }
                        }
                        _this.anchorX = anchorX;
                        _this.anchorY = anchorY;
                        _this.move(x, y);
                        null === (_this$_root = _this._root) || void 0 === _this$_root ? void 0 : _this$_root.append(_this.root)
                    };
                    if (this.contentTemplate.render) {
                        this.contentTemplate.render({
                            model: options,
                            container: this._contentGroup.element,
                            onRendered: onRender
                        })
                    } else {
                        this.contentTemplate(this.widget, this._contentGroup);
                        onRender()
                    }
                }
            }, {
                key: "_draw",
                value: function() {
                    var renderer = this.widget._renderer;
                    var options = this.options;
                    var shadowSettings = (0, _extend.extend)({
                        x: "-50%",
                        y: "-50%",
                        width: "200%",
                        height: "200%"
                    }, options.shadow);
                    var shadow = this._shadow = renderer.shadowFilter().attr(shadowSettings);
                    var cloudSettings = {
                        opacity: options.opacity,
                        "stroke-width": 0,
                        fill: options.color
                    };
                    var borderOptions = options.border || {};
                    if (borderOptions.visible) {
                        (0, _extend.extend)(cloudSettings, {
                            "stroke-width": borderOptions.width,
                            stroke: borderOptions.color,
                            "stroke-opacity": borderOptions.opacity,
                            dashStyle: borderOptions.dashStyle
                        })
                    }
                    var group = this._root = renderer.g().append(this.root);
                    if (options.type) {
                        group.attr({
                            "class": "dxc-".concat(options.type, "-annotation")
                        })
                    }
                    var cloudGroup = renderer.g().attr({
                        filter: shadow.id
                    }).append(group);
                    this._cloud = renderer.path([], "area").attr(cloudSettings).sharp().append(cloudGroup);
                    this._contentGroup = renderer.g().append(group)
                }
            }, {
                key: "getBBox",
                value: function() {
                    var size = this._size || {};
                    var margins = this.margins || {};
                    var rotationAngle = getCloudAngle(size, this.x, this.y, this.anchorX, this.anchorY);
                    return {
                        x: Math.floor(this.x - size.width / 2 - margins.lm),
                        y: Math.floor(this.y - size.height / 2 - margins.tm - (270 === rotationAngle ? this.options.arrowLength : 0)),
                        width: size.width + margins.lm + margins.rm,
                        height: size.height + margins.tm + margins.bm + (90 === rotationAngle || 270 === rotationAngle ? this.options.arrowLength : 0)
                    }
                }
            }, {
                key: "clear",
                value: function() {
                    if (this._root) {
                        this._root.remove();
                        this._shadow.remove();
                        this._root = null
                    }
                    return this
                }
            }, {
                key: "customizeCloud",
                value: function(attr) {
                    if (this._cloud) {
                        this._cloud.attr(attr)
                    }
                }
            }, {
                key: "moveRoot",
                value: function(x, y) {
                    if (this._root) {
                        this._root.move(x, y)
                    }
                }
            }, {
                key: "move",
                value: function(x, y) {
                    x = round(x);
                    y = round(y);
                    this.x = x;
                    this.y = y;
                    var rotationAngle = getCloudAngle(this._size, x, y, this.anchorX, this.anchorY);
                    var radRotationAngle = rotationAngle * PI / 180;
                    this._cloud.attr({
                        d: getCloudPoints(rotateSize(this._size, rotationAngle), x, y, rotateX(this.anchorX, this.anchorY, radRotationAngle, x, y), rotateY(this.anchorX, this.anchorY, radRotationAngle, x, y), this.options, this.bonded)
                    }).rotate(rotationAngle, x, y);
                    this.moveContentGroup(this.widget, this._contentGroup, x - this._contentBBox.x - this._contentBBox.width / 2, y - this._contentBBox.y - this._contentBBox.height / 2)
                }
            }, {
                key: "hitTest",
                value: function(x, y) {
                    var _ref5 = this._size || {},
                        width = _ref5.width,
                        height = _ref5.height;
                    return Math.abs(x - this.x) <= width / 2 && Math.abs(y - this.y) <= height / 2
                }
            }]);
            return Plaque
        }()
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/advanced_chart.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend2 = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _range = __webpack_require__( /*! ../translators/range */ 112);
        var _range2 = _interopRequireDefault(_range);
        var _base_axis = __webpack_require__( /*! ../axes/base_axis */ 211);
        var _base_axis2 = _interopRequireDefault(_base_axis);
        var _series_family = __webpack_require__( /*! ../core/series_family */ 428);
        var _series_family2 = _interopRequireDefault(_series_family);
        var _base_chart = __webpack_require__( /*! ./base_chart */ 256);
        var _crosshair = __webpack_require__( /*! ./crosshair */ 429);
        var _crosshair2 = _interopRequireDefault(_crosshair);
        var _range_data_calculator = __webpack_require__( /*! ../series/helpers/range_data_calculator */ 209);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var _isArray = Array.isArray;
        var DEFAULT_AXIS_NAME = "defaultAxisName";
        var FONT = "font";
        var COMMON_AXIS_SETTINGS = "commonAxisSettings";
        var DEFAULT_PANE_NAME = "default";
        var VISUAL_RANGE = "VISUAL_RANGE";

        function prepareAxis(axisOptions) {
            return _isArray(axisOptions) ? 0 === axisOptions.length ? [{}] : axisOptions : [axisOptions]
        }

        function processBubbleMargin(opt, bubbleSize) {
            if (opt.processBubbleSize) {
                opt.size = bubbleSize
            }
            return opt
        }

        function estimateBubbleSize(size, panesCount, maxSize, rotated) {
            var width = rotated ? size.width / panesCount : size.width;
            var height = rotated ? size.height : size.height / panesCount;
            return Math.min(width, height) * maxSize
        }

        function setAxisVisualRangeByOption(arg, axis, isDirectOption, index) {
            var options;
            var visualRange;
            if (isDirectOption) {
                visualRange = arg.value;
                options = {
                    skipEventRising: true
                };
                var pathElements = arg.fullName.split(".");
                var destElem = pathElements[pathElements.length - 1];
                if ("endValue" === destElem || "startValue" === destElem) {
                    options = {
                        allowPartialUpdate: true
                    };
                    visualRange = _defineProperty({}, destElem, arg.value)
                }
            } else {
                visualRange = ((0, _type.isDefined)(index) ? arg.value[index] : arg.value).visualRange
            }
            axis.visualRange(visualRange, options)
        }
        var AdvancedChart = _base_chart.BaseChart.inherit({
            _setDeprecatedOptions: function() {
                this.callBase.apply(this, arguments);
                (0, _extend2.extend)(this._deprecatedOptions, {
                    barWidth: {
                        since: "18.1",
                        message: "Use the 'commonSeriesSettings.barPadding' or 'series.barPadding' option instead"
                    },
                    equalBarWidth: {
                        since: "18.1",
                        message: "Use the 'commonSeriesSettings.ignoreEmptyPoints' or 'series.ignoreEmptyPoints' option instead"
                    }
                })
            },
            _fontFields: [COMMON_AXIS_SETTINGS + ".label." + FONT, COMMON_AXIS_SETTINGS + ".title." + FONT],
            _partialOptionChangesMap: {
                visualRange: VISUAL_RANGE,
                _customVisualRange: VISUAL_RANGE,
                strips: "REFRESH_AXES",
                constantLines: "REFRESH_AXES"
            },
            _partialOptionChangesPath: {
                argumentAxis: ["strips", "constantLines", "visualRange", "_customVisualRange"],
                valueAxis: ["strips", "constantLines", "visualRange", "_customVisualRange"]
            },
            _initCore: function() {
                this._panesClipRects = {};
                this.callBase()
            },
            _disposeCore: function() {
                var disposeObjectsInArray = this._disposeObjectsInArray;
                var panesClipRects = this._panesClipRects;
                this.callBase();
                disposeObjectsInArray.call(panesClipRects, "fixed");
                disposeObjectsInArray.call(panesClipRects, "base");
                disposeObjectsInArray.call(panesClipRects, "wide");
                this._panesClipRects = null
            },
            _dispose: function() {
                var that = this;
                var disposeObjectsInArray = this._disposeObjectsInArray;
                that.callBase();
                that.panes = null;
                if (that._legend) {
                    that._legend.dispose();
                    that._legend = null
                }
                disposeObjectsInArray.call(that, "panesBackground");
                disposeObjectsInArray.call(that, "seriesFamilies");
                that._disposeAxes()
            },
            _createPanes: function() {
                this._cleanPanesClipRects("fixed");
                this._cleanPanesClipRects("base");
                this._cleanPanesClipRects("wide")
            },
            _cleanPanesClipRects: function(clipArrayName) {
                var clipArray = this._panesClipRects[clipArrayName];
                (clipArray || []).forEach(function(clipRect) {
                    return clipRect && clipRect.dispose()
                });
                this._panesClipRects[clipArrayName] = []
            },
            _getElementsClipRectID: function(paneName) {
                var clipShape = this._panesClipRects.fixed[this._getPaneIndex(paneName)];
                return clipShape && clipShape.id
            },
            _getPaneIndex: function(paneName) {
                var paneIndex;
                var name = paneName || DEFAULT_PANE_NAME;
                (0, _iterator.each)(this.panes, function(index, pane) {
                    if (pane.name === name) {
                        paneIndex = index;
                        return false
                    }
                });
                return paneIndex
            },
            _updateSize: function() {
                this.callBase();
                (0, _utils.setCanvasValues)(this._canvas)
            },
            _reinitAxes: function() {
                this.panes = this._createPanes();
                this._populateAxes();
                this._axesReinitialized = true
            },
            _getCrosshairMargins: function() {
                var crosshairOptions = this._getCrosshairOptions() || {};
                var crosshairEnabled = crosshairOptions.enabled;
                var margins = _crosshair2.default.getMargins();
                return {
                    x: crosshairEnabled && crosshairOptions.horizontalLine.visible ? margins.x : 0,
                    y: crosshairEnabled && crosshairOptions.verticalLine.visible ? margins.y : 0
                }
            },
            _populateAxes: function() {
                var that = this;
                var panes = that.panes;
                var rotated = that._isRotated();
                var argumentAxesOptions = prepareAxis(that.option("argumentAxis") || {})[0];
                var valueAxisOption = that.option("valueAxis");
                var valueAxesOptions = prepareAxis(valueAxisOption || {});
                var argumentAxesPopulatedOptions = [];
                var valueAxesPopulatedOptions = [];
                var axisNames = [];
                var valueAxesCounter = 0;
                var paneWithNonVirtualAxis;
                var crosshairMargins = that._getCrosshairMargins();

                function getNextAxisName() {
                    return DEFAULT_AXIS_NAME + valueAxesCounter++
                }
                if (rotated) {
                    paneWithNonVirtualAxis = "right" === argumentAxesOptions.position ? panes[panes.length - 1].name : panes[0].name
                } else {
                    paneWithNonVirtualAxis = "top" === argumentAxesOptions.position ? panes[0].name : panes[panes.length - 1].name
                }
                argumentAxesPopulatedOptions = (0, _utils.map)(panes, function(pane) {
                    var virtual = pane.name !== paneWithNonVirtualAxis;
                    return that._populateAxesOptions("argumentAxis", argumentAxesOptions, {
                        pane: pane.name,
                        name: null,
                        optionPath: "argumentAxis",
                        crosshairMargin: rotated ? crosshairMargins.x : crosshairMargins.y
                    }, rotated, virtual)
                });
                (0, _iterator.each)(valueAxesOptions, function(priority, axisOptions) {
                    var _axisOptions$panes;
                    var axisPanes = [];
                    var name = axisOptions.name;
                    if (name && (0, _array.inArray)(name, axisNames) !== -1) {
                        that._incidentOccurred("E2102");
                        return
                    }
                    name && axisNames.push(name);
                    if (axisOptions.pane) {
                        axisPanes.push(axisOptions.pane)
                    }
                    if (null === (_axisOptions$panes = axisOptions.panes) || void 0 === _axisOptions$panes ? void 0 : _axisOptions$panes.length) {
                        axisPanes = axisPanes.concat(axisOptions.panes.slice(0))
                    }
                    axisPanes = (0, _utils.unique)(axisPanes);
                    if (!axisPanes.length) {
                        axisPanes.push(void 0)
                    }(0, _iterator.each)(axisPanes, function(_, pane) {
                        var optionPath = _isArray(valueAxisOption) ? "valueAxis[".concat(priority, "]") : "valueAxis";
                        valueAxesPopulatedOptions.push(that._populateAxesOptions("valueAxis", axisOptions, {
                            name: name || getNextAxisName(),
                            pane: pane,
                            priority: priority,
                            optionPath: optionPath,
                            crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x
                        }, rotated))
                    })
                });
                that._redesignAxes(argumentAxesPopulatedOptions, true, paneWithNonVirtualAxis);
                that._redesignAxes(valueAxesPopulatedOptions, false)
            },
            _redesignAxes: function(options, isArgumentAxes, paneWithNonVirtualAxis) {
                var that = this;
                var axesBasis = [];
                var axes = isArgumentAxes ? that._argumentAxes : that._valueAxes;
                (0, _iterator.each)(options, function(_, opt) {
                    var curAxes = axes && axes.filter(function(a) {
                        return a.name === opt.name && (!(0, _type.isDefined)(opt.pane) && that.panes.some(function(p) {
                            return p.name === a.pane
                        }) || a.pane === opt.pane)
                    });
                    if (curAxes && curAxes.length > 0) {
                        (0, _iterator.each)(curAxes, function(_, axis) {
                            axis.updateOptions(opt);
                            axis.validate();
                            axesBasis.push({
                                axis: axis
                            })
                        })
                    } else {
                        axesBasis.push({
                            options: opt
                        })
                    }
                });
                if (axes) {
                    (0, _iterator.reverseEach)(axes, function(index, axis) {
                        if (!axesBasis.some(function(basis) {
                                return basis.axis && basis.axis === axis
                            })) {
                            that._disposeAxis(index, isArgumentAxes)
                        }
                    })
                } else {
                    if (isArgumentAxes) {
                        axes = that._argumentAxes = []
                    } else {
                        axes = that._valueAxes = []
                    }
                }(0, _iterator.each)(axesBasis, function(_, basis) {
                    var axis = basis.axis;
                    if (basis.axis && isArgumentAxes) {
                        basis.axis.isVirtual = basis.axis.pane !== paneWithNonVirtualAxis
                    } else {
                        if (basis.options) {
                            axis = that._createAxis(isArgumentAxes, basis.options, isArgumentAxes ? basis.options.pane !== paneWithNonVirtualAxis : void 0);
                            axes.push(axis)
                        }
                    }
                    axis.applyVisualRangeSetter(that._getVisualRangeSetter())
                })
            },
            _disposeAxis: function(index, isArgumentAxis) {
                var axes = isArgumentAxis ? this._argumentAxes : this._valueAxes;
                var axis = axes[index];
                if (!axis) {
                    return
                }
                axis.dispose();
                axes.splice(index, 1)
            },
            _disposeAxes: function() {
                var that = this;
                var disposeObjectsInArray = that._disposeObjectsInArray;
                disposeObjectsInArray.call(that, "_argumentAxes");
                disposeObjectsInArray.call(that, "_valueAxes")
            },
            _appendAdditionalSeriesGroups: function() {
                this._crosshairCursorGroup.linkAppend();
                this._scrollBar && this._scrollBarGroup.linkAppend()
            },
            _getLegendTargets: function() {
                var _this = this;
                return (this.series || []).map(function(s) {
                    var item = _this._getLegendOptions(s);
                    item.legendData.series = s;
                    if (!s.getOptions().showInLegend) {
                        item.legendData.visible = false
                    }
                    return item
                })
            },
            _legendItemTextField: "name",
            _seriesPopulatedHandlerCore: function() {
                this._processSeriesFamilies();
                this._processValueAxisFormat()
            },
            _renderTrackers: function() {
                var that = this;
                var i;
                for (i = 0; i < that.series.length; ++i) {
                    that.series[i].drawTrackers()
                }
            },
            _specialProcessSeries: function() {
                this._processSeriesFamilies()
            },
            _processSeriesFamilies: function() {
                var _that$seriesFamilies;
                var that = this;
                var types = [];
                var families = [];
                var paneSeries;
                var themeManager = that._themeManager;
                var negativesAsZeroes = themeManager.getOptions("negativesAsZeroes");
                var negativesAsZeros = themeManager.getOptions("negativesAsZeros");
                var familyOptions = {
                    equalBarWidth: themeManager.getOptions("equalBarWidth"),
                    minBubbleSize: themeManager.getOptions("minBubbleSize"),
                    maxBubbleSize: themeManager.getOptions("maxBubbleSize"),
                    barWidth: themeManager.getOptions("barWidth"),
                    barGroupPadding: themeManager.getOptions("barGroupPadding"),
                    barGroupWidth: themeManager.getOptions("barGroupWidth"),
                    negativesAsZeroes: (0, _type.isDefined)(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros
                };
                if (null === (_that$seriesFamilies = that.seriesFamilies) || void 0 === _that$seriesFamilies ? void 0 : _that$seriesFamilies.length) {
                    (0, _iterator.each)(that.seriesFamilies, function(_, family) {
                        family.updateOptions(familyOptions);
                        family.adjustSeriesValues()
                    });
                    return
                }(0, _iterator.each)(that.series, function(_, item) {
                    if ((0, _array.inArray)(item.type, types) === -1) {
                        types.push(item.type)
                    }
                });
                (0, _iterator.each)(that._getLayoutTargets(), function(_, pane) {
                    paneSeries = that._getSeriesForPane(pane.name);
                    (0, _iterator.each)(types, function(_, type) {
                        var family = new _series_family2.default.SeriesFamily({
                            type: type,
                            pane: pane.name,
                            equalBarWidth: familyOptions.equalBarWidth,
                            minBubbleSize: familyOptions.minBubbleSize,
                            maxBubbleSize: familyOptions.maxBubbleSize,
                            barWidth: familyOptions.barWidth,
                            barGroupPadding: familyOptions.barGroupPadding,
                            barGroupWidth: familyOptions.barGroupWidth,
                            negativesAsZeroes: familyOptions.negativesAsZeroes,
                            rotated: that._isRotated()
                        });
                        family.add(paneSeries);
                        family.adjustSeriesValues();
                        families.push(family)
                    })
                });
                that.seriesFamilies = families
            },
            _updateSeriesDimensions: function() {
                var that = this;
                var i;
                var seriesFamilies = that.seriesFamilies || [];
                for (i = 0; i < seriesFamilies.length; i++) {
                    var family = seriesFamilies[i];
                    family.updateSeriesValues();
                    family.adjustSeriesDimensions()
                }
            },
            _getLegendCallBack: function(series) {
                return this._legend && this._legend.getActionCallback(series)
            },
            _appendAxesGroups: function() {
                var that = this;
                that._stripsGroup.linkAppend();
                that._gridGroup.linkAppend();
                that._axesGroup.linkAppend();
                that._constantLinesGroup.linkAppend();
                that._labelAxesGroup.linkAppend();
                that._scaleBreaksGroup.linkAppend()
            },
            _populateMarginOptions: function() {
                var that = this;
                var bubbleSize = estimateBubbleSize(that.getSize(), that.panes.length, that._themeManager.getOptions("maxBubbleSize"), that._isRotated());
                var argumentMarginOptions = {};
                that._valueAxes.forEach(function(valueAxis) {
                    var groupSeries = that.series.filter(function(series) {
                        return series.getValueAxis() === valueAxis
                    });
                    var marginOptions = {};
                    groupSeries.forEach(function(series) {
                        if (series.isVisible()) {
                            var seriesMarginOptions = processBubbleMargin(series.getMarginOptions(), bubbleSize);
                            marginOptions = (0, _utils.mergeMarginOptions)(marginOptions, seriesMarginOptions);
                            argumentMarginOptions = (0, _utils.mergeMarginOptions)(argumentMarginOptions, seriesMarginOptions)
                        }
                    });
                    valueAxis.setMarginOptions(marginOptions)
                });
                that._argumentAxes.forEach(function(a) {
                    return a.setMarginOptions(argumentMarginOptions)
                })
            },
            _populateBusinessRange: function(updatedAxis, keepRange) {
                var that = this;
                var rotated = that._isRotated();
                var argRange = new _range2.default.Range({
                    rotated: !!rotated
                });
                var series = that._getVisibleSeries();
                that._valueAxes.forEach(function(valueAxis) {
                    var groupRange = new _range2.default.Range({
                        rotated: !!rotated,
                        pane: valueAxis.pane,
                        axis: valueAxis.name
                    });
                    var groupSeries = series.filter(function(series) {
                        return series.getValueAxis() === valueAxis
                    });
                    groupSeries.forEach(function(series) {
                        var seriesRange = series.getRangeData();
                        groupRange.addRange(seriesRange.val);
                        argRange.addRange(seriesRange.arg)
                    });
                    if (!updatedAxis || updatedAxis && groupSeries.length && valueAxis === updatedAxis) {
                        valueAxis.setGroupSeries(groupSeries);
                        valueAxis.setBusinessRange(groupRange, that._axesReinitialized || keepRange, that._argumentAxes[0]._lastVisualRangeUpdateMode)
                    }
                });
                if (!updatedAxis || updatedAxis && series.length) {
                    that._argumentAxes.forEach(function(a) {
                        return a.setBusinessRange(argRange, that._axesReinitialized, void 0, that._groupsData.categories)
                    })
                }
                that._populateMarginOptions()
            },
            getArgumentAxis: function() {
                return (this._argumentAxes || []).filter(function(a) {
                    return !a.isVirtual
                })[0]
            },
            getValueAxis: function(name) {
                var _this2 = this;
                return (this._valueAxes || []).filter((0, _type.isDefined)(name) ? function(a) {
                    return a.name === name
                } : function(a) {
                    return a.pane === _this2.defaultPane
                })[0]
            },
            _getGroupsData: function() {
                var that = this;
                var groups = [];
                that._valueAxes.forEach(function(axis) {
                    groups.push({
                        series: that.series.filter(function(series) {
                            return series.getValueAxis() === axis
                        }),
                        valueAxis: axis,
                        valueOptions: axis.getOptions()
                    })
                });
                return {
                    groups: groups,
                    argumentAxes: that._argumentAxes,
                    argumentOptions: that._argumentAxes[0].getOptions()
                }
            },
            _groupSeries: function() {
                var that = this;
                that._correctValueAxes(false);
                that._groupsData = that._getGroupsData()
            },
            _processValueAxisFormat: function() {
                var axesWithFullStackedFormat = [];
                this.series.forEach(function(series) {
                    var axis = series.getValueAxis();
                    if (series.isFullStackedSeries()) {
                        axis.setPercentLabelFormat();
                        axesWithFullStackedFormat.push(axis)
                    }
                });
                this._valueAxes.forEach(function(axis) {
                    if (axesWithFullStackedFormat.indexOf(axis) === -1) {
                        axis.resetAutoLabelFormat()
                    }
                })
            },
            _populateAxesOptions: function(typeSelector, userOptions, axisOptions, rotated, virtual) {
                var that = this;
                var preparedUserOptions = that._prepareStripsAndConstantLines(typeSelector, userOptions, rotated);
                var options = (0, _extend2.extend)(true, {}, preparedUserOptions, axisOptions, that._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));
                if (virtual) {
                    options.visible = options.tick.visible = options.minorTick.visible = options.label.visible = false;
                    options.title = {}
                }
                return options
            },
            _getValFilter: function(series) {
                return (0, _range_data_calculator.getViewPortFilter)(series.getValueAxis().visualRange() || {})
            },
            _createAxis: function(isArgumentAxes, options, virtual) {
                var that = this;
                var typeSelector = isArgumentAxes ? "argumentAxis" : "valueAxis";
                var renderingSettings = (0, _extend2.extend)({
                    renderer: that._renderer,
                    incidentOccurred: that._incidentOccurred,
                    eventTrigger: that._eventTrigger,
                    axisClass: isArgumentAxes ? "arg" : "val",
                    widgetClass: "dxc",
                    stripsGroup: that._stripsGroup,
                    labelAxesGroup: that._labelAxesGroup,
                    constantLinesGroup: that._constantLinesGroup,
                    scaleBreaksGroup: that._scaleBreaksGroup,
                    axesContainerGroup: that._axesGroup,
                    gridGroup: that._gridGroup,
                    isArgumentAxis: isArgumentAxes
                }, that._getAxisRenderingOptions(typeSelector));
                var axis = new _base_axis2.default.Axis(renderingSettings);
                axis.updateOptions(options);
                axis.isVirtual = virtual;
                return axis
            },
            _applyVisualRangeByVirtualAxes: function(axis, range) {
                return false
            },
            _applyCustomVisualRangeOption: function(axis, range) {
                var that = this;
                if (axis.getOptions().optionPath) {
                    that._parseVisualRangeOption("".concat(axis.getOptions().optionPath, ".visualRange"), range)
                }
            },
            _getVisualRangeSetter: function() {
                var chart = this;
                return function(axis, _ref) {
                    var skipEventRising = _ref.skipEventRising,
                        range = _ref.range;
                    chart._applyCustomVisualRangeOption(axis, range);
                    axis.setCustomVisualRange(range);
                    axis.skipEventRising = skipEventRising;
                    if (!chart._applyVisualRangeByVirtualAxes(axis, range)) {
                        if (chart._applyingChanges) {
                            chart._change_VISUAL_RANGE()
                        } else {
                            chart._requestChange([VISUAL_RANGE])
                        }
                    }
                }
            },
            _getTrackerSettings: function() {
                return (0, _extend2.extend)(this.callBase(), {
                    argumentAxis: this.getArgumentAxis()
                })
            },
            _prepareStripsAndConstantLines: function(typeSelector, userOptions, rotated) {
                userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);
                if (userOptions.strips) {
                    (0, _iterator.each)(userOptions.strips, function(i) {
                        userOptions.strips[i] = (0, _extend2.extend)(true, {}, userOptions.stripStyle, userOptions.strips[i])
                    })
                }
                if (userOptions.constantLines) {
                    (0, _iterator.each)(userOptions.constantLines, function(i, line) {
                        userOptions.constantLines[i] = (0, _extend2.extend)(true, {}, userOptions.constantLineStyle, line)
                    })
                }
                return userOptions
            },
            refresh: function() {
                this._disposeAxes();
                this.callBase()
            },
            _layoutAxes: function(drawAxes) {
                var that = this;
                var cleanPanesCanvases = drawAxes();
                var needSpace = that.checkForMoreSpaceForPanesCanvas();
                if (needSpace) {
                    var size = this._layout.backward(this._rect, this._rect, [needSpace.width, needSpace.height]);
                    needSpace.width = Math.max(0, size[0]);
                    needSpace.height = Math.max(0, size[1]);
                    this._canvas = this._createCanvasFromRect(this._rect);
                    drawAxes(needSpace, cleanPanesCanvases)
                }
            },
            checkForMoreSpaceForPanesCanvas: function() {
                return this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), this._isRotated())
            },
            _parseVisualRangeOption: function(fullName, value) {
                var that = this;
                var name = fullName.split(/[.[]/)[0];
                var index = fullName.match(/\d+/g);
                index = (0, _type.isDefined)(index) ? parseInt(index[0]) : index;
                if (fullName.indexOf("visualRange") > 0) {
                    that._setCustomVisualRange(name, index, value)
                } else {
                    if (("object" === (0, _type.type)(value) || _isArray(value)) && name.indexOf("Axis") > 0 && JSON.stringify(value).indexOf("visualRange") > 0) {
                        if ((0, _type.isDefined)(value.visualRange)) {
                            that._setCustomVisualRange(name, index, value.visualRange)
                        } else {
                            if (_isArray(value)) {
                                value.forEach(function(a, i) {
                                    return (0, _type.isDefined)(a.visualRange) && that._setCustomVisualRange(name, i, a.visualRange)
                                })
                            }
                        }
                    }
                }
            },
            _setCustomVisualRange: function(axesName, index, value) {
                var that = this;
                var options = that._options.silent(axesName);
                if (!options) {
                    return
                }
                if (!(0, _type.isDefined)(index)) {
                    options._customVisualRange = value
                } else {
                    options[index]._customVisualRange = value
                }
                that._axesReinitialized = true
            },
            _raiseZoomEndHandlers: function() {
                this._valueAxes.forEach(function(axis) {
                    return axis.handleZoomEnd()
                })
            },
            _setOptionsByReference: function() {
                this.callBase();
                (0, _extend2.extend)(this._optionsByReference, {
                    "valueAxis.visualRange": true
                })
            },
            _notifyOptionChanged: function(option, value, previousValue) {
                this.callBase.apply(this, arguments);
                if (!this._optionChangedLocker) {
                    this._parseVisualRangeOption(option, value)
                }
            },
            _notifyVisualRange: function() {
                var that = this;
                that._valueAxes.forEach(function(axis) {
                    if (axis.getOptions().optionPath) {
                        var path = "".concat(axis.getOptions().optionPath, ".visualRange");
                        var visualRange = (0, _utils.convertVisualRangeObject)(axis.visualRange(), !_isArray(that.option(path)));
                        if (!axis.skipEventRising || !(0, _utils.rangesAreEqual)(visualRange, that.option(path))) {
                            that.option(path, visualRange)
                        } else {
                            axis.skipEventRising = null
                        }
                    }
                })
            },
            _notify: function() {
                this.callBase();
                this._axesReinitialized = false;
                if (true !== this.option("disableTwoWayBinding")) {
                    this._notifyVisualRange()
                }
            },
            _getAxesForScaling: function() {
                return this._valueAxes
            },
            _getAxesByOptionPath: function(arg, isDirectOption, optionName) {
                var that = this;
                var sourceAxes = that._getAxesForScaling();
                var axes = [];
                if (isDirectOption) {
                    var axisPath;
                    if (arg.fullName) {
                        axisPath = arg.fullName.slice(0, arg.fullName.indexOf("."))
                    }
                    axes = sourceAxes.filter(function(a) {
                        return a.getOptions().optionPath === axisPath
                    })
                } else {
                    if ("object" === (0, _type.type)(arg.value)) {
                        axes = sourceAxes.filter(function(a) {
                            return a.getOptions().optionPath === arg.name
                        })
                    } else {
                        if (_isArray(arg.value)) {
                            arg.value.forEach(function(v, index) {
                                var axis = sourceAxes.filter(function(a) {
                                    return a.getOptions().optionPath === "".concat(arg.name, "[").concat(index, "]")
                                })[0];
                                (0, _type.isDefined)(v[optionName]) && (0, _type.isDefined)(axis) && (axes[index] = axis)
                            })
                        }
                    }
                }
                return axes
            },
            _optionChanged: function(arg) {
                var that = this;
                if (!that._optionChangedLocker) {
                    var optionName = "visualRange";
                    var axes;
                    var isDirectOption = arg.fullName.indexOf(optionName) > 0 ? true : that.getPartialChangeOptionsName(arg).indexOf(optionName) > -1 ? false : void 0;
                    if ((0, _type.isDefined)(isDirectOption)) {
                        axes = that._getAxesByOptionPath(arg, isDirectOption, optionName);
                        if (axes) {
                            if (axes.length > 1 || _isArray(arg.value)) {
                                axes.forEach(function(a, index) {
                                    return setAxisVisualRangeByOption(arg, a, isDirectOption, index)
                                })
                            } else {
                                if (1 === axes.length) {
                                    setAxisVisualRangeByOption(arg, axes[0], isDirectOption)
                                }
                            }
                        }
                    }
                }
                that.callBase(arg)
            },
            _change_VISUAL_RANGE: function() {
                var that = this;
                that._recreateSizeDependentObjects(false);
                if (!that._changes.has("FULL_RENDER")) {
                    var resizePanesOnZoom = that.option("resizePanesOnZoom");
                    that._doRender({
                        force: true,
                        drawTitle: false,
                        drawLegend: false,
                        adjustAxes: null !== resizePanesOnZoom && void 0 !== resizePanesOnZoom ? resizePanesOnZoom : that.option("adjustAxesOnZoom") || false,
                        animate: false
                    });
                    that._raiseZoomEndHandlers()
                }
            },
            resetVisualRange: function() {
                var that = this;
                that._valueAxes.forEach(function(axis) {
                    axis.resetVisualRange(false);
                    that._applyCustomVisualRangeOption(axis)
                });
                that._requestChange([VISUAL_RANGE])
            },
            _legendDataField: "series",
            _adjustSeriesLabels: _common.noop,
            _correctValueAxes: _common.noop
        });
        exports.AdvancedChart = AdvancedChart
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/smart_formatter.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.smartFormatter = smartFormatter;
        exports.formatRange = formatRange;
        var _format_helper = __webpack_require__( /*! ../../format_helper */ 63);
        var _format_helper2 = _interopRequireDefault(_format_helper);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _date = __webpack_require__( /*! ../../core/utils/date */ 24);
        var _date2 = _interopRequireDefault(_date);
        var _math = __webpack_require__( /*! ../../core/utils/math */ 31);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _format = _format_helper2.default.format;
        var abs = Math.abs,
            floor = Math.floor;
        var EXPONENTIAL = "exponential";
        var formats = ["fixedPoint", "thousands", "millions", "billions", "trillions", EXPONENTIAL];
        var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "month", "year"];

        function getDatesDifferences(prevDate, curDate, nextDate, tickFormat) {
            var prevDifferences;
            var nextDifferences;
            var dateUnitInterval;
            var dateUnitsLength = dateUnitIntervals.length;
            var i;
            var j;
            if ("week" === tickFormat) {
                tickFormat = "day"
            } else {
                if ("quarter" === tickFormat) {
                    tickFormat = "month"
                } else {
                    if ("shorttime" === tickFormat) {
                        tickFormat = "hour"
                    } else {
                        if ("longtime" === tickFormat) {
                            tickFormat = "second"
                        }
                    }
                }
            }
            var tickFormatIndex = dateUnitIntervals.indexOf(tickFormat);
            if (nextDate) {
                nextDifferences = _date2.default.getDatesDifferences(curDate, nextDate);
                prevDifferences = _date2.default.getDatesDifferences(curDate, prevDate);
                if (nextDifferences[tickFormat]) {
                    for (i = dateUnitsLength - 1; i >= tickFormatIndex; i--) {
                        dateUnitInterval = dateUnitIntervals[i];
                        if (i === tickFormatIndex) {
                            setDateUnitInterval(nextDifferences, tickFormatIndex + (nextDifferences.millisecond ? 2 : 1))
                        } else {
                            if (nextDifferences[dateUnitInterval]) {
                                resetDateUnitInterval(nextDifferences, i);
                                break
                            }
                        }
                    }
                }
            } else {
                prevDifferences = _date2.default.getDatesDifferences(prevDate, curDate);
                for (i = dateUnitsLength - 1; i >= tickFormatIndex; i--) {
                    dateUnitInterval = dateUnitIntervals[i];
                    if (prevDifferences[dateUnitInterval]) {
                        if (i - tickFormatIndex > 1) {
                            for (j = tickFormatIndex + 1; j >= 0; j--) {
                                resetDateUnitInterval(prevDifferences, j)
                            }
                            break
                        } else {
                            if (isDateTimeStart(curDate, dateUnitInterval)) {
                                for (j = i - 1; j > 0; j--) {
                                    resetDateUnitInterval(prevDifferences, j)
                                }
                                break
                            }
                        }
                    }
                }
            }
            return nextDate ? nextDifferences : prevDifferences
        }

        function isDateTimeStart(date, dateUnitInterval) {
            var unitNumbers = [date.getMilliseconds(), date.getSeconds(), date.getMinutes(), date.getHours(), date.getDate(), date.getMonth()];
            var unitIndex = dateUnitIntervals.indexOf(dateUnitInterval);
            var i;
            for (i = 0; i < unitIndex; i++) {
                if (4 === i && 1 !== unitNumbers[i] || 4 !== i && 0 !== unitNumbers[i]) {
                    return false
                }
            }
            return true
        }

        function resetDateUnitInterval(differences, intervalIndex) {
            var dateUnitInterval = dateUnitIntervals[intervalIndex];
            if (differences[dateUnitInterval]) {
                differences[dateUnitInterval] = false;
                differences.count--
            }
        }

        function setDateUnitInterval(differences, intervalIndex) {
            var dateUnitInterval = dateUnitIntervals[intervalIndex];
            if (false === differences[dateUnitInterval]) {
                differences[dateUnitInterval] = true;
                differences.count++
            }
        }

        function getNoZeroIndex(str) {
            return str.length - parseInt(str).toString().length
        }

        function getTransitionTickIndex(ticks, value) {
            var i;
            var curDiff;
            var minDiff;
            var nearestTickIndex = 0;
            minDiff = abs(value - ticks[0]);
            for (i = 1; i < ticks.length; i++) {
                curDiff = abs(value - ticks[i]);
                if (curDiff < minDiff) {
                    minDiff = curDiff;
                    nearestTickIndex = i
                }
            }
            return nearestTickIndex
        }

        function splitDecimalNumber(value) {
            return value.toString().split(".")
        }

        function createFormat(type) {
            var formatter;
            if ((0, _type.isFunction)(type)) {
                formatter = type;
                type = null
            }
            return {
                type: type,
                formatter: formatter
            }
        }

        function smartFormatter(tick, options) {
            var tickInterval = options.tickInterval;
            var tickIntervalIndex;
            var tickIndex;
            var actualIndex;
            var stringTick = abs(tick).toString();
            var precision = 0;
            var typeFormat;
            var offset = 0;
            var separatedTickInterval;
            var indexOfFormat = 0;
            var indexOfTick = -1;
            var datesDifferences;
            var format = options.labelOptions.format;
            var ticks = options.ticks;
            var log10Tick;
            var prevDateIndex;
            var nextDateIndex;
            var isLogarithmic = "logarithmic" === options.type;
            if (1 === ticks.length && 0 === ticks.indexOf(tick) && !(0, _type.isDefined)(tickInterval)) {
                tickInterval = abs(tick) >= 1 ? 1 : (0, _math.adjust)(1 - abs(tick), tick)
            }
            if (!(0, _type.isDefined)(format) && "discrete" !== options.type && tick && (10 === options.logarithmBase || !isLogarithmic)) {
                if ("datetime" !== options.dataType && (0, _type.isDefined)(tickInterval)) {
                    if (ticks.length && ticks.indexOf(tick) === -1) {
                        indexOfTick = getTransitionTickIndex(ticks, tick);
                        tickInterval = (0, _math.adjust)(abs(tick - ticks[indexOfTick]), tick)
                    }
                    separatedTickInterval = splitDecimalNumber(tickInterval);
                    if (separatedTickInterval < 2) {
                        separatedTickInterval = splitDecimalNumber(tick)
                    }
                    if (isLogarithmic) {
                        log10Tick = (0, _utils.getAdjustedLog10)(abs(tick));
                        if (log10Tick > 0) {
                            typeFormat = formats[floor(log10Tick / 3)] || EXPONENTIAL
                        } else {
                            if (log10Tick < -4) {
                                typeFormat = EXPONENTIAL
                            } else {
                                precision = void 0
                            }
                        }
                    } else {
                        if (separatedTickInterval.length > 1 && !(0, _type.isExponential)(tickInterval)) {
                            precision = separatedTickInterval[1].length;
                            typeFormat = formats[indexOfFormat]
                        } else {
                            if ((0, _type.isExponential)(tickInterval) && (stringTick.indexOf(".") !== -1 || (0, _type.isExponential)(tick))) {
                                typeFormat = EXPONENTIAL;
                                if (!(0, _type.isExponential)(tick)) {
                                    precision = abs(getNoZeroIndex(stringTick.split(".")[1]) - (0, _math.getExponent)(tickInterval) + 1)
                                } else {
                                    precision = Math.max(abs((0, _math.getExponent)(tick) - (0, _math.getExponent)(tickInterval)), abs((0, _math.getPrecision)(tick) - (0, _math.getPrecision)(tickInterval)))
                                }
                            } else {
                                tickIntervalIndex = floor((0, _utils.getAdjustedLog10)(tickInterval));
                                actualIndex = tickIndex = floor((0, _utils.getAdjustedLog10)(abs(tick)));
                                if (tickIndex - tickIntervalIndex >= 2) {
                                    actualIndex = tickIntervalIndex
                                }
                                indexOfFormat = floor(actualIndex / 3);
                                offset = 3 * indexOfFormat;
                                if (indexOfFormat < 5) {
                                    if (tickIntervalIndex - offset === 2 && tickIndex >= 3) {
                                        indexOfFormat++;
                                        offset = 3 * indexOfFormat
                                    }
                                    typeFormat = formats[indexOfFormat]
                                } else {
                                    typeFormat = formats[formats.length - 1]
                                }
                                if (offset > 0) {
                                    separatedTickInterval = splitDecimalNumber(tickInterval / Math.pow(10, offset));
                                    if (separatedTickInterval[1]) {
                                        precision = separatedTickInterval[1].length
                                    }
                                }
                            }
                        }
                    }
                    if (void 0 !== typeFormat || void 0 !== precision) {
                        format = {
                            type: typeFormat,
                            precision: precision
                        }
                    }
                } else {
                    if ("datetime" === options.dataType) {
                        typeFormat = _date2.default.getDateFormatByTickInterval(tickInterval);
                        if (options.showTransition && ticks.length) {
                            indexOfTick = ticks.map(Number).indexOf(+tick);
                            if (1 === ticks.length && 0 === indexOfTick) {
                                typeFormat = _format_helper2.default.getDateFormatByTicks(ticks)
                            } else {
                                if (indexOfTick === -1) {
                                    prevDateIndex = getTransitionTickIndex(ticks, tick)
                                } else {
                                    prevDateIndex = 0 === indexOfTick ? ticks.length - 1 : indexOfTick - 1;
                                    nextDateIndex = 0 === indexOfTick ? 1 : -1
                                }
                                datesDifferences = getDatesDifferences(ticks[prevDateIndex], tick, ticks[nextDateIndex], typeFormat);
                                typeFormat = _format_helper2.default.getDateFormatByDifferences(datesDifferences, typeFormat)
                            }
                        }
                        format = createFormat(typeFormat)
                    }
                }
            }
            return _format(tick, format)
        }

        function getHighDiffFormat(diff) {
            var stop = false;
            for (var i in diff) {
                if (true === diff[i] || "hour" === i || stop) {
                    diff[i] = false;
                    stop = true
                } else {
                    if (false === diff[i]) {
                        diff[i] = true
                    }
                }
            }
            return createFormat(_format_helper2.default.getDateFormatByDifferences(diff))
        }

        function getHighAndSelfDiffFormat(diff, interval) {
            var stop = false;
            for (var i in diff) {
                if (stop) {
                    diff[i] = false
                } else {
                    if (i === interval) {
                        stop = true
                    } else {
                        diff[i] = true
                    }
                }
            }
            return createFormat(_format_helper2.default.getDateFormatByDifferences(diff))
        }

        function formatDateRange(startValue, endValue, tickInterval) {
            var diff = getDatesDifferences(startValue, endValue);
            var typeFormat = _date2.default.getDateFormatByTickInterval(tickInterval);
            var diffFormatType = _format_helper2.default.getDateFormatByDifferences(diff, typeFormat);
            var diffFormat = createFormat(diffFormatType);
            var values = [];
            if (tickInterval in diff) {
                var rangeFormat = getHighAndSelfDiffFormat(getDatesDifferences(startValue, endValue), tickInterval);
                var value = _format(startValue, rangeFormat);
                if (value) {
                    values.push(value)
                }
            } else {
                var _rangeFormat = getHighDiffFormat(getDatesDifferences(startValue, endValue));
                var highValue = _format(startValue, _rangeFormat);
                if (highValue) {
                    values.push(highValue)
                }
                values.push("".concat(_format(startValue, diffFormat), " - ").concat(_format(endValue, diffFormat)))
            }
            return values.join(", ")
        }

        function processDateInterval(interval) {
            if ((0, _type.isObject)(interval)) {
                var dateUnits = Object.keys(interval);
                var sum = dateUnits.reduce(function(sum, k) {
                    return interval[k] + sum
                }, 0);
                if (1 === sum) {
                    var dateUnit = dateUnits.filter(function(k) {
                        return 1 === interval[k]
                    })[0];
                    return dateUnit.slice(0, dateUnit.length - 1)
                }
            }
            return interval
        }

        function formatRange(startValue, endValue, tickInterval, _ref) {
            var dataType = _ref.dataType,
                type = _ref.type,
                logarithmBase = _ref.logarithmBase;
            if ("discrete" === type) {
                return ""
            }
            if ("datetime" === dataType) {
                return formatDateRange(startValue, endValue, processDateInterval(tickInterval))
            }
            var formatOptions = {
                ticks: [],
                type: type,
                dataType: dataType,
                tickInterval: tickInterval,
                logarithmBase: logarithmBase,
                labelOptions: {}
            };
            return "".concat(smartFormatter(startValue, formatOptions), " - ").concat(smartFormatter(endValue, formatOptions))
        }
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/tick_generator.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _date = __webpack_require__( /*! ../../core/utils/date */ 24);
        var _date2 = _interopRequireDefault(_date);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _math = __webpack_require__( /*! ../../core/utils/math */ 31);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest()
        }

        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) {
                return
            }
            if ("string" === typeof o) {
                return _arrayLikeToArray(o, minLen)
            }
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if ("Object" === n && o.constructor) {
                n = o.constructor.name
            }
            if ("Map" === n || "Set" === n) {
                return Array.from(o)
            }
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return _arrayLikeToArray(o, minLen)
            }
        }

        function _arrayLikeToArray(arr, len) {
            if (null == len || len > arr.length) {
                len = arr.length
            }
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
            }
            return arr2
        }

        function _iterableToArrayLimit(arr, i) {
            if ("undefined" === typeof Symbol || !(Symbol.iterator in Object(arr))) {
                return
            }
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) {
                        break
                    }
                }
            } catch (err) {
                _d = true;
                _e = err
            } finally {
                try {
                    if (!_n && null != _i.return) {
                        _i.return()
                    }
                } finally {
                    if (_d) {
                        throw _e
                    }
                }
            }
            return _arr
        }

        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) {
                return arr
            }
        }
        var convertDateUnitToMilliseconds = _date2.default.convertDateUnitToMilliseconds;
        var dateToMilliseconds = _date2.default.dateToMilliseconds;
        var math = Math;
        var mathAbs = math.abs;
        var mathFloor = math.floor;
        var mathCeil = math.ceil;
        var mathPow = math.pow;
        var NUMBER_MULTIPLIERS = [1, 2, 2.5, 5];
        var LOGARITHMIC_MULTIPLIERS = [1, 2, 3, 5];
        var DATETIME_MULTIPLIERS = {
            millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],
            second: [1, 2, 3, 5, 10, 15, 20, 30],
            minute: [1, 2, 3, 5, 10, 15, 20, 30],
            hour: [1, 2, 3, 4, 6, 8, 12],
            day: [1, 2],
            week: [1, 2],
            month: [1, 2, 3, 6]
        };
        var DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND = (0, _extend.extend)({}, DATETIME_MULTIPLIERS, {
            day: [1]
        });
        var DATETIME_MINOR_MULTIPLIERS = {
            millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],
            second: [1, 2, 3, 5, 10, 15, 20, 30],
            minute: [1, 2, 3, 5, 10, 15, 20, 30],
            hour: [1, 2, 3, 4, 6, 8, 12],
            day: [1, 2, 3, 7, 14],
            month: [1, 2, 3, 6]
        };
        var MINOR_DELIMITERS = [2, 4, 5, 8, 10];
        var VISIBILITY_DELIMITER = 3;
        var MINUTE = 6e4;

        function dummyGenerator(options) {
            return function(data, screenDelta, tickInterval, forceTickInterval) {
                var count = mathFloor(screenDelta / options.axisDivisionFactor);
                count = count < 1 ? 1 : count;
                var interval = screenDelta / count;
                return {
                    ticks: interval > 0 ? Array.apply(null, new Array(count + 1)).map(function(_, i) {
                        return interval * i
                    }) : [],
                    tickInterval: interval
                }
            }
        }

        function discreteGenerator(options) {
            return function(data, screenDelta, tickInterval, forceTickInterval) {
                var categories = (0, _utils.getCategoriesInfo)(data.categories, data.min, data.max).categories;
                return {
                    ticks: categories,
                    tickInterval: mathCeil(categories.length * options.axisDivisionFactor / screenDelta)
                }
            }
        }
        var getValue = function(value) {
            return value
        };
        var getLogValue = function(base, allowNegatives, linearThreshold) {
            return function(value) {
                return (0, _utils.getLogExt)(value, base, allowNegatives, linearThreshold)
            }
        };
        var raiseTo = function(base, allowNegatives, linearThreshold) {
            return function(value) {
                return (0, _utils.raiseToExt)(value, base, allowNegatives, linearThreshold)
            }
        };
        var mathRaiseTo = function(base) {
            return function(value) {
                return (0, _utils.raiseTo)(value, base)
            }
        };
        var logAbsValue = function(base) {
            return function(value) {
                return 0 === value ? 0 : (0, _utils.getLog)(mathAbs(value), base)
            }
        };
        var correctValueByInterval = function(post, round, getValue) {
            return function(value, interval) {
                return (0, _math.adjust)(post(round((0, _math.adjust)(getValue(value) / interval)) * interval))
            }
        };

        function correctMinValueByEndOnTick(floorFunc, ceilFunc, resolveEndOnTick, endOnTick) {
            if ((0, _type.isDefined)(endOnTick)) {
                return endOnTick ? floorFunc : ceilFunc
            }
            return function(value, interval, businessViewInfo, forceEndOnTick) {
                var floorTickValue = floorFunc(value, interval);
                if (value - floorTickValue === 0 || !(0, _type.isDefined)(businessViewInfo) || resolveEndOnTick(value, floorTickValue, interval, businessViewInfo) || forceEndOnTick) {
                    return floorTickValue
                }
                return ceilFunc(value, interval)
            }
        }

        function resolveEndOnTick(curValue, tickValue, interval, businessViewInfo) {
            var prevTickDataDiff = interval - mathAbs(tickValue - curValue);
            var intervalCount = math.max(mathCeil(businessViewInfo.businessDelta / interval), 2);
            var businessRatio = businessViewInfo.screenDelta / (intervalCount * interval);
            var potentialTickScreenDiff = math.round(businessRatio * prevTickDataDiff);
            var delimiterFactor = (0, _utils.getLogExt)(businessRatio * interval / businessViewInfo.axisDivisionFactor, 2) + 1;
            var delimiterMultiplier = (businessViewInfo.isSpacedMargin ? 2 : 1) * delimiterFactor;
            var screenDelimiter = math.round(VISIBILITY_DELIMITER * delimiterMultiplier);
            return businessViewInfo.businessDelta > businessViewInfo.interval && potentialTickScreenDiff >= screenDelimiter
        }

        function resolveEndOnTickLog(base) {
            return function(curValue, tickValue, interval, businessViewInfo) {
                return resolveEndOnTick((0, _utils.getLogExt)(curValue, base), (0, _utils.getLogExt)(tickValue, base), interval, businessViewInfo)
            }
        }

        function resolveEndOnTickDate(curValue, tickValue, interval, businessViewInfo) {
            return resolveEndOnTick(curValue.valueOf(), tickValue.valueOf(), dateToMilliseconds(interval), businessViewInfo)
        }

        function getBusinessDelta(data, breaks) {
            var spacing = 0;
            if (breaks) {
                spacing = breaks.reduce(function(prev, item) {
                    return prev + (item.to - item.from)
                }, 0)
            }
            return mathAbs(data.max - data.min - spacing)
        }

        function getBusinessDeltaLog(base, allowNegatives, linearThreshold) {
            var getLog = getLogValue(base, allowNegatives, linearThreshold);
            return function(data, breaks) {
                var spacing = 0;
                if (breaks) {
                    spacing = breaks.reduce(function(prev, item) {
                        return prev + mathAbs(getLog(item.to / item.from))
                    }, 0)
                }
                return mathCeil(mathAbs(getLog(data.max) - getLog(data.min)) - spacing)
            }
        }

        function getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount) {
            var count = screenDelta / axisDivisionFactor - (addTickCount || 0);
            count = count < 1 ? 1 : count;
            return businessDelta / count
        }

        function getMultiplierFactor(interval, factorDelta) {
            return mathPow(10, mathFloor((0, _utils.getLogExt)(interval, 10)) + (factorDelta || 0))
        }

        function calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, _, minTickInterval) {
            var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount);
            var result = 1;
            var onlyIntegers = false === allowDecimals;
            if (!forceTickInterval || !tickInterval) {
                if (interval >= 1 || !onlyIntegers && interval > 0) {
                    result = adjustInterval(interval, multipliers, onlyIntegers)
                }
                if (!tickInterval || !forceTickInterval && tickInterval < result) {
                    tickInterval = result
                }
            }
            if (!forceTickInterval && minTickInterval) {
                minTickInterval = adjustInterval(minTickInterval, multipliers, onlyIntegers);
                if (minTickInterval > tickInterval) {
                    tickInterval = minTickInterval
                }
            }
            return tickInterval
        }

        function adjustInterval(interval, multipliers, onlyIntegers) {
            var factor = getMultiplierFactor(interval, -1);
            var result = 1;
            multipliers = multipliers || NUMBER_MULTIPLIERS;
            if (interval > 0) {
                interval /= factor;
                result = multipliers.concat(10 * multipliers[0]).map(function(m) {
                    return 10 * m
                }).reduce(function(r, m) {
                    if (.1 === factor && onlyIntegers && 25 === m) {
                        return r
                    }
                    return r < interval ? m : r
                }, 0);
                result = (0, _math.adjust)(result * factor, factor)
            }
            return result
        }

        function calculateMinorTickInterval(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {
            var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);
            return tickInterval || MINOR_DELIMITERS.reduce(function(r, d) {
                var cur = businessDelta / d;
                return cur >= interval ? cur : r
            }, 0)
        }

        function getCalculateTickIntervalLog(skipCalculationLimits) {
            return function(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, _, __, minTickInterval) {
                var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);
                var result = 0;
                var adjustInterval = getAdjustIntervalLog(skipCalculationLimits);
                if (!forceTickInterval || !tickInterval) {
                    if (interval > 0) {
                        result = adjustInterval(interval, multipliers)
                    }
                    if (!tickInterval || !forceTickInterval && tickInterval < result) {
                        tickInterval = result
                    }
                }
                if (!forceTickInterval && minTickInterval) {
                    minTickInterval = adjustInterval(minTickInterval, multipliers);
                    if (minTickInterval > tickInterval) {
                        tickInterval = minTickInterval
                    }
                }
                return tickInterval
            }
        }

        function getAdjustIntervalLog(skipCalculationLimits) {
            return function(interval, multipliers) {
                var factor = getMultiplierFactor(interval);
                multipliers = multipliers || LOGARITHMIC_MULTIPLIERS;
                if (!skipCalculationLimits && factor < 1) {
                    factor = 1
                }
                return multipliers.concat(10 * multipliers[0]).reduce(function(r, m) {
                    return r < interval ? m * factor : r
                }, 0)
            }
        }

        function getDataTimeMultipliers(gapSize) {
            if (gapSize && gapSize > 2) {
                return DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND
            } else {
                return DATETIME_MULTIPLIERS
            }
        }

        function numbersReducer(interval, key) {
            return function(r, m) {
                if (!r && interval <= convertDateUnitToMilliseconds(key, m)) {
                    r = {};
                    r[key + "s"] = m
                }
                return r
            }
        }

        function yearsReducer(interval, factor) {
            return function(r, m) {
                var years = factor * m;
                if (!r && interval <= convertDateUnitToMilliseconds("year", years) && 2.5 !== years) {
                    r = {
                        years: years
                    }
                }
                return r
            }
        }

        function calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, gapSize, minTickInterval) {
            if (!forceTickInterval || !tickInterval) {
                var result = adjustIntervalDateTime(getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor), multipliers, null, gapSize);
                if (!tickInterval || !forceTickInterval && dateToMilliseconds(tickInterval) <= dateToMilliseconds(result)) {
                    tickInterval = result
                }
            }
            if (!forceTickInterval && minTickInterval) {
                minTickInterval = adjustIntervalDateTime(minTickInterval, multipliers, null, gapSize);
                if (dateToMilliseconds(minTickInterval) > dateToMilliseconds(tickInterval)) {
                    tickInterval = minTickInterval
                }
            }
            return tickInterval
        }

        function adjustIntervalDateTime(interval, multipliers, _, gapSize) {
            var result;
            multipliers = multipliers || getDataTimeMultipliers(gapSize);
            for (var key in multipliers) {
                result = multipliers[key].reduce(numbersReducer(interval, key), result);
                if (result) {
                    break
                }
            }
            if (!result) {
                for (var factor = 1;; factor *= 10) {
                    result = NUMBER_MULTIPLIERS.reduce(yearsReducer(interval, factor), result);
                    if (result) {
                        break
                    }
                }
            }
            return result
        }

        function calculateMinorTickIntervalDateTime(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {
            return calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, true, axisDivisionFactor, DATETIME_MINOR_MULTIPLIERS)
        }

        function getTickIntervalByCustomTicks(getValue, postProcess) {
            return function(ticks) {
                return ticks ? postProcess(mathAbs((0, _math.adjust)(getValue(ticks[1]) - getValue(ticks[0])))) || void 0 : void 0
            }
        }

        function addInterval(value, interval, isNegative) {
            return _date2.default.addInterval(value, interval, isNegative)
        }

        function addIntervalLog(log, raise) {
            return function(value, interval, isNegative) {
                return raise(addInterval(log(value), interval, isNegative))
            }
        }

        function addIntervalDate(value, interval, isNegative) {
            return addInterval(value, interval, isNegative)
        }

        function addIntervalWithBreaks(addInterval, breaks, correctValue) {
            breaks = breaks.filter(function(b) {
                return !b.gapSize
            });
            return function(value, interval, isNegative) {
                var breakSize;
                value = addInterval(value, interval, isNegative);
                if (!breaks.every(function(item) {
                        if (value >= addInterval(item.from, interval) && addInterval(value, interval) < item.to) {
                            breakSize = item.to - item.from - 2 * (addInterval(item.from, interval) - item.from)
                        }
                        return !breakSize
                    })) {
                    value = correctValue(addInterval(value, breakSize), interval)
                }
                return value
            }
        }

        function calculateTicks(addInterval, correctMinValue, adjustInterval, resolveEndOnTick) {
            return function(data, tickInterval, endOnTick, gaps, breaks, businessDelta, screenDelta, axisDivisionFactor, generateExtraTick) {
                var correctTickValue = correctTickValueOnGapSize(addInterval, gaps);
                var min = data.min;
                var max = data.max;
                var businessViewInfo = {
                    screenDelta: screenDelta,
                    businessDelta: businessDelta,
                    axisDivisionFactor: axisDivisionFactor,
                    isSpacedMargin: data.isSpacedMargin,
                    interval: tickInterval
                };
                var cur = correctMinValue(min, tickInterval, businessViewInfo);
                var ticks = [];
                if (null === breaks || void 0 === breaks ? void 0 : breaks.length) {
                    addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue)
                }
                if (cur > max) {
                    cur = correctMinValue(min, adjustInterval(businessDelta / 2), businessViewInfo);
                    if (cur > max) {
                        endOnTick = true;
                        cur = correctMinValue(min, tickInterval, businessViewInfo, endOnTick)
                    }
                }
                cur = correctTickValue(cur);
                var prev;
                while (cur < max && cur !== prev || generateExtraTick && cur <= max) {
                    ticks.push(cur);
                    prev = cur;
                    cur = correctTickValue(addInterval(cur, tickInterval))
                }
                if (endOnTick || cur - max === 0 || !(0, _type.isDefined)(endOnTick) && resolveEndOnTick(max, cur, tickInterval, businessViewInfo)) {
                    ticks.push(cur)
                }
                return ticks
            }
        }

        function calculateMinorTicks(updateTickInterval, addInterval, correctMinValue, correctTickValue, ceil) {
            return function(min, max, majorTicks, minorTickInterval, tickInterval, breaks, maxCount) {
                var factor = tickInterval / minorTickInterval;
                var lastMajor = majorTicks[majorTicks.length - 1];
                var firstMajor = majorTicks[0];
                var tickBalance = maxCount - 1;
                if (null === breaks || void 0 === breaks ? void 0 : breaks.length) {
                    addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue)
                }
                minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, firstMajor, factor);
                if (0 === minorTickInterval) {
                    return []
                }
                var cur = correctTickValue(correctMinValue(min, tickInterval, min), minorTickInterval);
                minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, cur, factor);
                var ticks = [];
                while (cur < firstMajor && (!tickBalance || tickBalance > 0)) {
                    cur >= min && ticks.push(cur);
                    tickBalance--;
                    cur = addInterval(cur, minorTickInterval)
                }
                var middleTicks = majorTicks.reduce(function(r, tick) {
                    tickBalance = maxCount - 1;
                    if (null === r.prevTick) {
                        r.prevTick = tick;
                        return r
                    }
                    minorTickInterval = updateTickInterval(minorTickInterval, tick, r.prevTick, factor);
                    var cur = correctTickValue(r.prevTick, minorTickInterval);
                    while (cur < tick && (!tickBalance || tickBalance > 0)) {
                        cur !== r.prevTick && r.minors.push(cur);
                        tickBalance--;
                        cur = addInterval(cur, minorTickInterval)
                    }
                    r.prevTick = tick;
                    return r
                }, {
                    prevTick: null,
                    minors: []
                });
                ticks = ticks.concat(middleTicks.minors);
                var maxValue = ceil(max, tickInterval, min);
                minorTickInterval = updateTickInterval(minorTickInterval, maxValue, maxValue, factor);
                cur = correctTickValue(lastMajor, minorTickInterval);
                var prev;
                while (cur < max && cur !== prev) {
                    ticks.push(cur);
                    prev = cur;
                    cur = addInterval(cur, minorTickInterval)
                }
                if (lastMajor - max !== 0 && cur - max === 0) {
                    ticks.push(cur)
                }
                return ticks
            }
        }

        function filterTicks(ticks, breaks) {
            if (breaks.length) {
                var result = breaks.reduce(function(result, b) {
                    var tmpTicks = [];
                    var i;
                    for (i = result[1]; i < ticks.length; i++) {
                        var tickValue = ticks[i];
                        if (tickValue < b.from) {
                            tmpTicks.push(tickValue)
                        }
                        if (tickValue >= b.to) {
                            break
                        }
                    }
                    return [result[0].concat(tmpTicks), i]
                }, [
                    [], 0
                ]);
                return result[0].concat(ticks.slice(result[1]))
            }
            return ticks
        }

        function correctTickValueOnGapSize(addInterval, breaks) {
            return function(value) {
                var gapSize;
                if (!breaks.every(function(item) {
                        if (value >= item.from && value < item.to) {
                            gapSize = item.gapSize
                        }
                        return !gapSize
                    })) {
                    value = addInterval(value, gapSize)
                }
                return value
            }
        }

        function generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, getMajorTickIntervalByCustomTicks, getMinorTickIntervalByCustomTicks, convertTickInterval, calculateTicks, calculateMinorTicks, processScaleBreaks) {
            function processCustomTicks(customTicks) {
                return {
                    tickInterval: getMajorTickIntervalByCustomTicks(customTicks.majors),
                    ticks: customTicks.majors || [],
                    minorTickInterval: getMinorTickIntervalByCustomTicks(customTicks.minors),
                    minorTicks: customTicks.minors || []
                }
            }

            function correctUserTickInterval(tickInterval, businessDelta, limit) {
                if (tickInterval && businessDelta / convertTickInterval(tickInterval) >= limit + 1) {
                    options.incidentOccurred("W2003");
                    tickInterval = void 0
                }
                return tickInterval
            }

            function generateMajorTicks(ticks, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks) {
                if (customTicks.majors) {
                    ticks.breaks = breaks;
                    return ticks
                }
                var gaps = breaks.filter(function(b) {
                    return b.gapSize
                });
                var majorTicks;
                tickInterval = options.skipCalculationLimits ? tickInterval : correctUserTickInterval(tickInterval, businessDelta, screenDelta);
                tickInterval = calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, options.axisDivisionFactor, options.numberMultipliers, options.allowDecimals, breaks.length, gaps[0] && gaps[0].gapSize.days, options.minTickInterval);
                if (!options.skipTickGeneration) {
                    majorTicks = calculateTicks(data, tickInterval, options.endOnTick, gaps, breaks, businessDelta, screenDelta, options.axisDivisionFactor, options.generateExtraTick);
                    breaks = processScaleBreaks(breaks, majorTicks, tickInterval);
                    majorTicks = filterTicks(majorTicks, breaks);
                    ticks.breaks = breaks;
                    ticks.ticks = ticks.ticks.concat(majorTicks)
                }
                ticks.tickInterval = tickInterval;
                return ticks
            }

            function generateMinorTicks(ticks, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks) {
                if (!options.calculateMinors) {
                    return ticks
                }
                if (customTicks.minors) {
                    return ticks
                }
                var minorBusinessDelta = convertTickInterval(ticks.tickInterval);
                var minorScreenDelta = screenDelta * minorBusinessDelta / businessDelta;
                var breaks = ticks.breaks;
                if (!minorTickInterval && minorTickCount) {
                    minorTickInterval = getMinorTickIntervalByCustomTicks([minorBusinessDelta / (minorTickCount + 1), minorBusinessDelta / (minorTickCount + 1) * 2])
                } else {
                    minorTickCount = void 0
                }
                minorTickInterval = correctUserTickInterval(minorTickInterval, minorBusinessDelta, minorScreenDelta);
                minorTickInterval = calculateMinorTickInterval(minorBusinessDelta, minorScreenDelta, minorTickInterval, options.minorAxisDivisionFactor);
                ticks.minorTicks = filterTicks(ticks.minorTicks.concat(calculateMinorTicks(data.min, data.max, ticks.ticks, minorTickInterval, ticks.tickInterval, breaks, minorTickCount)), breaks);
                ticks.minorTickInterval = minorTickInterval;
                return ticks
            }
            return function(data, screenDelta, tickInterval, forceTickInterval, customTicks, minorTickInterval, minorTickCount, breaks) {
                customTicks = customTicks || {};
                var businessDelta = getBusinessDelta(data, breaks);
                var result = processCustomTicks(customTicks);
                if (!isNaN(businessDelta)) {
                    if (0 === businessDelta && !customTicks.majors) {
                        result.ticks = [data.min]
                    } else {
                        result = generateMajorTicks(result, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks || []);
                        if (!options.skipTickGeneration && businessDelta > 0) {
                            result = generateMinorTicks(result, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks)
                        }
                    }
                }
                return result
            }
        }

        function getBaseTick(breakValue, _ref, interval, getValue) {
            var _ref2 = _slicedToArray(_ref, 2),
                tick = _ref2[0],
                insideTick = _ref2[1];
            if (!(0, _type.isDefined)(tick) || mathAbs(getValue(breakValue) - getValue(tick)) / interval > .25) {
                if ((0, _type.isDefined)(insideTick)) {
                    tick = insideTick
                } else {
                    if (!(0, _type.isDefined)(tick)) {
                        tick = breakValue
                    }
                }
            }
            return tick
        }

        function getScaleBreaksProcessor(convertTickInterval, getValue, addCorrection) {
            return function(breaks, ticks, tickInterval) {
                var interval = convertTickInterval(tickInterval);
                var correction = .5 * interval;
                return breaks.reduce(function(result, b) {
                    var breakTicks = ticks.filter(function(tick) {
                        return tick <= b.from
                    });
                    var from = addCorrection(getBaseTick(b.from, [].concat(breakTicks[breakTicks.length - 1], ticks[breakTicks.length]), interval, getValue), correction);
                    breakTicks = ticks.filter(function(tick) {
                        return tick >= b.to
                    });
                    var to = addCorrection(getBaseTick(b.to, [].concat(breakTicks[0], ticks[ticks.length - breakTicks.length - 1]), interval, getValue), -correction);
                    if (getValue(to) - getValue(from) < interval && !b.gapSize) {
                        return result
                    }
                    if (b.gapSize) {
                        return result.concat([b])
                    }
                    return result.concat([{
                        from: from,
                        to: to,
                        cumulativeWidth: b.cumulativeWidth
                    }])
                }, [])
            }
        }

        function numericGenerator(options) {
            var floor = correctValueByInterval(getValue, mathFloor, getValue);
            var ceil = correctValueByInterval(getValue, mathCeil, getValue);
            var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, getValue);
            return generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, getValue, calculateTicks(addInterval, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTick, options.endOnTick), adjustInterval, resolveEndOnTick), calculateMinorTicks(getValue, addInterval, floor, addInterval, getValue), getScaleBreaksProcessor(getValue, getValue, function(value, correction) {
                return value + correction
            }))
        }
        var correctValueByIntervalLog = function(post, getRound, getValue) {
            return function(value, interval) {
                return (0, _math.sign)(value) * (0, _math.adjust)(post(getRound(value)((0, _math.adjust)(getValue(value) / interval)) * interval))
            }
        };

        function logarithmicGenerator(options) {
            var base = options.logBase;
            var raise = raiseTo(base, options.allowNegatives, options.linearThreshold);
            var log = getLogValue(base, options.allowNegatives, options.linearThreshold);
            var absLog = logAbsValue(base);
            var absRaise = mathRaiseTo(base);
            var absFloor = function(value) {
                return value < 0 ? mathCeil : mathFloor
            };
            var absCeil = function(value) {
                return value < 0 ? mathFloor : mathCeil
            };
            var floor = correctValueByIntervalLog(absRaise, absFloor, absLog);
            var ceil = correctValueByIntervalLog(absRaise, absCeil, absLog);
            var ceilNumber = correctValueByInterval(getValue, mathCeil, getValue);
            return generator(options, getBusinessDeltaLog(base, options.allowNegatives, options.linearThreshold), getCalculateTickIntervalLog(options.skipCalculationLimits), calculateMinorTickInterval, getTickIntervalByCustomTicks(log, getValue), getTickIntervalByCustomTicks(getValue, getValue), getValue, calculateTicks(addIntervalLog(log, raise), correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickLog(base), options.endOnTick), getAdjustIntervalLog(options.skipCalculationLimits), resolveEndOnTickLog(base)), calculateMinorTicks(function(_, tick, prevTick, factor) {
                return Math.max(Math.abs(tick), Math.abs(prevTick)) / factor
            }, addInterval, floor, ceilNumber, ceil), getScaleBreaksProcessor(getValue, log, function(value, correction) {
                return raise(log(value) + correction)
            }))
        }

        function dateGenerator(options) {
            function floor(value, interval) {
                var floorNumber = correctValueByInterval(getValue, mathFloor, getValue);
                var intervalObject = (0, _type.isString)(interval) ? _date2.default.getDateIntervalByString(interval.toLowerCase()) : interval;
                var divider = dateToMilliseconds(interval);
                if (intervalObject.days % 7 === 0 || interval.quarters) {
                    intervalObject = adjustIntervalDateTime(divider)
                }
                var correctDateWithUnitBeginning = function(v) {
                    return _date2.default.correctDateWithUnitBeginning(v, intervalObject, null, options.firstDayOfWeek)
                };
                var floorAtStartDate = function(v) {
                    return new Date(mathFloor((v.getTime() - v.getTimezoneOffset() * MINUTE) / divider) * divider + v.getTimezoneOffset() * MINUTE)
                };
                value = correctDateWithUnitBeginning(value);
                if ("years" in intervalObject) {
                    value.setFullYear(floorNumber(value.getFullYear(), intervalObject.years, 0))
                } else {
                    if ("quarters" in intervalObject) {
                        value = correctDateWithUnitBeginning(floorAtStartDate(value))
                    } else {
                        if ("months" in intervalObject) {
                            value.setMonth(floorNumber(value.getMonth(), intervalObject.months, 0))
                        } else {
                            if ("weeks" in intervalObject || "days" in intervalObject) {
                                value = correctDateWithUnitBeginning(floorAtStartDate(value))
                            } else {
                                if ("hours" in intervalObject) {
                                    value.setHours(floorNumber(value.getHours(), intervalObject.hours, 0))
                                } else {
                                    if ("minutes" in intervalObject) {
                                        value.setMinutes(floorNumber(value.getMinutes(), intervalObject.minutes, 0))
                                    } else {
                                        if ("seconds" in intervalObject) {
                                            value.setSeconds(floorNumber(value.getSeconds(), intervalObject.seconds, 0))
                                        } else {
                                            if ("milliseconds" in intervalObject) {
                                                value = floorAtStartDate(value)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return value
            }

            function ceil(value, interval) {
                var newValue = floor(value, interval);
                while (value - newValue > 0) {
                    newValue = addIntervalDate(newValue, interval)
                }
                return newValue
            }
            var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, _date2.default.convertMillisecondsToDateUnits);
            return generator(options, getBusinessDelta, calculateTickIntervalDateTime, calculateMinorTickIntervalDateTime, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, dateToMilliseconds, calculateTicks(addIntervalDate, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickDate, options.endOnTick), adjustIntervalDateTime, resolveEndOnTickDate), calculateMinorTicks(getValue, addIntervalDate, floor, addIntervalDate, getValue), getScaleBreaksProcessor(dateToMilliseconds, getValue, function(value, correction) {
                return new Date(value.getTime() + correction)
            }))
        }
        exports.tickGenerator = function(options) {
            var result;
            if (options.rangeIsEmpty) {
                result = dummyGenerator(options)
            } else {
                if ("discrete" === options.axisType) {
                    result = discreteGenerator(options)
                } else {
                    if ("logarithmic" === options.axisType) {
                        result = logarithmicGenerator(options)
                    } else {
                        if ("datetime" === options.dataType) {
                            result = dateGenerator(options)
                        } else {
                            result = numericGenerator(options)
                        }
                    }
                }
            }
            return result
        }
    },
    /*!***********************************************!*\
      !*** ./artifacts/transpiled/viz/axes/tick.js ***!
      \***********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;

        function getPathStyle(options) {
            return {
                stroke: options.color,
                "stroke-width": options.width,
                "stroke-opacity": options.opacity,
                opacity: 1
            }
        }

        function createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {
            var tickOffset = offset || axis._tickOffset;
            var lineGroup = axis._axisLineGroup;
            var elementsGroup = axis._axisElementsGroup;
            var tickStyle = getPathStyle(tickOptions);
            var gridStyle = getPathStyle(gridOptions);
            var emptyStrRegExp = /^\s+$/;
            var axisOptions = axis.getOptions();
            var labelOptions = axisOptions.label;
            var labelStyle = axis._textOptions;

            function getLabelFontStyle(tick) {
                var fontStyle = axis._textFontStyles;
                var customizeColor = labelOptions.customizeColor;
                if (customizeColor && customizeColor.call) {
                    fontStyle = extend({}, axis._textFontStyles, {
                        fill: customizeColor.call(tick, tick)
                    })
                }
                return fontStyle
            }

            function createLabelHint(tick, range) {
                var labelHint = axis.formatHint(tick.value, labelOptions, range);
                if (isDefined(labelHint) && "" !== labelHint) {
                    tick.label.setTitle(labelHint)
                }
            }
            return function(value) {
                var tick = {
                    value: value,
                    updateValue: function(newValue) {
                        this.value = value = newValue
                    },
                    initCoords: function() {
                        this.coords = axis._getTranslatedValue(value, tickOffset);
                        this.labelCoords = axis._getTranslatedValue(value)
                    },
                    saveCoords: function() {
                        this._storedCoords = this.coords;
                        this._storedLabelsCoords = this.labelCoords
                    },
                    drawMark: function(options) {
                        if (!tickOptions.visible || skippedCategory === value) {
                            return
                        }
                        if (axis.areCoordsOutsideAxis(this.coords)) {
                            return
                        }
                        if (this.mark) {
                            this.mark.append(lineGroup);
                            axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));
                            this.updateTickPosition(options)
                        } else {
                            this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);
                            this.updateTickPosition(options)
                        }
                    },
                    setSkippedCategory: function(category) {
                        skippedCategory = category
                    },
                    _updateLine: function(lineElement, settings, storedSettings, animate, isGridLine) {
                        if (!lineElement) {
                            return
                        }
                        if (null === settings.points || null === settings.r) {
                            lineElement.remove();
                            return
                        }
                        if (animate && storedSettings && null !== storedSettings.points) {
                            settings.opacity = 1;
                            lineElement.attr(storedSettings);
                            lineElement.animate(settings)
                        } else {
                            settings.opacity = animate ? 0 : 1;
                            lineElement.attr(settings);
                            animate && lineElement.animate({
                                opacity: 1
                            }, {
                                delay: .5,
                                partitionDuration: .5
                            })
                        }
                        this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine)
                    },
                    updateTickPosition: function(options, animate) {
                        this._updateLine(this.mark, {
                            points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)
                        }, this._storedCoords && {
                            points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)
                        }, animate, false)
                    },
                    drawLabel: function(range) {
                        var labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);
                        if (!labelIsVisible) {
                            if (this.label) {
                                this.label.remove()
                            }
                            return
                        }
                        var text = axis.formatLabel(value, labelOptions, range);
                        if (this.label) {
                            this.label.attr({
                                text: text,
                                rotate: 0
                            }).append(elementsGroup);
                            createLabelHint(this, range);
                            this.updateLabelPosition();
                            return
                        }
                        if (isDefined(text) && "" !== text && !emptyStrRegExp.test(text)) {
                            this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).data("chart-data-argument", this.value).append(elementsGroup);
                            this.updateLabelPosition();
                            createLabelHint(this, range)
                        }
                    },
                    fadeOutElements: function() {
                        var startSettings = {
                            opacity: 1
                        };
                        var endSettings = {
                            opacity: 0
                        };
                        var animationSettings = {
                            partitionDuration: .5
                        };
                        if (this.label) {
                            this._fadeOutLabel()
                        }
                        if (this.grid) {
                            this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings)
                        }
                        if (this.mark) {
                            this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings)
                        }
                    },
                    _fadeInLabel: function() {
                        var group = axis._renderer.g().attr({
                            opacity: 0
                        }).append(axis._axisElementsGroup).animate({
                            opacity: 1
                        }, {
                            delay: .5,
                            partitionDuration: .5
                        });
                        this.label.append(group)
                    },
                    _fadeOutLabel: function() {
                        var group = axis._renderer.g().attr({
                            opacity: 1
                        }).animate({
                            opacity: 0
                        }, {
                            partitionDuration: .5
                        }).append(axis._axisElementsGroup);
                        this.label.append(group)
                    },
                    updateLabelPosition: function(animate) {
                        if (!this.label) {
                            return
                        }
                        if (animate && this._storedLabelsCoords) {
                            this.label.attr({
                                x: this._storedLabelsCoords.x,
                                y: this._storedLabelsCoords.y
                            });
                            this.label.animate({
                                x: this.labelCoords.x,
                                y: this.labelCoords.y
                            })
                        } else {
                            this.label.attr({
                                x: this.labelCoords.x,
                                y: this.labelCoords.y
                            });
                            if (animate) {
                                this._fadeInLabel()
                            }
                        }
                    },
                    updateMultilineTextAlignment: function() {
                        if (!this.label) {
                            return
                        }
                        this.label.attr({
                            textsAlignment: this.labelAlignment || axis.getOptions().label.alignment
                        })
                    },
                    drawGrid: function(drawLine) {
                        if (gridOptions.visible && skippedCategory !== this.value) {
                            if (this.grid) {
                                this.grid.append(axis._axisGridGroup);
                                axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));
                                this.updateGridPosition()
                            } else {
                                this.grid = drawLine(this, gridStyle);
                                this.grid && this.grid.append(axis._axisGridGroup)
                            }
                        }
                    },
                    updateGridPosition: function(animate) {
                        this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true)
                    },
                    removeLabel: function() {
                        this.label.remove();
                        this.label = null
                    }
                };
                return tick
            }
        }
        exports.tick = createTick
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/xy_axes.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _range = __webpack_require__( /*! ../translators/range */ 112);
        var _range2 = _interopRequireDefault(_range);
        var _format_helper = __webpack_require__( /*! ../../format_helper */ 63);
        var _date = __webpack_require__( /*! ../../core/utils/date */ 24);
        var _date2 = _interopRequireDefault(_date);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _datetime_breaks = __webpack_require__( /*! ./datetime_breaks */ 833);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _utils2 = _interopRequireDefault(_utils);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _axes_constants = __webpack_require__( /*! ./axes_constants */ 263);
        var _axes_constants2 = _interopRequireDefault(_axes_constants);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var getNextDateUnit = _date2.default.getNextDateUnit;
        var correctDateWithUnitBeginning = _date2.default.correctDateWithUnitBeginning;
        var _math = Math;
        var _max = _math.max;
        var TOP = _axes_constants2.default.top;
        var BOTTOM = _axes_constants2.default.bottom;
        var LEFT = _axes_constants2.default.left;
        var RIGHT = _axes_constants2.default.right;
        var CENTER = _axes_constants2.default.center;
        var SCALE_BREAK_OFFSET = 3;
        var RANGE_RATIO = .3;
        var WAVED_LINE_CENTER = 2;
        var WAVED_LINE_TOP = 0;
        var WAVED_LINE_BOTTOM = 4;
        var WAVED_LINE_LENGTH = 24;
        var TICKS_CORRECTIONS = {
            left: -1,
            top: -1,
            right: 0,
            bottom: 0,
            center: -.5
        };

        function prepareDatesDifferences(datesDifferences, tickInterval) {
            var dateUnitInterval;
            var i;
            if ("week" === tickInterval) {
                tickInterval = "day"
            }
            if ("quarter" === tickInterval) {
                tickInterval = "month"
            }
            if (datesDifferences[tickInterval]) {
                for (i = 0; i < _date2.default.dateUnitIntervals.length; i++) {
                    dateUnitInterval = _date2.default.dateUnitIntervals[i];
                    if (datesDifferences[dateUnitInterval]) {
                        datesDifferences[dateUnitInterval] = false;
                        datesDifferences.count--
                    }
                    if (dateUnitInterval === tickInterval) {
                        break
                    }
                }
            }
        }

        function sortingBreaks(breaks) {
            return breaks.sort(function(a, b) {
                return a.from - b.from
            })
        }

        function filterBreaks(breaks, viewport, breakStyle) {
            var minVisible = viewport.minVisible;
            var maxVisible = viewport.maxVisible;
            var breakSize = breakStyle ? breakStyle.width : 0;
            return breaks.reduce(function(result, currentBreak) {
                var from = currentBreak.from;
                var to = currentBreak.to;
                var lastResult = result[result.length - 1];
                var newBreak;
                if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {
                    return result
                }
                if (from > to) {
                    to = [from, from = to][0]
                }
                if (result.length && from < lastResult.to) {
                    if (to > lastResult.to) {
                        lastResult.to = to > maxVisible ? maxVisible : to;
                        if (lastResult.gapSize) {
                            lastResult.gapSize = void 0;
                            lastResult.cumulativeWidth += breakSize
                        }
                    }
                } else {
                    if ((from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) && to - from < maxVisible - minVisible) {
                        var _lastResult$cumulativ;
                        from = from >= minVisible ? from : minVisible;
                        to = to <= maxVisible ? to : maxVisible;
                        newBreak = {
                            from: from,
                            to: to,
                            cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize
                        };
                        if (currentBreak.gapSize) {
                            var _lastResult$cumulativ2;
                            newBreak.gapSize = _date2.default.convertMillisecondsToDateUnits(to - from);
                            newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0
                        }
                        result.push(newBreak)
                    }
                }
                return result
            }, [])
        }

        function getMarkerDates(min, max, markerInterval) {
            var origMin = min;
            var dates;
            min = correctDateWithUnitBeginning(min, markerInterval);
            max = correctDateWithUnitBeginning(max, markerInterval);
            dates = _date2.default.getSequenceByInterval(min, max, markerInterval);
            if (dates.length && origMin > dates[0]) {
                dates = dates.slice(1)
            }
            return dates
        }

        function getStripHorizontalAlignmentPosition(alignment) {
            var position = "start";
            if ("center" === alignment) {
                position = "center"
            }
            if ("right" === alignment) {
                position = "end"
            }
            return position
        }

        function getStripVerticalAlignmentPosition(alignment) {
            var position = "start";
            if ("center" === alignment) {
                position = "center"
            }
            if ("bottom" === alignment) {
                position = "end"
            }
            return position
        }

        function getMarkerInterval(tickInterval) {
            var markerInterval = getNextDateUnit(tickInterval);
            if ("quarter" === markerInterval) {
                markerInterval = getNextDateUnit(markerInterval)
            }
            return markerInterval
        }

        function getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {
            var format = markerInterval;
            var datesDifferences = prevDate && _date2.default.getDatesDifferences(prevDate, curDate);
            if (prevDate && "year" !== tickInterval) {
                prepareDatesDifferences(datesDifferences, tickInterval);
                format = (0, _format_helper.getDateFormatByDifferences)(datesDifferences)
            }
            return format
        }

        function getMaxSide(act, boxes) {
            return boxes.reduce(function(prevValue, box) {
                return _max(prevValue, act(box))
            }, 0)
        }

        function getDistanceByAngle(bBox, rotationAngle) {
            rotationAngle = _math.abs(rotationAngle);
            rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;
            var a = rotationAngle * (_math.PI / 180);
            if (a >= _math.atan(bBox.height / bBox.width)) {
                return bBox.height / _math.abs(_math.sin(a))
            } else {
                return bBox.width
            }
        }

        function getMaxConstantLinePadding(constantLines) {
            return constantLines.reduce(function(padding, options) {
                return _max(padding, options.paddingTopBottom)
            }, 0)
        }

        function getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {
            return constantLines.some(function(options) {
                return options.label.verticalAlignment === alignment
            }) && labelHeight || 0
        }

        function getLeftMargin(bBox) {
            return _math.abs(bBox.x) || 0
        }

        function getRightMargin(bBox) {
            return _math.abs(bBox.width - _math.abs(bBox.x)) || 0
        }

        function generateRangesOnPoints(points, edgePoints, getRange) {
            var i;
            var length;
            var maxRange = null;
            var ranges = [];
            var curValue;
            var prevValue;
            var curRange;
            for (i = 1, length = points.length; i < length; i++) {
                curValue = points[i];
                prevValue = points[i - 1];
                curRange = getRange(curValue, prevValue);
                if (edgePoints.indexOf(curValue) >= 0) {
                    if (!maxRange || curRange > maxRange.length) {
                        maxRange = {
                            start: curValue,
                            end: prevValue,
                            length: curRange
                        }
                    }
                } else {
                    if (maxRange && curRange < maxRange.length) {
                        ranges.push(maxRange)
                    } else {
                        ranges.push({
                            start: curValue,
                            end: prevValue,
                            length: curRange
                        })
                    }
                    maxRange = null
                }
            }
            if (maxRange) {
                ranges.push(maxRange)
            }
            return ranges
        }

        function generateAutoBreaks(_ref, series, _ref2) {
            var logarithmBase = _ref.logarithmBase,
                type = _ref.type,
                maxAutoBreakCount = _ref.maxAutoBreakCount;
            var minVisible = _ref2.minVisible,
                maxVisible = _ref2.maxVisible;
            var breaks = [];
            var getRange = "logarithmic" === type ? function(min, max) {
                return _utils2.default.getLog(max / min, logarithmBase)
            } : function(min, max) {
                return max - min
            };
            var visibleRange = getRange(minVisible, maxVisible);
            var points = series.reduce(function(result, s) {
                var points = s.getPointsInViewPort();
                result[0] = result[0].concat(points[0]);
                result[1] = result[1].concat(points[1]);
                return result
            }, [
                [],
                []
            ]);
            var sortedAllPoints = points[0].concat(points[1]).sort(function(a, b) {
                return b - a
            });
            var edgePoints = points[1].filter(function(p) {
                return points[0].indexOf(p) < 0
            });
            var minDiff = RANGE_RATIO * visibleRange;
            var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function(a, b) {
                return b.length - a.length
            });
            var epsilon = _math.min.apply(null, ranges.map(function(r) {
                return r.length
            })) / 1e3;
            var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;
            for (var i = 0; i < _maxAutoBreakCount; i++) {
                if (ranges[i].length >= minDiff) {
                    if (visibleRange <= ranges[i].length) {
                        break
                    }
                    visibleRange -= ranges[i].length;
                    if (visibleRange > epsilon || visibleRange < -epsilon) {
                        breaks.push({
                            from: ranges[i].start,
                            to: ranges[i].end
                        });
                        minDiff = RANGE_RATIO * visibleRange
                    }
                } else {
                    break
                }
            }
            sortingBreaks(breaks);
            return breaks
        }
        module.exports = {
            linear: {
                _getStep: function(boxes, rotationAngle) {
                    var spacing = this._options.label.minSpacing;
                    var func = this._isHorizontal ? function(box) {
                        return box.width + spacing
                    } : function(box) {
                        return box.height
                    };
                    var maxLabelLength = getMaxSide(func, boxes);
                    if (rotationAngle) {
                        maxLabelLength = getDistanceByAngle({
                            width: maxLabelLength,
                            height: this._getMaxLabelHeight(boxes, 0)
                        }, rotationAngle)
                    }
                    return _axes_constants2.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? "x" : "y", maxLabelLength)
                },
                _getMaxLabelHeight: function(boxes, spacing) {
                    return getMaxSide(function(box) {
                        return box.height
                    }, boxes) + spacing
                },
                _validateOverlappingMode: function(mode, displayMode) {
                    if (this._isHorizontal && ("rotate" === displayMode || "stagger" === displayMode) || !this._isHorizontal) {
                        return _axes_constants2.default.validateOverlappingMode(mode)
                    }
                    return mode
                },
                _validateDisplayMode: function(mode) {
                    return this._isHorizontal ? mode : "standard"
                },
                getMarkerTrackers: function() {
                    return this._markerTrackers
                },
                _getSharpParam: function(opposite) {
                    return this._isHorizontal ^ opposite ? "h" : "v"
                },
                _createAxisElement: function() {
                    return this._renderer.path([], "line")
                },
                _updateAxisElementPosition: function() {
                    var axisCoord = this._axisPosition;
                    var canvas = this._getCanvasStartEnd();
                    this._axisElement.attr({
                        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]
                    })
                },
                _getTranslatedCoord: function(value, offset) {
                    return this._translator.translate(value, offset)
                },
                _initAxisPositions: function() {
                    var that = this;
                    if (that.customPositionIsAvailable() && !(0, _type.isDefined)(that._customBoundaryPosition)) {
                        that._customBoundaryPosition = that.getCustomBoundaryPosition()
                    }
                    if (!that.customPositionIsAvailable() || that.customPositionIsBoundary()) {
                        that._axisPosition = that.getPredefinedPosition(that.getResolvedBoundaryPosition())
                    } else {
                        that._axisPosition = that.getCustomPosition()
                    }
                },
                _getTickMarkPoints: function(coords, length, tickOptions) {
                    var isHorizontal = this._isHorizontal;
                    var tickOrientation = this._options.tickOrientation;
                    var labelPosition = this._options.label.position;
                    var tickStartCoord;
                    if ((0, _type.isDefined)(tickOrientation)) {
                        tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length
                    } else {
                        var shift = tickOptions.shift || 0;
                        if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {
                            shift = -shift
                        }
                        tickStartCoord = shift + this.getTickStartPositionShift(length)
                    }
                    return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)]
                },
                getTickStartPositionShift: function(length) {
                    var width = this._options.width;
                    var position = this.getResolvedBoundaryPosition();
                    return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasCustomPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1)
                },
                _getTitleCoords: function() {
                    var that = this;
                    var horizontal = that._isHorizontal;
                    var x = that._axisPosition;
                    var y = that._axisPosition;
                    var align = that._options.title.alignment;
                    var canvas = that._getCanvasStartEnd();
                    var fromStartToEnd = horizontal || that._options.position === LEFT;
                    var canvasStart = fromStartToEnd ? canvas.start : canvas.end;
                    var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;
                    var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;
                    if (horizontal) {
                        x = coord
                    } else {
                        y = coord
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _drawTitleText: function(group, coords) {
                    var options = this._options;
                    var titleOptions = options.title;
                    var attrs = {
                        opacity: titleOptions.opacity,
                        align: titleOptions.alignment,
                        "class": titleOptions.cssClass
                    };
                    if (!titleOptions.text || !group) {
                        return
                    }
                    coords = coords || this._getTitleCoords();
                    if (!this._isHorizontal) {
                        attrs.rotate = options.position === LEFT ? 270 : 90
                    }
                    var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(_utils2.default.patchFontOptions(titleOptions.font)).attr(attrs).append(group);
                    this._checkTitleOverflow(text);
                    return text
                },
                _updateTitleCoords: function() {
                    this._title && this._title.element.attr(this._getTitleCoords())
                },
                _drawTitle: function() {
                    var title = this._drawTitleText(this._axisTitleGroup);
                    if (title) {
                        this._title = {
                            element: title
                        }
                    }
                },
                _measureTitle: function() {
                    if (this._title) {
                        if (this._title.bBox && !this._title.originalSize) {
                            this._title.originalSize = this._title.bBox
                        }
                        this._title.bBox = this._title.element.getBBox()
                    }
                },
                _drawDateMarker: function(date, options, range) {
                    var that = this;
                    var markerOptions = that._options.marker;
                    var invert = that._translator.getBusinessRange().invert;
                    var textIndent = markerOptions.width + markerOptions.textLeftIndent;
                    var pathElement;
                    if (null === options.x) {
                        return
                    }
                    if (!options.withoutStick) {
                        pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], "line").attr({
                            "stroke-width": markerOptions.width,
                            stroke: markerOptions.color,
                            "stroke-opacity": markerOptions.opacity,
                            sharp: "h"
                        }).append(that._axisElementsGroup)
                    }
                    var text = String(that.formatLabel(date, options.labelOptions, range));
                    return {
                        date: date,
                        x: options.x,
                        y: options.y,
                        cropped: options.withoutStick,
                        label: that._renderer.text(text, options.x, options.y).css(_utils2.default.patchFontOptions(markerOptions.label.font)).append(that._axisElementsGroup),
                        line: pathElement,
                        getEnd: function() {
                            return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width)
                        },
                        setTitle: function() {
                            this.title = text
                        },
                        hideLabel: function() {
                            this.label.dispose();
                            this.label = null;
                            this.title = text
                        },
                        hide: function() {
                            if (pathElement) {
                                pathElement.dispose();
                                pathElement = null
                            }
                            this.label.dispose();
                            this.label = null;
                            this.hidden = true
                        }
                    }
                },
                _drawDateMarkers: function() {
                    var that = this;
                    var options = that._options;
                    var translator = that._translator;
                    var viewport = that._getViewportRange();
                    var minBound = viewport.minVisible;
                    var dateMarkers = [];
                    var dateMarker;

                    function draw(markerDate, format, withoutStick) {
                        return that._drawDateMarker(markerDate, {
                            x: translator.translate(markerDate),
                            y: markersAreaTop,
                            labelOptions: that._getLabelFormatOptions(format),
                            withoutStick: withoutStick
                        }, viewport)
                    }
                    if (viewport.isEmpty() || !options.marker.visible || "datetime" !== options.argumentType || "discrete" === options.type || that._majorTicks.length <= 1) {
                        return []
                    }
                    var markersAreaTop = that._axisPosition + options.marker.topIndent;
                    var tickInterval = _date2.default.getDateUnitInterval(this._tickInterval);
                    var markerInterval = getMarkerInterval(tickInterval);
                    var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);
                    if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {
                        dateMarkers = markerDates.reduce(function(markers, curDate, i, dates) {
                            var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));
                            marker && markers.push(marker);
                            return markers
                        }, []);
                        if (minBound < markerDates[0]) {
                            dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);
                            dateMarker && dateMarkers.unshift(dateMarker)
                        }
                    }
                    return dateMarkers
                },
                _adjustDateMarkers: function(offset) {
                    offset = offset || 0;
                    var that = this;
                    var markerOptions = this._options.marker;
                    var textIndent = markerOptions.width + markerOptions.textLeftIndent;
                    var invert = this._translator.getBusinessRange().invert;
                    var canvas = that._getCanvasStartEnd();
                    var dateMarkers = this._dateMarkers;
                    if (!dateMarkers.length) {
                        return offset
                    }
                    if (dateMarkers[0].cropped) {
                        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {
                            dateMarkers[0].hideLabel()
                        }
                    }
                    var prevDateMarker;
                    dateMarkers.forEach(function(marker, i, markers) {
                        if (marker.cropped) {
                            return
                        }
                        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {
                            marker.hideLabel()
                        } else {
                            if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {
                                prevDateMarker = marker
                            } else {
                                marker.hide()
                            }
                        }
                    });
                    this._dateMarkers.forEach(function(marker) {
                        if (marker.label) {
                            var labelBBox = marker.labelBBox;
                            var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;
                            marker.label.attr({
                                translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,
                                translateY: dy + offset
                            })
                        }
                        if (marker.line) {
                            marker.line.attr({
                                translateY: offset
                            })
                        }
                    });
                    that._initializeMarkersTrackers(offset);
                    return offset + markerOptions.topIndent + markerOptions.separatorHeight
                },
                _checkMarkersPosition: function(invert, dateMarker, prevDateMarker) {
                    if (void 0 === prevDateMarker) {
                        return true
                    }
                    return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd()
                },
                _initializeMarkersTrackers: function(offset) {
                    var that = this;
                    var separatorHeight = that._options.marker.separatorHeight;
                    var renderer = that._renderer;
                    var businessRange = this._translator.getBusinessRange();
                    var canvas = that._getCanvasStartEnd();
                    var group = that._axisElementsGroup;
                    that._markerTrackers = this._dateMarkers.filter(function(marker) {
                        return !marker.hidden
                    }).map(function(marker, i, markers) {
                        var nextMarker = markers[i + 1] || {
                            x: canvas.end,
                            date: businessRange.max
                        };
                        var x = marker.x;
                        var y = marker.y + offset;
                        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], "area").attr({
                            "stroke-width": 1,
                            stroke: "grey",
                            fill: "grey",
                            opacity: 1e-4
                        }).append(group);
                        markerTracker.data("range", {
                            startValue: marker.date,
                            endValue: nextMarker.date
                        });
                        if (marker.title) {
                            markerTracker.setTitle(marker.title)
                        }
                        return markerTracker
                    })
                },
                _getLabelFormatOptions: function(formatString) {
                    var that = this;
                    var markerLabelOptions = that._markerLabelOptions;
                    if (!markerLabelOptions) {
                        that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label)
                    }
                    if (!(0, _type.isDefined)(that._options.marker.label.format)) {
                        markerLabelOptions.format = formatString
                    }
                    return markerLabelOptions
                },
                _adjustConstantLineLabels: function(constantLines) {
                    var that = this;
                    var axisPosition = that._options.position;
                    var canvas = that.getCanvas();
                    var canvasLeft = canvas.left;
                    var canvasRight = canvas.width - canvas.right;
                    var canvasTop = canvas.top;
                    var canvasBottom = canvas.height - canvas.bottom;
                    var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;
                    var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;
                    var maxLabel = 0;
                    constantLines.forEach(function(item) {
                        var isHorizontal = that._isHorizontal;
                        var linesOptions = item.options;
                        var paddingTopBottom = linesOptions.paddingTopBottom;
                        var paddingLeftRight = linesOptions.paddingLeftRight;
                        var labelOptions = linesOptions.label;
                        var labelVerticalAlignment = labelOptions.verticalAlignment;
                        var labelHorizontalAlignment = labelOptions.horizontalAlignment;
                        var labelIsInside = "inside" === labelOptions.position;
                        var label = item.label;
                        var box = item.labelBBox;
                        var translateX;
                        var translateY;
                        if (null === label || box.isEmpty) {
                            return
                        }
                        if (isHorizontal) {
                            if (labelIsInside) {
                                if (labelHorizontalAlignment === LEFT) {
                                    translateX = item.coord - paddingLeftRight - box.x - box.width
                                } else {
                                    translateX = item.coord + paddingLeftRight - box.x
                                }
                                switch (labelVerticalAlignment) {
                                    case CENTER:
                                        translateY = verticalCenter - box.y - box.height / 2;
                                        break;
                                    case BOTTOM:
                                        translateY = canvasBottom - paddingTopBottom - box.y - box.height;
                                        break;
                                    default:
                                        translateY = canvasTop + paddingTopBottom - box.y
                                }
                            } else {
                                if (axisPosition === labelVerticalAlignment) {
                                    maxLabel = _max(maxLabel, box.height + paddingTopBottom)
                                }
                                translateX = item.coord - box.x - box.width / 2;
                                if (labelVerticalAlignment === BOTTOM) {
                                    translateY = canvasBottom + paddingTopBottom - box.y
                                } else {
                                    translateY = canvasTop - paddingTopBottom - box.y - box.height
                                }
                            }
                        } else {
                            if (labelIsInside) {
                                if (labelVerticalAlignment === BOTTOM) {
                                    translateY = item.coord + paddingTopBottom - box.y
                                } else {
                                    translateY = item.coord - paddingTopBottom - box.y - box.height
                                }
                                switch (labelHorizontalAlignment) {
                                    case CENTER:
                                        translateX = horizontalCenter - box.x - box.width / 2;
                                        break;
                                    case RIGHT:
                                        translateX = canvasRight - paddingLeftRight - box.x - box.width;
                                        break;
                                    default:
                                        translateX = canvasLeft + paddingLeftRight - box.x
                                }
                            } else {
                                if (axisPosition === labelHorizontalAlignment) {
                                    maxLabel = _max(maxLabel, box.width + paddingLeftRight)
                                }
                                translateY = item.coord - box.y - box.height / 2;
                                if (labelHorizontalAlignment === RIGHT) {
                                    translateX = canvasRight + paddingLeftRight - box.x
                                } else {
                                    translateX = canvasLeft - paddingLeftRight - box.x - box.width
                                }
                            }
                        }
                        label.attr({
                            translateX: translateX,
                            translateY: translateY
                        })
                    });
                    return maxLabel
                },
                _drawConstantLinesForEstimating: function(constantLines) {
                    var that = this;
                    var renderer = this._renderer;
                    var group = renderer.g();
                    constantLines.forEach(function(options) {
                        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({
                            align: "center"
                        })
                    });
                    return group.append(renderer.root)
                },
                _estimateLabelHeight: function(bBox, labelOptions) {
                    var height = bBox.height;
                    var drawingType = labelOptions.drawingType;
                    if ("stagger" === this._validateDisplayMode(drawingType) || "stagger" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {
                        height = 2 * height + labelOptions.staggeringSpacing
                    }
                    if ("rotate" === this._validateDisplayMode(drawingType) || "rotate" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {
                        var sinCos = _utils2.default.getCosAndSin(labelOptions.rotationAngle);
                        height = height * sinCos.cos + bBox.width * sinCos.sin
                    }
                    return height && (height + labelOptions.indentFromAxis || 0) || 0
                },
                estimateMargins: function(canvas) {
                    this.updateCanvas(canvas);
                    var that = this;
                    var range = that._getViewportRange();
                    var ticksData = this._createTicksAndLabelFormat(range);
                    var ticks = ticksData.ticks;
                    var tickInterval = ticksData.tickInterval;
                    var options = this._options;
                    var constantLineOptions = that._outsideConstantLines.filter(function(l) {
                        return l.labelOptions.visible
                    }).map(function(l) {
                        return l.options
                    });
                    var rootElement = that._renderer.root;
                    var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;
                    var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);
                    var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);
                    var titleElement = that._drawTitleText(rootElement, {
                        x: 0,
                        y: 0
                    });
                    var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);
                    var labelBox = labelElement && labelElement.getBBox() || {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                    var titleBox = titleElement && titleElement.getBBox() || {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                    var constantLinesBox = constantLinesLabelsElement.getBBox();
                    var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;
                    var labelHeight = that._estimateLabelHeight(labelBox, options.label);
                    var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;
                    var height = labelHeight + titleHeight;
                    var margins = {
                        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),
                        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),
                        top: ("top" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, "top", constantLinesHeight),
                        bottom: ("top" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, "bottom", constantLinesHeight)
                    };
                    labelElement && labelElement.remove();
                    titleElement && titleElement.remove();
                    constantLinesLabelsElement && constantLinesLabelsElement.remove();
                    return margins
                },
                _checkAlignmentConstantLineLabels: function(labelOptions) {
                    var position = labelOptions.position;
                    var verticalAlignment = (labelOptions.verticalAlignment || "").toLowerCase();
                    var horizontalAlignment = (labelOptions.horizontalAlignment || "").toLowerCase();
                    if (this._isHorizontal) {
                        if ("outside" === position) {
                            verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
                            horizontalAlignment = CENTER
                        } else {
                            verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;
                            horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT
                        }
                    } else {
                        if ("outside" === position) {
                            verticalAlignment = CENTER;
                            horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT
                        } else {
                            verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
                            horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT
                        }
                    }
                    labelOptions.verticalAlignment = verticalAlignment;
                    labelOptions.horizontalAlignment = horizontalAlignment
                },
                _getConstantLineLabelsCoords: function(value, lineLabelOptions) {
                    var that = this;
                    var x = value;
                    var y = value;
                    if (that._isHorizontal) {
                        y = that._orthogonalPositions["top" === lineLabelOptions.verticalAlignment ? "start" : "end"]
                    } else {
                        x = that._orthogonalPositions["right" === lineLabelOptions.horizontalAlignment ? "end" : "start"]
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _getAdjustedStripLabelCoords: function(strip) {
                    var stripOptions = strip.options;
                    var paddingTopBottom = stripOptions.paddingTopBottom;
                    var paddingLeftRight = stripOptions.paddingLeftRight;
                    var horizontalAlignment = stripOptions.label.horizontalAlignment;
                    var verticalAlignment = stripOptions.label.verticalAlignment;
                    var box = strip.labelBBox;
                    var labelHeight = box.height;
                    var labelWidth = box.width;
                    var labelCoords = strip.labelCoords;
                    var y = labelCoords.y - box.y;
                    var x = labelCoords.x - box.x;
                    if (verticalAlignment === TOP) {
                        y += paddingTopBottom
                    } else {
                        if (verticalAlignment === CENTER) {
                            y -= labelHeight / 2
                        } else {
                            if (verticalAlignment === BOTTOM) {
                                y -= paddingTopBottom + labelHeight
                            }
                        }
                    }
                    if (horizontalAlignment === LEFT) {
                        x += paddingLeftRight
                    } else {
                        if (horizontalAlignment === CENTER) {
                            x -= labelWidth / 2
                        } else {
                            if (horizontalAlignment === RIGHT) {
                                x -= paddingLeftRight + labelWidth
                            }
                        }
                    }
                    return {
                        translateX: x,
                        translateY: y
                    }
                },
                _adjustTitle: function(offset) {
                    offset = offset || 0;
                    if (!this._title) {
                        return
                    }
                    var that = this;
                    var options = that._options;
                    var position = options.position;
                    var margin = options.title.margin;
                    var title = that._title;
                    var boxTitle = title.bBox;
                    var x = boxTitle.x;
                    var y = boxTitle.y;
                    var width = boxTitle.width;
                    var height = boxTitle.height;
                    var axisPosition = that._axisPosition;
                    var loCoord = axisPosition - margin - offset;
                    var hiCoord = axisPosition + margin + offset;
                    var params = {};
                    if (that._isHorizontal) {
                        if (position === TOP) {
                            params.translateY = loCoord - (y + height)
                        } else {
                            params.translateY = hiCoord - y
                        }
                    } else {
                        if (position === LEFT) {
                            params.translateX = loCoord - (x + width)
                        } else {
                            params.translateX = hiCoord - x
                        }
                    }
                    title.element.attr(params)
                },
                _checkTitleOverflow: function(titleElement) {
                    if (!this._title && !titleElement) {
                        return
                    }
                    var canvasLength = this._getScreenDelta();
                    var title = titleElement ? {
                        bBox: titleElement.getBBox(),
                        element: titleElement
                    } : this._title;
                    var titleOptions = this._options.title;
                    var boxTitle = title.bBox;
                    if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {
                        title.element.setMaxSize(canvasLength, void 0, {
                            wordWrap: titleOptions.wordWrap || "none",
                            textOverflow: titleOptions.textOverflow || "ellipsis"
                        });
                        this._wrapped = titleOptions.wordWrap && "none" !== titleOptions.wordWrap
                    } else {
                        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);
                        !this._wrapped && moreThanOriginalSize && title.element.restoreText()
                    }
                },
                coordsIn: function(x, y) {
                    var canvas = this.getCanvas();
                    var isHorizontal = this._options.isHorizontal;
                    var position = this._options.position;
                    var coord = isHorizontal ? y : x;
                    if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {
                        return false
                    }
                    if (isHorizontal && position === _axes_constants2.default.top || !isHorizontal && position === _axes_constants2.default.left) {
                        return coord < canvas[position]
                    }
                    return coord > canvas[isHorizontal ? "height" : "width"] - canvas[position]
                },
                _boundaryTicksVisibility: {
                    min: true,
                    max: true
                },
                adjust: function(alignToBounds) {
                    var that = this;
                    var seriesData = that._seriesData;
                    var viewport = {
                        min: seriesData.min,
                        max: seriesData.max
                    };
                    if (!alignToBounds) {
                        viewport = that._series.filter(function(s) {
                            return s.isVisible()
                        }).reduce(function(range, s) {
                            var seriesRange = s.getViewport();
                            range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;
                            range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;
                            if (s.showZero) {
                                range = new _range2.default.Range(range);
                                range.correctValueZeroLevel()
                            }
                            return range
                        }, {})
                    }
                    if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {
                        seriesData.minVisible = viewport.min;
                        seriesData.maxVisible = viewport.max
                    }
                    that._translator.updateBusinessRange(that.adjustViewport(seriesData));
                    that._breaks = that._getScaleBreaks(that._options, {
                        minVisible: seriesData.minVisible,
                        maxVisible: seriesData.maxVisible
                    }, that._series, that.isArgumentAxis)
                },
                hasWrap: function() {
                    return this._wrapped
                },
                getAxisPosition: function() {
                    return this._axisPosition
                },
                _getStick: function() {
                    return !this._options.valueMarginsEnabled
                },
                _getStripLabelCoords: function(from, to, stripLabelOptions) {
                    var that = this;
                    var orthogonalPositions = that._orthogonalPositions;
                    var isHorizontal = that._isHorizontal;
                    var horizontalAlignment = stripLabelOptions.horizontalAlignment;
                    var verticalAlignment = stripLabelOptions.verticalAlignment;
                    var x;
                    var y;
                    if (isHorizontal) {
                        if (horizontalAlignment === CENTER) {
                            x = from + (to - from) / 2
                        } else {
                            if (horizontalAlignment === LEFT) {
                                x = from
                            } else {
                                if (horizontalAlignment === RIGHT) {
                                    x = to
                                }
                            }
                        }
                        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)]
                    } else {
                        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];
                        if (verticalAlignment === TOP) {
                            y = from
                        } else {
                            if (verticalAlignment === CENTER) {
                                y = to + (from - to) / 2
                            } else {
                                if (verticalAlignment === BOTTOM) {
                                    y = to
                                }
                            }
                        }
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _getTranslatedValue: function(value, offset) {
                    var pos1 = this._translator.translate(value, offset, "semidiscrete" === this._options.type && this._options.tickInterval);
                    var pos2 = this._axisPosition;
                    var isHorizontal = this._isHorizontal;
                    return {
                        x: isHorizontal ? pos1 : pos2,
                        y: isHorizontal ? pos2 : pos1
                    }
                },
                areCoordsOutsideAxis: function(coords) {
                    var coord = this._isHorizontal ? coords.x : coords.y;
                    var visibleArea = this.getVisibleArea();
                    if (coord < visibleArea[0] || coord > visibleArea[1]) {
                        return true
                    }
                    return false
                },
                _getSkippedCategory: function(ticks) {
                    var skippedCategory;
                    if (this._options.type === _axes_constants2.default.discrete && this._tickOffset && 0 !== ticks.length) {
                        skippedCategory = ticks[ticks.length - 1]
                    }
                    return skippedCategory
                },
                _getScaleBreaks: function(axisOptions, viewport, series, isArgumentAxis) {
                    var that = this;
                    var breaks = (axisOptions.breaks || []).map(function(b) {
                        return {
                            from: that.parser(b.startValue),
                            to: that.parser(b.endValue)
                        }
                    });
                    if ("discrete" !== axisOptions.type && "datetime" === axisOptions.dataType && axisOptions.workdaysOnly) {
                        breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays))
                    }
                    if (!isArgumentAxis && "discrete" !== axisOptions.type && "datetime" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {
                        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport))
                    }
                    return filterBreaks(sortingBreaks(breaks), viewport, axisOptions.breakStyle)
                },
                _drawBreak: function(translatedEnd, positionFrom, positionTo, width, options, group) {
                    var that = this;
                    var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);
                    var attr = {
                        "stroke-width": 1,
                        stroke: options.borderColor,
                        sharp: !options.isWaved ? options.isHorizontal ? "h" : "v" : void 0
                    };
                    var spaceAttr = {
                        stroke: options.color,
                        "stroke-width": width
                    };
                    var getPoints = that._isHorizontal ? rotateLine : function(p) {
                        return p
                    };
                    var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);
                    drawer(width / 2, spaceAttr);
                    drawer(0, attr);
                    drawer(width, attr)
                },
                _createBreakClipRect: function(from, to) {
                    var that = this;
                    var canvas = that._canvas;
                    var clipWidth = to - from;
                    var clipRect;
                    if (that._isHorizontal) {
                        clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth)
                    } else {
                        clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height)
                    }
                    that._breaksElements = that._breaksElements || [];
                    that._breaksElements.push(clipRect);
                    return clipRect.id
                },
                _createBreaksGroup: function(clipFrom, clipTo) {
                    var that = this;
                    var group = that._renderer.g().attr({
                        "class": that._axisCssPrefix + "breaks",
                        "clip-path": that._createBreakClipRect(clipFrom, clipTo)
                    }).append(that._scaleBreaksGroup);
                    that._breaksElements = that._breaksElements || [];
                    that._breaksElements.push(group);
                    return group
                },
                _disposeBreaksGroup: function() {
                    (this._breaksElements || []).forEach(function(clipRect) {
                        clipRect.dispose()
                    });
                    this._breaksElements = null
                },
                drawScaleBreaks: function(customCanvas) {
                    var that = this;
                    var options = that._options;
                    var breakStyle = options.breakStyle;
                    var position = options.position;
                    var positionFrom;
                    var positionTo;
                    var breaks = that._translator.getBusinessRange().breaks || [];
                    var additionGroup;
                    var additionBreakFrom;
                    var additionBreakTo;
                    that._disposeBreaksGroup();
                    if (!(breaks && breaks.length)) {
                        return
                    }
                    var breakOptions = {
                        color: that._options.containerColor,
                        borderColor: breakStyle.color,
                        isHorizontal: that._isHorizontal,
                        isWaved: "straight" !== breakStyle.line.toLowerCase()
                    };
                    if (customCanvas) {
                        positionFrom = customCanvas.start;
                        positionTo = customCanvas.end
                    } else {
                        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);
                        positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0)
                    }
                    var mainGroup = that._createBreaksGroup(positionFrom, positionTo);
                    if (that._axisShift && options.visible) {
                        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;
                        additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;
                        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo)
                    }
                    breaks.forEach(function(br) {
                        if (!br.gapSize) {
                            var breakCoord = that._getTranslatedCoord(br.to);
                            that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);
                            if (that._axisShift && options.visible) {
                                that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup)
                            }
                        }
                    })
                },
                _getSpiderCategoryOption: _common.noop,
                shift: function(margins) {
                    var that = this;
                    var options = that._options;
                    var isHorizontal = options.isHorizontal;
                    var axesSpacing = that.getMultipleAxesSpacing();
                    var constantLinesGroups = that._axisConstantLineGroups;

                    function shiftGroup(side, group) {
                        var attr = {
                            translateX: 0,
                            translateY: 0
                        };
                        var shift = margins[side] ? margins[side] + axesSpacing : 0;
                        attr[isHorizontal ? "translateY" : "translateX"] = (side === LEFT || side === TOP ? -1 : 1) * shift;
                        (group[side] || group).attr(attr);
                        return shift
                    }
                    that._axisShift = shiftGroup(options.position, that._axisGroup);
                    (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(function(side) {
                        shiftGroup(side, constantLinesGroups.above);
                        shiftGroup(side, constantLinesGroups.under)
                    })
                },
                getCustomPosition: function(position) {
                    var that = this;
                    var oppositeAxis = that.getOppositeAxis();
                    var resolvedPosition = null !== position && void 0 !== position ? position : that.getResolvedPositionOption();
                    var offset = that.getOptions().offset;
                    var oppositeTranslator = oppositeAxis.getTranslator();
                    var oppositeAxisType = oppositeAxis.getOptions().type;
                    var validPosition = oppositeAxis.validateUnit(resolvedPosition);
                    var currentPosition;
                    if ("discrete" === oppositeAxisType && (!oppositeTranslator._categories || oppositeTranslator._categories.indexOf(validPosition) < 0)) {
                        validPosition = void 0
                    }
                    if (that.positionIsBoundary(resolvedPosition)) {
                        currentPosition = that.getPredefinedPosition(resolvedPosition)
                    } else {
                        if (!(0, _type.isDefined)(validPosition)) {
                            currentPosition = that.getPredefinedPosition(that.getOptions().position)
                        } else {
                            currentPosition = oppositeTranslator.to(validPosition, -1)
                        }
                    }
                    if (isFinite(currentPosition) && isFinite(offset)) {
                        currentPosition += offset
                    }
                    return currentPosition
                },
                getCustomBoundaryPosition: function(position) {
                    var that = this;
                    var oppositeAxis = that.getOppositeAxis();
                    var resolvedPosition = null !== position && void 0 !== position ? position : that.getResolvedPositionOption();
                    var oppositeTranslator = oppositeAxis.getTranslator();
                    var visibleArea = oppositeTranslator.getCanvasVisibleArea();
                    if (!(0, _type.isDefined)(oppositeAxis._orthogonalPositions) || 0 === oppositeTranslator.canvasLength) {
                        return
                    }
                    var currentPosition = that.getCustomPosition(resolvedPosition);
                    if (!(0, _type.isDefined)(currentPosition)) {
                        return that.getResolvedBoundaryPosition()
                    } else {
                        if (currentPosition <= visibleArea.min) {
                            return that._isHorizontal ? TOP : LEFT
                        } else {
                            if (currentPosition >= visibleArea.max) {
                                return that._isHorizontal ? BOTTOM : RIGHT
                            }
                        }
                    }
                    return currentPosition
                },
                getResolvedPositionOption: function() {
                    var _options$customPositi;
                    var options = this.getOptions();
                    return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position
                },
                customPositionIsAvailable: function() {
                    var options = this.getOptions();
                    return (0, _type.isDefined)(this.getOppositeAxis()) && ((0, _type.isDefined)(options.customPosition) || isFinite(options.offset))
                },
                hasCustomPosition: function() {
                    return this.customPositionIsAvailable() && !this.customPositionIsBoundary()
                },
                getResolvedBoundaryPosition: function() {
                    return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position
                },
                customPositionEqualsToPredefined: function() {
                    return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position
                },
                customPositionIsBoundary: function() {
                    return this.positionIsBoundary(this._customBoundaryPosition)
                },
                positionIsBoundary: function(position) {
                    return [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0
                },
                getPredefinedPosition: function(position) {
                    var _this$_orthogonalPosi;
                    return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? "start" : "end"]
                }
            }
        };

        function getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {
            var elementType = isWaved ? "bezier" : "line";
            var group = renderer.g().append(root);
            return function(offset, attr) {
                renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group)
            }
        }

        function getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {
            if (!isWaved) {
                return [positionFrom, breakStart + offset, positionTo, breakStart + offset]
            }
            breakStart += offset;
            var currentPosition;
            var topPoint = breakStart + WAVED_LINE_TOP;
            var centerPoint = breakStart + WAVED_LINE_CENTER;
            var bottomPoint = breakStart + WAVED_LINE_BOTTOM;
            var points = [
                [positionFrom, centerPoint]
            ];
            for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {
                points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint])
            }
            return [].concat.apply([], points)
        }

        function rotateLine(lineCoords) {
            var points = [];
            var i;
            for (i = 0; i < lineCoords.length; i += 2) {
                points.push(lineCoords[i + 1]);
                points.push(lineCoords[i])
            }
            return points
        }
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/core/series_family.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _math = __webpack_require__( /*! ../../core/utils/math */ 31);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _utils = __webpack_require__( /*! ./utils */ 13);
        var round = Math.round,
            abs = Math.abs,
            pow = Math.pow,
            sqrt = Math.sqrt;
        var _min = Math.min;
        var DEFAULT_BAR_GROUP_PADDING = .3;

        function validateBarPadding(barPadding) {
            return barPadding < 0 || barPadding > 1 ? void 0 : barPadding
        }

        function validateBarGroupPadding(barGroupPadding) {
            return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding
        }

        function isStackExist(series, arg, equalBarWidth) {
            return series.some(function(s) {
                return equalBarWidth && !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function(point) {
                    return point.hasValue()
                })
            })
        }

        function correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {
            series.forEach(function(series) {
                var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);
                var points = series.getPointsByArg(arg, true);
                var barPadding = validateBarPadding(series.getOptions().barPadding);
                var barWidth = series.getOptions().barWidth;
                var offset = getOffset(stackIndex, parameters);
                var width = parameters.width;
                var extraParameters;
                if (stackIndex === -1) {
                    return
                }
                if ((0, _type.isDefined)(barPadding) || (0, _type.isDefined)(barWidth)) {
                    extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);
                    width = extraParameters.width;
                    offset = getOffset(stackIndex, extraParameters)
                }
                correctPointCoordinates(points, width, offset)
            })
        }

        function adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {
            var commonStacks = [];
            var allArguments = [];
            var seriesInStacks = {};
            var barWidth = options.barWidth;
            var barGroupWidth = options.barGroupWidth;
            var interval = series[0] && series[0].getArgumentAxis().getTranslator().getInterval();
            var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));
            series.forEach(function(s, i) {
                var stackName = s.getStackName() || s.getBarOverlapGroup() || i.toString();
                var argument;
                for (argument in s.pointsByArgument) {
                    if (allArguments.indexOf(argument.valueOf()) === -1) {
                        allArguments.push(argument.valueOf())
                    }
                }
                if (commonStacks.indexOf(stackName) === -1) {
                    commonStacks.push(stackName);
                    seriesInStacks[stackName] = []
                }
                seriesInStacks[stackName].push(s)
            });
            allArguments.forEach(function(arg) {
                var currentStacks = commonStacks.reduce(function(stacks, stack) {
                    if (isStackExist(seriesInStacks[stack], arg, options.equalBarWidth)) {
                        stacks.push(stack)
                    }
                    return stacks
                }, []);
                var parameters = calculateParams(barsArea, currentStacks.length, barWidth);
                commonStacks.forEach(function(stack) {
                    correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback)
                })
            })
        }

        function calculateParams(barsArea, count, percentWidth, fixedBarWidth) {
            var spacing;
            var width;
            if (fixedBarWidth) {
                width = _min(fixedBarWidth, round(barsArea / count));
                spacing = count > 1 ? round((barsArea - width * count) / (count - 1)) : 0
            } else {
                if ((0, _type.isDefined)(percentWidth)) {
                    width = round(barsArea * percentWidth / count);
                    spacing = round(count > 1 ? (barsArea - barsArea * percentWidth) / (count - 1) : 0)
                } else {
                    spacing = round(barsArea / count * .2);
                    width = round((barsArea - spacing * (count - 1)) / count)
                }
            }
            return {
                width: width > 1 ? width : 1,
                spacing: spacing,
                middleIndex: count / 2
            }
        }

        function getOffset(stackIndex, parameters) {
            return (stackIndex - parameters.middleIndex + .5) * parameters.width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing
        }

        function correctPointCoordinates(points, width, offset) {
            (0, _iterator.each)(points, function(_, point) {
                point.correctCoordinates({
                    width: width,
                    offset: offset
                })
            })
        }

        function getValueType(value) {
            return value >= 0 ? "positive" : "negative"
        }

        function getVisibleSeries(that) {
            return that.series.filter(function(s) {
                return s.isVisible()
            })
        }

        function getAbsStackSumByArg(stackKeepers, stackName, argument) {
            var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;
            var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;
            return positiveStackValue + negativeStackValue
        }

        function getStackSumByArg(stackKeepers, stackName, argument) {
            var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;
            var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;
            return positiveStackValue + negativeStackValue
        }

        function getSeriesStackIndexCallback(inverted) {
            if (!inverted) {
                return function(index) {
                    return index
                }
            } else {
                return function(index, stackCount) {
                    return stackCount - index - 1
                }
            }
        }

        function isInverted(series) {
            return series[0] && series[0].getArgumentAxis().getTranslator().isInverted()
        }

        function adjustBarSeriesDimensions() {
            var series = getVisibleSeries(this);
            adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)))
        }

        function getFirstValueSign(series) {
            var points = series.getPoints();
            var value;
            for (var i = 0; i < points.length; i++) {
                var point = points[i];
                value = point.initialValue && point.initialValue.valueOf();
                if (abs(value) > 0) {
                    break
                }
            }
            return (0, _math.sign)(value)
        }

        function adjustStackedSeriesValues() {
            var that = this;
            var negativesAsZeroes = that._options.negativesAsZeroes;
            var series = getVisibleSeries(that);
            var stackKeepers = {
                positive: {},
                negative: {}
            };
            var holesStack = {
                left: {},
                right: {}
            };
            var lastSeriesInPositiveStack = {};
            var lastSeriesInNegativeStack = {};
            series.forEach(function(singleSeries) {
                var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();
                var hole = false;
                var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;
                singleSeries._prevSeries = stack[stackName];
                stack[stackName] = singleSeries;
                singleSeries.holes = (0, _extend.extend)(true, {}, holesStack);
                singleSeries.getPoints().forEach(function(point, index, points) {
                    var value = point.initialValue && point.initialValue.valueOf();
                    var argument = point.argument.valueOf();
                    var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;
                    var isNotBarSeries = "bar" !== singleSeries.type;
                    if (negativesAsZeroes && value < 0) {
                        stacks = stackKeepers.positive;
                        value = 0;
                        point.resetValue()
                    }
                    stacks[stackName] = stacks[stackName] || {};
                    var currentStack = stacks[stackName];
                    if (currentStack[argument]) {
                        if (isNotBarSeries) {
                            point.correctValue(currentStack[argument])
                        }
                        currentStack[argument] += value
                    } else {
                        currentStack[argument] = value;
                        if (isNotBarSeries) {
                            point.resetCorrection()
                        }
                    }
                    if (!point.hasValue()) {
                        var prevPoint = points[index - 1];
                        if (!hole && prevPoint && prevPoint.hasValue()) {
                            argument = prevPoint.argument.valueOf();
                            prevPoint._skipSetRightHole = true;
                            holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0))
                        }
                        hole = true
                    } else {
                        if (hole) {
                            hole = false;
                            holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));
                            point._skipSetLeftHole = true
                        }
                    }
                })
            });
            series.forEach(function(singleSeries) {
                var holes = singleSeries.holes;
                singleSeries.getPoints().forEach(function(point) {
                    var argument = point.argument.valueOf();
                    point.resetHoles();
                    !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, "left");
                    !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, "right");
                    point._skipSetLeftHole = null;
                    point._skipSetRightHole = null
                })
            });
            that._stackKeepers = stackKeepers;
            series.forEach(function(singleSeries) {
                singleSeries.getPoints().forEach(function(point) {
                    var argument = point.argument.valueOf();
                    var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();
                    var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);
                    var total = getStackSumByArg(stackKeepers, stackName, argument);
                    point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument])
                })
            })
        }

        function updateStackedSeriesValues() {
            var that = this;
            var series = getVisibleSeries(that);
            var stack = that._stackKeepers;
            var stackKeepers = {
                positive: {},
                negative: {}
            };
            (0, _iterator.each)(series, function(_, singleSeries) {
                var minBarSize = singleSeries.getOptions().minBarSize;
                var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
                var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
                var stackName = singleSeries.getStackName();
                (0, _iterator.each)(singleSeries.getPoints(), function(index, point) {
                    if (!point.hasValue()) {
                        return
                    }
                    var value = point.initialValue && point.initialValue.valueOf();
                    var argument = point.argument.valueOf();
                    if (that.fullStacked) {
                        value = value / getAbsStackSumByArg(stack, stackName, argument) || 0
                    }
                    var updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);
                    var valueType = getValueType(updateValue);
                    var currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                    if (currentStack[argument]) {
                        point.minValue = currentStack[argument];
                        currentStack[argument] += updateValue
                    } else {
                        currentStack[argument] = updateValue
                    }
                    point.value = currentStack[argument]
                })
            });
            if (that.fullStacked) {
                updateFullStackedSeriesValues(series, stackKeepers)
            }
        }

        function updateFullStackedSeriesValues(series, stackKeepers) {
            (0, _iterator.each)(series, function(_, singleSeries) {
                var stackName = singleSeries.getStackName ? singleSeries.getStackName() : "default";
                (0, _iterator.each)(singleSeries.getPoints(), function(index, point) {
                    var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());
                    point.value = point.value / stackSum;
                    if ((0, _type.isNumeric)(point.minValue)) {
                        point.minValue = point.minValue / stackSum
                    }
                })
            })
        }

        function updateBarSeriesValues() {
            (0, _iterator.each)(this.series, function(_, singleSeries) {
                var minBarSize = singleSeries.getOptions().minBarSize;
                var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
                var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
                if (minShownBusinessValue) {
                    (0, _iterator.each)(singleSeries.getPoints(), function(index, point) {
                        if (point.hasValue()) {
                            point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue)
                        }
                    })
                }
            })
        }

        function adjustCandlestickSeriesDimensions() {
            var series = getVisibleSeries(this);
            adjustBarSeriesDimensionsCore(series, {
                barWidth: null,
                equalBarWidth: true,
                barGroupPadding: .3
            }, getSeriesStackIndexCallback(isInverted(series)))
        }

        function adjustBubbleSeriesDimensions() {
            var series = getVisibleSeries(this);
            if (!series.length) {
                return
            }
            var options = this._options;
            var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();
            var visibleAreaY = series[0].getValueAxis().getVisibleArea();
            var min = _min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);
            var minBubbleArea = pow(options.minBubbleSize, 2);
            var maxBubbleArea = pow(min * options.maxBubbleSize, 2);
            var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;
            var minPointSize = 1 / 0;
            var maxPointSize = -(1 / 0);
            var pointSize;
            var bubbleArea;
            var sizeProportion;
            (0, _iterator.each)(series, function(_, seriesItem) {
                (0, _iterator.each)(seriesItem.getPoints(), function(_, point) {
                    maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;
                    minPointSize = minPointSize < point.size ? minPointSize : point.size
                })
            });
            var sizeDispersion = maxPointSize - minPointSize;
            var areaDispersion = abs(maxBubbleArea - minBubbleArea);
            (0, _iterator.each)(series, function(_, seriesItem) {
                (0, _iterator.each)(seriesItem.getPoints(), function(_, point) {
                    if (maxPointSize === minPointSize) {
                        pointSize = round(equalBubbleSize)
                    } else {
                        sizeProportion = abs(point.size - minPointSize) / sizeDispersion;
                        bubbleArea = areaDispersion * sizeProportion + minBubbleArea;
                        pointSize = round(sqrt(bubbleArea))
                    }
                    point.correctCoordinates(pointSize)
                })
            })
        }

        function SeriesFamily(options) {
            var debug = __webpack_require__( /*! ../../core/utils/console */ 65).debug;
            debug.assert(options.type, "type was not passed or empty");
            var that = this;
            that.type = (0, _utils.normalizeEnum)(options.type);
            that.pane = options.pane;
            that.series = [];
            that.updateOptions(options);
            switch (that.type) {
                case "bar":
                    that.adjustSeriesDimensions = adjustBarSeriesDimensions;
                    that.updateSeriesValues = updateBarSeriesValues;
                    that.adjustSeriesValues = adjustStackedSeriesValues;
                    break;
                case "rangebar":
                    that.adjustSeriesDimensions = adjustBarSeriesDimensions;
                    break;
                case "fullstackedbar":
                    that.fullStacked = true;
                    that.adjustSeriesDimensions = adjustBarSeriesDimensions;
                    that.adjustSeriesValues = adjustStackedSeriesValues;
                    that.updateSeriesValues = updateStackedSeriesValues;
                    break;
                case "stackedbar":
                    that.adjustSeriesDimensions = adjustBarSeriesDimensions;
                    that.adjustSeriesValues = adjustStackedSeriesValues;
                    that.updateSeriesValues = updateStackedSeriesValues;
                    break;
                case "fullstackedarea":
                case "fullstackedline":
                case "fullstackedspline":
                case "fullstackedsplinearea":
                    that.fullStacked = true;
                    that.adjustSeriesValues = adjustStackedSeriesValues;
                    break;
                case "stackedarea":
                case "stackedsplinearea":
                case "stackedline":
                case "stackedspline":
                    that.adjustSeriesValues = adjustStackedSeriesValues;
                    break;
                case "candlestick":
                case "stock":
                    that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;
                    break;
                case "bubble":
                    that.adjustSeriesDimensions = adjustBubbleSeriesDimensions
            }
        }
        exports.SeriesFamily = SeriesFamily;
        SeriesFamily.prototype = {
            constructor: SeriesFamily,
            adjustSeriesDimensions: _common.noop,
            adjustSeriesValues: _common.noop,
            updateSeriesValues: _common.noop,
            updateOptions: function(options) {
                this._options = options
            },
            dispose: function() {
                this.series = null
            },
            add: function(series) {
                var type = this.type;
                this.series = (0, _utils.map)(series, function(singleSeries) {
                    return singleSeries.type === type ? singleSeries : null
                })
            }
        }
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/crosshair.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var math = Math;
        var mathAbs = math.abs;
        var mathMin = math.min;
        var mathMax = math.max;
        var mathFloor = math.floor;
        var HORIZONTAL = "horizontal";
        var VERTICAL = "vertical";
        var LABEL_BACKGROUND_PADDING_X = 8;
        var LABEL_BACKGROUND_PADDING_Y = 4;
        var CENTER = "center";
        var RIGHT = "right";
        var LEFT = "left";
        var TOP = "top";
        var BOTTOM = "bottom";
        exports.getMargins = function() {
            return {
                x: LABEL_BACKGROUND_PADDING_X,
                y: LABEL_BACKGROUND_PADDING_Y
            }
        };

        function getRectangleBBox(bBox) {
            return {
                x: bBox.x - LABEL_BACKGROUND_PADDING_X,
                y: bBox.y - LABEL_BACKGROUND_PADDING_Y,
                width: bBox.width + 2 * LABEL_BACKGROUND_PADDING_X,
                height: bBox.height + 2 * LABEL_BACKGROUND_PADDING_Y
            }
        }

        function getLabelCheckerPosition(x, y, isHorizontal, canvas) {
            var params = isHorizontal ? ["x", "width", "y", "height", y, 0] : ["y", "height", "x", "width", x, 1];
            return function(bBox, position, coord) {
                var labelCoord = {
                    x: coord.x,
                    y: coord.y
                };
                var rectangleBBox = getRectangleBBox(bBox);
                var delta = isHorizontal ? coord.y - bBox.y - bBox.height / 2 : coord.y - bBox.y;
                labelCoord.y = isHorizontal || !isHorizontal && position === BOTTOM ? coord.y + delta : coord.y;
                if (rectangleBBox[params[0]] < 0) {
                    labelCoord[params[0]] -= rectangleBBox[params[0]]
                } else {
                    if (rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] > canvas[params[1]]) {
                        labelCoord[params[0]] -= rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] - canvas[params[1]]
                    }
                }
                if (params[4] - rectangleBBox[params[3]] / 2 < 0) {
                    labelCoord[params[2]] -= params[4] - rectangleBBox[params[3]] / 2
                } else {
                    if (params[4] + rectangleBBox[params[3]] / 2 > canvas[params[3]]) {
                        labelCoord[params[2]] -= params[4] + rectangleBBox[params[3]] / 2 - canvas[params[3]]
                    }
                }
                return labelCoord
            }
        }

        function Crosshair(renderer, options, params, group) {
            var that = this;
            that._renderer = renderer;
            that._crosshairGroup = group;
            that._options = {};
            that.update(options, params)
        }
        Crosshair.prototype = {
            constructor: Crosshair,
            update: function(options, params) {
                var that = this;
                var canvas = params.canvas;
                that._canvas = {
                    top: canvas.top,
                    bottom: canvas.height - canvas.bottom,
                    left: canvas.left,
                    right: canvas.width - canvas.right,
                    width: canvas.width,
                    height: canvas.height
                };
                that._axes = params.axes;
                that._panes = params.panes;
                that._prepareOptions(options, HORIZONTAL);
                that._prepareOptions(options, VERTICAL)
            },
            dispose: function() {
                var that = this;
                that._renderer = that._crosshairGroup = that._options = that._axes = that._canvas = that._horizontalGroup = that._verticalGroup = that._horizontal = that._vertical = that._circle = that._panes = null
            },
            _prepareOptions: function(options, direction) {
                var lineOptions = options[direction + "Line"];
                this._options[direction] = {
                    visible: lineOptions.visible,
                    line: {
                        stroke: lineOptions.color || options.color,
                        "stroke-width": lineOptions.width || options.width,
                        dashStyle: lineOptions.dashStyle || options.dashStyle,
                        opacity: lineOptions.opacity || options.opacity,
                        "stroke-linecap": "butt"
                    },
                    label: (0, _extend.extend)(true, {}, options.label, lineOptions.label)
                }
            },
            _createLines: function(options, sharpParam, group) {
                var lines = [];
                var canvas = this._canvas;
                var points = [canvas.left, canvas.top, canvas.left, canvas.top];
                for (var i = 0; i < 2; i++) {
                    lines.push(this._renderer.path(points, "line").attr(options).sharp(sharpParam).append(group))
                }
                return lines
            },
            render: function() {
                var that = this;
                var renderer = that._renderer;
                var options = that._options;
                var verticalOptions = options.vertical;
                var horizontalOptions = options.horizontal;
                var extraOptions = horizontalOptions.visible ? horizontalOptions.line : verticalOptions.line;
                var circleOptions = {
                    stroke: extraOptions.stroke,
                    "stroke-width": extraOptions["stroke-width"],
                    dashStyle: extraOptions.dashStyle,
                    opacity: extraOptions.opacity
                };
                var canvas = that._canvas;
                that._horizontal = {};
                that._vertical = {};
                that._circle = renderer.circle(canvas.left, canvas.top, 0).attr(circleOptions).append(that._crosshairGroup);
                that._horizontalGroup = renderer.g().append(that._crosshairGroup);
                that._verticalGroup = renderer.g().append(that._crosshairGroup);
                if (verticalOptions.visible) {
                    that._vertical.lines = that._createLines(verticalOptions.line, "h", that._verticalGroup);
                    that._vertical.labels = that._createLabels(that._axes[0], verticalOptions, false, that._verticalGroup)
                }
                if (horizontalOptions.visible) {
                    that._horizontal.lines = that._createLines(horizontalOptions.line, "v", that._horizontalGroup);
                    that._horizontal.labels = that._createLabels(that._axes[1], horizontalOptions, true, that._horizontalGroup)
                }
                that.hide()
            },
            _createLabels: function(axes, options, isHorizontal, group) {
                var that = this;
                var canvas = that._canvas;
                var renderer = that._renderer;
                var x;
                var y;
                var text;
                var labels = [];
                var background;
                var currentLabelPos;
                var labelOptions = options.label;
                if (labelOptions.visible) {
                    axes.forEach(function(axis) {
                        var position = axis.getOptions().position;
                        if (axis.getTranslator().getBusinessRange().isEmpty()) {
                            return
                        }
                        currentLabelPos = axis.getLabelsPosition();
                        if (isHorizontal) {
                            y = canvas.top;
                            x = currentLabelPos
                        } else {
                            x = canvas.left;
                            y = currentLabelPos
                        }
                        var align = position === TOP || position === BOTTOM ? CENTER : position === RIGHT ? LEFT : RIGHT;
                        background = renderer.rect(0, 0, 0, 0).attr({
                            fill: labelOptions.backgroundColor || options.line.stroke
                        }).append(group);
                        text = renderer.text("0", 0, 0).css((0, _utils.patchFontOptions)(options.label.font)).attr({
                            align: align,
                            "class": labelOptions.cssClass
                        }).append(group);
                        labels.push({
                            text: text,
                            background: background,
                            axis: axis,
                            options: labelOptions,
                            pos: {
                                coord: currentLabelPos,
                                side: position
                            },
                            startXY: {
                                x: x,
                                y: y
                            }
                        })
                    })
                }
                return labels
            },
            _updateText: function(value, axisName, labels, point, func) {
                var that = this;
                labels.forEach(function(label) {
                    var axis = label.axis;
                    var coord = label.startXY;
                    var textElement = label.text;
                    var backgroundElement = label.background;
                    var text = "";
                    if (!axis.name || axis.name === axisName) {
                        text = axis.getFormattedValue(value, label.options, point)
                    }
                    if (text) {
                        textElement.attr({
                            text: text,
                            x: coord.x,
                            y: coord.y
                        });
                        textElement.attr(func(textElement.getBBox(), label.pos.side, coord));
                        that._updateLinesCanvas(label);
                        backgroundElement.attr(getRectangleBBox(textElement.getBBox()))
                    } else {
                        textElement.attr({
                            text: ""
                        });
                        backgroundElement.attr({
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        })
                    }
                })
            },
            hide: function() {
                this._crosshairGroup.attr({
                    visibility: "hidden"
                })
            },
            _updateLinesCanvas: function(label) {
                var position = label.pos.side;
                var labelCoord = label.pos.coord;
                var coords = this._linesCanvas;
                var canvas = this._canvas;
                coords[position] = coords[position] !== canvas[position] && mathAbs(coords[position] - canvas[position]) < mathAbs(labelCoord - canvas[position]) ? coords[position] : labelCoord
            },
            _updateLines: function(lines, x, y, r, isHorizontal) {
                var coords = this._linesCanvas;
                var canvas = this._canvas;
                var points = isHorizontal ? [
                    [mathMin(x - r, coords.left), canvas.top, x - r, canvas.top],
                    [x + r, canvas.top, mathMax(coords.right, x + r), canvas.top]
                ] : [
                    [canvas.left, mathMin(coords.top, y - r), canvas.left, y - r],
                    [canvas.left, y + r, canvas.left, mathMax(coords.bottom, y + r)]
                ];
                for (var i = 0; i < 2; i++) {
                    lines[i].attr({
                        points: points[i]
                    }).sharp(isHorizontal ? "v" : "h", isHorizontal ? y === canvas.bottom ? -1 : 1 : x === canvas.right ? -1 : 1)
                }
            },
            _resetLinesCanvas: function() {
                var canvas = this._canvas;
                this._linesCanvas = {
                    left: canvas.left,
                    right: canvas.right,
                    top: canvas.top,
                    bottom: canvas.bottom
                }
            },
            _getClipRectForPane: function(x, y) {
                var panes = this._panes;
                var i;
                var coords;
                for (i = 0; i < panes.length; i++) {
                    coords = panes[i].coords;
                    if (coords.left <= x && coords.right >= x && coords.top <= y && coords.bottom >= y) {
                        return panes[i].clipRect
                    }
                }
                return {
                    id: null
                }
            },
            show: function(data) {
                var that = this;
                var point = data.point;
                var pointData = point.getCrosshairData(data.x, data.y);
                var r = point.getPointRadius();
                var horizontal = that._horizontal;
                var vertical = that._vertical;
                var rad = !r ? 0 : r + 3;
                var canvas = that._canvas;
                var x = mathFloor(pointData.x);
                var y = mathFloor(pointData.y);
                if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {
                    that._crosshairGroup.attr({
                        visibility: "visible"
                    });
                    that._resetLinesCanvas();
                    that._circle.attr({
                        cx: x,
                        cy: y,
                        r: rad,
                        "clip-path": that._getClipRectForPane(x, y).id
                    });
                    if (horizontal.lines) {
                        that._updateText(pointData.yValue, pointData.axis, horizontal.labels, point, getLabelCheckerPosition(x, y, true, canvas));
                        that._updateLines(horizontal.lines, x, y, rad, true);
                        that._horizontalGroup.attr({
                            translateY: y - canvas.top
                        })
                    }
                    if (vertical.lines) {
                        that._updateText(pointData.xValue, pointData.axis, vertical.labels, point, getLabelCheckerPosition(x, y, false, canvas));
                        that._updateLines(vertical.lines, x, y, rad, false);
                        that._verticalGroup.attr({
                            translateX: x - canvas.left
                        })
                    }
                } else {
                    that.hide()
                }
            }
        };
        exports.Crosshair = Crosshair
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/viz/translators/translator1d.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _Number = Number;

        function Translator1D() {
            this.setDomain(arguments[0], arguments[1]).setCodomain(arguments[2], arguments[3])
        }
        Translator1D.prototype = {
            constructor: Translator1D,
            setDomain: function(domain1, domain2) {
                var that = this;
                that._domain1 = _Number(domain1);
                that._domain2 = _Number(domain2);
                that._domainDelta = that._domain2 - that._domain1;
                return that
            },
            setCodomain: function(codomain1, codomain2) {
                var that = this;
                that._codomain1 = _Number(codomain1);
                that._codomain2 = _Number(codomain2);
                that._codomainDelta = that._codomain2 - that._codomain1;
                return that
            },
            getDomain: function() {
                return [this._domain1, this._domain2]
            },
            getCodomain: function() {
                return [this._codomain1, this._codomain2]
            },
            getDomainStart: function() {
                return this._domain1
            },
            getDomainEnd: function() {
                return this._domain2
            },
            getCodomainStart: function() {
                return this._codomain1
            },
            getCodomainEnd: function() {
                return this._codomain2
            },
            getDomainRange: function() {
                return this._domainDelta
            },
            getCodomainRange: function() {
                return this._codomainDelta
            },
            translate: function(value) {
                var ratio = (_Number(value) - this._domain1) / this._domainDelta;
                return 0 <= ratio && ratio <= 1 ? this._codomain1 + ratio * this._codomainDelta : NaN
            },
            adjust: function(value) {
                var ratio = (_Number(value) - this._domain1) / this._domainDelta;
                var result = NaN;
                if (ratio < 0) {
                    result = this._domain1
                } else {
                    if (ratio > 1) {
                        result = this._domain2
                    } else {
                        if (0 <= ratio && ratio <= 1) {
                            result = _Number(value)
                        }
                    }
                }
                return result
            }
        };
        exports.Translator1D = Translator1D
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/base_range_container.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var iterateUtils = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var BaseElement = __webpack_require__( /*! ./base_indicators */ 265).BaseElement;
        var _Number = Number;
        var _abs = Math.abs;
        var _isString = __webpack_require__( /*! ../../core/utils/type */ 1).isString;
        var _isArray = Array.isArray;
        var _isFinite = isFinite;
        var _each = iterateUtils.each;
        var BaseRangeContainer = BaseElement.inherit({
            _init: function() {
                this._root = this._renderer.g().attr({
                    "class": "dxg-range-container"
                }).linkOn(this._container, "range-container")
            },
            _dispose: function() {
                this._root.linkOff()
            },
            clean: function() {
                this._root.linkRemove().clear();
                this._options = this.enabled = null;
                return this
            },
            _getRanges: function() {
                var that = this;
                var options = that._options;
                var translator = that._translator;
                var totalStart = translator.getDomain()[0];
                var totalEnd = translator.getDomain()[1];
                var totalDelta = totalEnd - totalStart;
                var isNotEmptySegment = totalDelta >= 0 ? isNotEmptySegmentAsc : isNotEmptySegmentDesc;
                var subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDesc;
                var list = [];
                var ranges = [];
                var backgroundRanges = [{
                    start: totalStart,
                    end: totalEnd
                }];
                var threshold = _abs(totalDelta) / 1e4;
                var backgroundColor = _isString(options.backgroundColor) ? options.backgroundColor : "none";
                var width = options.width || {};
                var startWidth = _Number(width > 0 ? width : width.start);
                var endWidth = _Number(width > 0 ? width : width.end);
                var deltaWidth = endWidth - startWidth;
                if (void 0 !== options.ranges && !_isArray(options.ranges)) {
                    return null
                }
                if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0)) {
                    return null
                }
                list = (_isArray(options.ranges) ? options.ranges : []).reduce(function(result, rangeOptions, i) {
                    rangeOptions = rangeOptions || {};
                    var start = translator.adjust(rangeOptions.startValue);
                    var end = translator.adjust(rangeOptions.endValue);
                    if (_isFinite(start) && _isFinite(end) && isNotEmptySegment(start, end, threshold)) {
                        result.push({
                            start: start,
                            end: end,
                            color: rangeOptions.color,
                            classIndex: i
                        })
                    }
                    return result
                }, []);
                var palette = that._themeManager.createPalette(options.palette, {
                    type: "indicatingSet",
                    extensionMode: options.paletteExtensionMode,
                    keepLastColorInEnd: true,
                    count: list.length
                });
                _each(list, function(_, item) {
                    var paletteColor = palette.getNextColor();
                    item.color = _isString(item.color) && item.color || paletteColor || "none";
                    item.className = "dxg-range dxg-range-" + item.classIndex;
                    delete item.classIndex
                });
                _each(list, function(_, item) {
                    var i;
                    var ii;
                    var sub;
                    var subs;
                    var range;
                    var newRanges = [];
                    var newBackgroundRanges = [];
                    for (i = 0, ii = ranges.length; i < ii; ++i) {
                        range = ranges[i];
                        subs = subtractSegment(range.start, range.end, item.start, item.end);
                        (sub = subs[0]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
                        (sub = subs[1]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub)
                    }
                    newRanges.push(item);
                    ranges = newRanges;
                    for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {
                        range = backgroundRanges[i];
                        subs = subtractSegment(range.start, range.end, item.start, item.end);
                        (sub = subs[0]) && newBackgroundRanges.push(sub);
                        (sub = subs[1]) && newBackgroundRanges.push(sub)
                    }
                    backgroundRanges = newBackgroundRanges
                });
                _each(backgroundRanges, function(_, range) {
                    range.color = backgroundColor;
                    range.className = "dxg-range dxg-background-range";
                    ranges.push(range)
                });
                _each(ranges, function(_, range) {
                    range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;
                    range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth
                });
                return ranges
            },
            render: function(options) {
                var that = this;
                that._options = options;
                that._processOptions();
                that._ranges = that._getRanges();
                if (that._ranges) {
                    that.enabled = true;
                    that._root.linkAppend()
                }
                return that
            },
            resize: function(layout) {
                var that = this;
                that._root.clear();
                if (that._isVisible(layout)) {
                    _each(that._ranges, function(_, range) {
                        that._createRange(range, layout).attr({
                            fill: range.color,
                            "class": range.className
                        }).append(that._root)
                    })
                }
                return that
            },
            _processOptions: null,
            _isVisible: null,
            _createRange: null,
            getColorForValue: function(value) {
                var color = null;
                _each(this._ranges, function(_, range) {
                    if (range.start <= value && value <= range.end || range.start >= value && value >= range.end) {
                        color = range.color;
                        return false
                    }
                });
                return color
            }
        });

        function subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {
            var result;
            if (otherStart > segmentStart && otherEnd < segmentEnd) {
                result = [{
                    start: segmentStart,
                    end: otherStart
                }, {
                    start: otherEnd,
                    end: segmentEnd
                }]
            } else {
                if (otherStart >= segmentEnd || otherEnd <= segmentStart) {
                    result = [{
                        start: segmentStart,
                        end: segmentEnd
                    }]
                } else {
                    if (otherStart <= segmentStart && otherEnd >= segmentEnd) {
                        result = []
                    } else {
                        if (otherStart > segmentStart) {
                            result = [{
                                start: segmentStart,
                                end: otherStart
                            }]
                        } else {
                            if (otherEnd < segmentEnd) {
                                result = [{
                                    start: otherEnd,
                                    end: segmentEnd
                                }]
                            }
                        }
                    }
                }
            }
            return result
        }

        function subtractSegmentDesc(segmentStart, segmentEnd, otherStart, otherEnd) {
            var result;
            if (otherStart < segmentStart && otherEnd > segmentEnd) {
                result = [{
                    start: segmentStart,
                    end: otherStart
                }, {
                    start: otherEnd,
                    end: segmentEnd
                }]
            } else {
                if (otherStart <= segmentEnd || otherEnd >= segmentStart) {
                    result = [{
                        start: segmentStart,
                        end: segmentEnd
                    }]
                } else {
                    if (otherStart >= segmentStart && otherEnd <= segmentEnd) {
                        result = []
                    } else {
                        if (otherStart < segmentStart) {
                            result = [{
                                start: segmentStart,
                                end: otherStart
                            }]
                        } else {
                            if (otherEnd > segmentEnd) {
                                result = [{
                                    start: otherEnd,
                                    end: segmentEnd
                                }]
                            }
                        }
                    }
                }
            }
            return result
        }

        function isNotEmptySegmentAsc(start, end, threshold) {
            return end - start >= threshold
        }

        function isNotEmptySegmentDesc(start, end, threshold) {
            return start - end >= threshold
        }
        module.exports = BaseRangeContainer
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/circular_gauge.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _isFinite = isFinite;
        var registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 9);
        var objectUtils = __webpack_require__( /*! ../../core/utils/object */ 47);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var dxBaseGauge = __webpack_require__( /*! ./base_gauge */ 153).dxBaseGauge;
        var dxGauge = __webpack_require__( /*! ./common */ 213).dxGauge;
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var _normalizeAngle = vizUtils.normalizeAngle;
        var _getCosAndSin = vizUtils.getCosAndSin;
        var circularIndicatorsModule = __webpack_require__( /*! ./circular_indicators */ 849);
        var createIndicatorCreator = __webpack_require__( /*! ./common */ 213).createIndicatorCreator;
        var CircularRangeContainer = __webpack_require__( /*! ./circular_range_container */ 850);
        var _abs = Math.abs;
        var _max = Math.max;
        var _min = Math.min;
        var _round = Math.round;
        var _each = each;
        var PI = Math.PI;

        function getSides(startAngle, endAngle) {
            var startCosSin = _getCosAndSin(startAngle);
            var endCosSin = _getCosAndSin(endAngle);
            var startCos = startCosSin.cos;
            var startSin = startCosSin.sin;
            var endCos = endCosSin.cos;
            var endSin = endCosSin.sin;
            return {
                left: startSin <= 0 && endSin >= 0 || startSin <= 0 && endSin <= 0 && startCos <= endCos || startSin >= 0 && endSin >= 0 && startCos >= endCos ? -1 : _min(startCos, endCos, 0),
                right: startSin >= 0 && endSin <= 0 || startSin >= 0 && endSin >= 0 && startCos >= endCos || startSin <= 0 && endSin <= 0 && startCos <= endCos ? 1 : _max(startCos, endCos, 0),
                up: startCos <= 0 && endCos >= 0 || startCos <= 0 && endCos <= 0 && startSin >= endSin || startCos >= 0 && endCos >= 0 && startSin <= endSin ? -1 : -_max(startSin, endSin, 0),
                down: startCos >= 0 && endCos <= 0 || startCos >= 0 && endCos >= 0 && startSin <= endSin || startCos <= 0 && endCos <= 0 && startSin >= endSin ? 1 : -_min(startSin, endSin, 0)
            }
        }
        var dxCircularGauge = dxGauge.inherit({
            _rootClass: "dxg-circular-gauge",
            _factoryMethods: {
                rangeContainer: "createCircularRangeContainer",
                indicator: "createCircularIndicator"
            },
            _gridSpacingFactor: 17,
            _scaleTypes: {
                type: "polarAxes",
                drawingType: "circular"
            },
            _getThemeManagerOptions: function() {
                var options = this.callBase.apply(this, arguments);
                options.subTheme = "_circular";
                return options
            },
            _updateScaleTickIndent: function(scaleOptions) {
                var indentFromTick = scaleOptions.label.indentFromTick;
                var length = scaleOptions.tick.visible ? scaleOptions.tick.length : 0;
                var textParams = this._scale.measureLabels(extend({}, this._canvas));
                var tickCorrection = length;
                if ("inside" === scaleOptions.orientation) {
                    tickCorrection = 0
                } else {
                    if ("center" === scaleOptions.orientation) {
                        tickCorrection = .5 * length
                    }
                }
                scaleOptions.label.indentFromAxis = indentFromTick >= 0 ? indentFromTick + tickCorrection : indentFromTick - tickCorrection - _max(textParams.width, textParams.height);
                this._scale.updateOptions(scaleOptions)
            },
            _setupCodomain: function() {
                var that = this;
                var geometry = that.option("geometry") || {};
                var startAngle = geometry.startAngle;
                var endAngle = geometry.endAngle;
                var sides;
                startAngle = _isFinite(startAngle) ? _normalizeAngle(startAngle) : 225;
                endAngle = _isFinite(endAngle) ? _normalizeAngle(endAngle) : -45;
                if (_abs(startAngle - endAngle) < 1) {
                    endAngle -= 360;
                    sides = {
                        left: -1,
                        up: -1,
                        right: 1,
                        down: 1
                    }
                } else {
                    startAngle < endAngle && (endAngle -= 360);
                    sides = getSides(startAngle, endAngle)
                }
                that._area = {
                    x: 0,
                    y: 0,
                    radius: 100,
                    startCoord: startAngle,
                    endCoord: endAngle,
                    sides: sides
                };
                that._translator.setCodomain(startAngle, endAngle)
            },
            _shiftScale: function(layout) {
                var scale = this._scale;
                var canvas = scale.getCanvas();
                canvas.width = canvas.height = 2 * layout.radius;
                scale.draw(canvas);
                var centerCoords = scale.getCenter();
                scale.shift({
                    right: layout.x - centerCoords.x,
                    bottom: layout.y - centerCoords.y
                })
            },
            _getScaleLayoutValue: function() {
                return this._area.radius
            },
            _getTicksOrientation: function(scaleOptions) {
                return scaleOptions.orientation
            },
            _getTicksCoefficients: function(options) {
                var coefs = {
                    inner: 0,
                    outer: 1
                };
                if ("inside" === options.orientation) {
                    coefs.inner = 1;
                    coefs.outer = 0
                } else {
                    if ("center" === options.orientation) {
                        coefs.inner = coefs.outer = .5
                    }
                }
                return coefs
            },
            _correctScaleIndents: function(result, indentFromTick, textParams) {
                if (indentFromTick >= 0) {
                    result.horizontalOffset = indentFromTick + textParams.width;
                    result.verticalOffset = indentFromTick + textParams.height
                } else {
                    result.horizontalOffset = result.verticalOffset = 0;
                    result.min -= -indentFromTick + _max(textParams.width, textParams.height)
                }
                result.inverseHorizontalOffset = textParams.width / 2;
                result.inverseVerticalOffset = textParams.height / 2
            },
            _measureMainElements: function(elements, scaleMeasurement) {
                var that = this;
                var radius = that._area.radius;
                var maxRadius = 0;
                var minRadius = 1 / 0;
                var maxHorizontalOffset = 0;
                var maxVerticalOffset = 0;
                var maxInverseHorizontalOffset = 0;
                var maxInverseVerticalOffset = 0;
                var scale = that._scale;
                _each(elements.concat(scale), function(_, element) {
                    var bounds = element.measure ? element.measure({
                        radius: radius - element.getOffset()
                    }) : scaleMeasurement;
                    bounds.min > 0 && (minRadius = _min(minRadius, bounds.min));
                    bounds.max > 0 && (maxRadius = _max(maxRadius, bounds.max));
                    bounds.horizontalOffset > 0 && (maxHorizontalOffset = _max(maxHorizontalOffset, bounds.max + bounds.horizontalOffset));
                    bounds.verticalOffset > 0 && (maxVerticalOffset = _max(maxVerticalOffset, bounds.max + bounds.verticalOffset));
                    bounds.inverseHorizontalOffset > 0 && (maxInverseHorizontalOffset = _max(maxInverseHorizontalOffset, bounds.inverseHorizontalOffset));
                    bounds.inverseVerticalOffset > 0 && (maxInverseVerticalOffset = _max(maxInverseVerticalOffset, bounds.inverseVerticalOffset))
                });
                maxHorizontalOffset = _max(maxHorizontalOffset - maxRadius, 0);
                maxVerticalOffset = _max(maxVerticalOffset - maxRadius, 0);
                return {
                    minRadius: minRadius,
                    maxRadius: maxRadius,
                    horizontalMargin: maxHorizontalOffset,
                    verticalMargin: maxVerticalOffset,
                    inverseHorizontalMargin: maxInverseHorizontalOffset,
                    inverseVerticalMargin: maxInverseVerticalOffset
                }
            },
            _applyMainLayout: function(elements, scaleMeasurement) {
                var measurements = this._measureMainElements(elements, scaleMeasurement);
                var area = this._area;
                var sides = area.sides;
                var margins = {
                    left: (sides.left < -.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                    right: (sides.right > .1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                    top: (sides.up < -.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0,
                    bottom: (sides.down > .1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0
                };
                var rect = selectRectByAspectRatio(this._innerRect, (sides.down - sides.up) / (sides.right - sides.left), margins);
                var radius = _min(getWidth(rect) / (sides.right - sides.left), getHeight(rect) / (sides.down - sides.up));
                radius = radius - measurements.maxRadius + area.radius;
                var x = rect.left - getWidth(rect) * sides.left / (sides.right - sides.left);
                var y = rect.top - getHeight(rect) * sides.up / (sides.down - sides.up);
                area.x = _round(x);
                area.y = _round(y);
                area.radius = radius;
                rect.left -= margins.left;
                rect.right += margins.right;
                rect.top -= margins.top;
                rect.bottom += margins.bottom;
                this._innerRect = rect
            },
            _getElementLayout: function(offset) {
                return {
                    x: this._area.x,
                    y: this._area.y,
                    radius: _round(this._area.radius - offset)
                }
            },
            _getApproximateScreenRange: function() {
                var that = this;
                var area = that._area;
                var r = _min(that._canvas.width / (area.sides.right - area.sides.left), that._canvas.height / (area.sides.down - area.sides.up));
                r > area.totalRadius && (r = area.totalRadius);
                r = .8 * r;
                return -that._translator.getCodomainRange() * r * PI / 180
            },
            _getDefaultSize: function() {
                return {
                    width: 300,
                    height: 300
                }
            },
            _factory: objectUtils.clone(dxBaseGauge.prototype._factory)
        });

        function getWidth(rect) {
            return rect.right - rect.left
        }

        function getHeight(rect) {
            return rect.bottom - rect.top
        }

        function selectRectByAspectRatio(srcRect, aspectRatio, margins) {
            var rect = extend({}, srcRect);
            var selfAspectRatio;
            var width = 0;
            var height = 0;
            margins = margins || {};
            if (aspectRatio > 0) {
                rect.left += margins.left || 0;
                rect.right -= margins.right || 0;
                rect.top += margins.top || 0;
                rect.bottom -= margins.bottom || 0;
                if (getWidth(rect) > 0 && getHeight(rect) > 0) {
                    selfAspectRatio = getHeight(rect) / getWidth(rect);
                    if (selfAspectRatio > 1) {
                        aspectRatio < selfAspectRatio ? width = getWidth(rect) : height = getHeight(rect)
                    } else {
                        aspectRatio > selfAspectRatio ? height = getHeight(rect) : width = getWidth(rect)
                    }
                    width > 0 || (width = height / aspectRatio);
                    height > 0 || (height = width * aspectRatio);
                    width = (getWidth(rect) - width) / 2;
                    height = (getHeight(rect) - height) / 2;
                    rect.left += width;
                    rect.right -= width;
                    rect.top += height;
                    rect.bottom -= height
                } else {
                    rect.left = rect.right = (rect.left + rect.right) / 2;
                    rect.top = rect.bottom = (rect.top + rect.bottom) / 2
                }
            }
            return rect
        }
        dxCircularGauge._TESTS_selectRectByAspectRatio = selectRectByAspectRatio;
        var indicators = dxCircularGauge.prototype._factory.indicators = {};
        dxCircularGauge.prototype._factory.createIndicator = createIndicatorCreator(indicators);
        indicators._default = circularIndicatorsModule._default;
        indicators.rectangleneedle = circularIndicatorsModule.rectangleneedle;
        indicators.triangleneedle = circularIndicatorsModule.triangleneedle;
        indicators.twocolorneedle = circularIndicatorsModule.twocolorneedle;
        indicators.trianglemarker = circularIndicatorsModule.trianglemarker;
        indicators.textcloud = circularIndicatorsModule.textcloud;
        indicators.rangebar = circularIndicatorsModule.rangebar;
        dxCircularGauge.prototype._factory.RangeContainer = CircularRangeContainer;
        registerComponent("dxCircularGauge", dxCircularGauge);
        module.exports = dxCircularGauge
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/projection.main.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.projection = exports.Projection = void 0;
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _event_emitter = __webpack_require__( /*! ./event_emitter */ 434);

        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest()
        }

        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) {
                return
            }
            if ("string" === typeof o) {
                return _arrayLikeToArray(o, minLen)
            }
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if ("Object" === n && o.constructor) {
                n = o.constructor.name
            }
            if ("Map" === n || "Set" === n) {
                return Array.from(o)
            }
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return _arrayLikeToArray(o, minLen)
            }
        }

        function _arrayLikeToArray(arr, len) {
            if (null == len || len > arr.length) {
                len = arr.length
            }
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
            }
            return arr2
        }

        function _iterableToArrayLimit(arr, i) {
            if ("undefined" === typeof Symbol || !(Symbol.iterator in Object(arr))) {
                return
            }
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) {
                        break
                    }
                }
            } catch (err) {
                _d = true;
                _e = err
            } finally {
                try {
                    if (!_n && null != _i.return) {
                        _i.return()
                    }
                } finally {
                    if (_d) {
                        throw _e
                    }
                }
            }
            return _arr
        }

        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) {
                return arr
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var _Number = Number;
        var _min = Math.min;
        var _max = Math.max;
        var _abs = Math.abs;
        var _round = Math.round;
        var _ln = Math.log;
        var _pow = Math.pow;
        var TWO_TO_LN2 = 2 / Math.LN2;
        var MIN_BOUNDS_RANGE = 1 / 3600 / 180 / 10;
        var DEFAULT_MIN_ZOOM = 1;
        var DEFAULT_MAX_ZOOM = 256;
        var DEFAULT_CENTER = [NaN, NaN];
        var DEFAULT_ENGINE_NAME = "mercator";

        function floatsEqual(f1, f2) {
            return _abs(f1 - f2) < 1e-8
        }

        function arraysEqual(a1, a2) {
            return floatsEqual(a1[0], a2[0]) && floatsEqual(a1[1], a2[1])
        }

        function parseAndClamp(value, minValue, maxValue, defaultValue) {
            var val = _Number(value);
            return isFinite(val) ? _min(_max(val, minValue), maxValue) : defaultValue
        }

        function parseAndClampArray(value, minValue, maxValue, defaultValue) {
            return [parseAndClamp(value[0], minValue[0], maxValue[0], defaultValue[0]), parseAndClamp(value[1], minValue[1], maxValue[1], defaultValue[1])]
        }

        function getEngine(engine) {
            return engine instanceof Engine && engine || projection.get(engine) || projection(engine) || projection.get(DEFAULT_ENGINE_NAME)
        }
        var Projection = exports.Projection = function(parameters) {
            var that = this;
            that._initEvents();
            that._params = parameters;
            that._engine = getEngine();
            that._center = that._engine.center();
            that._adjustCenter()
        };
        Projection.prototype = {
            constructor: Projection,
            _minZoom: DEFAULT_MIN_ZOOM,
            _maxZoom: DEFAULT_MAX_ZOOM,
            _zoom: DEFAULT_MIN_ZOOM,
            _center: DEFAULT_CENTER,
            _canvas: {},
            _scale: [],
            dispose: function() {
                this._disposeEvents()
            },
            setEngine: function(value) {
                var that = this;
                var engine = getEngine(value);
                if (that._engine !== engine) {
                    that._engine = engine;
                    that._fire("engine");
                    if (that._changeCenter(engine.center())) {
                        that._triggerCenterChanged()
                    }
                    if (that._changeZoom(that._minZoom)) {
                        that._triggerZoomChanged()
                    }
                    that._adjustCenter();
                    that._setupScreen()
                }
            },
            setBounds: function(bounds) {
                if (void 0 !== bounds) {
                    this.setEngine(this._engine.original().bounds(bounds))
                }
            },
            _setupScreen: function() {
                var that = this;
                var canvas = that._canvas;
                var width = canvas.width;
                var height = canvas.height;
                var engine = that._engine;
                var aspectRatio = engine.ar();
                that._x0 = canvas.left + width / 2;
                that._y0 = canvas.top + height / 2;
                var min = [that.project([engine.min()[0], 0])[0], that.project([0, engine.min()[1]])[1]];
                var max = [that.project([engine.max()[0], 0])[0], that.project([0, engine.max()[1]])[1]];
                var screenAR = width / height;
                var boundsAR = _abs(max[0] - min[0]) / _abs(max[1] - min[1]);
                var correction;
                if (isNaN(boundsAR) || 0 === boundsAR || _min(screenAR, aspectRatio) <= aspectRatio * boundsAR && aspectRatio * boundsAR <= _max(screenAR, aspectRatio)) {
                    correction = 1
                } else {
                    correction = boundsAR > 1 ? boundsAR : 1 / boundsAR
                }
                if (aspectRatio * boundsAR >= screenAR) {
                    that._xRadius = width / 2 / correction;
                    that._yRadius = width / 2 / (aspectRatio * correction)
                } else {
                    that._xRadius = height / 2 * (aspectRatio / correction);
                    that._yRadius = height / 2 / correction
                }
                that._fire("screen")
            },
            setSize: function(canvas) {
                this._canvas = canvas;
                this._setupScreen()
            },
            _toScreen: function(coordinates) {
                return [this._x0 + this._xRadius * coordinates[0], this._y0 + this._yRadius * coordinates[1]]
            },
            _fromScreen: function(coordinates) {
                return [(coordinates[0] - this._x0) / this._xRadius, (coordinates[1] - this._y0) / this._yRadius]
            },
            _toTransformed: function(coordinates) {
                return [coordinates[0] * this._zoom + this._xCenter, coordinates[1] * this._zoom + this._yCenter]
            },
            _toTransformedFast: function(coordinates) {
                return [coordinates[0] * this._zoom, coordinates[1] * this._zoom]
            },
            _fromTransformed: function(coordinates) {
                return [(coordinates[0] - this._xCenter) / this._zoom, (coordinates[1] - this._yCenter) / this._zoom]
            },
            _adjustCenter: function() {
                var that = this;
                var center = that._engine.project(that._center);
                that._xCenter = -center[0] * that._zoom || 0;
                that._yCenter = -center[1] * that._zoom || 0
            },
            project: function(coordinates) {
                return this._engine.project(coordinates)
            },
            transform: function(coordinates) {
                return this._toScreen(this._toTransformedFast(coordinates))
            },
            isInvertible: function() {
                return this._engine.isInvertible()
            },
            getSquareSize: function(size) {
                return [size[0] * this._zoom * this._xRadius, size[1] * this._zoom * this._yRadius]
            },
            getZoom: function() {
                return this._zoom
            },
            _changeZoom: function(value) {
                var that = this;
                var oldZoom = that._zoom;
                var newZoom = that._zoom = parseAndClamp(value, that._minZoom, that._maxZoom, that._minZoom);
                var isChanged = !floatsEqual(oldZoom, newZoom);
                if (isChanged) {
                    that._adjustCenter();
                    that._fire("zoom")
                }
                return isChanged
            },
            setZoom: function(value) {
                if (this._engine.isInvertible() && this._changeZoom(value)) {
                    this._triggerZoomChanged()
                }
            },
            getScaledZoom: function() {
                return _round((this._scale.length - 1) * _ln(this._zoom) / _ln(this._maxZoom))
            },
            setScaledZoom: function(scaledZoom) {
                this.setZoom(this._scale[_round(scaledZoom)])
            },
            changeScaledZoom: function(deltaZoom) {
                this.setZoom(this._scale[_max(_min(_round(this.getScaledZoom() + deltaZoom), this._scale.length - 1), 0)])
            },
            getZoomScalePartition: function() {
                return this._scale.length - 1
            },
            _setupScaling: function() {
                var that = this;
                var k = _max(_round(TWO_TO_LN2 * _ln(that._maxZoom)), 4);
                var step = _pow(that._maxZoom, 1 / k);
                var zoom = that._minZoom;
                that._scale = [zoom];
                for (var i = 1; i <= k; ++i) {
                    that._scale.push(zoom *= step)
                }
            },
            setMaxZoom: function(maxZoom) {
                var that = this;
                that._minZoom = DEFAULT_MIN_ZOOM;
                that._maxZoom = parseAndClamp(maxZoom, that._minZoom, _Number.MAX_VALUE, DEFAULT_MAX_ZOOM);
                that._setupScaling();
                if (that._zoom > that._maxZoom) {
                    that.setZoom(that._maxZoom)
                }
                that._fire("max-zoom")
            },
            getCenter: function() {
                return this._center.slice()
            },
            setCenter: function(value) {
                if (this._engine.isInvertible() && this._changeCenter(value || [])) {
                    this._triggerCenterChanged()
                }
            },
            _changeCenter: function(value) {
                var that = this;
                var engine = that._engine;
                var oldCenter = that._center;
                var newCenter = that._center = parseAndClampArray(value, engine.min(), engine.max(), engine.center());
                var isChanged = !arraysEqual(oldCenter, newCenter);
                if (isChanged) {
                    that._adjustCenter();
                    that._fire("center")
                }
                return isChanged
            },
            _triggerCenterChanged: function() {
                this._params.centerChanged(this.getCenter())
            },
            _triggerZoomChanged: function() {
                this._params.zoomChanged(this.getZoom())
            },
            setCenterByPoint: function(coordinates, screenPosition) {
                var that = this;
                var p = that._engine.project(coordinates);
                var q = that._fromScreen(screenPosition);
                that.setCenter(that._engine.unproject([-q[0] / that._zoom + p[0], -q[1] / that._zoom + p[1]]))
            },
            beginMoveCenter: function() {
                if (this._engine.isInvertible()) {
                    this._moveCenter = this._center
                }
            },
            endMoveCenter: function() {
                var that = this;
                if (that._moveCenter) {
                    if (!arraysEqual(that._moveCenter, that._center)) {
                        that._triggerCenterChanged()
                    }
                    that._moveCenter = null
                }
            },
            moveCenter: function(shift) {
                var that = this;
                if (that._moveCenter) {
                    var current = that.toScreenPoint(that._center);
                    that._changeCenter(that.fromScreenPoint([current[0] + shift[0], current[1] + shift[1]]))
                }
            },
            getViewport: function() {
                var that = this;
                var unproject = that._engine.unproject;
                var lt = unproject(that._fromTransformed([-1, -1]));
                var lb = unproject(that._fromTransformed([-1, 1]));
                var rt = unproject(that._fromTransformed([1, -1]));
                var rb = unproject(that._fromTransformed([1, 1]));
                var minMax = findMinMax([selectFarthestPoint(lt[0], lb[0], rt[0], rb[0]), selectFarthestPoint(lt[1], rt[1], lb[1], rb[1])], [selectFarthestPoint(rt[0], rb[0], lt[0], lb[0]), selectFarthestPoint(lb[1], rb[1], lt[1], rt[1])]);
                return [].concat(minMax.min, minMax.max)
            },
            setViewport: function(viewport) {
                var engine = this._engine;
                var data = viewport ? getZoomAndCenterFromViewport(engine.project, engine.unproject, viewport) : [this._minZoom, engine.center()];
                this.setZoom(data[0]);
                this.setCenter(data[1])
            },
            getTransform: function() {
                return {
                    translateX: this._xCenter * this._xRadius,
                    translateY: this._yCenter * this._yRadius
                }
            },
            fromScreenPoint: function(coordinates) {
                return this._engine.unproject(this._fromTransformed(this._fromScreen(coordinates)))
            },
            toScreenPoint: function(coordinates) {
                return this._toScreen(this._toTransformed(this._engine.project(coordinates)))
            },
            _eventNames: ["engine", "screen", "center", "zoom", "max-zoom"]
        };
        (0, _event_emitter.makeEventEmitter)(Projection);

        function selectFarthestPoint(point1, point2, basePoint1, basePoint2) {
            var basePoint = (basePoint1 + basePoint2) / 2;
            return _abs(point1 - basePoint) > _abs(point2 - basePoint) ? point1 : point2
        }

        function selectClosestPoint(point1, point2, basePoint1, basePoint2) {
            var basePoint = (basePoint1 + basePoint2) / 2;
            return _abs(point1 - basePoint) < _abs(point2 - basePoint) ? point1 : point2
        }

        function getZoomAndCenterFromViewport(project, unproject, viewport) {
            var lt = project([viewport[0], viewport[3]]);
            var lb = project([viewport[0], viewport[1]]);
            var rt = project([viewport[2], viewport[3]]);
            var rb = project([viewport[2], viewport[1]]);
            var l = selectClosestPoint(lt[0], lb[0], rt[0], rb[0]);
            var r = selectClosestPoint(rt[0], rb[0], lt[0], lb[0]);
            var t = selectClosestPoint(lt[1], rt[1], lb[1], rb[1]);
            var b = selectClosestPoint(lb[1], rb[1], lt[1], rt[1]);
            return [2 / _max(_abs(l - r), _abs(t - b)), unproject([(l + r) / 2, (t + b) / 2])]
        }

        function setMinMax(engine, p1, p2) {
            var _findMinMax = findMinMax(p1, p2),
                min = _findMinMax.min,
                max = _findMinMax.max;
            engine.min = returnArray(min);
            engine.max = returnArray(max)
        }
        var Engine = function() {
            function Engine(parameters) {
                _classCallCheck(this, Engine);
                var that = this;
                var project = createProjectMethod(parameters.to);
                var unproject = parameters.from ? createUnprojectMethod(parameters.from) : returnValue(DEFAULT_CENTER);
                that.project = project;
                that.unproject = unproject;
                that.original = returnValue(that);
                that.source = function() {
                    return (0, _extend.extend)({}, parameters)
                };
                that.isInvertible = returnValue(!!parameters.from);
                that.ar = returnValue(parameters.aspectRatio > 0 ? _Number(parameters.aspectRatio) : 1);
                that.center = returnArray(unproject([0, 0]));
                setMinMax(that, [unproject([-1, 0])[0], unproject([0, 1])[1]], [unproject([1, 0])[0], unproject([0, -1])[1]])
            }
            _createClass(Engine, [{
                key: "aspectRatio",
                value: function(_aspectRatio) {
                    var engine = new Engine((0, _extend.extend)(this.source(), {
                        aspectRatio: _aspectRatio
                    }));
                    engine.original = this.original;
                    engine.min = this.min;
                    engine.max = this.max;
                    return engine
                }
            }, {
                key: "bounds",
                value: function(_bounds) {
                    _bounds = _bounds || [];
                    var parameters = this.source();
                    var min = this.min();
                    var max = this.max();
                    var b1 = parseAndClampArray([_bounds[0], _bounds[1]], min, max, min);
                    var b2 = parseAndClampArray([_bounds[2], _bounds[3]], min, max, max);
                    var p1 = parameters.to(b1);
                    var p2 = parameters.to(b2);
                    var delta = _min(_abs(p2[0] - p1[0]) > MIN_BOUNDS_RANGE ? _abs(p2[0] - p1[0]) : 2, _abs(p2[1] - p1[1]) > MIN_BOUNDS_RANGE ? _abs(p2[1] - p1[1]) : 2);
                    if (delta < 2) {
                        (0, _extend.extend)(parameters, createProjectUnprojectMethods(parameters.to, parameters.from, p1, p2, delta))
                    }
                    var engine = new Engine(parameters);
                    engine.original = this.original;
                    setMinMax(engine, b1, b2);
                    return engine
                }
            }]);
            return Engine
        }();

        function invertVerticalAxis(pair) {
            return [pair[0], -pair[1]]
        }

        function createProjectMethod(method) {
            return function(arg) {
                return invertVerticalAxis(method(arg))
            }
        }

        function createUnprojectMethod(method) {
            return function(arg) {
                return method(invertVerticalAxis(arg))
            }
        }

        function returnValue(value) {
            return function() {
                return value
            }
        }

        function returnArray(value) {
            return function() {
                return value.slice()
            }
        }

        function findMinMax(p1, p2) {
            return {
                min: [_min(p1[0], p2[0]), _min(p1[1], p2[1])],
                max: [_max(p1[0], p2[0]), _max(p1[1], p2[1])]
            }
        }
        var projection = exports.projection = function(parameters) {
            return parameters && parameters.to ? new Engine(parameters) : null
        };
        var projectionsCache = {};
        projection.get = function(name) {
            return projectionsCache[name] || null
        };
        projection.add = function(name, engine) {
            engine = engine instanceof Engine && engine || projection(engine);
            if (!projectionsCache[name] && engine) {
                projectionsCache[name] = engine
            }
            return projection
        };

        function createProjectUnprojectMethods(project, unproject, p1, p2, delta) {
            var x0 = (p1[0] + p2[0]) / 2 - delta / 2;
            var y0 = (p1[1] + p2[1]) / 2 - delta / 2;
            var k = 2 / delta;
            return {
                to: function(coordinates) {
                    var _project = project(coordinates),
                        _project2 = _slicedToArray(_project, 2),
                        p0 = _project2[0],
                        p1 = _project2[1];
                    return [-1 + (p0 - x0) * k, -1 + (p1 - y0) * k]
                },
                from: function(coordinates) {
                    return unproject([x0 + (coordinates[0] + 1) / k, y0 + (coordinates[1] + 1) / k])
                }
            }
        }
        exports._TESTS_Engine = Engine
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/event_emitter.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Callbacks = __webpack_require__( /*! ../../core/utils/callbacks */ 27);
        var eventEmitterMethods = {
            _initEvents: function() {
                var names = this._eventNames;
                var i;
                var ii = names.length;
                var events = this._events = {};
                for (i = 0; i < ii; ++i) {
                    events[names[i]] = Callbacks()
                }
            },
            _disposeEvents: function() {
                var events = this._events;
                var name;
                for (name in events) {
                    events[name].empty()
                }
                this._events = null
            },
            on: function(handlers) {
                var events = this._events;
                var name;
                for (name in handlers) {
                    events[name].add(handlers[name])
                }
                return dispose;

                function dispose() {
                    for (name in handlers) {
                        events[name].remove(handlers[name])
                    }
                }
            },
            _fire: function(name, arg) {
                this._events[name].fire(arg)
            }
        };
        exports.makeEventEmitter = function(target) {
            var proto = target.prototype;
            var name;
            for (name in eventEmitterMethods) {
                proto[name] = eventEmitterMethods[name]
            }
        };
        exports._TESTS_eventEmitterMethods = eventEmitterMethods
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/projection.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var projectionModule = __webpack_require__( /*! ./projection.main */ 433);
        var projection = projectionModule.projection;
        var _min = Math.min;
        var _max = Math.max;
        var _sin = Math.sin;
        var _asin = Math.asin;
        var _tan = Math.tan;
        var _atan = Math.atan;
        var _exp = Math.exp;
        var _log = Math.log;
        var PI = Math.PI;
        var PI_DIV_4 = PI / 4;
        var GEO_LON_BOUND = 180;
        var GEO_LAT_BOUND = 90;
        var RADIANS = PI / 180;
        var MERCATOR_LAT_BOUND = (2 * _atan(_exp(PI)) - PI / 2) / RADIANS;
        var MILLER_LAT_BOUND = (2.5 * _atan(_exp(.8 * PI)) - .625 * PI) / RADIANS;

        function clamp(value, threshold) {
            return _max(_min(value, +threshold), -threshold)
        }
        projection.add("mercator", projection({
            aspectRatio: 1,
            to: function(coordinates) {
                return [coordinates[0] / GEO_LON_BOUND, _log(_tan(PI_DIV_4 + clamp(coordinates[1], MERCATOR_LAT_BOUND) * RADIANS / 2)) / PI]
            },
            from: function(coordinates) {
                return [coordinates[0] * GEO_LON_BOUND, (2 * _atan(_exp(coordinates[1] * PI)) - PI / 2) / RADIANS]
            }
        }));
        projection.add("equirectangular", projection({
            aspectRatio: 2,
            to: function(coordinates) {
                return [coordinates[0] / GEO_LON_BOUND, coordinates[1] / GEO_LAT_BOUND]
            },
            from: function(coordinates) {
                return [coordinates[0] * GEO_LON_BOUND, coordinates[1] * GEO_LAT_BOUND]
            }
        }));
        projection.add("lambert", projection({
            aspectRatio: 2,
            to: function(coordinates) {
                return [coordinates[0] / GEO_LON_BOUND, _sin(clamp(coordinates[1], GEO_LAT_BOUND) * RADIANS)]
            },
            from: function(coordinates) {
                return [coordinates[0] * GEO_LON_BOUND, _asin(clamp(coordinates[1], 1)) / RADIANS]
            }
        }));
        projection.add("miller", projection({
            aspectRatio: 1,
            to: function(coordinates) {
                return [coordinates[0] / GEO_LON_BOUND, 1.25 * _log(_tan(PI_DIV_4 + clamp(coordinates[1], MILLER_LAT_BOUND) * RADIANS * .4)) / PI]
            },
            from: function(coordinates) {
                return [coordinates[0] * GEO_LON_BOUND, (2.5 * _atan(_exp(.8 * coordinates[1] * PI)) - .625 * PI) / RADIANS]
            }
        }));
        exports.projection = projection
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/sparklines/base_sparkline.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var isFunction = __webpack_require__( /*! ../../core/utils/type */ 1).isFunction;
        var BaseWidget = __webpack_require__( /*! ../core/base_widget */ 102);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var addNamespace = __webpack_require__( /*! ../../events/utils */ 8).addNamespace;
        var pointerEvents = __webpack_require__( /*! ../../events/pointer */ 23);
        var pointInCanvas = __webpack_require__( /*! ../core/utils */ 13).pointInCanvas;
        var DEFAULT_LINE_SPACING = 2;
        var EVENT_NS = "sparkline-tooltip";
        var POINTER_ACTION = addNamespace([pointerEvents.down, pointerEvents.move], EVENT_NS);
        var translator2DModule = __webpack_require__( /*! ../translators/translator2d */ 264);
        var _extend = extend;
        var _floor = Math.floor;
        var _noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;

        function inCanvas(_ref, x, y) {
            var left = _ref.left,
                top = _ref.top,
                bottom = _ref.bottom,
                right = _ref.right,
                width = _ref.width,
                height = _ref.height;
            return pointInCanvas({
                left: left,
                top: top,
                right: width - right,
                bottom: height - bottom,
                width: width,
                height: height
            }, x, y)
        }

        function pointerHandler(_ref2) {
            var data = _ref2.data;
            var that = data.widget;
            that._enableOutHandler();
            that._showTooltip()
        }

        function generateDefaultCustomizeTooltipCallback(fontOptions, rtlEnabled) {
            var lineSpacing = fontOptions.lineSpacing;
            var lineHeight = (void 0 !== lineSpacing && null !== lineSpacing ? lineSpacing : DEFAULT_LINE_SPACING) + fontOptions.size;
            return function(customizeObject) {
                var html = "";
                var vt = customizeObject.valueText;
                for (var i = 0; i < vt.length; i += 2) {
                    html += "<tr><td>" + vt[i] + "</td><td style='width: 15px'></td><td style='text-align: " + (rtlEnabled ? "left" : "right") + "'>" + vt[i + 1] + "</td></tr>"
                }
                return {
                    html: "<table style='border-spacing:0px; line-height: " + lineHeight + "px'>" + html + "</table>"
                }
            }
        }

        function generateCustomizeTooltipCallback(customizeTooltip, fontOptions, rtlEnabled) {
            var defaultCustomizeTooltip = generateDefaultCustomizeTooltipCallback(fontOptions, rtlEnabled);
            if (isFunction(customizeTooltip)) {
                return function(customizeObject) {
                    var res = customizeTooltip.call(customizeObject, customizeObject);
                    if (!("html" in res) && !("text" in res)) {
                        _extend(res, defaultCustomizeTooltip.call(customizeObject, customizeObject))
                    }
                    return res
                }
            } else {
                return defaultCustomizeTooltip
            }
        }

        function createAxis(isHorizontal) {
            var translator = new translator2DModule.Translator2D({}, {}, {
                shiftZeroValue: !isHorizontal,
                isHorizontal: !!isHorizontal
            });
            return {
                getTranslator: function() {
                    return translator
                },
                update: function(range, canvas, options) {
                    translator.update(range, canvas, options)
                },
                getVisibleArea: function() {
                    var visibleArea = translator.getCanvasVisibleArea();
                    return [visibleArea.min, visibleArea.max]
                },
                visualRange: _noop,
                calculateInterval: _noop,
                getMarginOptions: function() {
                    return {}
                }
            }
        }
        var _initTooltip;
        var BaseSparkline = BaseWidget.inherit({
            _getLayoutItems: _noop,
            _useLinks: false,
            _themeDependentChanges: ["OPTIONS"],
            _initCore: function() {
                var that = this;
                that._tooltipTracker = that._renderer.root;
                that._tooltipTracker.attr({
                    "pointer-events": "visible"
                });
                that._createHtmlElements();
                that._initTooltipEvents();
                that._argumentAxis = createAxis(true);
                that._valueAxis = createAxis()
            },
            _getDefaultSize: function() {
                return this._defaultSize
            },
            _disposeCore: function() {
                this._disposeWidgetElements();
                this._disposeTooltipEvents();
                this._ranges = null
            },
            _optionChangesOrder: ["OPTIONS"],
            _change_OPTIONS: function() {
                this._prepareOptions();
                this._change(["UPDATE"])
            },
            _customChangesOrder: ["UPDATE"],
            _change_UPDATE: function() {
                this._update()
            },
            _update: function() {
                var that = this;
                if (that._tooltipShown) {
                    that._tooltipShown = false;
                    that._tooltip.hide()
                }
                that._cleanWidgetElements();
                that._updateWidgetElements();
                that._drawWidgetElements()
            },
            _updateWidgetElements: function() {
                var canvas = this._getCorrectCanvas();
                this._updateRange();
                this._argumentAxis.update(this._ranges.arg, canvas, this._getStick());
                this._valueAxis.update(this._ranges.val, canvas)
            },
            _getStick: function() {},
            _applySize: function(rect) {
                this._allOptions.size = {
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1]
                };
                this._change(["UPDATE"])
            },
            _setupResizeHandler: _noop,
            _prepareOptions: function() {
                return _extend(true, {}, this._themeManager.theme(), this.option())
            },
            _getTooltipCoords: function() {
                var canvas = this._canvas;
                var rootOffset = this._renderer.getRootOffset();
                return {
                    x: canvas.width / 2 + rootOffset.left,
                    y: canvas.height / 2 + rootOffset.top
                }
            },
            _initTooltipEvents: function() {
                var data = {
                    widget: this
                };
                this._renderer.root.off("." + EVENT_NS).on(POINTER_ACTION, data, pointerHandler)
            },
            _showTooltip: function() {
                var that = this;
                var tooltip;
                if (!that._tooltipShown) {
                    that._tooltipShown = true;
                    tooltip = that._getTooltip();
                    tooltip.isEnabled() && that._tooltip.show(that._getTooltipData(), that._getTooltipCoords(), {})
                }
            },
            _hideTooltip: function() {
                if (this._tooltipShown) {
                    this._tooltipShown = false;
                    this._tooltip.hide()
                }
            },
            _stopCurrentHandling: function() {
                this._hideTooltip()
            },
            _enableOutHandler: function() {
                var that = this;
                if (that._outHandler) {
                    return
                }
                var handler = function(_ref3) {
                    var pageX = _ref3.pageX,
                        pageY = _ref3.pageY;
                    var _that$_renderer$getRo = that._renderer.getRootOffset(),
                        left = _that$_renderer$getRo.left,
                        top = _that$_renderer$getRo.top;
                    var x = _floor(pageX - left);
                    var y = _floor(pageY - top);
                    if (!inCanvas(that._canvas, x, y)) {
                        that._hideTooltip();
                        that._disableOutHandler()
                    }
                };
                eventsEngine.on(domAdapter.getDocument(), POINTER_ACTION, handler);
                this._outHandler = handler
            },
            _disableOutHandler: function() {
                this._outHandler && eventsEngine.off(domAdapter.getDocument(), POINTER_ACTION, this._outHandler);
                this._outHandler = null
            },
            _disposeTooltipEvents: function() {
                this._tooltipTracker.off();
                this._disableOutHandler();
                this._renderer.root.off("." + EVENT_NS)
            },
            _getTooltip: function() {
                var that = this;
                if (!that._tooltip) {
                    _initTooltip.apply(this, arguments);
                    that._setTooltipRendererOptions(that._tooltipRendererOptions);
                    that._tooltipRendererOptions = null;
                    that._setTooltipOptions()
                }
                return that._tooltip
            }
        });
        module.exports = BaseSparkline;
        BaseSparkline.addPlugin(__webpack_require__( /*! ../core/tooltip */ 111).plugin);
        _initTooltip = BaseSparkline.prototype._initTooltip;
        BaseSparkline.prototype._initTooltip = _noop;
        var _disposeTooltip = BaseSparkline.prototype._disposeTooltip;
        BaseSparkline.prototype._disposeTooltip = function() {
            if (this._tooltip) {
                _disposeTooltip.apply(this, arguments)
            }
        };
        BaseSparkline.prototype._setTooltipRendererOptions = function() {
            var options = this._getRendererOptions();
            if (this._tooltip) {
                this._tooltip.setRendererOptions(options)
            } else {
                this._tooltipRendererOptions = options
            }
        };
        BaseSparkline.prototype._setTooltipOptions = function() {
            var tooltip = this._tooltip;
            var options = tooltip && this._getOption("tooltip");
            tooltip && tooltip.update(_extend({}, options, {
                customizeTooltip: generateCustomizeTooltipCallback(options.customizeTooltip, options.font, this.option("rtlEnabled")),
                enabled: options.enabled && this._isTooltipEnabled()
            }))
        };
        var exportPlugin = extend(true, {}, __webpack_require__( /*! ../core/export */ 99).plugin, {
            init: _noop,
            dispose: _noop,
            customize: null,
            members: {
                _getExportMenuOptions: null
            }
        });
        BaseSparkline.addPlugin(exportPlugin)
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tiling.squarified.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _max = Math.max;
        var _squarify = __webpack_require__( /*! ./tiling.squarified.base */ 438);

        function accumulate(total, current) {
            return _max(total, current)
        }

        function squarified(data) {
            return _squarify(data, accumulate, false)
        }
        __webpack_require__( /*! ./tiling */ 128).addAlgorithm("squarified", squarified);
        module.exports = squarified
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tiling.squarified.base.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _max = Math.max;
        var _round = Math.round;
        var tiling = __webpack_require__( /*! ./tiling */ 128);

        function compare(a, b) {
            return b.value - a.value
        }

        function getAspectRatio(value) {
            return _max(value, 1 / value)
        }

        function findAppropriateCollection(nodes, head, context) {
            var bestAspectRatio = 1 / 0;
            var nextAspectRatio;
            var sum = 0;
            var nextSum;
            var i;
            var j;
            var ii = nodes.length;
            var coeff = context.areaToValue / context.staticSide;
            var totalAspectRatio;
            for (i = head; i < ii;) {
                nextSum = sum + nodes[i].value;
                totalAspectRatio = context.staticSide / coeff / nextSum;
                nextAspectRatio = 0;
                for (j = head; j <= i; ++j) {
                    nextAspectRatio = context.accumulate(nextAspectRatio, getAspectRatio(totalAspectRatio * nodes[j].value / nextSum), j - head + 1)
                }
                if (nextAspectRatio < bestAspectRatio) {
                    bestAspectRatio = nextAspectRatio;
                    sum = nextSum;
                    ++i
                } else {
                    break
                }
            }
            return {
                sum: sum,
                count: i - head,
                side: _round(coeff * sum)
            }
        }

        function getArea(rect) {
            return (rect[2] - rect[0]) * (rect[3] - rect[1])
        }

        function doStep(nodes, head, context) {
            var sidesData = tiling.buildSidesData(context.rect, context.directions, context.staticSideIndex);
            var area = getArea(context.rect);
            var rowData = area > 0 ? findAppropriateCollection(nodes, head, {
                areaToValue: area / context.sum,
                accumulate: context.accumulate,
                staticSide: sidesData.staticSide
            }) : {
                sum: 1,
                side: sidesData.variedSide,
                count: nodes.length - head
            };
            tiling.calculateRectangles(nodes, head, context.rect, sidesData, rowData);
            context.sum -= rowData.sum;
            return head + rowData.count
        }
        module.exports = function(data, accumulate, isFixedStaticSide) {
            var items = data.items;
            var ii = items.length;
            var i;
            var context = {
                sum: data.sum,
                rect: data.rect,
                directions: data.directions,
                accumulate: accumulate
            };
            if (isFixedStaticSide) {
                context.staticSideIndex = tiling.getStaticSideIndex(context.rect)
            }
            items.sort(compare);
            for (i = 0; i < ii;) {
                i = doStep(items, i, context)
            }
        }
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/colorizing.discrete.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function discreteColorizer(options, themeManager, root) {
            var palette = themeManager.createPalette(options.palette, {
                useHighlight: true,
                extensionMode: options.paletteExtensionMode,
                count: options.colorizeGroups ? getNodesCount(root) : getLeafsCount(root)
            });
            return (options.colorizeGroups ? discreteGroupColorizer : discreteLeafColorizer)(palette, root)
        }

        function getLeafsCount(root) {
            var allNodes = root.nodes.slice();
            var i;
            var ii = allNodes.length;
            var count = 0;
            var node;
            for (i = 0; i < ii; ++i) {
                node = allNodes[i];
                if (node.isNode()) {
                    count = Math.max(count, getLeafsCount(node))
                } else {
                    count += 1
                }
            }
            return count
        }

        function discreteLeafColorizer(palette) {
            var colors = palette.generateColors();
            return function(node) {
                return colors[node.index]
            }
        }

        function getNodesCount(root) {
            var allNodes = root.nodes.slice();
            var i;
            var ii = allNodes.length;
            var count = 0;
            var node;
            for (i = 0; i < ii; ++i) {
                node = allNodes[i];
                if (node.isNode()) {
                    count += getNodesCount(node) + 1
                }
            }
            return count
        }

        function prepareDiscreteGroupColors(palette, root) {
            var colors = {};
            var allNodes = root.nodes.slice();
            var i;
            var ii = allNodes.length;
            var node;
            for (i = 0; i < ii; ++i) {
                node = allNodes[i];
                if (node.isNode()) {
                    allNodes = allNodes.concat(node.nodes);
                    ii = allNodes.length
                } else {
                    if (!colors[node.parent._id]) {
                        colors[node.parent._id] = palette.getNextColor()
                    }
                }
            }
            return colors
        }

        function discreteGroupColorizer(palette, root) {
            var colors = prepareDiscreteGroupColors(palette, root);
            return function(node) {
                return colors[node._id]
            }
        }
        __webpack_require__( /*! ./colorizing */ 129).addColorizer("discrete", discreteColorizer);
        module.exports = discreteColorizer
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/hover.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./tree_map.base */ 73).prototype;
        var nodeProto = __webpack_require__( /*! ./node */ 175).prototype;
        var expand = __webpack_require__( /*! ../core/helpers */ 150).expand;
        var common = __webpack_require__( /*! ./common */ 266);
        var _parseScalar = __webpack_require__( /*! ../core/utils */ 13).parseScalar;
        var _buildRectAppearance = common.buildRectAppearance;
        var STATE_CODE = 1;
        __webpack_require__( /*! ./api */ 154);
        __webpack_require__( /*! ./states */ 441);
        proto._eventsMap.onHoverChanged = {
            name: "hoverChanged"
        };
        expand(proto._handlers, "calculateAdditionalStates", function(states, options) {
            states[1] = options.hoverStyle ? _buildRectAppearance(options.hoverStyle) : {}
        });
        __webpack_require__( /*! ./tree_map.base */ 73).addChange({
            code: "HOVER_ENABLED",
            handler: function() {
                var hoverEnabled = _parseScalar(this._getOption("hoverEnabled", true), true);
                if (!hoverEnabled) {
                    this.clearHover()
                }
                this._hoverEnabled = hoverEnabled
            },
            isThemeDependent: true,
            isOptionChange: true,
            option: "hoverEnabled"
        });
        nodeProto.statesMap[1] = 1;
        nodeProto.additionalStates.push(1);
        expand(proto, "_extendProxyType", function(proto) {
            var that = this;
            proto.setHover = function() {
                that._hoverNode(this._id)
            };
            proto.isHovered = function() {
                return that._hoverIndex === this._id
            }
        });
        expand(proto, "_onNodesCreated", function() {
            this._hoverIndex = -1
        });
        expand(proto, "_changeGroupSettings", function() {
            var that = this;
            that._groupHoverEnabled = _parseScalar(that._getOption("group").hoverEnabled, true);
            if (!that._groupHoverEnabled) {
                that.clearHover()
            }
        });
        proto._applyHoverState = function(index, state) {
            setNodeStateRecursive(this._nodes[index], STATE_CODE, state);
            this._eventTrigger("hoverChanged", {
                node: this._nodes[index].proxy
            })
        };

        function setNodeStateRecursive(node, code, state) {
            var nodes = node.isNode() && node.nodes;
            var i;
            var ii = nodes && nodes.length;
            node.setState(code, state);
            for (i = 0; i < ii; ++i) {
                setNodeStateRecursive(nodes[i], code, state)
            }
        }
        proto._hoverNode = function(index) {
            var that = this;
            var currentIndex = that._hoverIndex;
            if (that._hoverEnabled && currentIndex !== index) {
                if (!that._groupHoverEnabled && index >= 0 && that._nodes[index].isNode()) {
                    that.clearHover();
                    return
                }
                that._context.suspend();
                that._hoverIndex = -1;
                if (currentIndex >= 0) {
                    that._applyHoverState(currentIndex, false)
                }
                that._hoverIndex = index;
                if (index >= 0) {
                    that._applyHoverState(index, true)
                }
                that._context.resume()
            }
        };
        proto.clearHover = function() {
            this._hoverNode(-1)
        }
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/states.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./tree_map.base */ 73).prototype;
        var nodeProto = __webpack_require__( /*! ./node */ 175).prototype;
        var handlers = proto._handlers;
        var _calculateState = handlers.calculateState;
        var _buildState = nodeProto._buildState;
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        handlers.calculateState = function(options) {
            var states = {
                0: _calculateState(options)
            };
            handlers.calculateAdditionalStates(states, options);
            return states
        };
        handlers.calculateAdditionalStates = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        nodeProto.code = 0;
        nodeProto.statesMap = {
            0: 0
        };
        nodeProto.additionalStates = [];
        nodeProto._buildState = function(state, extra) {
            var states = {
                0: _buildState(state[0], extra)
            };
            if (this.additionalStates.length) {
                buildAdditionalStates(states, states[0], state, this.additionalStates)
            }
            return states
        };
        nodeProto._getState = function() {
            return this.state[this.statesMap[this.code]]
        };
        nodeProto.setState = function(code, state) {
            if (state) {
                this.code |= code
            } else {
                this.code &= ~code
            }
            this.ctx.change(["TILES"])
        };

        function buildAdditionalStates(states, base, source, list) {
            var i;
            var ii = list.length;
            for (i = 0; i < ii; ++i) {
                states[list[i]] = _extend({}, base, source[list[i]])
            }
        }
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tooltip.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./tree_map.base */ 73).prototype;
        var expand = __webpack_require__( /*! ../core/helpers */ 150).expand;
        __webpack_require__( /*! ./api */ 154);
        expand(proto, "_extendProxyType", function(proto) {
            var that = this;
            proto.showTooltip = function(coords) {
                that._showTooltip(this._id, coords)
            }
        });
        expand(proto, "_onNodesCreated", function() {
            if (this._tooltipIndex >= 0) {
                this._tooltip.hide()
            }
            this._tooltipIndex = -1
        });
        expand(proto, "_onTilingPerformed", function() {
            if (this._tooltipIndex >= 0) {
                this._moveTooltip(this._nodes[this._tooltipIndex])
            }
        });

        function getCoords(rect, renderer) {
            var offset = renderer.getRootOffset();
            return [(rect[0] + rect[2]) / 2 + offset.left, (rect[1] + rect[3]) / 2 + offset.top]
        }
        proto._showTooltip = function(index, coords) {
            var that = this;
            var tooltip = that._tooltip;
            var node = that._nodes[index];
            var state = that._tooltipIndex === index || tooltip.show({
                value: node.value,
                valueText: tooltip.formatValue(node.value),
                node: node.proxy
            }, {
                x: 0,
                y: 0,
                offset: 0
            }, {
                node: node.proxy
            });
            if (state) {
                that._moveTooltip(node, coords)
            } else {
                tooltip.hide()
            }
            that._tooltipIndex = state ? index : -1
        };
        proto._moveTooltip = function(node, coords) {
            var xy = coords || node.rect && getCoords(node.rect, this._renderer) || [-1e3, -1e3];
            this._tooltip.move(xy[0], xy[1], 0)
        };
        proto.hideTooltip = function() {
            if (this._tooltipIndex >= 0) {
                this._tooltipIndex = -1;
                this._tooltip.hide()
            }
        };
        __webpack_require__( /*! ./tree_map.base */ 73).addPlugin(__webpack_require__( /*! ../core/tooltip */ 111).plugin)
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/viz/funnel/funnel.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var tiling = __webpack_require__( /*! ./tiling */ 887);
        var dynamicSlope = __webpack_require__( /*! ./tiling.funnel */ 888);
        var dynamicHeight = __webpack_require__( /*! ./tiling.pyramid */ 889);
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var Item = __webpack_require__( /*! ./item */ 890);
        var NODES_CREATE_CHANGE = "NODES_CREATE";
        tiling.addAlgorithm("dynamicslope", dynamicSlope, true);
        tiling.addAlgorithm("dynamicheight", dynamicHeight);

        function invertFigure(figure) {
            return figure.map(function(coord, index) {
                return index % 2 ? 1 - coord : coord
            })
        }

        function getLegendItemState(itemState) {
            return {
                fill: itemState.fill,
                hatching: itemState.hatching
            }
        }
        var dxFunnel = __webpack_require__( /*! ../core/base_widget */ 102).inherit({
            _rootClass: "dxf-funnel",
            _rootClassPrefix: "dxf",
            _proxyData: [],
            _optionChangesMap: {
                dataSource: "DATA_SOURCE",
                neckWidth: NODES_CREATE_CHANGE,
                neckHeight: NODES_CREATE_CHANGE,
                inverted: NODES_CREATE_CHANGE,
                algorithm: NODES_CREATE_CHANGE,
                item: NODES_CREATE_CHANGE,
                valueField: NODES_CREATE_CHANGE,
                argumentField: NODES_CREATE_CHANGE,
                colorField: NODES_CREATE_CHANGE,
                palette: NODES_CREATE_CHANGE,
                paletteExtensionMode: NODES_CREATE_CHANGE,
                sortData: NODES_CREATE_CHANGE
            },
            _themeDependentChanges: [NODES_CREATE_CHANGE],
            _getDefaultSize: function() {
                return {
                    width: 400,
                    height: 400
                }
            },
            _themeSection: "funnel",
            _fontFields: ["legend.title.font", "legend.title.subtitle.font", "legend.font"],
            _optionChangesOrder: ["DATA_SOURCE"],
            _initialChanges: ["DATA_SOURCE"],
            _initCore: function() {
                this._group = this._renderer.g().append(this._renderer.root);
                this._items = []
            },
            _eventsMap: {
                onHoverChanged: {
                    name: "hoverChanged"
                },
                onSelectionChanged: {
                    name: "selectionChanged"
                }
            },
            _disposeCore: noop,
            _applySize: function(rect) {
                this._rect = rect.slice();
                this._change(["TILING"]);
                return this._rect
            },
            _getAlignmentRect: function() {
                return this._rect
            },
            _change_TILING: function() {
                var that = this;
                var items = that._items;
                var rect = that._rect;
                var convertCoord = function(coord, index) {
                    var offset = index % 2;
                    return rect[0 + offset] + (rect[2 + offset] - rect[0 + offset]) * coord
                };
                this._group.clear();
                items.forEach(function(item, index) {
                    var coords = item.figure.map(convertCoord);
                    var element = that._renderer.path([], "area").attr({
                        points: coords
                    }).append(that._group);
                    item.coords = coords;
                    item.element = element
                });
                this._requestChange(["TILES"])
            },
            _customChangesOrder: [NODES_CREATE_CHANGE, "LAYOUT", "TILING", "TILES", "DRAWN"],
            _dataSourceChangedHandler: function() {
                this._requestChange([NODES_CREATE_CHANGE])
            },
            _change_DRAWN: function() {
                this._drawn()
            },
            _change_DATA_SOURCE: function() {
                this._change(["DRAWN"]);
                this._updateDataSource()
            },
            _change_NODES_CREATE: function() {
                this._buildNodes()
            },
            _change_TILES: function() {
                this._applyTilesAppearance()
            },
            _suspend: function() {
                if (!this._applyingChanges) {
                    this._suspendChanges()
                }
            },
            _resume: function() {
                if (!this._applyingChanges) {
                    this._resumeChanges()
                }
            },
            _applyTilesAppearance: function() {
                this._items.forEach(function(item) {
                    var state = item.getState();
                    item.element.smartAttr(item.states[state])
                })
            },
            _hitTestTargets: function(x, y) {
                var that = this;
                var data;
                this._proxyData.some(function(callback) {
                    data = callback.call(that, x, y);
                    if (data) {
                        return true
                    }
                });
                return data
            },
            clearHover: function() {
                this._suspend();
                this._items.forEach(function(item) {
                    item.isHovered() && item.hover(false)
                });
                this._resume()
            },
            clearSelection: function() {
                this._suspend();
                this._items.forEach(function(item) {
                    item.isSelected() && item.select(false)
                });
                this._resume()
            },
            _getData: function() {
                var that = this;
                var data = that._dataSourceItems() || [];
                var valueField = that._getOption("valueField", true);
                var argumentField = that._getOption("argumentField", true);
                var colorField = that._getOption("colorField", true);
                var processedData = data.reduce(function(d, item) {
                    var value = Number(item[valueField]);
                    if (value >= 0) {
                        d[0].push({
                            value: value,
                            color: item[colorField],
                            argument: item[argumentField],
                            dataItem: item
                        });
                        d[1] += value
                    }
                    return d
                }, [
                    [], 0
                ]);
                var items = processedData[0];
                if (!processedData[1]) {
                    items = items.map(function(item) {
                        item.value += 1;
                        return item
                    })
                }
                if (data.length > 0 && 0 === items.length) {
                    that._incidentOccurred("E2005", valueField)
                }
                if (that._getOption("sortData", true)) {
                    items.sort(function(a, b) {
                        return b.value - a.value
                    })
                }
                return items
            },
            _buildNodes: function() {
                var that = this;
                var data = that._getData();
                var algorithm = tiling.getAlgorithm(that._getOption("algorithm", true));
                var percents = algorithm.normalizeValues(data);
                var itemOptions = that._getOption("item");
                var figures = algorithm.getFigures(percents, that._getOption("neckWidth", true), that._getOption("neckHeight", true));
                var palette = that._themeManager.createPalette(that._getOption("palette", true), {
                    useHighlight: true,
                    extensionMode: that._getOption("paletteExtensionMode", true),
                    count: figures.length
                });
                that._items = figures.map(function(figure, index) {
                    var curData = data[index];
                    var node = new Item(that, {
                        figure: figure,
                        data: curData,
                        percent: percents[index],
                        id: index,
                        color: curData.color || palette.getNextColor(),
                        itemOptions: itemOptions
                    });
                    return node
                });
                if (that._getOption("inverted", true)) {
                    that._items.forEach(function(item) {
                        item.figure = invertFigure(item.figure)
                    })
                }
                that._renderer.initHatching();
                that._change(["TILING", "DRAWN"])
            },
            _showTooltip: noop,
            hideTooltip: noop,
            getAllItems: function() {
                return this._items.slice()
            },
            _getLegendData: function() {
                return this._items.map(function(item) {
                    var states = item.states;
                    return {
                        id: item.id,
                        visible: true,
                        text: item.argument,
                        item: item,
                        states: {
                            normal: getLegendItemState(states.normal),
                            hover: getLegendItemState(states.hover),
                            selection: getLegendItemState(states.selection)
                        }
                    }
                })
            },
            _getMinSize: function() {
                var adaptiveLayout = this._getOption("adaptiveLayout");
                return [adaptiveLayout.width, adaptiveLayout.height]
            }
        });
        __webpack_require__( /*! ../../core/component_registrator */ 9)("dxFunnel", dxFunnel);
        module.exports = dxFunnel;
        dxFunnel.addPlugin(__webpack_require__( /*! ../core/data_source */ 152).plugin)
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/sankey.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _constants = __webpack_require__( /*! ./constants */ 445);
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var Node = __webpack_require__( /*! ./node_item */ 895);
        var Link = __webpack_require__( /*! ./link_item */ 896);
        var defaultLayoutBuilder = __webpack_require__( /*! ./layout */ 897);
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _isString = typeUtils.isString;
        var _isNumber = typeUtils.isNumeric;

        function moveLabel(node, labelOptions, availableLabelWidth, rect) {
            if (node._label.getBBox().width > availableLabelWidth) {
                node.labelText.applyEllipsis(availableLabelWidth)
            }
            var bBox = node._label.getBBox();
            var verticalOffset = labelOptions.verticalOffset;
            var horizontalOffset = labelOptions.horizontalOffset;
            var labelOffsetY = Math.round(node.rect.y + node.rect.height / 2 - bBox.y - bBox.height / 2) + verticalOffset;
            var labelOffsetX = node.rect.x + horizontalOffset + node.rect.width - bBox.x;
            if (labelOffsetX + bBox.width >= rect[2] - rect[0]) {
                labelOffsetX = node.rect.x - horizontalOffset - bBox.x - bBox.width
            }
            if (labelOffsetY >= rect[3]) {
                labelOffsetY = rect[3]
            }
            if (labelOffsetY - bBox.height < rect[1]) {
                labelOffsetY = node.rect.y - bBox.y + verticalOffset
            }
            node.labelText.attr({
                translateX: labelOffsetX,
                translateY: labelOffsetY
            })
        }

        function getConnectedLinks(layout, nodeName, linkType) {
            var result = [];
            var attrName = "in" === linkType ? "_to" : "_from";
            var invertedAttrName = "in" === linkType ? "_from" : "_to";
            layout.links.map(function(link) {
                return link[attrName]._name === nodeName
            }).forEach(function(connected, idx) {
                connected && result.push({
                    index: idx,
                    weight: layout.links[idx]._weight,
                    node: layout.links[idx][invertedAttrName]._name
                })
            });
            return result
        }
        var dxSankey = __webpack_require__( /*! ../core/base_widget */ 102).inherit({
            _rootClass: "dxs-sankey",
            _rootClassPrefix: "dxs",
            _proxyData: [],
            _optionChangesMap: {
                dataSource: "DATA_SOURCE",
                sortData: "DATA_SOURCE",
                alignment: "DATA_SOURCE",
                node: "BUILD_LAYOUT",
                link: "BUILD_LAYOUT",
                palette: "BUILD_LAYOUT",
                paletteExtensionMode: "BUILD_LAYOUT"
            },
            _themeDependentChanges: ["BUILD_LAYOUT"],
            _getDefaultSize: function() {
                return {
                    width: 400,
                    height: 400
                }
            },
            _themeSection: "sankey",
            _fontFields: ["label.font"],
            _optionChangesOrder: ["DATA_SOURCE"],
            _initialChanges: ["DATA_SOURCE"],
            _initCore: function() {
                this._groupLinks = this._renderer.g().append(this._renderer.root);
                this._groupNodes = this._renderer.g().append(this._renderer.root);
                this._groupLabels = this._renderer.g().attr({
                    "class": this._rootClassPrefix + "-labels"
                }).append(this._renderer.root);
                this._drawLabels = true;
                this._nodes = [];
                this._links = [];
                this._gradients = []
            },
            _disposeCore: noop,
            _applySize: function(rect) {
                this._rect = rect.slice();
                var adaptiveLayout = this._getOption("adaptiveLayout");
                if (adaptiveLayout.keepLabels || this._rect[2] - this._rect[0] > adaptiveLayout.width) {
                    this._drawLabels = true
                } else {
                    this._drawLabels = false
                }
                this._change(["BUILD_LAYOUT"]);
                return this._rect
            },
            _eventsMap: {
                onNodeHoverChanged: {
                    name: "nodeHoverChanged"
                },
                onLinkHoverChanged: {
                    name: "linkHoverChanged"
                }
            },
            _customChangesOrder: ["BUILD_LAYOUT", "NODES_DRAW", "LINKS_DRAW", "LABELS", "DRAWN"],
            _dataSourceChangedHandler: function() {
                this._requestChange(["BUILD_LAYOUT"])
            },
            _change_DRAWN: function() {
                this._drawn()
            },
            _change_DATA_SOURCE: function() {
                this._change(["DRAWN"]);
                this._updateDataSource()
            },
            _change_LABELS: function() {
                this._applyLabelsAppearance()
            },
            _change_BUILD_LAYOUT: function() {
                this._groupNodes.clear();
                this._groupLinks.clear();
                this._groupLabels.clear();
                this._buildLayout()
            },
            _change_NODES_DRAW: function() {
                var that = this;
                var nodes = that._nodes;
                nodes.forEach(function(node, index) {
                    var element = that._renderer.rect().attr(node.rect).append(that._groupNodes);
                    node.element = element
                });
                this._applyNodesAppearance()
            },
            _change_LINKS_DRAW: function() {
                var that = this;
                var links = that._links;
                links.forEach(function(link, index) {
                    var group = that._renderer.g().attr({
                        "class": "link",
                        "data-link-idx": index
                    }).append(that._groupLinks);
                    link.overlayElement = that._renderer.path([], "area").attr({
                        d: link.d
                    }).append(group);
                    link.element = that._renderer.path([], "area").attr({
                        d: link.d
                    }).append(group)
                });
                this._applyLinksAppearance()
            },
            _suspend: function() {
                if (!this._applyingChanges) {
                    this._suspendChanges()
                }
            },
            _resume: function() {
                if (!this._applyingChanges) {
                    this._resumeChanges()
                }
            },
            _showTooltip: noop,
            hideTooltip: noop,
            clearHover: function() {
                this._suspend();
                this._nodes.forEach(function(node) {
                    node.isHovered() && node.hover(false)
                });
                this._links.forEach(function(link) {
                    link.isHovered() && link.hover(false);
                    link.isAdjacentNodeHovered() && link.adjacentNodeHover(false)
                });
                this._resume()
            },
            _applyNodesAppearance: function() {
                this._nodes.forEach(function(node) {
                    var state = node.getState();
                    node.element.smartAttr(node.states[state])
                })
            },
            _applyLinksAppearance: function() {
                this._links.forEach(function(link) {
                    var state = link.getState();
                    link.element.smartAttr(link.states[state]);
                    link.overlayElement.smartAttr(link.overlayStates[state])
                })
            },
            _hitTestTargets: function(x, y) {
                var that = this;
                var data;
                this._proxyData.some(function(callback) {
                    data = callback.call(that, x, y);
                    if (data) {
                        return true
                    }
                });
                return data
            },
            _getData: function() {
                var that = this;
                var data = that._dataSourceItems() || [];
                var sourceField = that._getOption("sourceField", true);
                var targetField = that._getOption("targetField", true);
                var weightField = that._getOption("weightField", true);
                var processedData = [];
                data.forEach(function(item) {
                    var hasItemOwnProperty = Object.prototype.hasOwnProperty.bind(item);
                    if (!hasItemOwnProperty(sourceField)) {
                        that._incidentOccurred("E2007", sourceField)
                    } else {
                        if (!hasItemOwnProperty(targetField)) {
                            that._incidentOccurred("E2007", targetField)
                        } else {
                            if (!hasItemOwnProperty(weightField)) {
                                that._incidentOccurred("E2007", weightField)
                            } else {
                                if (!_isString(item[sourceField])) {
                                    that._incidentOccurred("E2008", sourceField)
                                } else {
                                    if (!_isString(item[targetField])) {
                                        that._incidentOccurred("E2008", targetField)
                                    } else {
                                        if (!_isNumber(item[weightField]) || item[weightField] <= 0) {
                                            that._incidentOccurred("E2009", weightField)
                                        } else {
                                            processedData.push([item[sourceField], item[targetField], item[weightField]])
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                return processedData
            },
            _buildLayout: function() {
                var _this = this;
                var that = this;
                var data = that._getData();
                var availableRect = this._rect;
                var nodeOptions = that._getOption("node");
                var sortData = that._getOption("sortData");
                var layoutBuilder = that._getOption("layoutBuilder", true) || defaultLayoutBuilder;
                var rect = {
                    x: availableRect[0],
                    y: availableRect[1],
                    width: availableRect[2] - availableRect[0],
                    height: availableRect[3] - availableRect[1]
                };
                var layout = layoutBuilder.computeLayout(data, sortData, {
                    availableRect: rect,
                    nodePadding: nodeOptions.padding,
                    nodeWidth: nodeOptions.width,
                    nodeAlign: that._getOption("alignment", true)
                }, that._incidentOccurred);
                that._layoutMap = layout;
                if (!Object.prototype.hasOwnProperty.call(layout, "error")) {
                    var nodeColors = {};
                    var nodeIdx = 0;
                    var linkOptions = that._getOption("link");
                    var totalNodesNum = layout.nodes.map(function(item) {
                        return item.length
                    }).reduce(function(previousValue, currentValue) {
                        return previousValue + currentValue
                    }, 0);
                    var palette = that._themeManager.createPalette(that._getOption("palette", true), {
                        useHighlight: true,
                        extensionMode: that._getOption("paletteExtensionMode", true),
                        count: totalNodesNum
                    });
                    that._nodes = [];
                    that._links = [];
                    that._gradients.forEach(function(gradient) {
                        gradient.dispose()
                    });
                    that._gradients = [];
                    that._shadowFilter && that._shadowFilter.dispose();
                    layout.nodes.forEach(function(cascadeNodes) {
                        cascadeNodes.forEach(function(node) {
                            var color = nodeOptions.color || palette.getNextColor();
                            var nodeItem = new Node(that, {
                                id: nodeIdx,
                                color: color,
                                rect: node,
                                options: nodeOptions,
                                linksIn: getConnectedLinks(layout, node._name, "in"),
                                linksOut: getConnectedLinks(layout, node._name, "out")
                            });
                            that._nodes.push(nodeItem);
                            nodeIdx++;
                            nodeColors[node._name] = color
                        })
                    });
                    layout.links.forEach(function(link) {
                        var gradient = null;
                        if (linkOptions.colorMode === _constants.COLOR_MODE_GRADIENT) {
                            gradient = that._renderer.linearGradient([{
                                offset: "0%",
                                "stop-color": nodeColors[link._from._name]
                            }, {
                                offset: "100%",
                                "stop-color": nodeColors[link._to._name]
                            }]);
                            _this._gradients.push(gradient)
                        }
                        var color = linkOptions.color;
                        if (linkOptions.colorMode === _constants.COLOR_MODE_SOURCE) {
                            color = nodeColors[link._from._name]
                        } else {
                            if (linkOptions.colorMode === _constants.COLOR_MODE_TARGET) {
                                color = nodeColors[link._to._name]
                            }
                        }
                        var linkItem = new Link(that, {
                            d: link.d,
                            boundingRect: link._boundingRect,
                            color: color,
                            options: linkOptions,
                            connection: {
                                source: link._from._name,
                                target: link._to._name,
                                weight: link._weight
                            },
                            gradient: gradient
                        });
                        that._links.push(linkItem)
                    });
                    that._renderer.initHatching();
                    that._change(["NODES_DRAW", "LINKS_DRAW", "LABELS"])
                }
                that._change(["DRAWN"])
            },
            _applyLabelsAppearance: function() {
                var that = this;
                var labelOptions = that._getOption("label");
                var availableWidth = that._rect[2] - that._rect[0];
                var nodeOptions = that._getOption("node");
                that._shadowFilter = that._renderer.shadowFilter("-50%", "-50%", "200%", "200%").attr(labelOptions.shadow);
                that._groupLabels.clear();
                if (that._drawLabels && labelOptions.visible) {
                    var availableLabelWidth = (availableWidth - (nodeOptions.width + labelOptions.horizontalOffset) - that._layoutMap.cascades.length * nodeOptions.width) / (that._layoutMap.cascades.length - 1) - labelOptions.horizontalOffset;
                    that._nodes.forEach(function(node) {
                        that._createLabel(node, labelOptions, that._shadowFilter.id);
                        moveLabel(node, labelOptions, availableLabelWidth, that._rect)
                    });
                    if ("none" !== labelOptions.overlappingBehavior) {
                        that._nodes.forEach(function(thisNode) {
                            var thisBox = thisNode._label.getBBox();
                            that._nodes.forEach(function(otherNode) {
                                var otherBox = otherNode._label.getBBox();
                                if (thisNode.id !== otherNode.id && defaultLayoutBuilder.overlap(thisBox, otherBox)) {
                                    if ("ellipsis" === labelOptions.overlappingBehavior) {
                                        thisNode.labelText.applyEllipsis(otherBox.x - thisBox.x)
                                    } else {
                                        if ("hide" === labelOptions.overlappingBehavior) {
                                            thisNode.labelText.remove()
                                        }
                                    }
                                }
                            })
                        })
                    }
                }
            },
            _createLabel: function(node, labelOptions, filter) {
                var textData = labelOptions.customizeText(node);
                var settings = node.getLabelAttributes(labelOptions, filter);
                if (textData) {
                    node._label = this._renderer.g().append(this._groupLabels);
                    node.labelText = this._renderer.text(textData).attr(settings.attr).css(settings.css);
                    node.labelText.append(node._label)
                }
            },
            _getMinSize: function() {
                var adaptiveLayout = this._getOption("adaptiveLayout");
                return [adaptiveLayout.width, adaptiveLayout.height]
            },
            getAllNodes: function() {
                return this._nodes.slice()
            },
            getAllLinks: function() {
                return this._links.slice()
            }
        });
        __webpack_require__( /*! ../../core/component_registrator */ 9)("dxSankey", dxSankey);
        module.exports = dxSankey;
        dxSankey.addPlugin(__webpack_require__( /*! ../core/data_source */ 152).plugin)
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/constants.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.COLOR_MODE_GRADIENT = "gradient";
        exports.COLOR_MODE_SOURCE = "source";
        exports.COLOR_MODE_TARGET = "target";
        exports.COLOR_MODE_NONE = "none"
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/graph.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var WHITE = "white";
        var GRAY = "gray";
        var BLACK = "black";
        var routines = {
            maxOfArray: function(arr, callback) {
                var m = 0;
                var callback_function = function(v) {
                    return v
                };
                if (callback) {
                    callback_function = callback
                }
                for (var i = 0; i < arr.length; i++) {
                    if (callback_function(arr[i]) > m) {
                        m = callback_function(arr[i])
                    }
                }
                return m
            }
        };
        var getVertices = function(links) {
            var vert = [];
            links.forEach(function(link) {
                if (vert.indexOf(link[0]) === -1) {
                    vert.push(link[0])
                }
                if (vert.indexOf(link[1]) === -1) {
                    vert.push(link[1])
                }
            });
            return vert
        };
        var getAdjacentVertices = function(links, vertex) {
            var avert = [];
            links.forEach(function(link) {
                if (link[0] === vertex && avert.indexOf(link[1]) === -1) {
                    avert.push(link[1])
                }
            });
            return avert
        };
        var getReverseAdjacentVertices = function(links, vertex) {
            var avert = [];
            links.forEach(function(link) {
                if (link[1] === vertex && avert.indexOf(link[0]) === -1) {
                    avert.push(link[0])
                }
            });
            return avert
        };
        var struct = {
            _hasCycle: false,
            _sortedList: [],
            hasCycle: function(links) {
                var _this = this;
                this._hasCycle = false;
                this._sortedList = [];
                var vertices = {};
                var allVertices = getVertices(links);
                allVertices.forEach(function(vertex) {
                    vertices[vertex] = {
                        color: WHITE
                    }
                });
                allVertices.forEach(function(vertex) {
                    if (vertices[vertex].color === WHITE) {
                        _this._depthFirstSearch(links, vertices, vertex)
                    }
                });
                this._sortedList.reverse();
                return this._hasCycle
            },
            _depthFirstSearch: function(links, vertices, vertex) {
                vertices[vertex].color = GRAY;
                var averts = getAdjacentVertices(links, vertex);
                for (var a = 0; a < averts.length; a++) {
                    if (vertices[averts[a]].color === WHITE) {
                        this._depthFirstSearch(links, vertices, averts[a])
                    } else {
                        if (vertices[averts[a]].color === GRAY) {
                            this._hasCycle = true
                        }
                    }
                }
                this._sortedList.push({
                    name: vertex,
                    lp: null,
                    incoming: getReverseAdjacentVertices(links, vertex),
                    outgoing: getAdjacentVertices(links, vertex)
                });
                vertices[vertex].color = BLACK
            },
            computeLongestPaths: function(links) {
                var sortedVertices = this._sortedList;
                sortedVertices.forEach(function(vertex) {
                    var averts = getReverseAdjacentVertices(links, vertex.name);
                    if (0 === averts.length) {
                        vertex.lp = 0
                    } else {
                        var maxLP = [];
                        averts.forEach(function(adjacentVertex) {
                            maxLP.push(sortedVertices.filter(function(sv) {
                                return sv.name === adjacentVertex
                            })[0].lp)
                        });
                        vertex.lp = routines.maxOfArray(maxLP) + 1
                    }
                });
                return this._sortedList
            }
        };
        module.exports = {
            struct: struct,
            routines: routines,
            getVertices: getVertices,
            getAdjacentVertices: getAdjacentVertices,
            getReverseAdjacentVertices: getReverseAdjacentVertices
        }
    }, , , ,
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel_creator.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _class = __webpack_require__( /*! ../core/class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _window = __webpack_require__( /*! ../core/utils/window */ 7);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _ui = __webpack_require__( /*! ../ui/widget/ui.errors */ 18);
        var _ui2 = _interopRequireDefault(_ui);
        var _string = __webpack_require__( /*! ../core/utils/string */ 43);
        var _string2 = _interopRequireDefault(_string);
        var _jszip = __webpack_require__( /*! jszip */ 296);
        var _jszip2 = _interopRequireDefault(_jszip);
        var _file_saver = __webpack_require__( /*! ./file_saver */ 176);
        var _file_saver2 = _interopRequireDefault(_file_saver);
        var _excel_format_converter = __webpack_require__( /*! ./excel_format_converter */ 186);
        var _excel_format_converter2 = _interopRequireDefault(_excel_format_converter);
        var _excel = __webpack_require__( /*! ./excel/excel.file */ 457);
        var _excel2 = _interopRequireDefault(_excel);
        var _deferred = __webpack_require__( /*! ../core/utils/deferred */ 6);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var XML_TAG = '<?xml version="1.0" encoding="utf-8"?>';
        var GROUP_SHEET_PR_XML = '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>';
        var SINGLE_SHEET_PR_XML = "<sheetPr/>";
        var BASE_STYLE_XML2 = '<borders count="1"><border><left style="thin"><color rgb="FFD3D3D3"/></left><right style="thin"><color rgb="FFD3D3D3"/></right><top style="thin"><color rgb="FFD3D3D3"/></top><bottom style="thin"><color rgb="FFD3D3D3"/></bottom></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
        var OPEN_XML_FORMAT_URL = "http://schemas.openxmlformats.org";
        var RELATIONSHIP_PART_NAME = "rels";
        var XL_FOLDER_NAME = "xl";
        var WORKBOOK_FILE_NAME = "workbook.xml";
        var CONTENTTYPES_FILE_NAME = "[Content_Types].xml";
        var SHAREDSTRING_FILE_NAME = "sharedStrings.xml";
        var STYLE_FILE_NAME = "styles.xml";
        var WORKSHEETS_FOLDER = "worksheets";
        var WORKSHEET_FILE_NAME = "sheet1.xml";
        var WORKSHEET_HEADER_XML = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">';
        var VALID_TYPES = {
            "boolean": "b",
            date: "d",
            number: "n",
            string: "s"
        };
        var EXCEL_START_TIME = Date.UTC(1899, 11, 30);
        var DAYS_COUNT_BEFORE_29_FEB_1900 = 60;
        var MAX_DIGIT_WIDTH_IN_PIXELS = 7;
        var UNSUPPORTED_FORMAT_MAPPING = {
            quarter: "shortDate",
            quarterAndYear: "shortDate",
            minute: "longTime",
            millisecond: "longTime"
        };
        var ExcelCreator = _class2.default.inherit({
            _getXMLTag: function(tagName, attributes, content) {
                var result = "<" + tagName;
                var i;
                var length = attributes.length;
                var attr;
                for (i = 0; i < length; i++) {
                    attr = attributes[i];
                    if (void 0 !== attr.value) {
                        result = result + " " + attr.name + '="' + attr.value + '"'
                    }
                }
                return (0, _type.isDefined)(content) ? result + ">" + content + "</" + tagName + ">" : result + " />"
            },
            _convertToExcelCellRef: function(zeroBasedRowIndex, zeroBasedCellIndex) {
                var columnName = "";
                var max = 26;
                var charCode;
                var isCellIndexFound;
                while (!isCellIndexFound) {
                    charCode = 65 + (zeroBasedCellIndex >= max ? zeroBasedCellIndex % max : Math.ceil(zeroBasedCellIndex));
                    columnName = String.fromCharCode(charCode) + columnName;
                    if (zeroBasedCellIndex >= max) {
                        zeroBasedCellIndex = Math.floor(zeroBasedCellIndex / max) - 1
                    } else {
                        isCellIndexFound = true
                    }
                }
                return columnName + (zeroBasedRowIndex + 1)
            },
            _convertToExcelCellRefAndTrackMaxIndex: function(rowIndex, cellIndex) {
                if (this._maxRowIndex < Number(rowIndex)) {
                    this._maxRowIndex = Number(rowIndex)
                }
                if (this._maxColumnIndex < Number(cellIndex)) {
                    this._maxColumnIndex = Number(cellIndex)
                }
                return this._convertToExcelCellRef(rowIndex, cellIndex)
            },
            _getDataType: function(dataType) {
                return VALID_TYPES[dataType] || VALID_TYPES.string
            },
            _tryGetExcelCellDataType: function(object) {
                if ((0, _type.isDefined)(object)) {
                    if ("number" === typeof object) {
                        if (isFinite(object)) {
                            return VALID_TYPES.number
                        } else {
                            return VALID_TYPES.string
                        }
                    } else {
                        if ((0, _type.isString)(object)) {
                            return VALID_TYPES.string
                        } else {
                            if ((0, _type.isDate)(object)) {
                                return VALID_TYPES.number
                            } else {
                                if ((0, _type.isBoolean)(object)) {
                                    return VALID_TYPES.boolean
                                }
                            }
                        }
                    }
                }
            },
            _formatObjectConverter: function(format, dataType) {
                var result = {
                    format: format,
                    precision: format && format.precision,
                    dataType: dataType
                };
                if ((0, _type.isObject)(format)) {
                    return (0, _extend.extend)(result, format, {
                        format: format.formatter || format.type,
                        currency: format.currency
                    })
                }
                return result
            },
            _tryConvertToExcelNumberFormat: function(format, dataType) {
                var newFormat = this._formatObjectConverter(format, dataType);
                format = newFormat.format;
                var currency = newFormat.currency;
                dataType = newFormat.dataType;
                if ((0, _type.isDefined)(format) && "date" === dataType) {
                    format = UNSUPPORTED_FORMAT_MAPPING[format && format.type || format] || format
                }
                return _excel_format_converter2.default.convertFormat(format, newFormat.precision, dataType, currency)
            },
            _appendString: function(value) {
                if ((0, _type.isDefined)(value)) {
                    value = String(value);
                    if (value.length) {
                        value = _string2.default.encodeHtml(value);
                        if (void 0 === this._stringHash[value]) {
                            this._stringHash[value] = this._stringArray.length;
                            this._stringArray.push(value)
                        }
                        return this._stringHash[value]
                    }
                }
            },
            _tryGetExcelDateValue: function(date) {
                var days;
                var totalTime;
                if ((0, _type.isDate)(date)) {
                    days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / 864e5);
                    if (days < DAYS_COUNT_BEFORE_29_FEB_1900) {
                        days--
                    }
                    totalTime = (3600 * date.getHours() + 60 * date.getMinutes() + date.getSeconds()) / 86400;
                    return days + totalTime
                }
            },
            _prepareValue: function(rowIndex, cellIndex) {
                var dataProvider = this._dataProvider;
                var _ref = dataProvider.getCellData(rowIndex, cellIndex) || {},
                    cellSourceData = _ref.cellSourceData;
                var _ref2 = dataProvider.getCellData(rowIndex, cellIndex) || {},
                    value = _ref2.value;
                var sourceValue;
                var type = this._getDataType(dataProvider.getCellType(rowIndex, cellIndex));
                if (type === VALID_TYPES.date && !(0, _type.isDate)(value)) {
                    type = VALID_TYPES.string
                }
                switch (type) {
                    case VALID_TYPES.string:
                        sourceValue = value;
                        value = this._appendString(value);
                        break;
                    case VALID_TYPES.date:
                        sourceValue = value;
                        value = this._tryGetExcelDateValue(value);
                        type = VALID_TYPES.number
                }
                return {
                    value: value,
                    type: type,
                    sourceValue: sourceValue,
                    cellSourceData: cellSourceData
                }
            },
            _callCustomizeExcelCell: function(_ref3) {
                var dataProvider = _ref3.dataProvider,
                    value = _ref3.value,
                    style = _ref3.style,
                    sourceData = _ref3.sourceData;
                var styleCopy = _excel2.default.copyCellFormat(style);
                var args = {
                    value: value,
                    numberFormat: styleCopy.numberFormat,
                    clearStyle: function() {
                        this.horizontalAlignment = null;
                        this.verticalAlignment = null;
                        this.wrapTextEnabled = null;
                        this.font = null;
                        this.numberFormat = null
                    }
                };
                if ((0, _type.isDefined)(styleCopy)) {
                    if ((0, _type.isDefined)(styleCopy.alignment)) {
                        args.horizontalAlignment = styleCopy.alignment.horizontal;
                        args.verticalAlignment = styleCopy.alignment.vertical;
                        args.wrapTextEnabled = styleCopy.alignment.wrapText
                    }
                    args.backgroundColor = styleCopy.backgroundColor;
                    args.fillPatternType = styleCopy.fillPatternType;
                    args.fillPatternColor = styleCopy.fillPatternColor;
                    args.font = styleCopy.font
                }
                dataProvider.customizeExcelCell(args, sourceData);
                var newStyle = styleCopy || {};
                newStyle.font = args.font;
                newStyle.alignment = newStyle.alignment || {};
                newStyle.alignment.horizontal = args.horizontalAlignment;
                newStyle.alignment.vertical = args.verticalAlignment;
                newStyle.alignment.wrapText = args.wrapTextEnabled;
                newStyle.backgroundColor = args.backgroundColor;
                newStyle.fillPatternType = args.fillPatternType;
                newStyle.fillPatternColor = args.fillPatternColor;
                newStyle.numberFormat = args.numberFormat;
                return {
                    value: args.value,
                    style: newStyle
                }
            },
            _getDataArray: function() {
                var that = this;
                var rowIndex;
                var cellIndex;
                var cellsArray;
                var cellData;
                var result = [];
                var dataProvider = that._dataProvider;
                var rowsLength = dataProvider.getRowsCount();
                var columns = dataProvider.getColumns();
                var cellsLength;
                for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                    cellsArray = [];
                    cellsLength = columns.length;
                    for (cellIndex = 0; cellIndex !== cellsLength; cellIndex++) {
                        cellData = that._prepareValue(rowIndex, cellIndex);
                        var styleArrayIndex = dataProvider.getStyleId(rowIndex, cellIndex);
                        var cellStyleId = this._styleArrayIndexToCellStyleIdMap[styleArrayIndex];
                        if (dataProvider.hasCustomizeExcelCell && dataProvider.hasCustomizeExcelCell()) {
                            var value = cellData.sourceValue || cellData.value;
                            var modifiedExcelCell = this._callCustomizeExcelCell({
                                dataProvider: dataProvider,
                                value: value,
                                style: that._styleArray[styleArrayIndex],
                                sourceData: cellData.cellSourceData
                            });
                            if (modifiedExcelCell.value !== value) {
                                if (_typeof(modifiedExcelCell.value) !== _typeof(value) || "number" === typeof modifiedExcelCell.value && !isFinite(modifiedExcelCell.value)) {
                                    var cellDataType = this._tryGetExcelCellDataType(modifiedExcelCell.value);
                                    if ((0, _type.isDefined)(cellDataType)) {
                                        cellData.type = cellDataType
                                    }
                                }
                                switch (cellData.type) {
                                    case VALID_TYPES.string:
                                        cellData.value = this._appendString(modifiedExcelCell.value);
                                        break;
                                    case VALID_TYPES.date:
                                        cellData.value = modifiedExcelCell.value;
                                        break;
                                    case VALID_TYPES.number:
                                        var newValue = modifiedExcelCell.value;
                                        var excelDateValue = this._tryGetExcelDateValue(newValue);
                                        if ((0, _type.isDefined)(excelDateValue)) {
                                            newValue = excelDateValue
                                        }
                                        cellData.value = newValue;
                                        break;
                                    default:
                                        cellData.value = modifiedExcelCell.value
                                }
                            }
                            cellStyleId = this._excelFile.registerCellFormat(modifiedExcelCell.style)
                        }
                        cellsArray.push({
                            style: cellStyleId,
                            value: cellData.value,
                            type: cellData.type
                        })
                    }
                    if (!that._needSheetPr && dataProvider.getGroupLevel(rowIndex) > 0) {
                        that._needSheetPr = true
                    }
                    result.push(cellsArray)
                }
                return result
            },
            _calculateWidth: function(pixelsWidth) {
                pixelsWidth = parseInt(pixelsWidth, 10);
                if (!pixelsWidth || pixelsWidth < 5) {
                    pixelsWidth = 100
                }
                return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + .5) / 100)
            },
            _prepareStyleData: function() {
                var _this = this;
                var that = this;
                var styles = that._dataProvider.getStyles();
                that._dataProvider.getColumns().forEach(function(column) {
                    that._colsArray.push(that._calculateWidth(column.width))
                });
                var fonts = [{
                    size: 11,
                    color: {
                        theme: 1
                    },
                    name: "Calibri",
                    family: 2,
                    scheme: "minor",
                    bold: false
                }, {
                    size: 11,
                    color: {
                        theme: 1
                    },
                    name: "Calibri",
                    family: 2,
                    scheme: "minor",
                    bold: true
                }];
                this._excelFile.registerFont(fonts[0]);
                this._excelFile.registerFont(fonts[1]);
                styles.forEach(function(style) {
                    var numberFormat = that._tryConvertToExcelNumberFormat(style.format, style.dataType);
                    if (!(0, _type.isDefined)(numberFormat)) {
                        numberFormat = 0
                    }
                    that._styleArray.push({
                        font: fonts[Number(!!style.bold)],
                        numberFormat: numberFormat,
                        alignment: {
                            vertical: "top",
                            wrapText: !!style.wrapText,
                            horizontal: style.alignment || "left"
                        }
                    })
                });
                that._styleArrayIndexToCellStyleIdMap = that._styleArray.map(function(item) {
                    return _this._excelFile.registerCellFormat(item)
                })
            },
            _prepareCellData: function() {
                this._cellsArray = this._getDataArray()
            },
            _createXMLRelationships: function(xmlRelationships) {
                return this._getXMLTag("Relationships", [{
                    name: "xmlns",
                    value: OPEN_XML_FORMAT_URL + "/package/2006/relationships"
                }], xmlRelationships)
            },
            _createXMLRelationship: function(id, type, target) {
                return this._getXMLTag("Relationship", [{
                    name: "Id",
                    value: "rId" + id
                }, {
                    name: "Type",
                    value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships/" + type
                }, {
                    name: "Target",
                    value: target
                }])
            },
            _getWorkbookContent: function() {
                var content = '<bookViews><workbookView xWindow="0" yWindow="0" windowWidth="0" windowHeight="0"/></bookViews><sheets><sheet name="Sheet" sheetId="1" r:id="rId1" /></sheets><definedNames><definedName name="_xlnm.Print_Titles" localSheetId="0">Sheet!$1:$1</definedName><definedName name="_xlnm._FilterDatabase" hidden="0" localSheetId="0">Sheet!$A$1:$F$6332</definedName></definedNames>';
                return XML_TAG + this._getXMLTag("workbook", [{
                    name: "xmlns:r",
                    value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships"
                }, {
                    name: "xmlns",
                    value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                }], content)
            },
            _getContentTypesContent: function() {
                return XML_TAG + '<Types xmlns="' + OPEN_XML_FORMAT_URL + '/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" /><Default Extension="xml" ContentType="application/xml" /><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" /><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" /><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" /><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" /></Types>'
            },
            _generateStylesXML: function() {
                var that = this;
                var folder = that._zip.folder(XL_FOLDER_NAME);
                var XML = "";
                XML += this._excelFile.generateNumberFormatsXml();
                XML += this._excelFile.generateFontsXml();
                XML += this._excelFile.generateFillsXml();
                XML += BASE_STYLE_XML2;
                XML += this._excelFile.generateCellFormatsXml();
                XML += that._getXMLTag("cellStyles", [{
                    name: "count",
                    value: 1
                }], that._getXMLTag("cellStyle", [{
                    name: "name",
                    value: "Normal"
                }, {
                    name: "xfId",
                    value: 0
                }, {
                    name: "builtinId",
                    value: 0
                }]));
                XML = XML_TAG + that._getXMLTag("styleSheet", [{
                    name: "xmlns",
                    value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                }], XML);
                folder.file(STYLE_FILE_NAME, XML);
                that._styleArray = []
            },
            _generateStringsXML: function() {
                var folder = this._zip.folder(XL_FOLDER_NAME);
                var stringIndex;
                var stringsLength = this._stringArray.length;
                var sharedStringXml = XML_TAG;
                for (stringIndex = 0; stringIndex < stringsLength; stringIndex++) {
                    this._stringArray[stringIndex] = this._getXMLTag("si", [], this._getXMLTag("t", [], this._stringArray[stringIndex]))
                }
                sharedStringXml += this._getXMLTag("sst", [{
                    name: "xmlns",
                    value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                }, {
                    name: "count",
                    value: this._stringArray.length
                }, {
                    name: "uniqueCount",
                    value: this._stringArray.length
                }], this._stringArray.join(""));
                folder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
                this._stringArray = []
            },
            _getPaneXML: function() {
                var attributes = [{
                    name: "activePane",
                    value: "bottomLeft"
                }, {
                    name: "state",
                    value: "frozen"
                }];
                var frozenArea = this._dataProvider.getFrozenArea();
                if (!(frozenArea.x || frozenArea.y)) {
                    return ""
                }
                if (frozenArea.x) {
                    attributes.push({
                        name: "xSplit",
                        value: frozenArea.x
                    })
                }
                if (frozenArea.y) {
                    attributes.push({
                        name: "ySplit",
                        value: frozenArea.y
                    })
                }
                attributes.push({
                    name: "topLeftCell",
                    value: this._convertToExcelCellRefAndTrackMaxIndex(frozenArea.y, frozenArea.x)
                });
                return this._getXMLTag("pane", attributes)
            },
            _getAutoFilterXML: function(maxCellIndex) {
                if (this._options.autoFilterEnabled) {
                    return '<autoFilter ref="A' + this._dataProvider.getHeaderRowCount() + ":" + maxCellIndex + '" />'
                }
                return ""
            },
            _getIgnoredErrorsXML: function(maxCellIndex) {
                if (this._options.ignoreErrors) {
                    return '<ignoredErrors><ignoredError sqref="A1:' + maxCellIndex + '" numberStoredAsText="1" /></ignoredErrors>'
                }
                return ""
            },
            _generateWorksheetXML: function() {
                var colIndex;
                var rowIndex;
                var cellData;
                var xmlCells;
                var xmlRows = [];
                var rowsLength = this._cellsArray.length;
                var cellsLength;
                var colsLength = this._colsArray.length;
                var rSpans = "1:" + colsLength;
                var headerRowCount = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 1;
                var xmlResult = [WORKSHEET_HEADER_XML];
                xmlResult.push(this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML);
                xmlResult.push('<dimension ref="A1:C1"/>');
                xmlResult.push("<sheetViews><sheetView ");
                xmlResult.push(this._rtlEnabled ? 'rightToLeft="1" ' : "");
                xmlResult.push('tabSelected="1" workbookViewId="0">');
                xmlResult.push(this._getPaneXML());
                xmlResult.push("</sheetView></sheetViews>");
                xmlResult.push('<sheetFormatPr defaultRowHeight="15"');
                xmlResult.push(' outlineLevelRow="' + (this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0) + '"');
                xmlResult.push(' x14ac:dyDescent="0.25"/>');
                for (colIndex = 0; colIndex < colsLength; colIndex++) {
                    this._colsArray[colIndex] = this._getXMLTag("col", [{
                        name: "width",
                        value: this._colsArray[colIndex]
                    }, {
                        name: "min",
                        value: Number(colIndex) + 1
                    }, {
                        name: "max",
                        value: Number(colIndex) + 1
                    }, {
                        name: "customWidth",
                        value: 1
                    }])
                }
                xmlResult.push(this._getXMLTag("cols", [], this._colsArray.join("")) + "<sheetData>");
                for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                    xmlCells = [];
                    cellsLength = this._cellsArray[rowIndex].length;
                    for (colIndex = 0; colIndex < cellsLength; colIndex++) {
                        rowIndex = Number(rowIndex);
                        cellData = this._cellsArray[rowIndex][colIndex];
                        xmlCells.push(this._getXMLTag("c", [{
                            name: "r",
                            value: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex, colIndex)
                        }, {
                            name: "s",
                            value: cellData.style
                        }, {
                            name: "t",
                            value: cellData.type
                        }], (0, _type.isDefined)(cellData.value) ? this._getXMLTag("v", [], cellData.value) : null))
                    }
                    xmlRows.push(this._getXMLTag("row", [{
                        name: "r",
                        value: Number(rowIndex) + 1
                    }, {
                        name: "spans",
                        value: rSpans
                    }, {
                        name: "outlineLevel",
                        value: rowIndex >= headerRowCount ? this._dataProvider.getGroupLevel(rowIndex) : 0
                    }, {
                        name: "x14ac:dyDescent",
                        value: "0.25"
                    }], xmlCells.join("")));
                    this._cellsArray[rowIndex] = null;
                    if (xmlRows.length > 1e4) {
                        xmlResult.push(xmlRows.join(""));
                        xmlRows = []
                    }
                }
                xmlResult.push(xmlRows.join(""));
                xmlRows = [];
                var rightBottomCellRef = this._convertToExcelCellRef(this._maxRowIndex, this._maxColumnIndex);
                xmlResult.push("</sheetData>" + this._getAutoFilterXML(rightBottomCellRef) + this._generateMergingXML() + this._getIgnoredErrorsXML(rightBottomCellRef) + "</worksheet>");
                this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(""));
                this._colsArray = [];
                this._cellsArray = [];
                xmlResult = []
            },
            _generateMergingXML: function() {
                var k;
                var l;
                var cellIndex;
                var rowIndex;
                var rowsLength = (0, _type.isDefined)(this._dataProvider.getHeaderRowCount) ? this._dataProvider.getHeaderRowCount() : this._dataProvider.getRowsCount();
                var columnsLength = this._dataProvider.getColumns().length;
                var usedArea = [];
                var mergeArray = [];
                var mergeIndex;
                var mergeXML = "";
                for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                    for (cellIndex = 0; cellIndex !== columnsLength; cellIndex++) {
                        if (!(0, _type.isDefined)(usedArea[rowIndex]) || !(0, _type.isDefined)(usedArea[rowIndex][cellIndex])) {
                            var cellMerge = this._dataProvider.getCellMerging(rowIndex, cellIndex);
                            if (cellMerge.colspan || cellMerge.rowspan) {
                                mergeArray.push({
                                    start: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex, cellIndex),
                                    end: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex + (cellMerge.rowspan || 0), cellIndex + (cellMerge.colspan || 0))
                                });
                                for (k = rowIndex; k <= rowIndex + cellMerge.rowspan || 0; k++) {
                                    for (l = cellIndex; l <= cellIndex + cellMerge.colspan || 0; l++) {
                                        if (!(0, _type.isDefined)(usedArea[k])) {
                                            usedArea[k] = []
                                        }
                                        usedArea[k][l] = true
                                    }
                                }
                            }
                        }
                    }
                }
                var mergeArrayLength = mergeArray.length;
                for (mergeIndex = 0; mergeIndex < mergeArrayLength; mergeIndex++) {
                    mergeXML += this._getXMLTag("mergeCell", [{
                        name: "ref",
                        value: mergeArray[mergeIndex].start + ":" + mergeArray[mergeIndex].end
                    }])
                }
                return mergeXML.length ? this._getXMLTag("mergeCells", [{
                    name: "count",
                    value: mergeArrayLength
                }], mergeXML) : ""
            },
            _generateCommonXML: function() {
                var relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, "officeDocument", "xl/" + WORKBOOK_FILE_NAME));
                var folder = this._zip.folder(XL_FOLDER_NAME);
                var relsXML = XML_TAG;
                this._zip.folder("_" + RELATIONSHIP_PART_NAME).file("." + RELATIONSHIP_PART_NAME, relsFileContent);
                var xmlRelationships = this._createXMLRelationship(1, "worksheet", "worksheets/" + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, "styles", STYLE_FILE_NAME) + this._createXMLRelationship(3, "sharedStrings", SHAREDSTRING_FILE_NAME);
                relsXML += this._createXMLRelationships(xmlRelationships);
                folder.folder("_" + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + ".rels", relsXML);
                folder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());
                this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent())
            },
            _generateContent: function() {
                this._prepareStyleData();
                this._prepareCellData();
                this._generateWorkXML();
                this._generateCommonXML()
            },
            _generateWorkXML: function() {
                this._generateStylesXML();
                this._generateStringsXML();
                this._generateWorksheetXML()
            },
            ctor: function(dataProvider, options) {
                this._rtlEnabled = options && !!options.rtlEnabled;
                this._options = options;
                this._maxRowIndex = 0;
                this._maxColumnIndex = 0;
                this._stringArray = [];
                this._stringHash = {};
                this._styleArray = [];
                this._colsArray = [];
                this._cellsArray = [];
                this._needSheetPr = false;
                this._dataProvider = dataProvider;
                this._excelFile = new _excel2.default;
                if ((0, _type.isDefined)(ExcelCreator.JSZip)) {
                    this._zip = new ExcelCreator.JSZip
                } else {
                    this._zip = null
                }
            },
            _checkZipState: function() {
                if (!this._zip) {
                    throw _ui2.default.Error("E1041", "JSZip")
                }
            },
            ready: function() {
                return this._dataProvider.ready()
            },
            getData: function(isBlob) {
                var options = {
                    type: isBlob ? "blob" : "base64",
                    compression: "DEFLATE",
                    mimeType: _file_saver2.default.MIME_TYPES.EXCEL
                };
                var deferred = new _deferred.Deferred;
                this._checkZipState();
                this._generateContent();
                if (this._zip.generateAsync) {
                    this._zip.generateAsync(options).then(deferred.resolve)
                } else {
                    deferred.resolve(this._zip.generate(options))
                }
                return deferred
            }
        });
        ExcelCreator.JSZip = _jszip2.default;
        exports.ExcelCreator = ExcelCreator;
        exports.getData = function(data, options) {
            var excelCreator = new exports.ExcelCreator(data, options);
            excelCreator._checkZipState();
            return excelCreator.ready().then(function() {
                return excelCreator.getData((0, _type.isFunction)((0, _window.getWindow)().Blob))
            })
        };
        exports.__internals = {
            CONTENTTYPES_FILE_NAME: CONTENTTYPES_FILE_NAME,
            RELATIONSHIP_PART_NAME: RELATIONSHIP_PART_NAME,
            XL_FOLDER_NAME: XL_FOLDER_NAME,
            WORKBOOK_FILE_NAME: WORKBOOK_FILE_NAME,
            STYLE_FILE_NAME: STYLE_FILE_NAME,
            WORKSHEET_FILE_NAME: WORKSHEET_FILE_NAME,
            WORKSHEETS_FOLDER: WORKSHEETS_FOLDER,
            WORKSHEET_HEADER_XML: WORKSHEET_HEADER_XML,
            SHAREDSTRING_FILE_NAME: SHAREDSTRING_FILE_NAME,
            GROUP_SHEET_PR_XML: GROUP_SHEET_PR_XML,
            SINGLE_SHEET_PR_XML: SINGLE_SHEET_PR_XML,
            BASE_STYLE_XML2: BASE_STYLE_XML2,
            XML_TAG: XML_TAG
        }
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/localization/intl/number.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _config = __webpack_require__( /*! ../../core/config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _core = __webpack_require__( /*! ../core */ 83);
        var _open_xml_currency_format = __webpack_require__( /*! ../open_xml_currency_format */ 272);
        var _open_xml_currency_format2 = _interopRequireDefault(_open_xml_currency_format);
        var _accounting_formats = __webpack_require__( /*! ../cldr-data/accounting_formats */ 454);
        var _accounting_formats2 = _interopRequireDefault(_accounting_formats);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
        var formattersCache = {};
        var getFormatter = function(format) {
            var key = (0, _core.locale)() + "/" + JSON.stringify(format);
            if (!formattersCache[key]) {
                formattersCache[key] = new Intl.NumberFormat((0, _core.locale)(), format).format
            }
            return formattersCache[key]
        };
        var getCurrencyFormatter = function(currency) {
            return new Intl.NumberFormat((0, _core.locale)(), {
                style: "currency",
                currency: currency
            })
        };
        module.exports = {
            engine: function() {
                return "intl"
            },
            _formatNumberCore: function(value, format, formatConfig) {
                if ("exponential" === format) {
                    return this.callBase.apply(this, arguments)
                }
                return getFormatter(this._normalizeFormatConfig(format, formatConfig))(value)
            },
            _normalizeFormatConfig: function(format, formatConfig, value) {
                var config;
                if ("decimal" === format) {
                    config = {
                        minimumIntegerDigits: formatConfig.precision || void 0,
                        useGrouping: false,
                        maximumFractionDigits: String(value).length,
                        round: value < 0 ? "ceil" : "floor"
                    }
                } else {
                    config = this._getPrecisionConfig(formatConfig.precision)
                }
                if ("percent" === format) {
                    config.style = "percent"
                } else {
                    if ("currency" === format) {
                        config.style = "currency";
                        config.currency = formatConfig.currency || (0, _config2.default)().defaultCurrency
                    }
                }
                return config
            },
            _getPrecisionConfig: function(precision) {
                var config;
                if (null === precision) {
                    config = {
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 20
                    }
                } else {
                    config = {
                        minimumFractionDigits: precision || 0,
                        maximumFractionDigits: precision || 0
                    }
                }
                return config
            },
            format: function(value, _format) {
                if ("number" !== typeof value) {
                    return value
                }
                _format = this._normalizeFormat(_format);
                if ("default" === _format.currency) {
                    _format.currency = (0, _config2.default)().defaultCurrency
                }
                if (!_format || "function" !== typeof _format && !_format.type && !_format.formatter) {
                    return getFormatter(_format)(value)
                }
                return this.callBase.apply(this, arguments)
            },
            _getCurrencySymbolInfo: function(currency) {
                var formatter = getCurrencyFormatter(currency);
                return this._extractCurrencySymbolInfo(formatter.format(0))
            },
            _extractCurrencySymbolInfo: function(currencyValueString) {
                var match = detectCurrencySymbolRegex.exec(currencyValueString) || [];
                var position = match[1] ? "before" : "after";
                var symbol = match[1] || match[4] || "";
                var delimiter = match[2] || match[3] || "";
                return {
                    position: position,
                    symbol: symbol,
                    delimiter: delimiter
                }
            },
            getCurrencySymbol: function(currency) {
                if (!currency) {
                    currency = (0, _config2.default)().defaultCurrency
                }
                var symbolInfo = this._getCurrencySymbolInfo(currency);
                return {
                    symbol: symbolInfo.symbol
                }
            },
            getOpenXmlCurrencyFormat: function(currency) {
                var targetCurrency = currency || (0, _config2.default)().defaultCurrency;
                var currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
                var closestAccountingFormat = (0, _core.getValueByClosestLocale)(function(locale) {
                    return _accounting_formats2.default[locale]
                });
                return (0, _open_xml_currency_format2.default)(currencySymbol, closestAccountingFormat)
            }
        }
    },
    /*!***********************************************************************!*\
      !*** ./artifacts/transpiled/localization/cldr-data/parent_locales.js ***!
      \***********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = {
            "en-150": "en-001",
            "en-AG": "en-001",
            "en-AI": "en-001",
            "en-AU": "en-001",
            "en-BB": "en-001",
            "en-BM": "en-001",
            "en-BS": "en-001",
            "en-BW": "en-001",
            "en-BZ": "en-001",
            "en-CA": "en-001",
            "en-CC": "en-001",
            "en-CK": "en-001",
            "en-CM": "en-001",
            "en-CX": "en-001",
            "en-CY": "en-001",
            "en-DG": "en-001",
            "en-DM": "en-001",
            "en-ER": "en-001",
            "en-FJ": "en-001",
            "en-FK": "en-001",
            "en-FM": "en-001",
            "en-GB": "en-001",
            "en-GD": "en-001",
            "en-GG": "en-001",
            "en-GH": "en-001",
            "en-GI": "en-001",
            "en-GM": "en-001",
            "en-GY": "en-001",
            "en-HK": "en-001",
            "en-IE": "en-001",
            "en-IL": "en-001",
            "en-IM": "en-001",
            "en-IN": "en-001",
            "en-IO": "en-001",
            "en-JE": "en-001",
            "en-JM": "en-001",
            "en-KE": "en-001",
            "en-KI": "en-001",
            "en-KN": "en-001",
            "en-KY": "en-001",
            "en-LC": "en-001",
            "en-LR": "en-001",
            "en-LS": "en-001",
            "en-MG": "en-001",
            "en-MO": "en-001",
            "en-MS": "en-001",
            "en-MT": "en-001",
            "en-MU": "en-001",
            "en-MW": "en-001",
            "en-MY": "en-001",
            "en-NA": "en-001",
            "en-NF": "en-001",
            "en-NG": "en-001",
            "en-NR": "en-001",
            "en-NU": "en-001",
            "en-NZ": "en-001",
            "en-PG": "en-001",
            "en-PH": "en-001",
            "en-PK": "en-001",
            "en-PN": "en-001",
            "en-PW": "en-001",
            "en-RW": "en-001",
            "en-SB": "en-001",
            "en-SC": "en-001",
            "en-SD": "en-001",
            "en-SG": "en-001",
            "en-SH": "en-001",
            "en-SL": "en-001",
            "en-SS": "en-001",
            "en-SX": "en-001",
            "en-SZ": "en-001",
            "en-TC": "en-001",
            "en-TK": "en-001",
            "en-TO": "en-001",
            "en-TT": "en-001",
            "en-TV": "en-001",
            "en-TZ": "en-001",
            "en-UG": "en-001",
            "en-VC": "en-001",
            "en-VG": "en-001",
            "en-VU": "en-001",
            "en-WS": "en-001",
            "en-ZA": "en-001",
            "en-ZM": "en-001",
            "en-ZW": "en-001",
            "en-AT": "en-150",
            "en-BE": "en-150",
            "en-CH": "en-150",
            "en-DE": "en-150",
            "en-DK": "en-150",
            "en-FI": "en-150",
            "en-NL": "en-150",
            "en-SE": "en-150",
            "en-SI": "en-150",
            "es-AR": "es-419",
            "es-BO": "es-419",
            "es-BR": "es-419",
            "es-BZ": "es-419",
            "es-CL": "es-419",
            "es-CO": "es-419",
            "es-CR": "es-419",
            "es-CU": "es-419",
            "es-DO": "es-419",
            "es-EC": "es-419",
            "es-GT": "es-419",
            "es-HN": "es-419",
            "es-MX": "es-419",
            "es-NI": "es-419",
            "es-PA": "es-419",
            "es-PE": "es-419",
            "es-PR": "es-419",
            "es-PY": "es-419",
            "es-SV": "es-419",
            "es-US": "es-419",
            "es-UY": "es-419",
            "es-VE": "es-419",
            "pt-AO": "pt-PT",
            "pt-CH": "pt-PT",
            "pt-CV": "pt-PT",
            "pt-FR": "pt-PT",
            "pt-GQ": "pt-PT",
            "pt-GW": "pt-PT",
            "pt-LU": "pt-PT",
            "pt-MO": "pt-PT",
            "pt-MZ": "pt-PT",
            "pt-ST": "pt-PT",
            "pt-TL": "pt-PT",
            "az-Arab": "root",
            "az-Cyrl": "root",
            "blt-Latn": "root",
            "bm-Nkoo": "root",
            "bs-Cyrl": "root",
            "byn-Latn": "root",
            "cu-Glag": "root",
            "dje-Arab": "root",
            "dyo-Arab": "root",
            "en-Dsrt": "root",
            "en-Shaw": "root",
            "ff-Adlm": "root",
            "ff-Arab": "root",
            "ha-Arab": "root",
            "iu-Latn": "root",
            "kk-Arab": "root",
            "ku-Arab": "root",
            "ky-Arab": "root",
            "ky-Latn": "root",
            "ml-Arab": "root",
            "mn-Mong": "root",
            "ms-Arab": "root",
            "pa-Arab": "root",
            "sd-Deva": "root",
            "sd-Khoj": "root",
            "sd-Sind": "root",
            "shi-Latn": "root",
            "so-Arab": "root",
            "sr-Latn": "root",
            "sw-Arab": "root",
            "tg-Arab": "root",
            "ug-Cyrl": "root",
            "uz-Arab": "root",
            "uz-Cyrl": "root",
            "vai-Latn": "root",
            "wo-Arab": "root",
            "yo-Arab": "root",
            "yue-Hans": "root",
            "zh-Hant": "root",
            "zh-Hant-MO": "zh-Hant-HK"
        }
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/localization/parentLocale.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var PARENT_LOCALE_SEPARATOR = "-";
        module.exports = function(parentLocales, locale) {
            var parentLocale = parentLocales[locale];
            if (parentLocale) {
                return "root" !== parentLocale && parentLocale
            }
            return locale.substr(0, locale.lastIndexOf(PARENT_LOCALE_SEPARATOR))
        }
    },
    /*!***************************************************************************!*\
      !*** ./artifacts/transpiled/localization/cldr-data/accounting_formats.js ***!
      \***************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = {
            af: "\xa4#,##0.00;(\xa4#,##0.00)",
            "af-NA": "\xa4#,##0.00;(\xa4#,##0.00)",
            agq: "#,##0.00\xa4",
            ak: "\xa4#,##0.00",
            am: "\xa4#,##0.00;(\xa4#,##0.00)",
            ar: "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-AE": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-BH": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-DJ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-DZ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-EG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-EH": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-ER": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-IL": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-IQ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-JO": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-KM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-KW": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-LB": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-LY": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-MA": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-MR": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-OM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-PS": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-QA": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-SA": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-SD": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-SO": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-SS": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-SY": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-TD": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-TN": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ar-YE": "\xa4#,##0.00;(\xa4#,##0.00)",
            as: "\xa4\xa0#,##,##0.00",
            asa: "#,##0.00\xa0\xa4",
            ast: "#,##0.00\xa0\xa4",
            az: "#,##0.00\xa0\xa4",
            "az-Cyrl": "#,##0.00\xa0\xa4",
            "az-Latn": "#,##0.00\xa0\xa4",
            bas: "#,##0.00\xa0\xa4",
            be: "#,##0.00\xa0\xa4",
            bem: "\xa4#,##0.00;(\xa4#,##0.00)",
            bez: "#,##0.00\xa4",
            bg: "0.00\xa0\xa4;(0.00\xa0\xa4)",
            bm: "\xa4#,##0.00;(\xa4#,##0.00)",
            bn: "#,##,##0.00\xa4;(#,##,##0.00\xa4)",
            "bn-IN": "#,##,##0.00\xa4;(#,##,##0.00\xa4)",
            bo: "\xa4\xa0#,##0.00",
            "bo-IN": "\xa4\xa0#,##0.00",
            br: "#,##0.00\xa0\xa4",
            brx: "\xa4\xa0#,##,##0.00",
            bs: "#,##0.00\xa0\xa4",
            "bs-Cyrl": "#,##0.00\xa0\xa4",
            "bs-Latn": "#,##0.00\xa0\xa4",
            ca: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "ca-AD": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "ca-ES-VALENCIA": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "ca-FR": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "ca-IT": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            ccp: "#,##,##0.00\xa4;(#,##,##0.00\xa4)",
            "ccp-IN": "#,##,##0.00\xa4;(#,##,##0.00\xa4)",
            ce: "#,##0.00\xa0\xa4",
            ceb: "\xa4#,##0.00;(\xa4#,##0.00)",
            cgg: "\xa4#,##0.00",
            chr: "\xa4#,##0.00;(\xa4#,##0.00)",
            ckb: "\xa4\xa0#,##0.00",
            "ckb-IR": "\xa4\xa0#,##0.00",
            cs: "#,##0.00\xa0\xa4",
            cu: "\xa4\xa0#,##0.00",
            cy: "\xa4#,##0.00;(\xa4#,##0.00)",
            da: "#,##0.00\xa0\xa4",
            "da-GL": "#,##0.00\xa0\xa4",
            dav: "\xa4#,##0.00;(\xa4#,##0.00)",
            de: "#,##0.00\xa0\xa4",
            "de-AT": "#,##0.00\xa0\xa4",
            "de-BE": "#,##0.00\xa0\xa4",
            "de-CH": "#,##0.00\xa0\xa4",
            "de-IT": "#,##0.00\xa0\xa4",
            "de-LI": "#,##0.00\xa0\xa4",
            "de-LU": "#,##0.00\xa0\xa4",
            dje: "#,##0.00\xa4",
            dsb: "#,##0.00\xa0\xa4",
            dua: "#,##0.00\xa0\xa4",
            dyo: "#,##0.00\xa0\xa4",
            dz: "\xa4#,##,##0.00",
            ebu: "\xa4#,##0.00;(\xa4#,##0.00)",
            ee: "\xa4#,##0.00;(\xa4#,##0.00)",
            "ee-TG": "\xa4#,##0.00;(\xa4#,##0.00)",
            el: "#,##0.00\xa0\xa4",
            "el-CY": "#,##0.00\xa0\xa4",
            en: "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-001": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-150": "#,##0.00\xa0\xa4",
            "en-AE": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-AG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-AI": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-AS": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-AT": "\xa4\xa0#,##0.00",
            "en-AU": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-BB": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-BE": "#,##0.00\xa0\xa4",
            "en-BI": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-BM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-BS": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-BW": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-BZ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-CA": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-CC": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-CH": "\xa4\xa0#,##0.00;\xa4-#,##0.00",
            "en-CK": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-CM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-CX": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-CY": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-DE": "#,##0.00\xa0\xa4",
            "en-DG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-DK": "#,##0.00\xa0\xa4",
            "en-DM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-ER": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-FI": "#,##0.00\xa0\xa4",
            "en-FJ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-FK": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-FM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-GB": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-GD": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-GG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-GH": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-GI": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-GM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-GU": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-GY": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-HK": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-IE": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-IL": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-IM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-IN": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-IO": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-JE": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-JM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-KE": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-KI": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-KN": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-KY": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-LC": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-LR": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-LS": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MH": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MO": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MP": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MS": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MT": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MU": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MW": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-MY": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-NA": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-NF": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-NG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-NL": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "en-NR": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-NU": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-NZ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-PG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-PH": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-PK": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-PN": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-PR": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-PW": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-RW": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SB": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SC": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SD": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SE": "#,##0.00\xa0\xa4",
            "en-SG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SH": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SI": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "en-SL": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SS": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SX": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-SZ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-TC": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-TK": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-TO": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-TT": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-TV": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-TZ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-UG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-UM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-US-POSIX": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-VC": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-VG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-VI": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-VU": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-WS": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-ZA": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-ZM": "\xa4#,##0.00;(\xa4#,##0.00)",
            "en-ZW": "\xa4#,##0.00;(\xa4#,##0.00)",
            eo: "\xa4\xa0#,##0.00",
            es: "#,##0.00\xa0\xa4",
            "es-419": "\xa4#,##0.00",
            "es-AR": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "es-BO": "\xa4#,##0.00",
            "es-BR": "\xa4#,##0.00",
            "es-BZ": "\xa4#,##0.00",
            "es-CL": "\xa4#,##0.00",
            "es-CO": "\xa4#,##0.00",
            "es-CR": "\xa4#,##0.00",
            "es-CU": "\xa4#,##0.00",
            "es-DO": "\xa4#,##0.00;(\xa4#,##0.00)",
            "es-EA": "#,##0.00\xa0\xa4",
            "es-EC": "\xa4#,##0.00",
            "es-GQ": "#,##0.00\xa0\xa4",
            "es-GT": "\xa4#,##0.00",
            "es-HN": "\xa4#,##0.00",
            "es-IC": "#,##0.00\xa0\xa4",
            "es-MX": "\xa4#,##0.00",
            "es-NI": "\xa4#,##0.00",
            "es-PA": "\xa4#,##0.00",
            "es-PE": "\xa4#,##0.00",
            "es-PH": "#,##0.00\xa0\xa4",
            "es-PR": "\xa4#,##0.00",
            "es-PY": "\xa4#,##0.00",
            "es-SV": "\xa4#,##0.00",
            "es-US": "\xa4#,##0.00",
            "es-UY": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "es-VE": "\xa4#,##0.00",
            et: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            eu: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            ewo: "#,##0.00\xa0\xa4",
            fa: "\u200e\xa4\xa0#,##0.00;\u200e(\xa4\xa0#,##0.00)",
            "fa-AF": "\xa4\xa0#,##0.00;\u200e(\xa4\xa0#,##0.00)",
            ff: "#,##0.00\xa0\xa4",
            "ff-Latn": "#,##0.00\xa0\xa4",
            "ff-Latn-BF": "#,##0.00\xa0\xa4",
            "ff-Latn-CM": "#,##0.00\xa0\xa4",
            "ff-Latn-GH": "#,##0.00\xa0\xa4",
            "ff-Latn-GM": "#,##0.00\xa0\xa4",
            "ff-Latn-GN": "#,##0.00\xa0\xa4",
            "ff-Latn-GW": "#,##0.00\xa0\xa4",
            "ff-Latn-LR": "#,##0.00\xa0\xa4",
            "ff-Latn-MR": "#,##0.00\xa0\xa4",
            "ff-Latn-NE": "#,##0.00\xa0\xa4",
            "ff-Latn-NG": "#,##0.00\xa0\xa4",
            "ff-Latn-SL": "#,##0.00\xa0\xa4",
            fi: "#,##0.00\xa0\xa4",
            fil: "\xa4#,##0.00;(\xa4#,##0.00)",
            fo: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fo-DK": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            fr: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-BE": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-BF": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-BI": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-BJ": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-BL": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-CA": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-CD": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-CF": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-CG": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-CH": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-CI": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-CM": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-DJ": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-DZ": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-GA": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-GF": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-GN": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-GP": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-GQ": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-HT": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-KM": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-LU": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-MA": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-MC": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-MF": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-MG": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-ML": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-MQ": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-MR": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-MU": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-NC": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-NE": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-PF": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-PM": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-RE": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-RW": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-SC": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-SN": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-SY": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-TD": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-TG": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-TN": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-VU": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-WF": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "fr-YT": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            fur: "\xa4\xa0#,##0.00",
            fy: "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            ga: "\xa4#,##0.00;(\xa4#,##0.00)",
            "ga-GB": "\xa4#,##0.00;(\xa4#,##0.00)",
            gd: "\xa4#,##0.00;(\xa4#,##0.00)",
            gl: "#,##0.00\xa0\xa4",
            gsw: "#,##0.00\xa0\xa4",
            "gsw-FR": "#,##0.00\xa0\xa4",
            "gsw-LI": "#,##0.00\xa0\xa4",
            gu: "\xa4#,##,##0.00;(\xa4#,##,##0.00)",
            guz: "\xa4#,##0.00;(\xa4#,##0.00)",
            gv: "\xa4#,##0.00",
            ha: "\xa4\xa0#,##0.00",
            "ha-GH": "\xa4\xa0#,##0.00",
            "ha-NE": "\xa4\xa0#,##0.00",
            haw: "\xa4#,##0.00;(\xa4#,##0.00)",
            he: "#,##0.00\xa0\xa4",
            hi: "\xa4#,##,##0.00",
            hr: "#,##0.00\xa0\xa4",
            "hr-BA": "#,##0.00\xa0\xa4",
            hsb: "#,##0.00\xa0\xa4",
            hu: "#,##0.00\xa0\xa4",
            hy: "#,##0.00\xa0\xa4",
            ia: "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            id: "\xa4#,##0.00",
            ig: "\xa4#,##0.00;(\xa4#,##0.00)",
            ii: "\xa4\xa0#,##0.00",
            is: "#,##0.00\xa0\xa4",
            it: "#,##0.00\xa0\xa4",
            "it-CH": "#,##0.00\xa0\xa4",
            "it-SM": "#,##0.00\xa0\xa4",
            "it-VA": "#,##0.00\xa0\xa4",
            ja: "\xa4#,##0.00;(\xa4#,##0.00)",
            jgo: "\xa4\xa0#,##0.00",
            jmc: "\xa4#,##0.00",
            jv: "\xa4\xa0#,##0.00",
            ka: "#,##0.00\xa0\xa4",
            kab: "#,##0.00\xa4",
            kam: "\xa4#,##0.00;(\xa4#,##0.00)",
            kde: "\xa4#,##0.00;(\xa4#,##0.00)",
            kea: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            khq: "#,##0.00\xa4",
            ki: "\xa4#,##0.00;(\xa4#,##0.00)",
            kk: "#,##0.00\xa0\xa4",
            kkj: "\xa4\xa0#,##0.00",
            kl: "\xa4#,##0.00;\xa4-#,##0.00",
            kln: "\xa4#,##0.00;(\xa4#,##0.00)",
            km: "#,##0.00\xa4;(#,##0.00\xa4)",
            kn: "\xa4#,##0.00;(\xa4#,##0.00)",
            ko: "\xa4#,##0.00;(\xa4#,##0.00)",
            "ko-KP": "\xa4#,##0.00;(\xa4#,##0.00)",
            kok: "\xa4#,##0.00;(\xa4#,##0.00)",
            ks: "\xa4\xa0#,##,##0.00",
            ksb: "#,##0.00\xa4",
            ksf: "#,##0.00\xa0\xa4",
            ksh: "#,##0.00\xa0\xa4",
            ku: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            kw: "\xa4#,##0.00",
            ky: "#,##0.00\xa0\xa4",
            lag: "\xa4\xa0#,##0.00",
            lb: "#,##0.00\xa0\xa4",
            lg: "#,##0.00\xa4",
            lkt: "\xa4\xa0#,##0.00",
            ln: "#,##0.00\xa0\xa4",
            "ln-AO": "#,##0.00\xa0\xa4",
            "ln-CF": "#,##0.00\xa0\xa4",
            "ln-CG": "#,##0.00\xa0\xa4",
            lo: "\xa4#,##0.00;\xa4-#,##0.00",
            lrc: "\xa4\xa0#,##0.00",
            "lrc-IQ": "\xa4\xa0#,##0.00",
            lt: "#,##0.00\xa0\xa4",
            lu: "#,##0.00\xa4",
            luo: "#,##0.00\xa4",
            luy: "\xa4#,##0.00;\xa4-\xa0#,##0.00",
            lv: "#,##0.00\xa0\xa4",
            mas: "\xa4#,##0.00;(\xa4#,##0.00)",
            "mas-TZ": "\xa4#,##0.00;(\xa4#,##0.00)",
            mer: "\xa4#,##0.00;(\xa4#,##0.00)",
            mfe: "\xa4\xa0#,##0.00",
            mg: "\xa4#,##0.00",
            mgh: "\xa4\xa0#,##0.00",
            mgo: "\xa4\xa0#,##0.00",
            mi: "\xa4\xa0#,##0.00",
            mk: "#,##0.00\xa0\xa4",
            ml: "\xa4#,##0.00;(\xa4#,##0.00)",
            mn: "\xa4\xa0#,##0.00",
            mr: "\xa4#,##0.00;(\xa4#,##0.00)",
            ms: "\xa4#,##0.00;(\xa4#,##0.00)",
            "ms-BN": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ms-SG": "\xa4#,##0.00;(\xa4#,##0.00)",
            mt: "\xa4#,##0.00",
            mua: "\xa4#,##0.00;(\xa4#,##0.00)",
            my: "\xa4\xa0#,##0.00",
            mzn: "\xa4\xa0#,##0.00",
            naq: "\xa4#,##0.00",
            nb: "\xa4\xa0#,##0.00",
            "nb-SJ": "\xa4\xa0#,##0.00",
            nd: "\xa4#,##0.00;(\xa4#,##0.00)",
            nds: "\xa4\xa0#,##0.00",
            "nds-NL": "\xa4\xa0#,##0.00",
            ne: "\xa4\xa0#,##0.00",
            "ne-IN": "\xa4\xa0#,##0.00",
            nl: "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "nl-AW": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "nl-BE": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "nl-BQ": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "nl-CW": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "nl-SR": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            "nl-SX": "\xa4\xa0#,##0.00;(\xa4\xa0#,##0.00)",
            nmg: "#,##0.00\xa0\xa4",
            nn: "#,##0.00\xa0\xa4",
            nnh: "\xa4\xa0#,##0.00",
            nus: "\xa4#,##0.00;(\xa4#,##0.00)",
            nyn: "\xa4#,##0.00",
            om: "\xa4#,##0.00",
            "om-KE": "\xa4#,##0.00",
            or: "\xa4#,##0.00;(\xa4#,##0.00)",
            os: "\xa4\xa0#,##0.00",
            "os-RU": "\xa4\xa0#,##0.00",
            pa: "\xa4\xa0#,##0.00",
            "pa-Arab": "\xa4\xa0#,##0.00",
            "pa-Guru": "\xa4\xa0#,##0.00",
            pl: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            prg: "\xa4\xa0#,##0.00",
            ps: "\xa4#,##0.00;(\xa4#,##0.00)",
            "ps-PK": "\xa4#,##0.00;(\xa4#,##0.00)",
            pt: "\xa4\xa0#,##0.00",
            "pt-AO": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-CH": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-CV": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-GQ": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-GW": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-LU": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-MO": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-MZ": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-PT": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-ST": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "pt-TL": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            qu: "\xa4\xa0#,##0.00",
            "qu-BO": "\xa4\xa0#,##0.00",
            "qu-EC": "\xa4\xa0#,##0.00",
            rm: "#,##0.00\xa0\xa4",
            rn: "#,##0.00\xa4",
            ro: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "ro-MD": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            rof: "\xa4#,##0.00",
            root: "\xa4\xa0#,##0.00",
            ru: "#,##0.00\xa0\xa4",
            "ru-BY": "#,##0.00\xa0\xa4",
            "ru-KG": "#,##0.00\xa0\xa4",
            "ru-KZ": "#,##0.00\xa0\xa4",
            "ru-MD": "#,##0.00\xa0\xa4",
            "ru-UA": "#,##0.00\xa0\xa4",
            rw: "\xa4\xa0#,##0.00",
            rwk: "#,##0.00\xa4",
            sah: "#,##0.00\xa0\xa4",
            saq: "\xa4#,##0.00;(\xa4#,##0.00)",
            sbp: "#,##0.00\xa4",
            sd: "\xa4\xa0#,##0.00",
            se: "#,##0.00\xa0\xa4",
            "se-FI": "#,##0.00\xa0\xa4",
            "se-SE": "#,##0.00\xa0\xa4",
            seh: "#,##0.00\xa4",
            ses: "#,##0.00\xa4",
            sg: "\xa4#,##0.00;\xa4-#,##0.00",
            shi: "#,##0.00\xa4",
            "shi-Latn": "#,##0.00\xa4",
            "shi-Tfng": "#,##0.00\xa4",
            si: "\xa4#,##0.00;(\xa4#,##0.00)",
            sk: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            sl: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            smn: "#,##0.00\xa0\xa4",
            sn: "\xa4#,##0.00;(\xa4#,##0.00)",
            so: "\xa4#,##0.00;(\xa4#,##0.00)",
            "so-DJ": "\xa4#,##0.00;(\xa4#,##0.00)",
            "so-ET": "\xa4#,##0.00;(\xa4#,##0.00)",
            "so-KE": "\xa4#,##0.00;(\xa4#,##0.00)",
            sq: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sq-MK": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sq-XK": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            sr: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sr-Cyrl": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sr-Cyrl-BA": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sr-Cyrl-ME": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sr-Cyrl-XK": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sr-Latn": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sr-Latn-BA": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sr-Latn-ME": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            "sr-Latn-XK": "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            sv: "#,##0.00\xa0\xa4",
            "sv-AX": "#,##0.00\xa0\xa4",
            "sv-FI": "#,##0.00\xa0\xa4",
            sw: "\xa4\xa0#,##0.00",
            "sw-CD": "\xa4\xa0#,##0.00",
            "sw-KE": "\xa4\xa0#,##0.00",
            "sw-UG": "\xa4\xa0#,##0.00",
            ta: "\xa4#,##0.00;(\xa4#,##0.00)",
            "ta-LK": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ta-MY": "\xa4#,##0.00;(\xa4#,##0.00)",
            "ta-SG": "\xa4#,##0.00;(\xa4#,##0.00)",
            te: "\xa4#,##0.00;(\xa4#,##0.00)",
            teo: "\xa4#,##0.00;(\xa4#,##0.00)",
            "teo-KE": "\xa4#,##0.00;(\xa4#,##0.00)",
            tg: "#,##0.00\xa0\xa4",
            th: "\xa4#,##0.00;(\xa4#,##0.00)",
            ti: "\xa4#,##0.00",
            "ti-ER": "\xa4#,##0.00",
            tk: "#,##0.00\xa0\xa4",
            to: "\xa4\xa0#,##0.00",
            tr: "\xa4#,##0.00;(\xa4#,##0.00)",
            "tr-CY": "\xa4#,##0.00;(\xa4#,##0.00)",
            tt: "#,##0.00\xa0\xa4",
            twq: "#,##0.00\xa4",
            tzm: "#,##0.00\xa0\xa4",
            ug: "\xa4#,##0.00;(\xa4#,##0.00)",
            uk: "#,##0.00\xa0\xa4",
            ur: "\xa4#,##0.00;(\xa4#,##0.00)",
            "ur-IN": "\xa4#,##0.00;(\xa4#,##0.00)",
            uz: "#,##0.00\xa0\xa4",
            "uz-Arab": "\xa4\xa0#,##0.00",
            "uz-Cyrl": "#,##0.00\xa0\xa4",
            "uz-Latn": "#,##0.00\xa0\xa4",
            vai: "\xa4#,##0.00;(\xa4#,##0.00)",
            "vai-Latn": "\xa4#,##0.00;(\xa4#,##0.00)",
            "vai-Vaii": "\xa4#,##0.00;(\xa4#,##0.00)",
            vi: "#,##0.00\xa0\xa4",
            vo: "\xa4\xa0#,##0.00",
            vun: "\xa4#,##0.00",
            wae: "\xa4\xa0#,##0.00",
            wo: "\xa4\xa0#,##0.00",
            xh: "\xa4#,##0.00",
            xog: "#,##0.00\xa0\xa4",
            yav: "#,##0.00\xa0\xa4;(#,##0.00\xa0\xa4)",
            yi: "\xa4\xa0#,##0.00",
            yo: "\xa4#,##0.00;(\xa4#,##0.00)",
            "yo-BJ": "\xa4#,##0.00;(\xa4#,##0.00)",
            yue: "\xa4#,##0.00;(\xa4#,##0.00)",
            "yue-Hans": "\xa4#,##0.00;(\xa4#,##0.00)",
            "yue-Hant": "\xa4#,##0.00;(\xa4#,##0.00)",
            zgh: "#,##0.00\xa4",
            zh: "\xa4#,##0.00;(\xa4#,##0.00)",
            "zh-Hans": "\xa4#,##0.00;(\xa4#,##0.00)",
            "zh-Hans-HK": "\xa4#,##0.00;(\xa4#,##0.00)",
            "zh-Hans-MO": "\xa4#,##0.00;(\xa4#,##0.00)",
            "zh-Hans-SG": "\xa4#,##0.00;(\xa4#,##0.00)",
            "zh-Hant": "\xa4#,##0.00;(\xa4#,##0.00)",
            "zh-Hant-HK": "\xa4#,##0.00;(\xa4#,##0.00)",
            "zh-Hant-MO": "\xa4#,##0.00;(\xa4#,##0.00)",
            zu: "\xa4#,##0.00;(\xa4#,##0.00)"
        }
    },
    /*!*******************************************************************************!*\
      !*** ./artifacts/transpiled/localization/cldr-data/first_day_of_week_data.js ***!
      \*******************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = {
            "af-NA": 1,
            agq: 1,
            ak: 1,
            ar: 6,
            "ar-EH": 1,
            "ar-ER": 1,
            "ar-KM": 1,
            "ar-LB": 1,
            "ar-MA": 1,
            "ar-MR": 1,
            "ar-PS": 1,
            "ar-SO": 1,
            "ar-SS": 1,
            "ar-TD": 1,
            "ar-TN": 1,
            asa: 1,
            ast: 1,
            az: 1,
            "az-Cyrl": 1,
            bas: 1,
            be: 1,
            bem: 1,
            bez: 1,
            bg: 1,
            bm: 1,
            br: 1,
            bs: 1,
            "bs-Cyrl": 1,
            ca: 1,
            ce: 1,
            cgg: 1,
            ckb: 6,
            cs: 1,
            cu: 1,
            cy: 1,
            da: 1,
            de: 1,
            dje: 1,
            dsb: 1,
            dua: 1,
            dyo: 1,
            ee: 1,
            el: 1,
            "en-001": 1,
            "en-AE": 6,
            "en-BI": 1,
            "en-MP": 1,
            "en-SD": 6,
            eo: 1,
            es: 1,
            et: 1,
            eu: 1,
            ewo: 1,
            fa: 6,
            ff: 1,
            fi: 1,
            fo: 1,
            fr: 1,
            "fr-DJ": 6,
            "fr-DZ": 6,
            "fr-SY": 6,
            fur: 1,
            fy: 1,
            ga: 1,
            gd: 1,
            gl: 1,
            gsw: 1,
            gv: 1,
            ha: 1,
            hr: 1,
            hsb: 1,
            hu: 1,
            hy: 1,
            ia: 1,
            ig: 1,
            is: 1,
            it: 1,
            jgo: 1,
            jmc: 1,
            ka: 1,
            kab: 6,
            kde: 1,
            kea: 1,
            khq: 1,
            kk: 1,
            kkj: 1,
            kl: 1,
            "ko-KP": 1,
            ksb: 1,
            ksf: 1,
            ksh: 1,
            ku: 1,
            kw: 1,
            ky: 1,
            lag: 1,
            lb: 1,
            lg: 1,
            ln: 1,
            lrc: 6,
            lt: 1,
            lu: 1,
            lv: 1,
            "mas-TZ": 1,
            mfe: 1,
            mg: 1,
            mgo: 1,
            mi: 1,
            mk: 1,
            mn: 1,
            ms: 1,
            mua: 1,
            mzn: 6,
            naq: 1,
            nb: 1,
            nds: 1,
            nl: 1,
            nmg: 1,
            nn: 1,
            nnh: 1,
            nus: 1,
            nyn: 1,
            os: 1,
            pl: 1,
            prg: 1,
            ps: 6,
            "pt-AO": 1,
            "pt-CH": 1,
            "pt-CV": 1,
            "pt-GQ": 1,
            "pt-GW": 1,
            "pt-LU": 1,
            "pt-ST": 1,
            "pt-TL": 1,
            "qu-BO": 1,
            "qu-EC": 1,
            rm: 1,
            rn: 1,
            ro: 1,
            rof: 1,
            ru: 1,
            rw: 1,
            rwk: 1,
            sah: 1,
            sbp: 1,
            se: 1,
            ses: 1,
            sg: 1,
            shi: 1,
            "shi-Latn": 1,
            si: 1,
            sk: 1,
            sl: 1,
            smn: 1,
            so: 1,
            "so-DJ": 6,
            sq: 1,
            sr: 1,
            "sr-Latn": 1,
            sv: 1,
            sw: 1,
            "ta-LK": 1,
            "ta-MY": 1,
            teo: 1,
            tg: 1,
            "ti-ER": 1,
            tk: 1,
            to: 1,
            tr: 1,
            tt: 1,
            twq: 1,
            tzm: 1,
            uk: 1,
            uz: 1,
            "uz-Arab": 6,
            "uz-Cyrl": 1,
            vai: 1,
            "vai-Latn": 1,
            vi: 1,
            vo: 1,
            vun: 1,
            wae: 1,
            wo: 1,
            xog: 1,
            yav: 1,
            yi: 1,
            yo: 1,
            zgh: 1
        }
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/localization/intl/date.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _core = __webpack_require__( /*! ../core */ 83);

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;
        var getIntlFormatter = function(format) {
            return function(date) {
                if (!format.timeZoneName) {
                    var year = date.getFullYear();
                    var recognizableAsTwentyCentury = String(year).length < 3;
                    var safeYearShift = 400;
                    var temporaryYearValue = recognizableAsTwentyCentury ? year + safeYearShift : year;
                    var utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
                    if (recognizableAsTwentyCentury) {
                        utcDate.setFullYear(year)
                    }
                    var utcFormat = (0, _extend.extend)({
                        timeZone: "UTC"
                    }, format);
                    return formatDateTime(utcDate, utcFormat)
                }
                return formatDateTime(date, format)
            }
        };
        var formattersCache = {};
        var getFormatter = function(format) {
            var key = (0, _core.locale)() + "/" + JSON.stringify(format);
            if (!formattersCache[key]) {
                formattersCache[key] = new Intl.DateTimeFormat((0, _core.locale)(), format).format
            }
            return formattersCache[key]
        };

        function formatDateTime(date, format) {
            return getFormatter(format)(date).replace(SYMBOLS_TO_REMOVE_REGEX, "")
        }
        var formatNumber = function(number) {
            return new Intl.NumberFormat((0, _core.locale)()).format(number)
        };
        var getAlternativeNumeralsMap = function() {
            var numeralsMapCache = {};
            return function(locale) {
                if (!(locale in numeralsMapCache)) {
                    if ("0" === formatNumber(0)) {
                        numeralsMapCache[locale] = false;
                        return false
                    }
                    numeralsMapCache[locale] = {};
                    for (var i = 0; i < 10; ++i) {
                        numeralsMapCache[locale][formatNumber(i)] = i
                    }
                }
                return numeralsMapCache[locale]
            }
        }();
        var normalizeNumerals = function(dateString) {
            var alternativeNumeralsMap = getAlternativeNumeralsMap((0, _core.locale)());
            if (!alternativeNumeralsMap) {
                return dateString
            }
            return dateString.split("").map(function(sign) {
                return sign in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign]) : sign
            }).join("")
        };
        var removeLeadingZeroes = function(str) {
            return str.replace(/(\D)0+(\d)/g, "$1$2")
        };
        var dateStringEquals = function(actual, expected) {
            return removeLeadingZeroes(actual) === removeLeadingZeroes(expected)
        };
        var normalizeMonth = function(text) {
            return text.replace("d\u2019", "de ")
        };
        var intlFormats = {
            day: {
                day: "numeric"
            },
            dayofweek: {
                weekday: "long"
            },
            longdate: {
                weekday: "long",
                year: "numeric",
                month: "long",
                day: "numeric"
            },
            longdatelongtime: {
                weekday: "long",
                year: "numeric",
                month: "long",
                day: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric"
            },
            longtime: {
                hour: "numeric",
                minute: "numeric",
                second: "numeric"
            },
            month: {
                month: "long"
            },
            monthandday: {
                month: "long",
                day: "numeric"
            },
            monthandyear: {
                year: "numeric",
                month: "long"
            },
            shortdate: {},
            shorttime: {
                hour: "numeric",
                minute: "numeric"
            },
            shortyear: {
                year: "2-digit"
            },
            year: {
                year: "numeric"
            }
        };
        Object.defineProperty(intlFormats, "shortdateshorttime", {
            get: function() {
                var defaultOptions = Intl.DateTimeFormat((0, _core.locale)()).resolvedOptions();
                return {
                    year: defaultOptions.year,
                    month: defaultOptions.month,
                    day: defaultOptions.day,
                    hour: "numeric",
                    minute: "numeric"
                }
            }
        });
        var getIntlFormat = function(format) {
            return "string" === typeof format && intlFormats[format.toLowerCase()]
        };
        var monthNameStrategies = {
            standalone: function(monthIndex, monthFormat) {
                var date = new Date(1999, monthIndex, 13, 1);
                var dateString = getIntlFormatter({
                    month: monthFormat
                })(date);
                return dateString
            },
            format: function(monthIndex, monthFormat) {
                var date = new Date(0, monthIndex, 13, 1);
                var dateString = normalizeMonth(getIntlFormatter({
                    day: "numeric",
                    month: monthFormat
                })(date));
                var parts = dateString.split(" ").filter(function(part) {
                    return part.indexOf("13") < 0
                });
                if (1 === parts.length) {
                    return parts[0]
                } else {
                    if (2 === parts.length) {
                        return parts[0].length > parts[1].length ? parts[0] : parts[1]
                    }
                }
                return monthNameStrategies.standalone(monthIndex, monthFormat)
            }
        };
        module.exports = {
            engine: function() {
                return "intl"
            },
            getMonthNames: function(format, type) {
                var intlFormats = {
                    wide: "long",
                    abbreviated: "short",
                    narrow: "narrow"
                };
                var monthFormat = intlFormats[format || "wide"];
                type = "format" === type ? type : "standalone";
                return Array.apply(null, new Array(12)).map(function(_, monthIndex) {
                    return monthNameStrategies[type](monthIndex, monthFormat)
                })
            },
            getDayNames: function(format) {
                var intlFormats = {
                    wide: "long",
                    abbreviated: "short",
                    "short": "narrow",
                    narrow: "narrow"
                };
                var getIntlDayNames = function(format) {
                    return Array.apply(null, new Array(7)).map(function(_, dayIndex) {
                        return getIntlFormatter({
                            weekday: format
                        })(new Date(0, 0, dayIndex))
                    })
                };
                var result = getIntlDayNames(intlFormats[format || "wide"]);
                return result
            },
            getPeriodNames: function() {
                var hour12Formatter = getIntlFormatter({
                    hour: "numeric",
                    hour12: true
                });
                return [1, 13].map(function(hours) {
                    var hourNumberText = formatNumber(1);
                    var timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);
                    if (2 !== timeParts.length) {
                        return ""
                    }
                    var biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
                    return biggerPart.trim()
                })
            },
            format: function(date, _format) {
                if (!date) {
                    return
                }
                if (!_format) {
                    return date
                }
                if ("function" !== typeof _format && !_format.formatter) {
                    _format = _format.type || _format
                }
                var intlFormat = getIntlFormat(_format);
                if (intlFormat) {
                    return getIntlFormatter(intlFormat)(date)
                }
                var formatType = _typeof(_format);
                if (_format.formatter || "function" === formatType || "string" === formatType) {
                    return this.callBase.apply(this, arguments)
                }
                return getIntlFormatter(_format)(date)
            },
            parse: function(dateString, format) {
                var _this = this;
                var formatter;
                if (format && !format.parser && "string" === typeof dateString) {
                    dateString = normalizeMonth(dateString);
                    formatter = function(date) {
                        return normalizeMonth(_this.format(date, format))
                    }
                }
                return this.callBase(dateString, formatter || format)
            },
            _parseDateBySimpleFormat: function(dateString, format) {
                var _this2 = this;
                dateString = normalizeNumerals(dateString);
                var formatParts = this.getFormatParts(format);
                var dateParts = dateString.split(/\D+/).filter(function(part) {
                    return part.length > 0
                });
                if (formatParts.length !== dateParts.length) {
                    return
                }
                var dateArgs = this._generateDateArgs(formatParts, dateParts);
                var constructDate = function(dateArgs, ampmShift) {
                    var hoursShift = ampmShift ? 12 : 0;
                    return new Date(dateArgs.year, dateArgs.month, dateArgs.day, (dateArgs.hours + hoursShift) % 24, dateArgs.minutes, dateArgs.seconds)
                };
                var constructValidDate = function(ampmShift) {
                    var parsedDate = constructDate(dateArgs, ampmShift);
                    if (dateStringEquals(normalizeNumerals(_this2.format(parsedDate, format)), dateString)) {
                        return parsedDate
                    }
                };
                return constructValidDate(false) || constructValidDate(true)
            },
            _generateDateArgs: function(formatParts, dateParts) {
                var currentDate = new Date;
                var dateArgs = {
                    year: currentDate.getFullYear(),
                    month: currentDate.getMonth(),
                    day: currentDate.getDate(),
                    hours: 0,
                    minutes: 0,
                    seconds: 0
                };
                formatParts.forEach(function(formatPart, index) {
                    var datePart = dateParts[index];
                    var parsed = parseInt(datePart, 10);
                    if ("month" === formatPart) {
                        parsed -= 1
                    }
                    dateArgs[formatPart] = parsed
                });
                return dateArgs
            },
            formatUsesMonthName: function(format) {
                if ("object" === _typeof(format) && !(format.type || format.format)) {
                    return "long" === format.month
                }
                return this.callBase.apply(this, arguments)
            },
            formatUsesDayName: function(format) {
                if ("object" === _typeof(format) && !(format.type || format.format)) {
                    return "long" === format.weekday
                }
                return this.callBase.apply(this, arguments)
            },
            getFormatParts: function(format) {
                if ("string" === typeof format) {
                    return this.callBase(format)
                }
                var intlFormat = (0, _extend.extend)({}, intlFormats[format.toLowerCase()]);
                var date = new Date(2001, 2, 4, 5, 6, 7);
                var formattedDate = getIntlFormatter(intlFormat)(date);
                formattedDate = normalizeNumerals(formattedDate);
                var formatParts = [{
                    name: "year",
                    value: 1
                }, {
                    name: "month",
                    value: 3
                }, {
                    name: "day",
                    value: 4
                }, {
                    name: "hours",
                    value: 5
                }, {
                    name: "minutes",
                    value: 6
                }, {
                    name: "seconds",
                    value: 7
                }];
                return formatParts.map(function(part) {
                    return {
                        name: part.name,
                        index: formattedDate.indexOf(part.value)
                    }
                }).filter(function(part) {
                    return part.index > -1
                }).sort(function(a, b) {
                    return a.index - b.index
                }).map(function(part) {
                    return part.name
                })
            }
        }
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.file.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel = __webpack_require__( /*! ./excel.tag_helper */ 84);
        var _excel2 = _interopRequireDefault(_excel);
        var _excel3 = __webpack_require__( /*! ./excel.cell_format_helper */ 458);
        var _excel4 = _interopRequireDefault(_excel3);
        var _excel5 = __webpack_require__( /*! ./excel.fill_helper */ 275);
        var _excel6 = _interopRequireDefault(_excel5);
        var _excel7 = __webpack_require__( /*! ./excel.font_helper */ 277);
        var _excel8 = _interopRequireDefault(_excel7);
        var _excel9 = __webpack_require__( /*! ./excel.number_format_helper */ 461);
        var _excel10 = _interopRequireDefault(_excel9);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var ExcelFile = function() {
            function ExcelFile() {
                _classCallCheck(this, ExcelFile);
                this._cellFormatTags = [];
                this._fillTags = [];
                this._fontTags = [];
                this._numberFormatTags = [];
                this._fillTags.push(_excel6.default.tryCreateTag({
                    patternFill: {
                        patternType: "none"
                    }
                }))
            }
            _createClass(ExcelFile, [{
                key: "registerCellFormat",
                value: function(cellFormat) {
                    var result;
                    var cellFormatTag = _excel4.default.tryCreateTag(cellFormat, {
                        registerFill: this.registerFill.bind(this),
                        registerFont: this.registerFont.bind(this),
                        registerNumberFormat: this.registerNumberFormat.bind(this)
                    });
                    if ((0, _type.isDefined)(cellFormatTag)) {
                        for (var i = 0; i < this._cellFormatTags.length; i++) {
                            if (_excel4.default.areEqual(this._cellFormatTags[i], cellFormatTag)) {
                                result = i;
                                break
                            }
                        }
                        if (void 0 === result) {
                            result = this._cellFormatTags.push(cellFormatTag) - 1
                        }
                    }
                    return result
                }
            }, {
                key: "generateCellFormatsXml",
                value: function() {
                    var cellFormatTagsAsXmlStringsArray = this._cellFormatTags.map(function(tag) {
                        return _excel4.default.toXml(tag)
                    });
                    return _excel2.default.toXml("cellXfs", {
                        count: cellFormatTagsAsXmlStringsArray.length
                    }, cellFormatTagsAsXmlStringsArray.join(""))
                }
            }, {
                key: "registerFill",
                value: function(fill) {
                    var result;
                    var fillTag = _excel6.default.tryCreateTag(fill);
                    if ((0, _type.isDefined)(fillTag)) {
                        for (var i = 0; i < this._fillTags.length; i++) {
                            if (_excel6.default.areEqual(this._fillTags[i], fillTag)) {
                                result = i;
                                break
                            }
                        }
                        if (void 0 === result) {
                            if (this._fillTags.length < 2) {
                                this._fillTags.push(_excel6.default.tryCreateTag({
                                    patternFill: {
                                        patternType: "Gray125"
                                    }
                                }))
                            }
                            result = this._fillTags.push(fillTag) - 1
                        }
                    }
                    return result
                }
            }, {
                key: "generateFillsXml",
                value: function() {
                    var tagsAsXmlStringsArray = this._fillTags.map(function(tag) {
                        return _excel6.default.toXml(tag)
                    });
                    return _excel2.default.toXml("fills", {
                        count: tagsAsXmlStringsArray.length
                    }, tagsAsXmlStringsArray.join(""))
                }
            }, {
                key: "registerFont",
                value: function(font) {
                    var result;
                    var fontTag = _excel8.default.tryCreateTag(font);
                    if ((0, _type.isDefined)(fontTag)) {
                        for (var i = 0; i < this._fontTags.length; i++) {
                            if (_excel8.default.areEqual(this._fontTags[i], fontTag)) {
                                result = i;
                                break
                            }
                        }
                        if (void 0 === result) {
                            result = this._fontTags.push(fontTag) - 1
                        }
                    }
                    return result
                }
            }, {
                key: "generateFontsXml",
                value: function() {
                    var xmlStringsArray = this._fontTags.map(function(tag) {
                        return _excel8.default.toXml(tag)
                    });
                    return _excel2.default.toXml("fonts", {
                        count: xmlStringsArray.length
                    }, xmlStringsArray.join(""))
                }
            }, {
                key: "_convertNumberFormatIndexToId",
                value: function(index) {
                    var CUSTOM_FORMAT_ID_START_VALUE = 165;
                    return CUSTOM_FORMAT_ID_START_VALUE + index
                }
            }, {
                key: "registerNumberFormat",
                value: function(numberFormat) {
                    var result;
                    var tag = _excel10.default.tryCreateTag(numberFormat);
                    if ((0, _type.isDefined)(tag)) {
                        for (var i = 0; i < this._numberFormatTags.length; i++) {
                            if (_excel10.default.areEqual(this._numberFormatTags[i], tag)) {
                                result = this._numberFormatTags[i][_excel10.default.ID_PROPERTY_NAME];
                                break
                            }
                        }
                        if (void 0 === result) {
                            tag[_excel10.default.ID_PROPERTY_NAME] = this._convertNumberFormatIndexToId(this._numberFormatTags.length);
                            result = tag[_excel10.default.ID_PROPERTY_NAME];
                            this._numberFormatTags.push(tag)
                        }
                    }
                    return result
                }
            }, {
                key: "generateNumberFormatsXml",
                value: function() {
                    if (this._numberFormatTags.length > 0) {
                        var xmlStringsArray = this._numberFormatTags.map(function(tag) {
                            return _excel10.default.toXml(tag)
                        });
                        return _excel2.default.toXml("numFmts", {
                            count: xmlStringsArray.length
                        }, xmlStringsArray.join(""))
                    } else {
                        return ""
                    }
                }
            }], [{
                key: "copyCellFormat",
                value: function(source) {
                    return _excel4.default.copy(source)
                }
            }]);
            return ExcelFile
        }();
        exports.default = ExcelFile;
        module.exports = ExcelFile
    },
    /*!*************************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.cell_format_helper.js ***!
      \*************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel = __webpack_require__( /*! ./excel.tag_helper */ 84);
        var _excel2 = _interopRequireDefault(_excel);
        var _excel3 = __webpack_require__( /*! ./excel.cell_alignment_helper */ 459);
        var _excel4 = _interopRequireDefault(_excel3);
        var _excel5 = __webpack_require__( /*! ./excel.fill_helper */ 275);
        var _excel6 = _interopRequireDefault(_excel5);
        var _excel7 = __webpack_require__( /*! ./excel.font_helper */ 277);
        var _excel8 = _interopRequireDefault(_excel7);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var cellFormatHelper = {
            tryCreateTag: function(sourceObj, sharedItemsContainer) {
                var result = null;
                if ((0, _type.isDefined)(sourceObj)) {
                    var numberFormatId;
                    if ("number" === typeof sourceObj.numberFormat) {
                        numberFormatId = sourceObj.numberFormat
                    } else {
                        numberFormatId = sharedItemsContainer.registerNumberFormat(sourceObj.numberFormat)
                    }
                    var fill = sourceObj.fill;
                    if (!(0, _type.isDefined)(fill)) {
                        fill = _excel6.default.tryCreateFillFromSimpleFormat(sourceObj)
                    }
                    result = {
                        numberFormatId: numberFormatId,
                        alignment: _excel4.default.tryCreateTag(sourceObj.alignment),
                        fontId: sharedItemsContainer.registerFont(sourceObj.font),
                        fillId: sharedItemsContainer.registerFill(fill)
                    };
                    if (cellFormatHelper.isEmpty(result)) {
                        result = null
                    }
                }
                return result
            },
            copy: function(source) {
                var result;
                if (null === source) {
                    result = null
                } else {
                    if ((0, _type.isDefined)(source)) {
                        result = {};
                        if (void 0 !== source.numberFormat) {
                            result.numberFormat = source.numberFormat
                        }
                        if (void 0 !== source.fill) {
                            result.fill = _excel6.default.copy(source.fill)
                        } else {
                            _excel6.default.copySimpleFormat(source, result)
                        }
                        if (void 0 !== source.alignment) {
                            result.alignment = _excel4.default.copy(source.alignment)
                        }
                        if (void 0 !== source.font) {
                            result.font = _excel8.default.copy(source.font)
                        }
                    }
                }
                return result
            },
            areEqual: function(leftTag, rightTag) {
                return cellFormatHelper.isEmpty(leftTag) && cellFormatHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.fontId === rightTag.fontId && leftTag.numberFormatId === rightTag.numberFormatId && leftTag.fillId === rightTag.fillId && _excel4.default.areEqual(leftTag.alignment, rightTag.alignment)
            },
            isEmpty: function(tag) {
                return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.fontId) && !(0, _type.isDefined)(tag.numberFormatId) && !(0, _type.isDefined)(tag.fillId) && _excel4.default.isEmpty(tag.alignment)
            },
            toXml: function(tag) {
                var isAlignmentEmpty = _excel4.default.isEmpty(tag.alignment);
                var applyNumberFormat;
                if ((0, _type.isDefined)(tag.numberFormatId)) {
                    applyNumberFormat = tag.numberFormatId > 0 ? 1 : 0
                }
                return _excel2.default.toXml("xf", {
                    xfId: 0,
                    applyAlignment: isAlignmentEmpty ? null : 1,
                    fontId: tag.fontId,
                    applyNumberFormat: applyNumberFormat,
                    fillId: tag.fillId,
                    numFmtId: tag.numberFormatId
                }, isAlignmentEmpty ? null : _excel4.default.toXml(tag.alignment))
            }
        };
        exports.default = cellFormatHelper
    },
    /*!****************************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.cell_alignment_helper.js ***!
      \****************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel = __webpack_require__( /*! ./excel.tag_helper */ 84);
        var _excel2 = _interopRequireDefault(_excel);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var cellAlignmentHelper = {
            tryCreateTag: function(sourceObj) {
                var result = null;
                if ((0, _type.isDefined)(sourceObj)) {
                    result = {
                        vertical: sourceObj.vertical,
                        wrapText: sourceObj.wrapText,
                        horizontal: sourceObj.horizontal
                    };
                    if (cellAlignmentHelper.isEmpty(result)) {
                        result = null
                    }
                }
                return result
            },
            copy: function(source) {
                var result = null;
                if ((0, _type.isDefined)(source)) {
                    result = {};
                    if (void 0 !== source.horizontal) {
                        result.horizontal = source.horizontal
                    }
                    if (void 0 !== source.vertical) {
                        result.vertical = source.vertical
                    }
                    if (void 0 !== source.wrapText) {
                        result.wrapText = source.wrapText
                    }
                }
                return result
            },
            areEqual: function(leftTag, rightTag) {
                return cellAlignmentHelper.isEmpty(leftTag) && cellAlignmentHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.vertical === rightTag.vertical && leftTag.wrapText === rightTag.wrapText && leftTag.horizontal === rightTag.horizontal
            },
            isEmpty: function(tag) {
                return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.vertical) && !(0, _type.isDefined)(tag.wrapText) && !(0, _type.isDefined)(tag.horizontal)
            },
            toXml: function(tag) {
                return _excel2.default.toXml("alignment", {
                    vertical: tag.vertical,
                    wrapText: (0, _type.isDefined)(tag.wrapText) ? Number(tag.wrapText) : void 0,
                    horizontal: tag.horizontal
                })
            }
        };
        exports.default = cellAlignmentHelper
    },
    /*!**************************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.pattern_fill_helper.js ***!
      \**************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel = __webpack_require__( /*! ./excel.tag_helper */ 84);
        var _excel2 = _interopRequireDefault(_excel);
        var _excel3 = __webpack_require__( /*! ./excel.color_helper */ 276);
        var _excel4 = _interopRequireDefault(_excel3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var patternFillHelper = {
            tryCreateTag: function(sourceObj) {
                var result = null;
                if ((0, _type.isDefined)(sourceObj)) {
                    result = {
                        patternType: sourceObj.patternType,
                        backgroundColor: _excel4.default.tryCreateTag(sourceObj.backgroundColor),
                        foregroundColor: _excel4.default.tryCreateTag(sourceObj.foregroundColor)
                    };
                    if (patternFillHelper.isEmpty(result)) {
                        result = null
                    }
                }
                return result
            },
            copy: function(source) {
                var result = null;
                if ((0, _type.isDefined)(source)) {
                    result = {};
                    if (void 0 !== source.patternType) {
                        result.patternType = source.patternType
                    }
                    if (void 0 !== source.backgroundColor) {
                        result.backgroundColor = _excel4.default.copy(source.backgroundColor)
                    }
                    if (void 0 !== source.foregroundColor) {
                        result.foregroundColor = _excel4.default.copy(source.foregroundColor)
                    }
                }
                return result
            },
            areEqual: function(leftTag, rightTag) {
                return patternFillHelper.isEmpty(leftTag) && patternFillHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.patternType === rightTag.patternType && _excel4.default.areEqual(leftTag.backgroundColor, rightTag.backgroundColor) && _excel4.default.areEqual(leftTag.foregroundColor, rightTag.foregroundColor)
            },
            isEmpty: function(tag) {
                return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.patternType)
            },
            toXml: function(tag) {
                var content = [(0, _type.isDefined)(tag.foregroundColor) ? _excel4.default.toXml("fgColor", tag.foregroundColor) : "", (0, _type.isDefined)(tag.backgroundColor) ? _excel4.default.toXml("bgColor", tag.backgroundColor) : ""].join("");
                return _excel2.default.toXml("patternFill", {
                    patternType: tag.patternType
                }, content)
            }
        };
        exports.default = patternFillHelper
    },
    /*!***************************************************************************!*\
      !*** ./artifacts/transpiled/exporter/excel/excel.number_format_helper.js ***!
      \***************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel = __webpack_require__( /*! ./excel.tag_helper */ 84);
        var _excel2 = _interopRequireDefault(_excel);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var numberFormatHelper = {
            ID_PROPERTY_NAME: "id",
            tryCreateTag: function(sourceObj) {
                var result = null;
                if ("string" === typeof sourceObj) {
                    result = {
                        formatCode: sourceObj
                    };
                    if (numberFormatHelper.isEmpty(result)) {
                        result = null
                    }
                }
                return result
            },
            areEqual: function(leftTag, rightTag) {
                return numberFormatHelper.isEmpty(leftTag) && numberFormatHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.formatCode === rightTag.formatCode
            },
            isEmpty: function(tag) {
                return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.formatCode) || "" === tag.formatCode
            },
            toXml: function(tag) {
                return _excel2.default.toXml("numFmt", {
                    numFmtId: tag[numberFormatHelper.ID_PROPERTY_NAME],
                    formatCode: tag.formatCode
                })
            }
        };
        exports.default = numberFormatHelper
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/exporter/svg_creator.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../core/renderer */ 2);
        var ajax = __webpack_require__( /*! ../core/utils/ajax */ 75);
        var window = __webpack_require__( /*! ../core/utils/window */ 7).getWindow();
        var isFunction = __webpack_require__( /*! ../core/utils/type */ 1).isFunction;
        var each = __webpack_require__( /*! ../core/utils/iterator */ 4).each;
        var svgUtils = __webpack_require__( /*! ../core/utils/svg */ 216);
        var deferredUtils = __webpack_require__( /*! ../core/utils/deferred */ 6);
        var when = deferredUtils.when;
        var Deferred = deferredUtils.Deferred;
        exports.svgCreator = {
            _markup: "",
            _imageArray: {},
            _imageDeferreds: [],
            _getBinaryFile: function(src, callback) {
                ajax.sendRequest({
                    url: src,
                    method: "GET",
                    responseType: "arraybuffer"
                }).done(callback).fail(function() {
                    callback(false)
                })
            },
            _loadImages: function() {
                var that = this;
                each(that._imageArray, function(src) {
                    var deferred = new Deferred;
                    that._imageDeferreds.push(deferred);
                    that._getBinaryFile(src, function(response) {
                        if (!response) {
                            delete that._imageArray[src];
                            deferred.resolve();
                            return
                        }
                        var i;
                        var binary = "";
                        var bytes = new Uint8Array(response);
                        var length = bytes.byteLength;
                        for (i = 0; i < length; i++) {
                            binary += String.fromCharCode(bytes[i])
                        }
                        that._imageArray[src] = "data:image/png;base64," + window.btoa(binary);
                        deferred.resolve()
                    })
                })
            },
            _parseImages: function(element) {
                var href;
                var that = this;
                if ("image" === element.tagName) {
                    href = $(element).attr("href") || $(element).attr("xlink:href");
                    if (!that._imageArray[href]) {
                        that._imageArray[href] = ""
                    }
                }
                each(element.childNodes, function(_, element) {
                    that._parseImages(element)
                })
            },
            _prepareImages: function(svgElem) {
                this._parseImages(svgElem);
                this._loadImages();
                return when.apply($, this._imageDeferreds)
            },
            getData: function(data, options) {
                var markup;
                var that = this;
                var xmlVersion = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>';
                var svgElem = svgUtils.getSvgElement(data);
                var $svgObject = $(svgElem);
                markup = xmlVersion + svgUtils.getSvgMarkup($svgObject.get(0), options.backgroundColor);
                return that._prepareImages(svgElem).then(function() {
                    each(that._imageArray, function(href, dataURI) {
                        var regexpString = "href=['|\"]".concat(href, "['|\"]");
                        markup = markup.replace(new RegExp(regexpString, "gi"), 'href="'.concat(dataURI, '"'))
                    });
                    return isFunction(window.Blob) ? that._getBlob(markup) : that._getBase64(markup)
                })
            },
            _getBlob: function(markup) {
                return new window.Blob([markup], {
                    type: "image/svg+xml"
                })
            },
            _getBase64: function(markup) {
                return window.btoa(markup)
            }
        };
        exports.getData = function(data, options) {
            return exports.svgCreator.getData(data, options)
        }
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/core/http_request.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var windowUtils = __webpack_require__( /*! ./utils/window */ 7);
        var window = windowUtils.getWindow();
        var injector = __webpack_require__( /*! ./utils/dependency_injector */ 56);
        var nativeXMLHttpRequest = {
            getXhr: function() {
                return new window.XMLHttpRequest
            }
        };
        module.exports = injector(nativeXMLHttpRequest)
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/exporter/pdf_creator.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var VERSION = __webpack_require__( /*! ../core/version */ 164);
        var window = __webpack_require__( /*! ../core/utils/window */ 7).getWindow();
        var imageCreator = __webpack_require__( /*! ./image_creator */ 278).imageCreator;
        var isFunction = __webpack_require__( /*! ../core/utils/type */ 1).isFunction;
        var extend = __webpack_require__( /*! ../core/utils/extend */ 0).extend;
        var mainPageTemplate = "%PDF-1.3\r\n2 0 obj\r\n<</ProcSet[/PDF/ImageB/ImageC/ImageI]/XObject<</I0 5 0 R>>>>\r\nendobj\r\n4 0 obj\r\n<</Type/Pages/Kids[1 0 R]/Count 1>>\r\nendobj\r\n7 0 obj\r\n<</OpenAction[1 0 R /FitH null]/Type/Catalog/Pages 4 0 R/PageLayout/OneColumn>>\r\nendobj\r\n1 0 obj\r\n<</Type/Page/Resources 2 0 R/MediaBox[0 0 _width_ _height_]/Contents 3 0 R/Parent 4 0 R>>\r\nendobj\r\n";
        var contentTemplate = "3 0 obj\r\n<</Length 52>>stream\r\n0.20 w\n0 G\nq _width_ 0 0 _height_ 0.00 0.00 cm /I0 Do Q\r\nendstream\r\nendobj\r\n";
        var infoTemplate = "6 0 obj\r\n<</CreationDate _date_/Producer(DevExtreme _version_)>>\r\nendobj\r\n";
        var imageStartTemplate = "5 0 obj\r\n<</Type/XObject/Subtype/Image/Width _width_/Height _height_/ColorSpace/DeviceRGB/BitsPerComponent 8/Filter/DCTDecode/Length _length_>>stream\r\n";
        var imageEndTemplate = "\r\nendstream\r\nendobj\r\n";
        var trailerTemplate = "trailer\r\n<<\r\n/Size 8\r\n/Root 7 0 R\r\n/Info 6 0 R\r\n>>\r\nstartxref\r\n_length_\r\n%%EOF";
        var xrefTemplate = "xref\r\n0 8\r\n0000000000 65535 f\r\n0000000241 00000 n\r\n0000000010 00000 n\r\n_main_ 00000 n\r\n0000000089 00000 n\r\n_image_ 00000 n\r\n_info_ 00000 n\r\n0000000143 00000 n\r\n";
        var pad = function pad(str, len) {
            return str.length < len ? pad("0" + str, len) : str
        };
        var composePdfString = function(imageString, options, curDate) {
            var margin = 2 * (options.margin || 0);
            var width = options.width + margin;
            var height = options.height + margin;
            var widthPt = (.75 * width).toFixed(2);
            var heightPt = (.75 * height).toFixed(2);
            var mainPage = mainPageTemplate.replace("_width_", widthPt).replace("_height_", heightPt);
            var content = contentTemplate.replace("_width_", widthPt).replace("_height_", heightPt);
            var info = infoTemplate.replace("_date_", curDate).replace("_version_", VERSION);
            var image = imageStartTemplate.replace("_width_", width).replace("_height_", height).replace("_length_", imageString.length) + imageString + imageEndTemplate;
            var xref = getXref(mainPage.length, content.length, info.length);
            var mainContent = mainPage + content + info + image;
            var trailer = trailerTemplate.replace("_length_", mainContent.length);
            return mainContent + xref + trailer
        };

        function getXref(mainPageLength, contentLength, infoLength) {
            return xrefTemplate.replace("_main_", pad(mainPageLength + "", 10)).replace("_info_", pad(mainPageLength + contentLength + "", 10)).replace("_image_", pad(mainPageLength + contentLength + infoLength + "", 10))
        }
        var getCurDate = function() {
            return new Date
        };
        var getBlob = function(binaryData) {
            var i = 0;
            var dataArray = new Uint8Array(binaryData.length);
            for (; i < binaryData.length; i++) {
                dataArray[i] = binaryData.charCodeAt(i)
            }
            return new window.Blob([dataArray.buffer], {
                type: "application/pdf"
            })
        };
        var getBase64 = function(binaryData) {
            return window.btoa(binaryData)
        };
        exports.getData = function(data, options) {
            return imageCreator.getImageData(data, extend({}, options, {
                format: "JPEG"
            })).then(function(imageString) {
                var binaryData = composePdfString(imageString, options, getCurDate());
                var pdfData = isFunction(window.Blob) ? getBlob(binaryData) : getBase64(binaryData);
                return pdfData
            })
        };
        exports.__tests = {
            set_composePdfString: function(func) {
                exports.__tests.composePdfString = composePdfString;
                composePdfString = func
            },
            restore_composePdfString: function(func) {
                if (exports.__tests.composePdfString) {
                    composePdfString = exports.__tests.composePdfString;
                    exports.__tests.composePdfString = null
                }
            },
            set_getCurDate: function(func) {
                exports.__tests.getCurDate = getCurDate;
                getCurDate = func
            },
            restore_getCurDate: function(func) {
                if (exports.__tests.getCurDate) {
                    getCurDate = exports.__tests.getCurDate;
                    exports.__tests.getCurDate = null
                }
            },
            set_getBlob: function(func) {
                exports.__tests.getBlob = getBlob;
                getBlob = func
            },
            restore_getBlob: function(func) {
                if (exports.__tests.getBlob) {
                    getBlob = exports.__tests.getBlob;
                    exports.__tests.getBlob = null
                }
            },
            set_getBase64: function(func) {
                exports.__tests.getBase64 = getBase64;
                getBase64 = func
            },
            restore_getBase64: function(func) {
                if (exports.__tests.getBase64) {
                    getBase64 = exports.__tests.getBase64;
                    exports.__tests.getBase64 = null
                }
            }
        }
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/excel_exporter.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.exportDataGrid = void 0;
        var _export_data_grid = __webpack_require__( /*! ./exporter/exceljs/export_data_grid */ 466);
        exports.exportDataGrid = _export_data_grid.exportDataGrid
    },
    /*!*******************************************************************!*\
      !*** ./artifacts/transpiled/exporter/exceljs/export_data_grid.js ***!
      \*******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports._getFullOptions = exports.MAX_EXCEL_COLUMN_WIDTH = exports.exportDataGrid = void 0;
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _excel_format_converter = __webpack_require__( /*! ../excel_format_converter */ 186);
        var _excel_format_converter2 = _interopRequireDefault(_excel_format_converter);
        var _message = __webpack_require__( /*! ../../localization/message */ 10);
        var _message2 = _interopRequireDefault(_message);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var MAX_DIGIT_WIDTH_IN_PIXELS = 7;
        var MAX_EXCEL_COLUMN_WIDTH = 255;

        function exportDataGrid(options) {
            if (!(0, _type.isDefined)(options)) {
                return
            }
            var _getFullOptions2 = _getFullOptions(options),
                customizeCell = _getFullOptions2.customizeCell,
                component = _getFullOptions2.component,
                worksheet = _getFullOptions2.worksheet,
                topLeftCell = _getFullOptions2.topLeftCell,
                autoFilterEnabled = _getFullOptions2.autoFilterEnabled,
                keepColumnWidths = _getFullOptions2.keepColumnWidths,
                selectedRowsOnly = _getFullOptions2.selectedRowsOnly,
                loadPanel = _getFullOptions2.loadPanel;
            var initialLoadPanelOptions = (0, _extend.extend)({}, component.option("loadPanel"));
            if ("animation" in component.option("loadPanel")) {
                loadPanel.animation = null
            }
            component.option("loadPanel", loadPanel);
            var wrapText = !!component.option("wordWrapEnabled");
            worksheet.properties.outlineProperties = {
                summaryBelow: false,
                summaryRight: false
            };
            var cellRange = {
                from: {
                    row: topLeftCell.row,
                    column: topLeftCell.column
                },
                to: {
                    row: topLeftCell.row,
                    column: topLeftCell.column
                }
            };
            var dataProvider = component.getDataProvider(selectedRowsOnly);
            return new Promise(function(resolve) {
                dataProvider.ready().done(function() {
                    var columns = dataProvider.getColumns();
                    var headerRowCount = dataProvider.getHeaderRowCount();
                    var dataRowsCount = dataProvider.getRowsCount();
                    if (keepColumnWidths) {
                        _setColumnsWidth(worksheet, columns, cellRange.from.column)
                    }
                    var mergedCells = [];
                    var mergeRanges = [];
                    for (var rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {
                        var row = worksheet.getRow(cellRange.from.row + rowIndex);
                        _exportRow(rowIndex, columns.length, row, cellRange.from.column, dataProvider, customizeCell, headerRowCount, mergedCells, mergeRanges, wrapText);
                        if (rowIndex >= headerRowCount) {
                            row.outlineLevel = dataProvider.getGroupLevel(rowIndex)
                        }
                        if (rowIndex >= 1) {
                            cellRange.to.row++
                        }
                    }
                    _mergeCells(worksheet, topLeftCell, mergeRanges);
                    cellRange.to.column += columns.length > 0 ? columns.length - 1 : 0;
                    var worksheetViewSettings = worksheet.views[0] || {};
                    if (component.option("rtlEnabled")) {
                        worksheetViewSettings.rightToLeft = true
                    }
                    if (headerRowCount > 0) {
                        if (Object.keys(worksheetViewSettings).indexOf("state") === -1) {
                            (0, _extend.extend)(worksheetViewSettings, {
                                state: "frozen",
                                ySplit: cellRange.from.row + dataProvider.getFrozenArea().y - 1
                            })
                        }
                        _setAutoFilter(dataProvider, worksheet, cellRange, autoFilterEnabled)
                    }
                    if (Object.keys(worksheetViewSettings).length > 0) {
                        worksheet.views = [worksheetViewSettings]
                    }
                    resolve(cellRange)
                }).always(function() {
                    component.option("loadPanel", initialLoadPanelOptions)
                })
            })
        }

        function _getFullOptions(options) {
            var fullOptions = (0, _extend.extend)({}, options);
            if (!(0, _type.isDefined)(fullOptions.topLeftCell)) {
                fullOptions.topLeftCell = {
                    row: 1,
                    column: 1
                }
            } else {
                if ((0, _type.isString)(fullOptions.topLeftCell)) {
                    var _fullOptions$workshee = fullOptions.worksheet.getCell(fullOptions.topLeftCell),
                        row = _fullOptions$workshee.row,
                        col = _fullOptions$workshee.col;
                    fullOptions.topLeftCell = {
                        row: row,
                        column: col
                    }
                }
            }
            if (!(0, _type.isDefined)(fullOptions.keepColumnWidths)) {
                fullOptions.keepColumnWidths = true
            }
            if (!(0, _type.isDefined)(fullOptions.selectedRowsOnly)) {
                fullOptions.selectedRowsOnly = false
            }
            if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
                fullOptions.loadPanel = {}
            }
            if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
                fullOptions.loadPanel.enabled = true
            }
            if (!(0, _type.isDefined)(fullOptions.loadPanel.text)) {
                fullOptions.loadPanel.text = _message2.default.format("dxDataGrid-exporting")
            }
            if (!(0, _type.isDefined)(fullOptions.autoFilterEnabled)) {
                fullOptions.autoFilterEnabled = false
            }
            return fullOptions
        }

        function _exportRow(rowIndex, cellCount, row, startColumnIndex, dataProvider, customizeCell, headerRowCount, mergedCells, mergeRanges, wrapText) {
            var styles = dataProvider.getStyles();
            for (var cellIndex = 0; cellIndex < cellCount; cellIndex++) {
                var cellData = dataProvider.getCellData(rowIndex, cellIndex, true);
                var gridCell = cellData.cellSourceData;
                var excelCell = row.getCell(startColumnIndex + cellIndex);
                if ((0, _type.isDate)(cellData.value)) {
                    excelCell.value = _convertDateForExcelJS(cellData.value)
                } else {
                    excelCell.value = cellData.value
                }
                if ((0, _type.isDefined)(excelCell.value)) {
                    var _styles$dataProvider$ = styles[dataProvider.getStyleId(rowIndex, cellIndex)],
                        bold = _styles$dataProvider$.bold,
                        horizontalAlignment = _styles$dataProvider$.alignment,
                        format = _styles$dataProvider$.format,
                        dataType = _styles$dataProvider$.dataType;
                    var numberFormat = _tryConvertToExcelNumberFormat(format, dataType);
                    if ((0, _type.isDefined)(numberFormat)) {
                        numberFormat = numberFormat.replace(/&quot;/g, "")
                    } else {
                        if ((0, _type.isString)(excelCell.value) && /^[@=+-]/.test(excelCell.value)) {
                            numberFormat = "@"
                        }
                    }
                    _setNumberFormat(excelCell, numberFormat);
                    _setFont(excelCell, bold);
                    _setAlignment(excelCell, wrapText, horizontalAlignment)
                }
                if ((0, _type.isDefined)(customizeCell)) {
                    customizeCell({
                        cell: excelCell,
                        excelCell: excelCell,
                        gridCell: gridCell
                    })
                }
                if (rowIndex < headerRowCount) {
                    var mergeRange = _tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider);
                    if ((0, _type.isDefined)(mergeRange)) {
                        mergeRanges.push(mergeRange)
                    }
                }
            }
        }

        function _convertDateForExcelJS(date) {
            return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()))
        }

        function _setAutoFilter(dataProvider, worksheet, cellRange, autoFilterEnabled) {
            if (autoFilterEnabled) {
                if (!(0, _type.isDefined)(worksheet.autoFilter) && dataProvider.getRowsCount() > 0) {
                    worksheet.autoFilter = cellRange
                }
            }
        }

        function _setNumberFormat(excelCell, numberFormat) {
            excelCell.numFmt = numberFormat
        }

        function _tryConvertToExcelNumberFormat(format, dataType) {
            var newFormat = _formatObjectConverter(format, dataType);
            var currency = newFormat.currency;
            format = newFormat.format;
            dataType = newFormat.dataType;
            return _excel_format_converter2.default.convertFormat(format, newFormat.precision, dataType, currency)
        }

        function _formatObjectConverter(format, dataType) {
            var result = {
                format: format,
                precision: format && format.precision,
                dataType: dataType
            };
            if ((0, _type.isObject)(format)) {
                return (0, _extend.extend)(result, format, {
                    format: format.formatter || format.type,
                    currency: format.currency
                })
            }
            return result
        }

        function _setFont(excelCell, bold) {
            if ((0, _type.isDefined)(bold)) {
                excelCell.font = excelCell.font || {};
                excelCell.font.bold = bold
            }
        }

        function _setAlignment(excelCell, wrapText, horizontalAlignment) {
            excelCell.alignment = excelCell.alignment || {};
            if ((0, _type.isDefined)(wrapText)) {
                excelCell.alignment.wrapText = wrapText
            }
            if ((0, _type.isDefined)(horizontalAlignment)) {
                excelCell.alignment.horizontal = horizontalAlignment
            }
            excelCell.alignment.vertical = "top"
        }

        function _setColumnsWidth(worksheet, columns, startColumnIndex) {
            if (!(0, _type.isDefined)(columns)) {
                return
            }
            for (var i = 0; i < columns.length; i++) {
                var columnWidth = columns[i].width;
                if ("number" === typeof columnWidth && isFinite(columnWidth)) {
                    worksheet.getColumn(startColumnIndex + i).width = Math.min(MAX_EXCEL_COLUMN_WIDTH, Math.floor(columnWidth / MAX_DIGIT_WIDTH_IN_PIXELS * 100) / 100)
                }
            }
        }

        function _tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider) {
            if (!mergedCells[rowIndex] || !mergedCells[rowIndex][cellIndex]) {
                var cellMerge = dataProvider.getCellMerging(rowIndex, cellIndex);
                if (cellMerge.colspan || cellMerge.rowspan) {
                    for (var i = rowIndex; i <= rowIndex + cellMerge.rowspan || 0; i++) {
                        for (var j = cellIndex; j <= cellIndex + cellMerge.colspan || 0; j++) {
                            if (!mergedCells[i]) {
                                mergedCells[i] = []
                            }
                            mergedCells[i][j] = true
                        }
                    }
                    return {
                        start: {
                            row: rowIndex,
                            column: cellIndex
                        },
                        end: {
                            row: rowIndex + (cellMerge.rowspan || 0),
                            column: cellIndex + (cellMerge.colspan || 0)
                        }
                    }
                }
            }
        }

        function _mergeCells(worksheet, topLeftCell, mergeRanges) {
            mergeRanges.forEach(function(mergeRange) {
                worksheet.mergeCells(mergeRange.start.row + topLeftCell.row, mergeRange.start.column + topLeftCell.column, mergeRange.end.row + topLeftCell.row, mergeRange.end.column + topLeftCell.column)
            })
        }
        exports.exportDataGrid = exportDataGrid;
        exports.MAX_EXCEL_COLUMN_WIDTH = MAX_EXCEL_COLUMN_WIDTH;
        exports._getFullOptions = _getFullOptions
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/localization/default_messages.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = {
            en: {
                Yes: "Yes",
                No: "No",
                Cancel: "Cancel",
                Clear: "Clear",
                Done: "Done",
                Loading: "Loading...",
                Select: "Select...",
                Search: "Search",
                Back: "Back",
                OK: "OK",
                "dxCollectionWidget-noDataText": "No data to display",
                "dxDropDownEditor-selectLabel": "Select",
                "validation-required": "Required",
                "validation-required-formatted": "{0} is required",
                "validation-numeric": "Value must be a number",
                "validation-numeric-formatted": "{0} must be a number",
                "validation-range": "Value is out of range",
                "validation-range-formatted": "{0} is out of range",
                "validation-stringLength": "The length of the value is not correct",
                "validation-stringLength-formatted": "The length of {0} is not correct",
                "validation-custom": "Value is invalid",
                "validation-custom-formatted": "{0} is invalid",
                "validation-async": "Value is invalid",
                "validation-async-formatted": "{0} is invalid",
                "validation-compare": "Values do not match",
                "validation-compare-formatted": "{0} does not match",
                "validation-pattern": "Value does not match pattern",
                "validation-pattern-formatted": "{0} does not match pattern",
                "validation-email": "Email is invalid",
                "validation-email-formatted": "{0} is invalid",
                "validation-mask": "Value is invalid",
                "dxLookup-searchPlaceholder": "Minimum character number: {0}",
                "dxList-pullingDownText": "Pull down to refresh...",
                "dxList-pulledDownText": "Release to refresh...",
                "dxList-refreshingText": "Refreshing...",
                "dxList-pageLoadingText": "Loading...",
                "dxList-nextButtonText": "More",
                "dxList-selectAll": "Select All",
                "dxListEditDecorator-delete": "Delete",
                "dxListEditDecorator-more": "More",
                "dxScrollView-pullingDownText": "Pull down to refresh...",
                "dxScrollView-pulledDownText": "Release to refresh...",
                "dxScrollView-refreshingText": "Refreshing...",
                "dxScrollView-reachBottomText": "Loading...",
                "dxDateBox-simulatedDataPickerTitleTime": "Select time",
                "dxDateBox-simulatedDataPickerTitleDate": "Select date",
                "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
                "dxDateBox-validation-datetime": "Value must be a date or time",
                "dxFileUploader-selectFile": "Select file",
                "dxFileUploader-dropFile": "or Drop file here",
                "dxFileUploader-bytes": "bytes",
                "dxFileUploader-kb": "kb",
                "dxFileUploader-Mb": "Mb",
                "dxFileUploader-Gb": "Gb",
                "dxFileUploader-upload": "Upload",
                "dxFileUploader-uploaded": "Uploaded",
                "dxFileUploader-readyToUpload": "Ready to upload",
                "dxFileUploader-uploadFailedMessage": "Upload failed",
                "dxFileUploader-invalidFileExtension": "File type is not allowed",
                "dxFileUploader-invalidMaxFileSize": "File is too large",
                "dxFileUploader-invalidMinFileSize": "File is too small",
                "dxRangeSlider-ariaFrom": "From",
                "dxRangeSlider-ariaTill": "Till",
                "dxSwitch-switchedOnText": "ON",
                "dxSwitch-switchedOffText": "OFF",
                "dxForm-optionalMark": "optional",
                "dxForm-requiredMessage": "{0} is required",
                "dxNumberBox-invalidValueMessage": "Value must be a number",
                "dxNumberBox-noDataText": "No data",
                "dxDataGrid-columnChooserTitle": "Column Chooser",
                "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
                "dxDataGrid-groupContinuesMessage": "Continues on the next page",
                "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
                "dxDataGrid-groupHeaderText": "Group by This Column",
                "dxDataGrid-ungroupHeaderText": "Ungroup",
                "dxDataGrid-ungroupAllText": "Ungroup All",
                "dxDataGrid-editingEditRow": "Edit",
                "dxDataGrid-editingSaveRowChanges": "Save",
                "dxDataGrid-editingCancelRowChanges": "Cancel",
                "dxDataGrid-editingDeleteRow": "Delete",
                "dxDataGrid-editingUndeleteRow": "Undelete",
                "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
                "dxDataGrid-validationCancelChanges": "Cancel changes",
                "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
                "dxDataGrid-noDataText": "No data",
                "dxDataGrid-searchPanelPlaceholder": "Search...",
                "dxDataGrid-filterRowShowAllText": "(All)",
                "dxDataGrid-filterRowResetOperationText": "Reset",
                "dxDataGrid-filterRowOperationEquals": "Equals",
                "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
                "dxDataGrid-filterRowOperationLess": "Less than",
                "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
                "dxDataGrid-filterRowOperationGreater": "Greater than",
                "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
                "dxDataGrid-filterRowOperationStartsWith": "Starts with",
                "dxDataGrid-filterRowOperationContains": "Contains",
                "dxDataGrid-filterRowOperationNotContains": "Does not contain",
                "dxDataGrid-filterRowOperationEndsWith": "Ends with",
                "dxDataGrid-filterRowOperationBetween": "Between",
                "dxDataGrid-filterRowOperationBetweenStartText": "Start",
                "dxDataGrid-filterRowOperationBetweenEndText": "End",
                "dxDataGrid-applyFilterText": "Apply filter",
                "dxDataGrid-trueText": "true",
                "dxDataGrid-falseText": "false",
                "dxDataGrid-sortingAscendingText": "Sort Ascending",
                "dxDataGrid-sortingDescendingText": "Sort Descending",
                "dxDataGrid-sortingClearText": "Clear Sorting",
                "dxDataGrid-editingSaveAllChanges": "Save changes",
                "dxDataGrid-editingCancelAllChanges": "Discard changes",
                "dxDataGrid-editingAddRow": "Add a row",
                "dxDataGrid-summaryMin": "Min: {0}",
                "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
                "dxDataGrid-summaryMax": "Max: {0}",
                "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
                "dxDataGrid-summaryAvg": "Avg: {0}",
                "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
                "dxDataGrid-summarySum": "Sum: {0}",
                "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
                "dxDataGrid-summaryCount": "Count: {0}",
                "dxDataGrid-columnFixingFix": "Fix",
                "dxDataGrid-columnFixingUnfix": "Unfix",
                "dxDataGrid-columnFixingLeftPosition": "To the left",
                "dxDataGrid-columnFixingRightPosition": "To the right",
                "dxDataGrid-exportTo": "Export",
                "dxDataGrid-exportToExcel": "Export to Excel file",
                "dxDataGrid-exporting": "Exporting...",
                "dxDataGrid-excelFormat": "Excel file",
                "dxDataGrid-selectedRows": "Selected rows",
                "dxDataGrid-exportSelectedRows": "Export selected rows",
                "dxDataGrid-exportAll": "Export all data",
                "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
                "dxDataGrid-headerFilterOK": "OK",
                "dxDataGrid-headerFilterCancel": "Cancel",
                "dxDataGrid-ariaColumn": "Column",
                "dxDataGrid-ariaValue": "Value",
                "dxDataGrid-ariaFilterCell": "Filter cell",
                "dxDataGrid-ariaCollapse": "Collapse",
                "dxDataGrid-ariaExpand": "Expand",
                "dxDataGrid-ariaDataGrid": "Data grid",
                "dxDataGrid-ariaSearchInGrid": "Search in data grid",
                "dxDataGrid-ariaSelectAll": "Select all",
                "dxDataGrid-ariaSelectRow": "Select row",
                "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
                "dxDataGrid-filterPanelCreateFilter": "Create Filter",
                "dxDataGrid-filterPanelClearFilter": "Clear",
                "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
                "dxTreeList-ariaTreeList": "Tree list",
                "dxTreeList-editingAddRowToNode": "Add",
                "dxPager-infoText": "Page {0} of {1} ({2} items)",
                "dxPager-pagesCountText": "of",
                "dxPivotGrid-grandTotal": "Grand Total",
                "dxPivotGrid-total": "{0} Total",
                "dxPivotGrid-fieldChooserTitle": "Field Chooser",
                "dxPivotGrid-showFieldChooser": "Show Field Chooser",
                "dxPivotGrid-expandAll": "Expand All",
                "dxPivotGrid-collapseAll": "Collapse All",
                "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
                "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
                "dxPivotGrid-removeAllSorting": "Remove All Sorting",
                "dxPivotGrid-dataNotAvailable": "N/A",
                "dxPivotGrid-rowFields": "Row Fields",
                "dxPivotGrid-columnFields": "Column Fields",
                "dxPivotGrid-dataFields": "Data Fields",
                "dxPivotGrid-filterFields": "Filter Fields",
                "dxPivotGrid-allFields": "All Fields",
                "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
                "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
                "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
                "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
                "dxScheduler-editorLabelTitle": "Subject",
                "dxScheduler-editorLabelStartDate": "Start Date",
                "dxScheduler-editorLabelEndDate": "End Date",
                "dxScheduler-editorLabelDescription": "Description",
                "dxScheduler-editorLabelRecurrence": "Repeat",
                "dxScheduler-openAppointment": "Open appointment",
                "dxScheduler-recurrenceNever": "Never",
                "dxScheduler-recurrenceMinutely": "Every minute",
                "dxScheduler-recurrenceHourly": "Hourly",
                "dxScheduler-recurrenceDaily": "Daily",
                "dxScheduler-recurrenceWeekly": "Weekly",
                "dxScheduler-recurrenceMonthly": "Monthly",
                "dxScheduler-recurrenceYearly": "Yearly",
                "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
                "dxScheduler-recurrenceRepeatOn": "Repeat On",
                "dxScheduler-recurrenceEnd": "End repeat",
                "dxScheduler-recurrenceAfter": "After",
                "dxScheduler-recurrenceOn": "On",
                "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
                "dxScheduler-recurrenceRepeatHourly": "hour(s)",
                "dxScheduler-recurrenceRepeatDaily": "day(s)",
                "dxScheduler-recurrenceRepeatWeekly": "week(s)",
                "dxScheduler-recurrenceRepeatMonthly": "month(s)",
                "dxScheduler-recurrenceRepeatYearly": "year(s)",
                "dxScheduler-switcherDay": "Day",
                "dxScheduler-switcherWeek": "Week",
                "dxScheduler-switcherWorkWeek": "Work Week",
                "dxScheduler-switcherMonth": "Month",
                "dxScheduler-switcherAgenda": "Agenda",
                "dxScheduler-switcherTimelineDay": "Timeline Day",
                "dxScheduler-switcherTimelineWeek": "Timeline Week",
                "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
                "dxScheduler-switcherTimelineMonth": "Timeline Month",
                "dxScheduler-recurrenceRepeatOnDate": "on date",
                "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
                "dxScheduler-allDay": "All day",
                "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
                "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
                "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
                "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
                "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
                "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
                "dxScheduler-noTimezoneTitle": "No timezone",
                "dxScheduler-moreAppointments": "{0} more",
                "dxCalendar-todayButtonText": "Today",
                "dxCalendar-ariaWidgetName": "Calendar",
                "dxColorView-ariaRed": "Red",
                "dxColorView-ariaGreen": "Green",
                "dxColorView-ariaBlue": "Blue",
                "dxColorView-ariaAlpha": "Transparency",
                "dxColorView-ariaHex": "Color code",
                "dxTagBox-selected": "{0} selected",
                "dxTagBox-allSelected": "All selected ({0})",
                "dxTagBox-moreSelected": "{0} more",
                "vizExport-printingButtonText": "Print",
                "vizExport-titleMenuText": "Exporting/Printing",
                "vizExport-exportButtonText": "{0} file",
                "dxFilterBuilder-and": "And",
                "dxFilterBuilder-or": "Or",
                "dxFilterBuilder-notAnd": "Not And",
                "dxFilterBuilder-notOr": "Not Or",
                "dxFilterBuilder-addCondition": "Add Condition",
                "dxFilterBuilder-addGroup": "Add Group",
                "dxFilterBuilder-enterValueText": "<enter a value>",
                "dxFilterBuilder-filterOperationEquals": "Equals",
                "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
                "dxFilterBuilder-filterOperationLess": "Is less than",
                "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
                "dxFilterBuilder-filterOperationGreater": "Is greater than",
                "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
                "dxFilterBuilder-filterOperationStartsWith": "Starts with",
                "dxFilterBuilder-filterOperationContains": "Contains",
                "dxFilterBuilder-filterOperationNotContains": "Does not contain",
                "dxFilterBuilder-filterOperationEndsWith": "Ends with",
                "dxFilterBuilder-filterOperationIsBlank": "Is blank",
                "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
                "dxFilterBuilder-filterOperationBetween": "Is between",
                "dxFilterBuilder-filterOperationAnyOf": "Is any of",
                "dxFilterBuilder-filterOperationNoneOf": "Is none of",
                "dxHtmlEditor-dialogColorCaption": "Change Font Color",
                "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
                "dxHtmlEditor-dialogLinkCaption": "Add Link",
                "dxHtmlEditor-dialogLinkUrlField": "URL",
                "dxHtmlEditor-dialogLinkTextField": "Text",
                "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
                "dxHtmlEditor-dialogImageCaption": "Add Image",
                "dxHtmlEditor-dialogImageUrlField": "URL",
                "dxHtmlEditor-dialogImageAltField": "Alternate text",
                "dxHtmlEditor-dialogImageWidthField": "Width (px)",
                "dxHtmlEditor-dialogImageHeightField": "Height (px)",
                "dxHtmlEditor-heading": "Heading",
                "dxHtmlEditor-normalText": "Normal text",
                "dxFileManager-newDirectoryName": "Untitled directory",
                "dxFileManager-rootDirectoryName": "Files",
                "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
                "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
                "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
                "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
                "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
                "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
                "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
                "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
                "dxFileManager-errorDefault": "Unspecified error.",
                "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
                "dxFileManager-commandCreate": "New directory",
                "dxFileManager-commandRename": "Rename",
                "dxFileManager-commandMove": "Move to",
                "dxFileManager-commandCopy": "Copy to",
                "dxFileManager-commandDelete": "Delete",
                "dxFileManager-commandDownload": "Download",
                "dxFileManager-commandUpload": "Upload files",
                "dxFileManager-commandRefresh": "Refresh",
                "dxFileManager-commandThumbnails": "Thumbnails View",
                "dxFileManager-commandDetails": "Details View",
                "dxFileManager-commandClearSelection": "Clear selection",
                "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
                "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
                "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
                "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
                "dxFileManager-dialogRenameItemTitle": "Rename",
                "dxFileManager-dialogRenameItemButtonText": "Save",
                "dxFileManager-dialogCreateDirectoryTitle": "New directory",
                "dxFileManager-dialogCreateDirectoryButtonText": "Create",
                "dxFileManager-dialogDeleteItemTitle": "Delete",
                "dxFileManager-dialogDeleteItemButtonText": "Delete",
                "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
                "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
                "dxFileManager-dialogButtonCancel": "Cancel",
                "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
                "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
                "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
                "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
                "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
                "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
                "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
                "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
                "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
                "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
                "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
                "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
                "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
                "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
                "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
                "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
                "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
                "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
                "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
                "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
                "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
                "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
                "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
                "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
                "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
                "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
                "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
                "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
                "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
                "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
                "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
                "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
                "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
                "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
                "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
                "dxFileManager-editingUploadCanceledMessage": "Canceled",
                "dxFileManager-listDetailsColumnCaptionName": "Name",
                "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
                "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
                "dxFileManager-listThumbnailsTooltipTextSize": "Size",
                "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
                "dxFileManager-notificationProgressPanelTitle": "Progress",
                "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
                "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
                "dxDiagram-categoryGeneral": "General",
                "dxDiagram-categoryFlowchart": "Flowchart",
                "dxDiagram-categoryOrgChart": "Org Chart",
                "dxDiagram-categoryContainers": "Containers",
                "dxDiagram-categoryCustom": "Custom",
                "dxDiagram-commandExportToSvg": "Export to SVG",
                "dxDiagram-commandExportToPng": "Export to PNG",
                "dxDiagram-commandExportToJpg": "Export to JPEG",
                "dxDiagram-commandUndo": "Undo",
                "dxDiagram-commandRedo": "Redo",
                "dxDiagram-commandFontName": "Font Name",
                "dxDiagram-commandFontSize": "Font Size",
                "dxDiagram-commandBold": "Bold",
                "dxDiagram-commandItalic": "Italic",
                "dxDiagram-commandUnderline": "Underline",
                "dxDiagram-commandTextColor": "Font Color",
                "dxDiagram-commandLineColor": "Line Color",
                "dxDiagram-commandLineWidth": "Line Width",
                "dxDiagram-commandLineStyle": "Line Style",
                "dxDiagram-commandLineStyleSolid": "Solid",
                "dxDiagram-commandLineStyleDotted": "Dotted",
                "dxDiagram-commandLineStyleDashed": "Dashed",
                "dxDiagram-commandFillColor": "Fill Color",
                "dxDiagram-commandAlignLeft": "Align Left",
                "dxDiagram-commandAlignCenter": "Align Center",
                "dxDiagram-commandAlignRight": "Align Right",
                "dxDiagram-commandConnectorLineType": "Connector Line Type",
                "dxDiagram-commandConnectorLineStraight": "Straight",
                "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
                "dxDiagram-commandConnectorLineStart": "Connector Line Start",
                "dxDiagram-commandConnectorLineEnd": "Connector Line End",
                "dxDiagram-commandConnectorLineNone": "None",
                "dxDiagram-commandConnectorLineArrow": "Arrow",
                "dxDiagram-commandFullscreen": "Full Screen",
                "dxDiagram-commandUnits": "Units",
                "dxDiagram-commandPageSize": "Page Size",
                "dxDiagram-commandPageOrientation": "Page Orientation",
                "dxDiagram-commandPageOrientationLandscape": "Landscape",
                "dxDiagram-commandPageOrientationPortrait": "Portrait",
                "dxDiagram-commandPageColor": "Page Color",
                "dxDiagram-commandShowGrid": "Show Grid",
                "dxDiagram-commandSnapToGrid": "Snap to Grid",
                "dxDiagram-commandGridSize": "Grid Size",
                "dxDiagram-commandZoomLevel": "Zoom Level",
                "dxDiagram-commandAutoZoom": "Auto Zoom",
                "dxDiagram-commandFitToContent": "Fit to Content",
                "dxDiagram-commandFitToWidth": "Fit to Width",
                "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
                "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
                "dxDiagram-commandSimpleView": "Simple View",
                "dxDiagram-commandCut": "Cut",
                "dxDiagram-commandCopy": "Copy",
                "dxDiagram-commandPaste": "Paste",
                "dxDiagram-commandSelectAll": "Select All",
                "dxDiagram-commandDelete": "Delete",
                "dxDiagram-commandBringToFront": "Bring to Front",
                "dxDiagram-commandSendToBack": "Send to Back",
                "dxDiagram-commandLock": "Lock",
                "dxDiagram-commandUnlock": "Unlock",
                "dxDiagram-commandInsertShapeImage": "Insert Image...",
                "dxDiagram-commandEditShapeImage": "Change Image...",
                "dxDiagram-commandDeleteShapeImage": "Delete Image",
                "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
                "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
                "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
                "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
                "dxDiagram-unitIn": "in",
                "dxDiagram-unitCm": "cm",
                "dxDiagram-unitPx": "px",
                "dxDiagram-dialogButtonOK": "OK",
                "dxDiagram-dialogButtonCancel": "Cancel",
                "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
                "dxDiagram-dialogEditShapeImageTitle": "Change Image",
                "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
                "dxDiagram-dialogEditShapeImageLabelText": "or drop file here",
                "dxDiagram-uiExport": "Export",
                "dxDiagram-uiProperties": "Properties",
                "dxDiagram-uiSettings": "Settings",
                "dxDiagram-uiShowToolbox": "Show Toolbox",
                "dxDiagram-uiSearch": "Search",
                "dxDiagram-uiStyle": "Style",
                "dxDiagram-uiLayout": "Layout",
                "dxDiagram-uiLayoutTree": "Tree",
                "dxDiagram-uiLayoutLayered": "Layered",
                "dxDiagram-uiDiagram": "Diagram",
                "dxDiagram-uiText": "Text",
                "dxDiagram-uiObject": "Object",
                "dxDiagram-uiConnector": "Connector",
                "dxDiagram-uiPage": "Page",
                "dxDiagram-shapeText": "Text",
                "dxDiagram-shapeRectangle": "Rectangle",
                "dxDiagram-shapeEllipse": "Ellipse",
                "dxDiagram-shapeCross": "Cross",
                "dxDiagram-shapeTriangle": "Triangle",
                "dxDiagram-shapeDiamond": "Diamond",
                "dxDiagram-shapeHeart": "Heart",
                "dxDiagram-shapePentagon": "Pentagon",
                "dxDiagram-shapeHexagon": "Hexagon",
                "dxDiagram-shapeOctagon": "Octagon",
                "dxDiagram-shapeStar": "Star",
                "dxDiagram-shapeArrowLeft": "Left Arrow",
                "dxDiagram-shapeArrowUp": "Up Arrow",
                "dxDiagram-shapeArrowRight": "Right Arrow",
                "dxDiagram-shapeArrowDown": "Down Arrow",
                "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
                "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
                "dxDiagram-shapeProcess": "Process",
                "dxDiagram-shapeDecision": "Decision",
                "dxDiagram-shapeTerminator": "Terminator",
                "dxDiagram-shapePredefinedProcess": "Predefined Process",
                "dxDiagram-shapeDocument": "Document",
                "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
                "dxDiagram-shapeManualInput": "Manual Input",
                "dxDiagram-shapePreparation": "Preparation",
                "dxDiagram-shapeData": "Data",
                "dxDiagram-shapeDatabase": "Database",
                "dxDiagram-shapeHardDisk": "Hard Disk",
                "dxDiagram-shapeInternalStorage": "Internal Storage",
                "dxDiagram-shapePaperTape": "Paper Tape",
                "dxDiagram-shapeManualOperation": "Manual Operation",
                "dxDiagram-shapeDelay": "Delay",
                "dxDiagram-shapeStoredData": "Stored Data",
                "dxDiagram-shapeDisplay": "Display",
                "dxDiagram-shapeMerge": "Merge",
                "dxDiagram-shapeConnector": "Connector",
                "dxDiagram-shapeOr": "Or",
                "dxDiagram-shapeSummingJunction": "Summing Junction",
                "dxDiagram-shapeContainerDefaultText": "Container",
                "dxDiagram-shapeVerticalContainer": "Vertical Container",
                "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
                "dxDiagram-shapeCardDefaultText": "Person's Name",
                "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
                "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
                "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
                "dxGantt-dialogTitle": "Title",
                "dxGantt-dialogStartTitle": "Start",
                "dxGantt-dialogEndTitle": "End",
                "dxGantt-dialogProgressTitle": "Progress",
                "dxGantt-dialogResourcesTitle": "Resources",
                "dxGantt-dialogResourceManagerTitle": "Resource Manager",
                "dxGantt-dialogTaskDetailsTitle": "Task Details",
                "dxGantt-dialogEditResourceListHint": "Edit Resource List",
                "dxGantt-dialogEditNoResources": "No resources",
                "dxGantt-dialogButtonAdd": "Add",
                "dxGantt-contextMenuNewTask": "New Task",
                "dxGantt-contextMenuNewSubtask": "New Subtask",
                "dxGantt-contextMenuDeleteTask": "Delete Task",
                "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
                "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
                "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
                "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resource: {0}",
                "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
                "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
                "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
                "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
                "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
                "dxGantt-undo": "Undo",
                "dxGantt-redo": "Redo",
                "dxGantt-expandAll": "Expand All",
                "dxGantt-collapseAll": "Collapse All",
                "dxGantt-addNewTask": "Add New Task",
                "dxGantt-deleteSelectedTask": "Delete Selected Task",
                "dxGantt-zoomIn": "Zoom In",
                "dxGantt-zoomOut": "Zoom Out",
                "dxGantt-fullScreen": "Full Screen"
            }
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/core/options/index.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Options = void 0;
        var _type = __webpack_require__( /*! ../utils/type */ 1);
        var _common = __webpack_require__( /*! ../utils/common */ 3);
        var _option_manager = __webpack_require__( /*! ./option_manager */ 469);
        var _object = __webpack_require__( /*! ../utils/object */ 47);
        var _utils = __webpack_require__( /*! ./utils */ 187);
        var _extend = __webpack_require__( /*! ../utils/extend */ 0);

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        exports.Options = function() {
            function Options(options, defaultOptions, optionsByReference, deprecatedOptions) {
                var _this = this;
                _classCallCheck(this, Options);
                this._deprecatedCallback;
                this._startChangeCallback;
                this._endChangeCallback;
                this._default = defaultOptions;
                this._deprecated = deprecatedOptions;
                this._deprecatedNames = [];
                this._initDeprecatedNames();
                this._optionManager = new _option_manager.OptionManager(options, optionsByReference);
                this._optionManager.onRelevantNamesPrepared(function(options, name, value, silent) {
                    return _this._setRelevantNames(options, name, value, silent)
                });
                this._cachedOptions = {};
                this._rules = []
            }
            _createClass(Options, [{
                key: "_initDeprecatedNames",
                value: function() {
                    for (var optionName in this._deprecated) {
                        this._deprecatedNames.push(optionName)
                    }
                }
            }, {
                key: "_getByRules",
                value: function(rules) {
                    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
                    return (0, _utils.convertRulesToOptions)(rules)
                }
            }, {
                key: "_notifyDeprecated",
                value: function(option) {
                    var info = this._deprecated[option];
                    if (info) {
                        this._deprecatedCallback(option, info)
                    }
                }
            }, {
                key: "_setRelevantNames",
                value: function(options, name, value, silent) {
                    if (name) {
                        var normalizedName = this._normalizeName(name, silent);
                        if (normalizedName && normalizedName !== name) {
                            this._setField(options, normalizedName, value);
                            this._clearField(options, name)
                        }
                    }
                }
            }, {
                key: "_setField",
                value: function(options, fullName, value) {
                    var fieldName = "";
                    var fieldObject = null;
                    do {
                        fieldName = fieldName ? ".".concat(fieldName) : "";
                        fieldName = (0, _utils.getFieldName)(fullName) + fieldName;
                        fullName = (0, _utils.getParentName)(fullName);
                        fieldObject = fullName ? this._optionManager.get(options, fullName, false) : options
                    } while (!fieldObject);
                    fieldObject[fieldName] = value
                }
            }, {
                key: "_clearField",
                value: function(options, name) {
                    delete options[name];
                    var previousFieldName = (0, _utils.getParentName)(name);
                    var fieldObject = previousFieldName ? this._optionManager.get(options, previousFieldName, false) : options;
                    if (fieldObject) {
                        delete fieldObject[(0, _utils.getFieldName)(name)]
                    }
                }
            }, {
                key: "_normalizeName",
                value: function(name, silent) {
                    if (this._deprecatedNames.length && name) {
                        for (var i = 0; i < this._deprecatedNames.length; i++) {
                            if (this._deprecatedNames[i] === name) {
                                var deprecate = this._deprecated[name];
                                if (deprecate) {
                                    !silent && this._notifyDeprecated(name);
                                    return deprecate.alias || name
                                }
                            }
                        }
                    }
                    return name
                }
            }, {
                key: "addRules",
                value: function(rules) {
                    this._rules = rules.concat(this._rules)
                }
            }, {
                key: "applyRules",
                value: function(rules) {
                    var options = this._getByRules(rules);
                    this.silent(options)
                }
            }, {
                key: "dispose",
                value: function() {
                    this._deprecatedCallback = _common.noop;
                    this._startChangeCallback = _common.noop;
                    this._endChangeCallback = _common.noop;
                    this._optionManager.dispose()
                }
            }, {
                key: "onChanging",
                value: function(callBack) {
                    this._optionManager.onChanging(callBack)
                }
            }, {
                key: "onChanged",
                value: function(callBack) {
                    this._optionManager.onChanged(callBack)
                }
            }, {
                key: "onDeprecated",
                value: function(callBack) {
                    this._deprecatedCallback = callBack
                }
            }, {
                key: "onStartChange",
                value: function(callBack) {
                    this._startChangeCallback = callBack
                }
            }, {
                key: "onEndChange",
                value: function(callBack) {
                    this._endChangeCallback = callBack
                }
            }, {
                key: "isInitial",
                value: function(name) {
                    var value = this.silent(name);
                    var initialValue = this.initial(name);
                    var areFunctions = (0, _type.isFunction)(value) && (0, _type.isFunction)(initialValue);
                    return areFunctions ? value.toString() === initialValue.toString() : (0, _common.equalByValue)(value, initialValue)
                }
            }, {
                key: "initial",
                value: function(name) {
                    return (0, _utils.getNestedOptionValue)(this._initial, name)
                }
            }, {
                key: "option",
                value: function(options, value) {
                    var isGetter = arguments.length < 2 && "object" !== (0, _type.type)(options);
                    if (isGetter) {
                        return this._optionManager.get(void 0, this._normalizeName(options))
                    } else {
                        this._startChangeCallback();
                        try {
                            this._optionManager.set(options, value)
                        } finally {
                            this._endChangeCallback()
                        }
                    }
                }
            }, {
                key: "silent",
                value: function(options, value) {
                    var isGetter = arguments.length < 2 && "object" !== (0, _type.type)(options);
                    if (isGetter) {
                        return this._optionManager.get(void 0, options, void 0, true)
                    } else {
                        this._optionManager.set(options, value, void 0, true)
                    }
                }
            }, {
                key: "reset",
                value: function(name) {
                    var _this2 = this;
                    if (name) {
                        var fullPath = name.replace(/\[([^\]])\]/g, ".$1").split(".");
                        var value = fullPath.reduce(function(value, field) {
                            return value ? value[field] : _this2.initial(field)
                        }, null);
                        var defaultValue = (0, _type.isObject)(value) ? (0, _object.clone)(value) : value;
                        this._optionManager.set(name, defaultValue, false)
                    }
                }
            }, {
                key: "getAliasesByName",
                value: function(name) {
                    var _this3 = this;
                    return Object.keys(this._deprecated).filter(function(aliasName) {
                        return name === _this3._deprecated[aliasName].alias
                    })
                }
            }, {
                key: "isDeprecated",
                value: function(name) {
                    return Object.prototype.hasOwnProperty.call(this._deprecated, name)
                }
            }, {
                key: "cache",
                value: function(name, options) {
                    var isGetter = arguments.length < 2;
                    if (isGetter) {
                        return this._cachedOptions[name]
                    } else {
                        this._cachedOptions[name] = (0, _extend.extend)(this._cachedOptions[name], options)
                    }
                }
            }, {
                key: "_initial",
                set: function(value) {
                    this._initialOptions = value
                },
                get: function() {
                    if (!this._initialOptions) {
                        var rulesOptions = this._getByRules(this.silent("defaultOptionsRules"));
                        this._initialOptions = this._default;
                        this._optionManager._setByReference(this._initialOptions, rulesOptions)
                    }
                    return this._initialOptions
                }
            }]);
            return Options
        }()
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/core/options/option_manager.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.OptionManager = void 0;
        var _data = __webpack_require__( /*! ../utils/data */ 20);
        var _common = __webpack_require__( /*! ../utils/common */ 3);
        var _comparator = __webpack_require__( /*! ../utils/comparator */ 279);
        var _extend = __webpack_require__( /*! ../utils/extend */ 0);
        var _type = __webpack_require__( /*! ../utils/type */ 1);
        var _utils = __webpack_require__( /*! ./utils */ 187);

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var cachedGetters = {};
        var cachedSetters = {};
        exports.OptionManager = function() {
            function OptionManager(options, optionsByReference) {
                _classCallCheck(this, OptionManager);
                this._options = options;
                this._optionsByReference = optionsByReference;
                this._changingCallback;
                this._changedCallback;
                this._namePreparedCallbacks
            }
            _createClass(OptionManager, [{
                key: "_setByReference",
                value: function(options, rulesOptions) {
                    (0, _extend.extend)(true, options, rulesOptions);
                    for (var fieldName in this._optionsByReference) {
                        if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
                            options[fieldName] = rulesOptions[fieldName]
                        }
                    }
                }
            }, {
                key: "_setPreparedValue",
                value: function(name, value, merge, silent) {
                    var previousValue = this.get(this._options, name, false);
                    if (!(0, _comparator.equals)(previousValue, value)) {
                        var path = name.split(/[.[]/);
                        !silent && this._changingCallback(name, previousValue, value);
                        cachedSetters[name] = cachedSetters[name] || (0, _data.compileSetter)(name);
                        cachedSetters[name](this._options, value, {
                            functionsAsIs: true,
                            merge: (0, _type.isDefined)(merge) ? merge : !this._optionsByReference[name],
                            unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
                        });
                        !silent && this._changedCallback(name, value, previousValue)
                    }
                }
            }, {
                key: "_prepareRelevantNames",
                value: function(options, name, value, silent) {
                    if ((0, _type.isPlainObject)(value)) {
                        for (var valueName in value) {
                            this._prepareRelevantNames(options, "".concat(name, ".").concat(valueName), value[valueName])
                        }
                    }
                    this._namePreparedCallbacks(options, name, value, silent)
                }
            }, {
                key: "get",
                value: function() {
                    var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._options;
                    var name = arguments.length > 1 ? arguments[1] : void 0;
                    var unwrapObservables = arguments.length > 2 ? arguments[2] : void 0;
                    cachedGetters[name] = cachedGetters[name] || (0, _data.compileGetter)(name);
                    return cachedGetters[name](options, {
                        functionsAsIs: true,
                        unwrapObservables: unwrapObservables
                    })
                }
            }, {
                key: "set",
                value: function(options, value, merge, silent) {
                    options = (0, _utils.normalizeOptions)(options, value);
                    for (var name in options) {
                        this._prepareRelevantNames(options, name, options[name], silent)
                    }
                    for (var _name in options) {
                        this._setPreparedValue(_name, options[_name], merge, silent)
                    }
                }
            }, {
                key: "onRelevantNamesPrepared",
                value: function(callBack) {
                    this._namePreparedCallbacks = callBack
                }
            }, {
                key: "onChanging",
                value: function(callBack) {
                    this._changingCallback = callBack
                }
            }, {
                key: "onChanged",
                value: function(callBack) {
                    this._changedCallback = callBack
                }
            }, {
                key: "dispose",
                value: function() {
                    this._changingCallback = _common.noop;
                    this._changedCallback = _common.noop
                }
            }]);
            return OptionManager
        }()
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/core/postponed_operations.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.PostponedOperations = void 0;
        var _deferred = __webpack_require__( /*! ./utils/deferred */ 6);
        var _type = __webpack_require__( /*! ./utils/type */ 1);

        function _toConsumableArray(arr) {
            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
        }

        function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) {
                return
            }
            if ("string" === typeof o) {
                return _arrayLikeToArray(o, minLen)
            }
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if ("Object" === n && o.constructor) {
                n = o.constructor.name
            }
            if ("Map" === n || "Set" === n) {
                return Array.from(o)
            }
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return _arrayLikeToArray(o, minLen)
            }
        }

        function _iterableToArray(iter) {
            if ("undefined" !== typeof Symbol && Symbol.iterator in Object(iter)) {
                return Array.from(iter)
            }
        }

        function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
                return _arrayLikeToArray(arr)
            }
        }

        function _arrayLikeToArray(arr, len) {
            if (null == len || len > arr.length) {
                len = arr.length
            }
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
            }
            return arr2
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        exports.PostponedOperations = function() {
            function PostponedOperations() {
                _classCallCheck(this, PostponedOperations);
                this._postponedOperations = {}
            }
            _createClass(PostponedOperations, [{
                key: "add",
                value: function(key, fn, postponedPromise) {
                    if (key in this._postponedOperations) {
                        postponedPromise && this._postponedOperations[key].promises.push(postponedPromise)
                    } else {
                        var completePromise = new _deferred.Deferred;
                        this._postponedOperations[key] = {
                            fn: fn,
                            completePromise: completePromise,
                            promises: postponedPromise ? [postponedPromise] : []
                        }
                    }
                    return this._postponedOperations[key].completePromise.promise()
                }
            }, {
                key: "callPostponedOperations",
                value: function() {
                    for (var key in this._postponedOperations) {
                        var operation = this._postponedOperations[key];
                        if ((0, _type.isDefined)(operation)) {
                            if (operation.promises && operation.promises.length) {
                                _deferred.when.apply(void 0, _toConsumableArray(operation.promises)).done(operation.fn).then(operation.completePromise.resolve)
                            } else {
                                operation.fn().done(operation.completePromise.resolve)
                            }
                        }
                    }
                    this._postponedOperations = {}
                }
            }]);
            return PostponedOperations
        }()
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/core/template_manager.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _renderer = __webpack_require__( /*! ./renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _type = __webpack_require__( /*! ./utils/type */ 1);
        var _common = __webpack_require__( /*! ./utils/common */ 3);
        var _extend = __webpack_require__( /*! ./utils/extend */ 0);
        var _errors = __webpack_require__( /*! ./errors */ 22);
        var _dom = __webpack_require__( /*! ./utils/dom */ 11);
        var _function_template = __webpack_require__( /*! ./templates/function_template */ 113);
        var _empty_template = __webpack_require__( /*! ./templates/empty_template */ 87);
        var _inflector = __webpack_require__( /*! ./utils/inflector */ 34);
        var _template_manager = __webpack_require__( /*! ./utils/template_manager */ 472);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var TEXT_NODE = 3;
        var ANONYMOUS_TEMPLATE_NAME = "template";
        var TEMPLATE_SELECTOR = '[data-options*="dxTemplate"]';
        var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
        var DEPRECATED_WIDGET_NAMES = {
            button: true,
            tabs: true,
            dropDownMenu: true
        };
        var DX_POLYMORPH_WIDGET_TEMPLATE = new _function_template.FunctionTemplate(function(_ref) {
            var model = _ref.model,
                parent = _ref.parent;
            var widgetName = model.widget;
            if (!widgetName) {
                return (0, _renderer2.default)()
            }
            var widgetElement = (0, _renderer2.default)("<div>");
            var widgetOptions = model.options || {};
            if (DEPRECATED_WIDGET_NAMES[widgetName]) {
                var deprecatedName = widgetName;
                widgetName = (0, _inflector.camelize)("dx-" + widgetName);
                (0, _errors.log)("W0001", 'dxToolbar - "widget" item field', deprecatedName, "16.1", "Use: " + widgetName + "instead")
            }
            if (parent) {
                parent._createComponent(widgetElement, widgetName, widgetOptions)
            } else {
                widgetElement[widgetName](widgetOptions)
            }
            return widgetElement
        });
        var TemplateManager = function() {
            function TemplateManager(createElement, anonymousTemplateName) {
                _classCallCheck(this, TemplateManager);
                this._tempTemplates = [];
                this._defaultTemplates = {};
                this._anonymousTemplateName = anonymousTemplateName || ANONYMOUS_TEMPLATE_NAME;
                this._createElement = createElement || _template_manager.defaultCreateElement;
                this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this)
            }
            _createClass(TemplateManager, [{
                key: "addDefaultTemplates",
                value: function(templates) {
                    this._defaultTemplates = (0, _extend.extend)({}, this._defaultTemplates, templates)
                }
            }, {
                key: "dispose",
                value: function() {
                    this._tempTemplates.forEach(function(tempTemplate) {
                        tempTemplate.template.dispose && tempTemplate.template.dispose()
                    });
                    this._tempTemplates = []
                }
            }, {
                key: "extractTemplates",
                value: function($el) {
                    var templates = this._extractTemplates($el);
                    var anonymousTemplateMeta = this._extractAnonymousTemplate($el);
                    return {
                        templates: templates,
                        anonymousTemplateMeta: anonymousTemplateMeta
                    }
                }
            }, {
                key: "_extractTemplates",
                value: function($el) {
                    var templateElements = $el.contents().filter(TEMPLATE_SELECTOR);
                    var templatesMap = {};
                    templateElements.each(function(_, template) {
                        var templateOptions = (0, _dom.getElementOptions)(template).dxTemplate;
                        if (!templateOptions) {
                            return
                        }
                        if (!templateOptions.name) {
                            throw (0, _errors.Error)("E0023")
                        }(0, _renderer2.default)(template).addClass(TEMPLATE_WRAPPER_CLASS).detach();
                        templatesMap[templateOptions.name] = templatesMap[templateOptions.name] || [];
                        templatesMap[templateOptions.name].push(template)
                    });
                    var templates = [];
                    for (var templateName in templatesMap) {
                        var deviceTemplate = (0, _template_manager.findTemplateByDevice)(templatesMap[templateName]);
                        if (deviceTemplate) {
                            templates.push({
                                name: templateName,
                                template: this._createTemplate(deviceTemplate)
                            })
                        }
                    }
                    return templates
                }
            }, {
                key: "_extractAnonymousTemplate",
                value: function($el) {
                    var $anonymousTemplate = $el.contents().detach();
                    var $notJunkTemplateContent = $anonymousTemplate.filter(function(_, element) {
                        var isTextNode = element.nodeType === TEXT_NODE;
                        var isEmptyText = (0, _renderer2.default)(element).text().trim().length < 1;
                        return !(isTextNode && isEmptyText)
                    });
                    return $notJunkTemplateContent.length > 0 ? {
                        template: this._createTemplate($anonymousTemplate),
                        name: this._anonymousTemplateName
                    } : {}
                }
            }, {
                key: "_createTemplateIfNeeded",
                value: function(templateSource) {
                    var cachedTemplate = this._tempTemplates.filter(function(tempTemplate) {
                        return tempTemplate.source === (0, _template_manager.templateKey)(templateSource)
                    })[0];
                    if (cachedTemplate) {
                        return cachedTemplate.template
                    }
                    var template = this._createTemplate(templateSource);
                    this._tempTemplates.push({
                        template: template,
                        source: (0, _template_manager.templateKey)(templateSource)
                    });
                    return template
                }
            }, {
                key: "_createTemplate",
                value: function(templateSource) {
                    return this._createElement((0, _template_manager.validateTemplateSource)(templateSource))
                }
            }, {
                key: "getTemplate",
                value: function(templateSource, templates, _ref2, context) {
                    var _this = this;
                    var isAsyncTemplate = _ref2.isAsyncTemplate,
                        skipTemplates = _ref2.skipTemplates;
                    if (!(0, _type.isFunction)(templateSource)) {
                        return (0, _template_manager.acquireTemplate)(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates)
                    }
                    return new _function_template.FunctionTemplate(function(options) {
                        var templateSourceResult = templateSource.apply(context, (0, _template_manager.getNormalizedTemplateArgs)(options));
                        if (!(0, _type.isDefined)(templateSourceResult)) {
                            return new _empty_template.EmptyTemplate
                        }
                        var dispose = false;
                        var template = (0, _template_manager.acquireTemplate)(templateSourceResult, function(templateSource) {
                            if (templateSource.nodeType || (0, _type.isRenderer)(templateSource) && !(0, _renderer2.default)(templateSource).is("script")) {
                                return new _function_template.FunctionTemplate(function() {
                                    return templateSource
                                })
                            }
                            dispose = true;
                            return _this._createTemplate(templateSource)
                        }, templates, isAsyncTemplate, skipTemplates, _this._defaultTemplates);
                        var result = template.render(options);
                        dispose && template.dispose && template.dispose();
                        return result
                    })
                }
            }, {
                key: "anonymousTemplateName",
                get: function() {
                    return this._anonymousTemplateName
                }
            }], [{
                key: "createDefaultOptions",
                value: function() {
                    return {
                        integrationOptions: {
                            watchMethod: function(fn, callback) {
                                var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                                if (!options.skipImmediate) {
                                    callback(fn())
                                }
                                return _common.noop
                            },
                            templates: {
                                "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
                            }
                        }
                    }
                }
            }]);
            return TemplateManager
        }();
        exports.default = TemplateManager
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/core/utils/template_manager.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.acquireTemplate = exports.acquireIntegrationTemplate = exports.defaultCreateElement = exports.templateKey = exports.validateTemplateSource = exports.getNormalizedTemplateArgs = exports.addOneRenderedCall = exports.findTemplateByDevice = void 0;
        var _renderer = __webpack_require__( /*! ../renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _type = __webpack_require__( /*! ./type */ 1);
        var _common = __webpack_require__( /*! ./common */ 3);
        var _extend = __webpack_require__( /*! ./extend */ 0);
        var _child_default_template = __webpack_require__( /*! ../templates/child_default_template */ 141);
        var _template_base = __webpack_require__( /*! ../templates/template_base */ 78);
        var _empty_template = __webpack_require__( /*! ../templates/empty_template */ 87);
        var _dom = __webpack_require__( /*! ./dom */ 11);
        var _devices = __webpack_require__( /*! ../devices */ 15);
        var _devices2 = _interopRequireDefault(_devices);
        var _template = __webpack_require__( /*! ../templates/template */ 473);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        exports.findTemplateByDevice = function(templates) {
            var suitableTemplate = (0, _common.findBestMatches)(_devices2.default.current(), templates, function(template) {
                return (0, _dom.getElementOptions)(template).dxTemplate
            })[0];
            templates.forEach(function(template) {
                if (template !== suitableTemplate) {
                    (0, _renderer2.default)(template).remove()
                }
            });
            return suitableTemplate
        };
        var addOneRenderedCall = exports.addOneRenderedCall = function(template) {
            var _render = template.render.bind(template);
            return (0, _extend.extend)({}, template, {
                render: function(options) {
                    var templateResult = _render(options);
                    options && options.onRendered && options.onRendered();
                    return templateResult
                }
            })
        };
        exports.getNormalizedTemplateArgs = function(options) {
            var args = [];
            if ("model" in options) {
                args.push(options.model)
            }
            if ("index" in options) {
                args.push(options.index)
            }
            args.push(options.container);
            return args
        };
        exports.validateTemplateSource = function(templateSource) {
            return "string" === typeof templateSource ? (0, _dom.normalizeTemplateElement)(templateSource) : templateSource
        };
        exports.templateKey = function(templateSource) {
            return (0, _type.isRenderer)(templateSource) && templateSource[0] || templateSource
        };
        exports.defaultCreateElement = function(element) {
            return new _template.Template(element)
        };
        var acquireIntegrationTemplate = exports.acquireIntegrationTemplate = function(templateSource, templates, isAsyncTemplate, skipTemplates) {
            var integrationTemplate = null;
            if (!skipTemplates || skipTemplates.indexOf(templateSource) === -1) {
                integrationTemplate = templates[templateSource];
                if (integrationTemplate && !(integrationTemplate instanceof _template_base.TemplateBase) && !isAsyncTemplate) {
                    integrationTemplate = addOneRenderedCall(integrationTemplate)
                }
            }
            return integrationTemplate
        };
        exports.acquireTemplate = function(templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) {
            if (null == templateSource) {
                return new _empty_template.EmptyTemplate
            }
            if (templateSource instanceof _child_default_template.ChildDefaultTemplate) {
                return defaultTemplates[templateSource.name]
            }
            if (templateSource instanceof _template_base.TemplateBase) {
                return templateSource
            }
            if ((0, _type.isFunction)(templateSource.render) && !(0, _type.isRenderer)(templateSource)) {
                return addOneRenderedCall(templateSource)
            }
            if (templateSource.nodeType || (0, _type.isRenderer)(templateSource)) {
                return createTemplate((0, _renderer2.default)(templateSource))
            }
            return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource)
        }
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/core/templates/template.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Template = void 0;
        var _renderer = __webpack_require__( /*! ../renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _template_base = __webpack_require__( /*! ./template_base */ 78);
        var _dom = __webpack_require__( /*! ../utils/dom */ 11);
        var _template_engine_registry = __webpack_require__( /*! ./template_engine_registry */ 165);
        __webpack_require__( /*! ./template_engines */ 474);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }

        function _inherits(subClass, superClass) {
            if ("function" !== typeof superClass && null !== superClass) {
                throw new TypeError("Super expression must either be null or a function")
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) {
                _setPrototypeOf(subClass, superClass)
            }
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o
            };
            return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                    result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (call && ("object" === _typeof(call) || "function" === typeof call)) {
                return call
            }
            return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
            if (void 0 === self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return self
        }

        function _isNativeReflectConstruct() {
            if ("undefined" === typeof Reflect || !Reflect.construct) {
                return false
            }
            if (Reflect.construct.sham) {
                return false
            }
            if ("function" === typeof Proxy) {
                return true
            }
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                return true
            } catch (e) {
                return false
            }
        }

        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
            };
            return _getPrototypeOf(o)
        }(0, _template_engine_registry.registerTemplateEngine)("default", {
            compile: function(element) {
                return (0, _dom.normalizeTemplateElement)(element)
            },
            render: function(template, model, index) {
                return template.clone()
            }
        });
        (0, _template_engine_registry.setTemplateEngine)("default");
        exports.Template = function(_TemplateBase) {
            _inherits(Template, _TemplateBase);
            var _super = _createSuper(Template);

            function Template(element) {
                var _this;
                _classCallCheck(this, Template);
                _this = _super.call(this);
                _this._element = element;
                return _this
            }
            _createClass(Template, [{
                key: "_renderCore",
                value: function(options) {
                    var transclude = options.transclude;
                    if (!transclude && !this._compiledTemplate) {
                        this._compiledTemplate = (0, _template_engine_registry.getCurrentTemplateEngine)().compile(this._element)
                    }
                    return (0, _renderer2.default)("<div>").append(transclude ? this._element : (0, _template_engine_registry.getCurrentTemplateEngine)().render(this._compiledTemplate, options.model, options.index)).contents()
                }
            }, {
                key: "source",
                value: function() {
                    return (0, _renderer2.default)(this._element).clone()
                }
            }]);
            return Template
        }(_template_base.TemplateBase)
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/core/templates/template_engines.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _dom = __webpack_require__( /*! ../utils/dom */ 11);
        var _template_engine_registry = __webpack_require__( /*! ./template_engine_registry */ 165);
        (0, _template_engine_registry.registerTemplateEngine)("jquery-tmpl", {
            compile: function(element) {
                return (0, _dom.extractTemplateMarkup)(element)
            },
            render: function(template, data) {
                return jQuery.tmpl(template, data)
            }
        });
        (0, _template_engine_registry.registerTemplateEngine)("jsrender", {
            compile: function(element) {
                return (jQuery ? jQuery : jsrender).templates((0, _dom.extractTemplateMarkup)(element))
            },
            render: function(template, data) {
                return template.render(data)
            }
        });
        (0, _template_engine_registry.registerTemplateEngine)("mustache", {
            compile: function(element) {
                return (0, _dom.extractTemplateMarkup)(element)
            },
            render: function(template, data) {
                return Mustache.render(template, data)
            }
        });
        (0, _template_engine_registry.registerTemplateEngine)("hogan", {
            compile: function(element) {
                return Hogan.compile((0, _dom.extractTemplateMarkup)(element))
            },
            render: function(template, data) {
                return template.render(data)
            }
        });
        (0, _template_engine_registry.registerTemplateEngine)("underscore", {
            compile: function(element) {
                return _.template((0, _dom.extractTemplateMarkup)(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        (0, _template_engine_registry.registerTemplateEngine)("handlebars", {
            compile: function(element) {
                return Handlebars.compile((0, _dom.extractTemplateMarkup)(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        (0, _template_engine_registry.registerTemplateEngine)("doT", {
            compile: function(element) {
                return doT.template((0, _dom.extractTemplateMarkup)(element))
            },
            render: function(template, data) {
                return template(data)
            }
        })
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/events/core/keyboard_processor.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _class = __webpack_require__( /*! ../../core/class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _utils = __webpack_require__( /*! ../../events/utils */ 8);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var COMPOSITION_START_EVENT = "compositionstart";
        var COMPOSITION_END_EVENT = "compositionend";
        var KEYDOWN_EVENT = "keydown";
        var NAMESPACE = "KeyboardProcessor";
        var KeyboardProcessor = _class2.default.inherit({
            _keydown: (0, _utils.addNamespace)(KEYDOWN_EVENT, NAMESPACE),
            _compositionStart: (0, _utils.addNamespace)(COMPOSITION_START_EVENT, NAMESPACE),
            _compositionEnd: (0, _utils.addNamespace)(COMPOSITION_END_EVENT, NAMESPACE),
            ctor: function(options) {
                var _this = this;
                options = options || {};
                if (options.element) {
                    this._element = (0, _renderer2.default)(options.element)
                }
                if (options.focusTarget) {
                    this._focusTarget = options.focusTarget
                }
                this._handler = options.handler;
                if (this._element) {
                    this._processFunction = function(e) {
                        var isNotFocusTarget = _this._focusTarget && _this._focusTarget !== e.target && (0, _array.inArray)(e.target, _this._focusTarget) < 0;
                        var shouldSkipProcessing = _this._isComposingJustFinished && 229 === e.which || _this._isComposing || isNotFocusTarget;
                        _this._isComposingJustFinished = false;
                        if (!shouldSkipProcessing) {
                            _this.process(e)
                        }
                    };
                    this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
                    _events_engine2.default.on(this._element, this._keydown, this._processFunction);
                    _events_engine2.default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
                    _events_engine2.default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext)
                }
            },
            dispose: function() {
                if (this._element) {
                    _events_engine2.default.off(this._element, this._keydown, this._processFunction);
                    _events_engine2.default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
                    _events_engine2.default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext)
                }
                this._element = void 0;
                this._handler = void 0
            },
            process: function(e) {
                this._handler({
                    keyName: (0, _utils.normalizeKeyName)(e),
                    key: e.key,
                    code: e.code,
                    ctrl: e.ctrlKey,
                    location: e.location,
                    metaKey: e.metaKey,
                    shift: e.shiftKey,
                    alt: e.altKey,
                    which: e.which,
                    originalEvent: e
                })
            },
            toggleProcessing: function(_ref) {
                var type = _ref.type;
                this._isComposing = type === COMPOSITION_START_EVENT;
                this._isComposingJustFinished = !this._isComposing
            }
        });
        module.exports = KeyboardProcessor
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/events/utils/add_namespace.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _errors = __webpack_require__( /*! ../../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var addNamespace = function addNamespace(eventNames, namespace) {
            if (!namespace) {
                throw _errors2.default.Error("E0017")
            }
            if (Array.isArray(eventNames)) {
                return eventNames.map(function(eventName) {
                    return addNamespace(eventName, namespace)
                }).join(" ")
            }
            if (eventNames.indexOf(" ") !== -1) {
                return addNamespace(eventNames.split(/\s+/g), namespace)
            }
            return "".concat(eventNames, ".").concat(namespace)
        };
        exports.default = addNamespace
    },
    /*!**********************************************************************************!*\
      !*** ./artifacts/transpiled/mobile/init_mobile_viewport/init_mobile_viewport.js ***!
      \**********************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var windowUtils = __webpack_require__( /*! ../../core/utils/window */ 7);
        var window = windowUtils.getWindow();
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var resizeCallbacks = __webpack_require__( /*! ../../core/utils/resize_callbacks */ 114);
        var support = __webpack_require__( /*! ../../core/utils/support */ 46);
        var styleUtils = __webpack_require__( /*! ../../core/utils/style */ 93);
        var devices = __webpack_require__( /*! ../../core/devices */ 15);
        var initMobileViewport = function(options) {
            options = extend({}, options);
            var realDevice = devices.real();
            var allowZoom = options.allowZoom;
            var allowPan = options.allowPan;
            var allowSelection = "allowSelection" in options ? options.allowSelection : "generic" === realDevice.platform;
            var metaSelector = "meta[name=viewport]";
            if (!$(metaSelector).length) {
                $("<meta>").attr("name", "viewport").appendTo("head")
            }
            var metaVerbs = ["width=device-width"];
            var msTouchVerbs = [];
            if (allowZoom) {
                msTouchVerbs.push("pinch-zoom")
            } else {
                metaVerbs.push("initial-scale=1.0", "maximum-scale=1.0, user-scalable=no")
            }
            if (allowPan) {
                msTouchVerbs.push("pan-x", "pan-y")
            }
            if (!allowPan && !allowZoom) {
                $("html, body").css({
                    msContentZooming: "none",
                    msUserSelect: "none",
                    overflow: "hidden"
                })
            } else {
                $("html").css("msOverflowStyle", "-ms-autohiding-scrollbar")
            }
            if (!allowSelection && support.supportProp("userSelect")) {
                $(".dx-viewport").css(styleUtils.styleProp("userSelect"), "none")
            }
            $(metaSelector).attr("content", metaVerbs.join());
            $("html").css("msTouchAction", msTouchVerbs.join(" ") || "none");
            realDevice = devices.real();
            if (support.touch) {
                eventsEngine.off(domAdapter.getDocument(), ".dxInitMobileViewport");
                eventsEngine.on(domAdapter.getDocument(), "dxpointermove.dxInitMobileViewport", function(e) {
                    var count = e.pointers.length;
                    var isTouchEvent = "touch" === e.pointerType;
                    var zoomDisabled = !allowZoom && count > 1;
                    var panDisabled = !allowPan && 1 === count && !e.isScrollingEvent;
                    if (isTouchEvent && (zoomDisabled || panDisabled)) {
                        e.preventDefault()
                    }
                })
            }
            if (realDevice.ios) {
                var isPhoneGap = "file:" === domAdapter.getLocation().protocol;
                if (!isPhoneGap) {
                    resizeCallbacks.add(function() {
                        var windowWidth = $(window).width();
                        $("body").width(windowWidth)
                    })
                }
            }
            if (realDevice.android) {
                resizeCallbacks.add(function() {
                    setTimeout(function() {
                        var activeElement = domAdapter.getActiveElement();
                        activeElement.scrollIntoViewIfNeeded ? activeElement.scrollIntoViewIfNeeded() : activeElement.scrollIntoView(false)
                    })
                })
            }
        };
        exports.initMobileViewport = initMobileViewport
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/events/index.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventsEngine = __webpack_require__( /*! ./core/events_engine */ 5);
        exports.on = eventsEngine.on;
        exports.one = eventsEngine.one;
        exports.off = eventsEngine.off;
        exports.trigger = eventsEngine.trigger;
        exports.triggerHandler = eventsEngine.triggerHandler;
        exports.Event = eventsEngine.Event
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/events/pointer/mspointer.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var BaseStrategy = __webpack_require__( /*! ./base */ 160);
        var Observer = __webpack_require__( /*! ./observer */ 283);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var eventMap = {
            dxpointerdown: "pointerdown",
            dxpointermove: "pointermove",
            dxpointerup: "pointerup",
            dxpointercancel: "pointercancel",
            dxpointerover: "pointerover",
            dxpointerout: "pointerout",
            dxpointerenter: "pointerenter",
            dxpointerleave: "pointerleave"
        };
        var observer;
        var activated = false;
        var activateStrategy = function() {
            if (activated) {
                return
            }
            observer = new Observer(eventMap, function(a, b) {
                return a.pointerId === b.pointerId
            }, function(e) {
                if (e.isPrimary) {
                    observer.reset()
                }
            });
            activated = true
        };
        var MsPointerStrategy = BaseStrategy.inherit({
            ctor: function() {
                this.callBase.apply(this, arguments);
                activateStrategy()
            },
            _fireEvent: function(args) {
                return this.callBase(extend({
                    pointers: observer.pointers(),
                    pointerId: args.originalEvent.pointerId
                }, args))
            }
        });
        MsPointerStrategy.map = eventMap;
        MsPointerStrategy.resetObserver = function() {
            observer.reset()
        };
        module.exports = MsPointerStrategy
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/events/pointer/mouse_and_touch.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var BaseStrategy = __webpack_require__( /*! ./base */ 160);
        var MouseStrategy = __webpack_require__( /*! ./mouse */ 284);
        var TouchStrategy = __webpack_require__( /*! ./touch */ 282);
        var eventUtils = __webpack_require__( /*! ../utils */ 8);
        var eventMap = {
            dxpointerdown: "touchstart mousedown",
            dxpointermove: "touchmove mousemove",
            dxpointerup: "touchend mouseup",
            dxpointercancel: "touchcancel",
            dxpointerover: "mouseover",
            dxpointerout: "mouseout",
            dxpointerenter: "mouseenter",
            dxpointerleave: "mouseleave"
        };
        var activated = false;
        var activateStrategy = function() {
            if (activated) {
                return
            }
            MouseStrategy.activate();
            activated = true
        };
        var MouseAndTouchStrategy = BaseStrategy.inherit({
            EVENT_LOCK_TIMEOUT: 100,
            ctor: function() {
                this.callBase.apply(this, arguments);
                activateStrategy()
            },
            _handler: function(e) {
                var isMouseEvent = eventUtils.isMouseEvent(e);
                if (!isMouseEvent) {
                    this._skipNextEvents = true
                }
                if (isMouseEvent && this._mouseLocked) {
                    return
                }
                if (isMouseEvent && this._skipNextEvents) {
                    this._skipNextEvents = false;
                    this._mouseLocked = true;
                    clearTimeout(this._unlockMouseTimer);
                    var that = this;
                    this._unlockMouseTimer = setTimeout(function() {
                        that._mouseLocked = false
                    }, this.EVENT_LOCK_TIMEOUT);
                    return
                }
                return this.callBase(e)
            },
            _fireEvent: function(args) {
                var isMouseEvent = eventUtils.isMouseEvent(args.originalEvent);
                var normalizer = isMouseEvent ? MouseStrategy.normalize : TouchStrategy.normalize;
                return this.callBase(extend(normalizer(args.originalEvent), args))
            },
            dispose: function() {
                this.callBase();
                this._skipNextEvents = false;
                this._mouseLocked = false;
                clearTimeout(this._unlockMouseTimer)
            }
        });
        MouseAndTouchStrategy.map = eventMap;
        MouseAndTouchStrategy.resetObserver = MouseStrategy.resetObserver;
        module.exports = MouseAndTouchStrategy
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/localization.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var core = __webpack_require__( /*! ./localization/core */ 83);
        var message = __webpack_require__( /*! ./localization/message */ 10);
        var number = __webpack_require__( /*! ./localization/number */ 49);
        var date = __webpack_require__( /*! ./localization/date */ 35);
        __webpack_require__( /*! ./localization/currency */ 131);
        exports.locale = core.locale.bind(core);
        exports.loadMessages = message.load.bind(message);
        exports.formatMessage = message.format.bind(message);
        exports.formatNumber = number.format.bind(number);
        exports.parseNumber = number.parse.bind(number);
        exports.formatDate = date.format.bind(date);
        exports.parseDate = date.parse.bind(date);
        exports.message = message;
        exports.number = number;
        exports.date = date;
        exports.disableIntl = function() {
            if ("intl" === number.engine()) {
                number.resetInjection()
            }
            if ("intl" === date.engine()) {
                date.resetInjection()
            }
        }
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/renderer.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var jQuery = __webpack_require__( /*! jquery */ 57);
        var rendererBase = __webpack_require__( /*! ../../core/renderer_base */ 268);
        var useJQuery = __webpack_require__( /*! ./use_jquery */ 85)();
        if (useJQuery) {
            rendererBase.set(jQuery)
        }
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/hooks.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var jQuery = __webpack_require__( /*! jquery */ 57);
        var useJQuery = __webpack_require__( /*! ./use_jquery */ 85)();
        var compareVersion = __webpack_require__( /*! ../../core/utils/version */ 60).compare;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var isNumeric = __webpack_require__( /*! ../../core/utils/type */ 1).isNumeric;
        var setEventFixMethod = __webpack_require__( /*! ../../events/utils */ 8).setEventFixMethod;
        var registerEvent = __webpack_require__( /*! ../../events/core/event_registrator */ 77);
        var hookTouchProps = __webpack_require__( /*! ../../events/core/hook_touch_props */ 269);
        if (useJQuery) {
            if (compareVersion(jQuery.fn.jquery, [3]) < 0) {
                var POINTER_TYPE_MAP = {
                    2: "touch",
                    3: "pen",
                    4: "mouse"
                };
                each(["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel", "MSPointerOver", "MSPointerOut", "mouseenter", "mouseleave", "pointerdown", "pointermove", "pointerup", "pointercancel", "pointerover", "pointerout", "pointerenter", "pointerleave"], function() {
                    jQuery.event.fixHooks[this] = {
                        filter: function(event, originalEvent) {
                            var pointerType = originalEvent.pointerType;
                            if (isNumeric(pointerType)) {
                                event.pointerType = POINTER_TYPE_MAP[pointerType]
                            }
                            return event
                        },
                        props: jQuery.event.mouseHooks.props.concat(["pointerId", "pointerType", "originalTarget", "width", "height", "pressure", "result", "tiltX", "charCode", "tiltY", "detail", "isPrimary", "prevValue"])
                    }
                });
                each(["touchstart", "touchmove", "touchend", "touchcancel"], function() {
                    jQuery.event.fixHooks[this] = {
                        filter: function(event, originalEvent) {
                            hookTouchProps(function(name, hook) {
                                event[name] = hook(originalEvent)
                            });
                            return event
                        },
                        props: jQuery.event.mouseHooks.props.concat(["touches", "changedTouches", "targetTouches", "detail", "result", "originalTarget", "charCode", "prevValue"])
                    }
                });
                jQuery.event.fixHooks.wheel = jQuery.event.mouseHooks;
                var DX_EVENT_HOOKS = {
                    props: jQuery.event.mouseHooks.props.concat(["pointerType", "pointerId", "pointers"])
                };
                registerEvent.callbacks.add(function(name) {
                    jQuery.event.fixHooks[name] = DX_EVENT_HOOKS
                });
                var fix = function(event, originalEvent) {
                    var fixHook = jQuery.event.fixHooks[originalEvent.type] || jQuery.event.mouseHooks;
                    var props = fixHook.props ? jQuery.event.props.concat(fixHook.props) : jQuery.event.props;
                    var propIndex = props.length;
                    while (propIndex--) {
                        var prop = props[propIndex];
                        event[prop] = originalEvent[prop]
                    }
                    return fixHook.filter ? fixHook.filter(event, originalEvent) : event
                };
                setEventFixMethod(fix)
            } else {
                hookTouchProps(function(name, hook) {
                    jQuery.event.addProp(name, hook)
                })
            }
        }
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/deferred.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var jQuery = __webpack_require__( /*! jquery */ 57);
        var deferredUtils = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var useJQuery = __webpack_require__( /*! ./use_jquery */ 85)();
        var compareVersion = __webpack_require__( /*! ../../core/utils/version */ 60).compare;
        if (useJQuery) {
            var Deferred = jQuery.Deferred;
            var strategy = {
                Deferred: Deferred
            };
            strategy.when = compareVersion(jQuery.fn.jquery, [3]) < 0 ? jQuery.when : function(singleArg) {
                if (0 === arguments.length) {
                    return (new Deferred).resolve()
                } else {
                    if (1 === arguments.length) {
                        return singleArg && singleArg.then ? singleArg : (new Deferred).resolve(singleArg)
                    } else {
                        return jQuery.when.apply(jQuery, arguments)
                    }
                }
            };
            deferredUtils.setStrategy(strategy)
        }
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/hold_ready.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var jQuery = __webpack_require__( /*! jquery */ 57);
        var themes_callback = __webpack_require__( /*! ../../ui/themes_callback */ 286);
        var ready = __webpack_require__( /*! ../../core/utils/ready_callbacks */ 51).add;
        if (jQuery && !themes_callback.fired()) {
            var holdReady = jQuery.holdReady || jQuery.fn.holdReady;
            holdReady(true);
            themes_callback.add(function() {
                ready(function() {
                    holdReady(false)
                })
            })
        }
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/events.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _jquery = __webpack_require__( /*! jquery */ 57);
        var _jquery2 = _interopRequireDefault(_jquery);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _use_jquery = __webpack_require__( /*! ./use_jquery */ 85);
        var _use_jquery2 = _interopRequireDefault(_use_jquery);
        var _event_registrator_callbacks = __webpack_require__( /*! ../../events/core/event_registrator_callbacks */ 130);
        var _event_registrator_callbacks2 = _interopRequireDefault(_event_registrator_callbacks);
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var useJQuery = (0, _use_jquery2.default)();
        if (useJQuery) {
            _event_registrator_callbacks2.default.add(function(name, eventObject) {
                _jquery2.default.event.special[name] = eventObject
            });
            if (_events_engine2.default.passiveEventHandlersSupported()) {
                _events_engine2.default.forcePassiveFalseEventNames.forEach(function(eventName) {
                    _jquery2.default.event.special[eventName] = {
                        setup: function(data, namespaces, handler) {
                            _dom_adapter2.default.listen(this, eventName, handler, {
                                passive: false
                            })
                        }
                    }
                })
            }
            _events_engine2.default.set({
                on: function(element) {
                    (0, _jquery2.default)(element).on.apply((0, _jquery2.default)(element), Array.prototype.slice.call(arguments, 1))
                },
                one: function(element) {
                    (0, _jquery2.default)(element).one.apply((0, _jquery2.default)(element), Array.prototype.slice.call(arguments, 1))
                },
                off: function(element) {
                    (0, _jquery2.default)(element).off.apply((0, _jquery2.default)(element), Array.prototype.slice.call(arguments, 1))
                },
                trigger: function(element) {
                    (0, _jquery2.default)(element).trigger.apply((0, _jquery2.default)(element), Array.prototype.slice.call(arguments, 1))
                },
                triggerHandler: function(element) {
                    (0, _jquery2.default)(element).triggerHandler.apply((0, _jquery2.default)(element), Array.prototype.slice.call(arguments, 1))
                },
                Event: _jquery2.default.Event
            })
        }
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/easing.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var jQuery = __webpack_require__( /*! jquery */ 57);
        var easing = __webpack_require__( /*! ../../animation/easing */ 281);
        if (jQuery) {
            easing.setEasing(jQuery.easing)
        }
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/element_data.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var jQuery = __webpack_require__( /*! jquery */ 57);
        var dataUtils = __webpack_require__( /*! ../../core/element_data */ 41);
        var useJQuery = __webpack_require__( /*! ./use_jquery */ 85)();
        if (useJQuery) {
            dataUtils.setDataStrategy(jQuery)
        }
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/element.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var setPublicElementWrapper = __webpack_require__( /*! ../../core/utils/dom */ 11).setPublicElementWrapper;
        var useJQuery = __webpack_require__( /*! ./use_jquery */ 85)();
        var getPublicElement = function($element) {
            return $element
        };
        if (useJQuery) {
            setPublicElementWrapper(getPublicElement)
        }
    },
    /*!**************************************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/component_registrator.js ***!
      \**************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _jquery = __webpack_require__( /*! jquery */ 57);
        var _jquery2 = _interopRequireDefault(_jquery);
        var _component_registrator_callbacks = __webpack_require__( /*! ../../core/component_registrator_callbacks */ 159);
        var _component_registrator_callbacks2 = _interopRequireDefault(_component_registrator_callbacks);
        var _errors = __webpack_require__( /*! ../../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        if (_jquery2.default) {
            var registerJQueryComponent = function(name, componentClass) {
                _jquery2.default.fn[name] = function(options) {
                    var isMemberInvoke = "string" === typeof options;
                    var result;
                    if (isMemberInvoke) {
                        var memberName = options;
                        var memberArgs = [].slice.call(arguments).slice(1);
                        this.each(function() {
                            var instance = componentClass.getInstance(this);
                            if (!instance) {
                                throw _errors2.default.Error("E0009", name)
                            }
                            var member = instance[memberName];
                            var memberValue = member.apply(instance, memberArgs);
                            if (void 0 === result) {
                                result = memberValue
                            }
                        })
                    } else {
                        this.each(function() {
                            var instance = componentClass.getInstance(this);
                            if (instance) {
                                instance.option(options)
                            } else {
                                new componentClass(this, options)
                            }
                        });
                        result = this
                    }
                    return result
                }
            };
            _component_registrator_callbacks2.default.add(registerJQueryComponent)
        }
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/integration/jquery/ajax.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var jQuery = __webpack_require__( /*! jquery */ 57);
        var ajax = __webpack_require__( /*! ../../core/utils/ajax */ 75);
        var useJQuery = __webpack_require__( /*! ./use_jquery */ 85)();
        if (useJQuery) {
            ajax.inject({
                sendRequest: function(options) {
                    if (!options.responseType && !options.upload) {
                        return jQuery.ajax(options)
                    }
                    return this.callBase.apply(this, [options])
                }
            })
        }
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/integration/angular.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var angular = __webpack_require__( /*! angular */ 287);
        if (angular) {
            __webpack_require__( /*! ./jquery */ 285);
            __webpack_require__( /*! ./angular/component_registrator */ 493);
            __webpack_require__( /*! ./angular/event_registrator */ 501);
            __webpack_require__( /*! ./angular/components */ 502);
            __webpack_require__( /*! ./angular/action_executors */ 503)
        }
    },
    /*!***************************************************************************!*\
      !*** ./artifacts/transpiled/integration/angular/component_registrator.js ***!
      \***************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _config = __webpack_require__( /*! ../../core/config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _component_registrator_callbacks = __webpack_require__( /*! ../../core/component_registrator_callbacks */ 159);
        var _component_registrator_callbacks2 = _interopRequireDefault(_component_registrator_callbacks);
        var _class = __webpack_require__( /*! ../../core/class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _callbacks = __webpack_require__( /*! ../../core/utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _type2 = _interopRequireDefault(_type);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _iterator2 = _interopRequireDefault(_iterator);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _array2 = _interopRequireDefault(_array);
        var _locker = __webpack_require__( /*! ../../core/utils/locker */ 288);
        var _locker2 = _interopRequireDefault(_locker);
        var _editor = __webpack_require__( /*! ../../ui/editor/editor */ 48);
        var _editor2 = _interopRequireDefault(_editor);
        var _template = __webpack_require__( /*! ./template */ 494);
        var _module = __webpack_require__( /*! ./module */ 189);
        var _module2 = _interopRequireDefault(_module);
        var _uiCollection_widget = __webpack_require__( /*! ../../ui/collection/ui.collection_widget.edit */ 52);
        var _uiCollection_widget2 = _interopRequireDefault(_uiCollection_widget);
        var _data = __webpack_require__( /*! ../../core/utils/data */ 20);
        var _data2 = _interopRequireDefault(_data);
        var _comparator = __webpack_require__( /*! ../../core/utils/comparator */ 279);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _extend2 = _interopRequireDefault(_extend);
        var _inflector = __webpack_require__( /*! ../../core/utils/inflector */ 34);
        var _inflector2 = _interopRequireDefault(_inflector);
        var _errors = __webpack_require__( /*! ../../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var each = _iterator2.default.each;
        var inArray = _array2.default.inArray;
        var compileSetter = _data2.default.compileSetter;
        var compileGetter = _data2.default.compileGetter;
        var extendFromObject = _extend2.default.extendFromObject;
        var ITEM_ALIAS_ATTRIBUTE_NAME = "dxItemAlias";
        var SKIP_APPLY_ACTION_CATEGORIES = ["rendering"];
        var NG_MODEL_OPTION = "value";
        var safeApply = function(func, scope) {
            if (scope.$root.$$phase) {
                return func(scope)
            } else {
                return scope.$apply(function() {
                    return func(scope)
                })
            }
        };
        var getClassMethod = function getClassMethod(initClass, methodName) {
            var hasParentProperty = Object.prototype.hasOwnProperty.bind(initClass)("parent");
            var isES6Class = !hasParentProperty && initClass.parent;
            if (isES6Class) {
                var baseClass = Object.getPrototypeOf(initClass);
                return baseClass.prototype[methodName] ? function() {
                    return baseClass.prototype[methodName]()
                } : getClassMethod(baseClass, methodName)
            } else {
                var method = initClass.parent.prototype[methodName];
                if (method) {
                    return function() {
                        return method()
                    }
                }
                if (!method || !initClass.parent.subclassOf) {
                    return function() {
                        return
                    }
                }
                return getClassMethod(initClass.parent, methodName)
            }
        };
        var ComponentBuilder = _class2.default.inherit({
            ctor: function(options) {
                this._componentDisposing = (0, _callbacks2.default)();
                this._optionChangedCallbacks = (0, _callbacks2.default)();
                this._ngLocker = new _locker2.default;
                this._scope = options.scope;
                this._$element = options.$element;
                this._$templates = options.$templates;
                this._componentClass = options.componentClass;
                this._parse = options.parse;
                this._compile = options.compile;
                this._itemAlias = options.itemAlias;
                this._transcludeFn = options.transcludeFn;
                this._digestCallbacks = options.dxDigestCallbacks;
                this._normalizeOptions(options.ngOptions);
                this._initComponentBindings();
                this._initComponent(this._scope);
                if (!options.ngOptions) {
                    this._addOptionsStringWatcher(options.ngOptionsString)
                }
            },
            _addOptionsStringWatcher: function(optionsString) {
                var _this = this;
                var clearOptionsStringWatcher = this._scope.$watch(optionsString, function(newOptions) {
                    if (!newOptions) {
                        return
                    }
                    clearOptionsStringWatcher();
                    _this._normalizeOptions(newOptions);
                    _this._initComponentBindings();
                    _this._component.option(_this._evalOptions(_this._scope))
                });
                this._componentDisposing.add(clearOptionsStringWatcher)
            },
            _normalizeOptions: function(options) {
                var _this2 = this;
                this._ngOptions = extendFromObject({}, options);
                if (!options) {
                    return
                }
                if (!Object.prototype.hasOwnProperty.call(options, "bindingOptions") && options.bindingOptions) {
                    this._ngOptions.bindingOptions = options.bindingOptions
                }
                if (options.bindingOptions) {
                    each(options.bindingOptions, function(key, value) {
                        if ("string" === _type2.default.type(value)) {
                            _this2._ngOptions.bindingOptions[key] = {
                                dataPath: value
                            }
                        }
                    })
                }
            },
            _initComponent: function(scope) {
                this._component = new this._componentClass(this._$element, this._evalOptions(scope));
                this._component._isHidden = true;
                this._handleDigestPhase()
            },
            _handleDigestPhase: function() {
                var _this3 = this;
                var beginUpdate = function() {
                    _this3._component.beginUpdate()
                };
                var endUpdate = function() {
                    _this3._component.endUpdate()
                };
                this._digestCallbacks.begin.add(beginUpdate);
                this._digestCallbacks.end.add(endUpdate);
                this._componentDisposing.add(function() {
                    _this3._digestCallbacks.begin.remove(beginUpdate);
                    _this3._digestCallbacks.end.remove(endUpdate)
                })
            },
            _initComponentBindings: function() {
                var _this4 = this;
                var optionDependencies = {};
                if (!this._ngOptions.bindingOptions) {
                    return
                }
                each(this._ngOptions.bindingOptions, function(optionPath, value) {
                    var separatorIndex = optionPath.search(/\[|\./);
                    var optionForSubscribe = separatorIndex > -1 ? optionPath.substring(0, separatorIndex) : optionPath;
                    var prevWatchMethod;
                    var clearWatcher;
                    var valuePath = value.dataPath;
                    var deepWatch = true;
                    var forcePlainWatchMethod = false;
                    if (void 0 !== value.deep) {
                        forcePlainWatchMethod = deepWatch = !!value.deep
                    }
                    if (!optionDependencies[optionForSubscribe]) {
                        optionDependencies[optionForSubscribe] = {}
                    }
                    optionDependencies[optionForSubscribe][optionPath] = valuePath;
                    var updateWatcher = function updateWatcher() {
                        var watchCallback = function(newValue, oldValue) {
                            if (_this4._ngLocker.locked(optionPath)) {
                                return
                            }
                            _this4._ngLocker.obtain(optionPath);
                            _this4._component.option(optionPath, newValue);
                            updateWatcher();
                            if ((0, _comparator.equals)(oldValue, newValue) && _this4._ngLocker.locked(optionPath)) {
                                _this4._ngLocker.release(optionPath)
                            }
                        };
                        var watchMethod = Array.isArray(_this4._scope.$eval(valuePath)) && !forcePlainWatchMethod ? "$watchCollection" : "$watch";
                        if (prevWatchMethod !== watchMethod) {
                            if (clearWatcher) {
                                clearWatcher()
                            }
                            clearWatcher = _this4._scope[watchMethod](valuePath, watchCallback, deepWatch);
                            prevWatchMethod = watchMethod
                        }
                    };
                    updateWatcher();
                    _this4._componentDisposing.add(clearWatcher)
                });
                this._optionChangedCallbacks.add(function(args) {
                    var optionName = args.name;
                    var fullName = args.fullName;
                    var component = args.component;
                    if (_this4._ngLocker.locked(fullName)) {
                        _this4._ngLocker.release(fullName);
                        return
                    }
                    if (!optionDependencies || !optionDependencies[optionName]) {
                        return
                    }
                    var isActivePhase = _this4._scope.$root.$$phase;
                    var obtainOption = function() {
                        _this4._ngLocker.obtain(fullName)
                    };
                    if (isActivePhase) {
                        _this4._digestCallbacks.begin.add(obtainOption)
                    } else {
                        obtainOption()
                    }
                    safeApply(function() {
                        each(optionDependencies[optionName], function(optionPath, valuePath) {
                            if (!_this4._optionsAreLinked(fullName, optionPath)) {
                                return
                            }
                            var value = component.option(optionPath);
                            _this4._parse(valuePath).assign(_this4._scope, value);
                            var scopeValue = _this4._parse(valuePath)(_this4._scope);
                            if (scopeValue !== value) {
                                args.component.option(optionPath, scopeValue)
                            }
                        })
                    }, _this4._scope);
                    var releaseOption = function releaseOption() {
                        if (_this4._ngLocker.locked(fullName)) {
                            _this4._ngLocker.release(fullName)
                        }
                        _this4._digestCallbacks.begin.remove(obtainOption);
                        _this4._digestCallbacks.end.remove(releaseOption)
                    };
                    if (isActivePhase) {
                        _this4._digestCallbacks.end.addPrioritized(releaseOption)
                    } else {
                        releaseOption()
                    }
                })
            },
            _optionsAreNested: function(optionPath1, optionPath2) {
                var parentSeparator = optionPath1[optionPath2.length];
                return 0 === optionPath1.indexOf(optionPath2) && ("." === parentSeparator || "[" === parentSeparator)
            },
            _optionsAreLinked: function(optionPath1, optionPath2) {
                if (optionPath1 === optionPath2) {
                    return true
                }
                return optionPath1.length > optionPath2.length ? this._optionsAreNested(optionPath1, optionPath2) : this._optionsAreNested(optionPath2, optionPath1)
            },
            _compilerByTemplate: function(template) {
                var _this5 = this;
                var scopeItemsPath = this._getScopeItemsPath();
                return function(options) {
                    var $resultMarkup = (0, _renderer2.default)(template).clone();
                    var dataIsScope = options.model && options.model.constructor === _this5._scope.$root.constructor;
                    var templateScope = dataIsScope ? options.model : options.noModel ? _this5._scope : _this5._createScopeWithData(options);
                    if (scopeItemsPath) {
                        _this5._synchronizeScopes(templateScope, scopeItemsPath, options.index)
                    }
                    $resultMarkup.appendTo(options.container);
                    if (!options.noModel) {
                        _events_engine2.default.on($resultMarkup, "$destroy", function() {
                            var destroyAlreadyCalled = !templateScope.$parent;
                            if (destroyAlreadyCalled) {
                                return
                            }
                            templateScope.$destroy()
                        })
                    }
                    var ngTemplate = _this5._compile($resultMarkup, _this5._transcludeFn);
                    _this5._applyAsync(function(scope) {
                        ngTemplate(scope, null, {
                            parentBoundTranscludeFn: _this5._transcludeFn
                        })
                    }, templateScope);
                    return $resultMarkup
                }
            },
            _applyAsync: function(func, scope) {
                var _this6 = this;
                func(scope);
                if (!scope.$root.$$phase) {
                    if (!this._renderingTimer) {
                        var clearRenderingTimer = function() {
                            clearTimeout(_this6._renderingTimer)
                        };
                        this._renderingTimer = setTimeout(function() {
                            scope.$apply();
                            _this6._renderingTimer = null;
                            _this6._componentDisposing.remove(clearRenderingTimer)
                        });
                        this._componentDisposing.add(clearRenderingTimer)
                    }
                }
            },
            _getScopeItemsPath: function() {
                if (this._componentClass.subclassOf(_uiCollection_widget2.default) && this._ngOptions.bindingOptions && this._ngOptions.bindingOptions.items) {
                    return this._ngOptions.bindingOptions.items.dataPath
                }
            },
            _createScopeWithData: function(options) {
                var newScope = this._scope.$new();
                if (this._itemAlias) {
                    newScope[this._itemAlias] = options.model
                }
                if (_type2.default.isDefined(options.index)) {
                    newScope.$index = options.index
                }
                return newScope
            },
            _synchronizeScopes: function(itemScope, parentPrefix, itemIndex) {
                if (this._itemAlias && "object" !== _typeof(itemScope[this._itemAlias])) {
                    this._synchronizeScopeField({
                        parentScope: this._scope,
                        childScope: itemScope,
                        fieldPath: this._itemAlias,
                        parentPrefix: parentPrefix,
                        itemIndex: itemIndex
                    })
                }
            },
            _synchronizeScopeField: function(args) {
                var parentScope = args.parentScope;
                var childScope = args.childScope;
                var fieldPath = args.fieldPath;
                var parentPrefix = args.parentPrefix;
                var itemIndex = args.itemIndex;
                var innerPathSuffix = fieldPath === this._itemAlias ? "" : "." + fieldPath;
                var collectionField = void 0 !== itemIndex;
                var optionOuterBag = [parentPrefix];
                if (collectionField) {
                    if (!_type2.default.isNumeric(itemIndex)) {
                        return
                    }
                    optionOuterBag.push("[", itemIndex, "]")
                }
                optionOuterBag.push(innerPathSuffix);
                var optionOuterPath = optionOuterBag.join("");
                var clearParentWatcher = parentScope.$watch(optionOuterPath, function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                        compileSetter(fieldPath)(childScope, newValue)
                    }
                });
                var clearItemWatcher = childScope.$watch(fieldPath, function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if (collectionField && !compileGetter(parentPrefix)(parentScope)[itemIndex]) {
                            clearItemWatcher();
                            return
                        }
                        compileSetter(optionOuterPath)(parentScope, newValue)
                    }
                });
                this._componentDisposing.add([clearParentWatcher, clearItemWatcher])
            },
            _evalOptions: function(scope) {
                var _this8 = this;
                var result = extendFromObject({}, this._ngOptions);
                delete result.bindingOptions;
                if (this._ngOptions.bindingOptions) {
                    each(this._ngOptions.bindingOptions, function(key, value) {
                        result[key] = scope.$eval(value.dataPath)
                    })
                }
                result._optionChangedCallbacks = this._optionChangedCallbacks;
                result._disposingCallbacks = this._componentDisposing;
                result.onActionCreated = function(component, action, config) {
                    if (config && inArray(config.category, SKIP_APPLY_ACTION_CATEGORIES) > -1) {
                        return action
                    }
                    var wrappedAction = function() {
                        var _this7 = this;
                        var args = arguments;
                        if (!scope || !scope.$root || scope.$root.$$phase) {
                            return action.apply(this, args)
                        }
                        return safeApply(function() {
                            return action.apply(_this7, args)
                        }, scope)
                    };
                    return wrappedAction
                };
                result.beforeActionExecute = result.onActionCreated;
                result.nestedComponentOptions = function(component) {
                    return {
                        templatesRenderAsynchronously: component.option("templatesRenderAsynchronously"),
                        forceApplyBindings: component.option("forceApplyBindings"),
                        modelByElement: component.option("modelByElement"),
                        onActionCreated: component.option("onActionCreated"),
                        beforeActionExecute: component.option("beforeActionExecute"),
                        nestedComponentOptions: component.option("nestedComponentOptions")
                    }
                };
                result.templatesRenderAsynchronously = true;
                if ((0, _config2.default)().wrapActionsBeforeExecute) {
                    result.forceApplyBindings = function() {
                        safeApply(function() {}, scope)
                    }
                }
                result.integrationOptions = {
                    createTemplate: function(element) {
                        return new _template.NgTemplate(element, _this8._compilerByTemplate.bind(_this8))
                    },
                    watchMethod: function(fn, callback, options) {
                        options = options || {};
                        var immediateValue;
                        var skipCallback = options.skipImmediate;
                        var disposeWatcher = scope.$watch(function() {
                            var value = fn();
                            if (value instanceof Date) {
                                value = value.valueOf()
                            }
                            return value
                        }, function(newValue) {
                            var isSameValue = immediateValue === newValue;
                            if (!skipCallback && (!isSameValue || isSameValue && options.deep)) {
                                callback(newValue)
                            }
                            skipCallback = false
                        }, options.deep);
                        if (!skipCallback) {
                            immediateValue = fn();
                            callback(immediateValue)
                        }
                        if ((0, _config2.default)().wrapActionsBeforeExecute) {
                            _this8._applyAsync(function() {}, scope)
                        }
                        return disposeWatcher
                    },
                    templates: {
                        "dx-polymorph-widget": {
                            render: function(options) {
                                var widgetName = options.model.widget;
                                if (!widgetName) {
                                    return
                                }
                                if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
                                    var deprecatedName = widgetName;
                                    widgetName = _inflector2.default.camelize("dx-" + widgetName);
                                    _errors2.default.log("W0001", "dxToolbar - 'widget' item field", deprecatedName, "16.1", "Use: '" + widgetName + "' instead")
                                }
                                var markup = (0, _renderer2.default)("<div>").attr(_inflector2.default.dasherize(widgetName), "options").get(0);
                                var newScope = _this8._scope.$new();
                                newScope.options = options.model.options;
                                options.container.append(markup);
                                _this8._compile(markup)(newScope)
                            }
                        }
                    }
                };
                result.modelByElement = function() {
                    return scope
                };
                return result
            }
        });
        ComponentBuilder = ComponentBuilder.inherit({
            ctor: function(options) {
                this._componentName = options.componentName;
                this._ngModel = options.ngModel;
                this._ngModelController = options.ngModelController;
                this.callBase.apply(this, arguments)
            },
            _isNgModelRequired: function() {
                return (this._componentClass.subclassOf(_editor2.default) || this._componentClass.prototype instanceof _editor2.default) && this._ngModel
            },
            _initComponentBindings: function() {
                this.callBase.apply(this, arguments);
                this._initNgModelBinding()
            },
            _initNgModelBinding: function() {
                var _this9 = this;
                if (!this._isNgModelRequired()) {
                    return
                }
                var clearNgModelWatcher = this._scope.$watch(this._ngModel, function(newValue, oldValue) {
                    if (_this9._ngLocker.locked(NG_MODEL_OPTION)) {
                        return
                    }
                    if (newValue === oldValue) {
                        return
                    }
                    _this9._component.option(NG_MODEL_OPTION, newValue)
                });
                this._optionChangedCallbacks.add(function(args) {
                    _this9._ngLocker.obtain(NG_MODEL_OPTION);
                    try {
                        if (args.name !== NG_MODEL_OPTION) {
                            return
                        }
                        _this9._ngModelController.$setViewValue(args.value)
                    } finally {
                        if (_this9._ngLocker.locked(NG_MODEL_OPTION)) {
                            _this9._ngLocker.release(NG_MODEL_OPTION)
                        }
                    }
                });
                this._componentDisposing.add(clearNgModelWatcher)
            },
            _evalOptions: function() {
                if (!this._isNgModelRequired()) {
                    return this.callBase.apply(this, arguments)
                }
                var result = this.callBase.apply(this, arguments);
                result[NG_MODEL_OPTION] = this._parse(this._ngModel)(this._scope);
                return result
            }
        });
        var registeredComponents = {};
        var registerComponentDirective = function(name) {
            var priority = "dxValidator" !== name ? 1 : 10;
            _module2.default.directive(name, ["$compile", "$parse", "dxDigestCallbacks", function($compile, $parse, dxDigestCallbacks) {
                return {
                    restrict: "A",
                    require: "^?ngModel",
                    priority: priority,
                    compile: function($element) {
                        var componentClass = registeredComponents[name];
                        var useTemplates = componentClass.prototype._useTemplates ? componentClass.prototype._useTemplates() : getClassMethod(componentClass, "_useTemplates")();
                        var $content = useTemplates ? $element.contents().detach() : null;
                        return function(scope, $element, attrs, ngModelController, transcludeFn) {
                            $element.append($content);
                            safeApply(function() {
                                new ComponentBuilder({
                                    componentClass: componentClass,
                                    componentName: name,
                                    compile: $compile,
                                    parse: $parse,
                                    $element: $element,
                                    scope: scope,
                                    ngOptionsString: attrs[name],
                                    ngOptions: attrs[name] ? scope.$eval(attrs[name]) : {},
                                    ngModel: attrs.ngModel,
                                    ngModelController: ngModelController,
                                    transcludeFn: transcludeFn,
                                    itemAlias: attrs[ITEM_ALIAS_ATTRIBUTE_NAME],
                                    dxDigestCallbacks: dxDigestCallbacks
                                })
                            }, scope)
                        }
                    }
                }
            }])
        };
        _component_registrator_callbacks2.default.add(function(name, componentClass) {
            if (!registeredComponents[name]) {
                registerComponentDirective(name)
            }
            registeredComponents[name] = componentClass
        })
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/integration/angular/template.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.NgTemplate = void 0;
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _template_base = __webpack_require__( /*! ../../core/templates/template_base */ 78);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _dom = __webpack_require__( /*! ../../core/utils/dom */ 11);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }

        function _inherits(subClass, superClass) {
            if ("function" !== typeof superClass && null !== superClass) {
                throw new TypeError("Super expression must either be null or a function")
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) {
                _setPrototypeOf(subClass, superClass)
            }
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o
            };
            return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                    result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (call && ("object" === _typeof(call) || "function" === typeof call)) {
                return call
            }
            return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
            if (void 0 === self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return self
        }

        function _isNativeReflectConstruct() {
            if ("undefined" === typeof Reflect || !Reflect.construct) {
                return false
            }
            if (Reflect.construct.sham) {
                return false
            }
            if ("function" === typeof Proxy) {
                return true
            }
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                return true
            } catch (e) {
                return false
            }
        }

        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
            };
            return _getPrototypeOf(o)
        }
        exports.NgTemplate = function(_TemplateBase) {
            _inherits(NgTemplate, _TemplateBase);
            var _super = _createSuper(NgTemplate);

            function NgTemplate(element, templateCompiler) {
                var _this;
                _classCallCheck(this, NgTemplate);
                _this = _super.call(this);
                _this._element = element;
                _this._compiledTemplate = templateCompiler((0, _dom.normalizeTemplateElement)(_this._element));
                return _this
            }
            _createClass(NgTemplate, [{
                key: "_renderCore",
                value: function(options) {
                    var compiledTemplate = this._compiledTemplate;
                    return (0, _type.isFunction)(compiledTemplate) ? compiledTemplate(options) : compiledTemplate
                }
            }, {
                key: "source",
                value: function() {
                    return (0, _renderer2.default)(this._element).clone()
                }
            }]);
            return NgTemplate
        }(_template_base.TemplateBase)
    },
    /*!*************************************************************************!*\
      !*** ./artifacts/transpiled/ui/collection/ui.collection_widget.base.js ***!
      \*************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _common2 = _interopRequireDefault(_common);
        var _dom = __webpack_require__( /*! ../../core/utils/dom */ 11);
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _iterator2 = _interopRequireDefault(_iterator);
        var _action = __webpack_require__( /*! ../../core/action */ 105);
        var _action2 = _interopRequireDefault(_action);
        var _guid = __webpack_require__( /*! ../../core/guid */ 36);
        var _guid2 = _interopRequireDefault(_guid);
        var _ui = __webpack_require__( /*! ../widget/ui.widget */ 17);
        var _ui2 = _interopRequireDefault(_ui);
        var _utils = __webpack_require__( /*! ../../events/utils */ 8);
        var eventUtils = _interopRequireWildcard(_utils);
        var _pointer = __webpack_require__( /*! ../../events/pointer */ 23);
        var _pointer2 = _interopRequireDefault(_pointer);
        var _data_helper = __webpack_require__( /*! ../../data_helper */ 82);
        var _data_helper2 = _interopRequireDefault(_data_helper);
        var _item = __webpack_require__( /*! ./item */ 135);
        var _item2 = _interopRequireDefault(_item);
        var _selectors = __webpack_require__( /*! ../widget/selectors */ 66);
        var _selectors2 = _interopRequireDefault(_selectors);
        var _message = __webpack_require__( /*! ../../localization/message */ 10);
        var _message2 = _interopRequireDefault(_message);
        var _hold = __webpack_require__( /*! ../../events/hold */ 95);
        var _hold2 = _interopRequireDefault(_hold);
        var _data = __webpack_require__( /*! ../../core/utils/data */ 20);
        var _click = __webpack_require__( /*! ../../events/click */ 19);
        var _click2 = _interopRequireDefault(_click);
        var _contextmenu = __webpack_require__( /*! ../../events/contextmenu */ 177);
        var _contextmenu2 = _interopRequireDefault(_contextmenu);
        var _bindable_template = __webpack_require__( /*! ../../core/templates/bindable_template */ 59);

        function _getRequireWildcardCache() {
            if ("function" !== typeof WeakMap) {
                return null
            }
            var cache = new WeakMap;
            _getRequireWildcardCache = function() {
                return cache
            };
            return cache
        }

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            }
            if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
                return {
                    "default": obj
                }
            }
            var cache = _getRequireWildcardCache();
            if (cache && cache.has(obj)) {
                return cache.get(obj)
            }
            var newObj = {};
            var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                        Object.defineProperty(newObj, key, desc)
                    } else {
                        newObj[key] = obj[key]
                    }
                }
            }
            newObj.default = obj;
            if (cache) {
                cache.set(obj, newObj)
            }
            return newObj
        }

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var COLLECTION_CLASS = "dx-collection";
        var ITEM_CLASS = "dx-item";
        var CONTENT_CLASS_POSTFIX = "-content";
        var ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
        var ITEM_DATA_KEY = "dxItemData";
        var ITEM_INDEX_KEY = "dxItemIndex";
        var ITEM_TEMPLATE_ID_PREFIX = "tmpl-";
        var ITEMS_SELECTOR = "[data-options*='dxItem']";
        var SELECTED_ITEM_CLASS = "dx-item-selected";
        var ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait";
        var EMPTY_COLLECTION = "dx-empty-collection";
        var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
        var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
        var ANONYMOUS_TEMPLATE_NAME = "item";
        var FOCUS_UP = "up";
        var FOCUS_DOWN = "down";
        var FOCUS_LEFT = "left";
        var FOCUS_RIGHT = "right";
        var FOCUS_PAGE_UP = "pageup";
        var FOCUS_PAGE_DOWN = "pagedown";
        var FOCUS_LAST = "last";
        var FOCUS_FIRST = "first";
        var CollectionWidget = _ui2.default.inherit({
            _activeStateUnit: "." + ITEM_CLASS,
            _supportedKeys: function() {
                var enter = function(e) {
                    var $itemElement = (0, _renderer2.default)(this.option("focusedElement"));
                    if (!$itemElement.length) {
                        return
                    }
                    this._itemClickHandler((0, _extend.extend)({}, e, {
                        target: $itemElement,
                        currentTarget: $itemElement
                    }))
                };
                var space = function(e) {
                    e.preventDefault();
                    enter.call(this, e)
                };
                var move = function(location, e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this._moveFocus(location, e)
                };
                return (0, _extend.extend)(this.callBase(), {
                    space: space,
                    enter: enter,
                    leftArrow: move.bind(this, FOCUS_LEFT),
                    rightArrow: move.bind(this, FOCUS_RIGHT),
                    upArrow: move.bind(this, FOCUS_UP),
                    downArrow: move.bind(this, FOCUS_DOWN),
                    pageUp: move.bind(this, FOCUS_UP),
                    pageDown: move.bind(this, FOCUS_DOWN),
                    home: move.bind(this, FOCUS_FIRST),
                    end: move.bind(this, FOCUS_LAST)
                })
            },
            _getDefaultOptions: function() {
                return (0, _extend.extend)(this.callBase(), {
                    selectOnFocus: false,
                    loopItemFocus: true,
                    items: [],
                    itemTemplate: "item",
                    onItemRendered: null,
                    onItemClick: null,
                    onItemHold: null,
                    itemHoldTimeout: 750,
                    onItemContextMenu: null,
                    onFocusedItemChanged: null,
                    noDataText: _message2.default.format("dxCollectionWidget-noDataText"),
                    dataSource: null,
                    _itemAttributes: {},
                    itemTemplateProperty: "template",
                    focusOnSelectedItem: true,
                    focusedElement: null,
                    displayExpr: void 0,
                    disabledExpr: function(data) {
                        return data ? data.disabled : void 0
                    },
                    visibleExpr: function(data) {
                        return data ? data.visible : void 0
                    }
                })
            },
            _init: function() {
                this._compileDisplayGetter();
                this.callBase();
                this._cleanRenderedItems();
                this._refreshDataSource()
            },
            _compileDisplayGetter: function() {
                var displayExpr = this.option("displayExpr");
                this._displayGetter = displayExpr ? (0, _data.compileGetter)(this.option("displayExpr")) : void 0
            },
            _initTemplates: function() {
                this._initItemsFromMarkup();
                this._initDefaultItemTemplate();
                this.callBase()
            },
            _getAnonymousTemplateName: function() {
                return ANONYMOUS_TEMPLATE_NAME
            },
            _initDefaultItemTemplate: function() {
                var fieldsMap = this._getFieldsMap();
                this._templateManager.addDefaultTemplates({
                    item: new _bindable_template.BindableTemplate(function($container, data) {
                        if ((0, _type.isPlainObject)(data)) {
                            this._prepareDefaultItemTemplate(data, $container)
                        } else {
                            if (fieldsMap && (0, _type.isFunction)(fieldsMap.text)) {
                                data = fieldsMap.text(data)
                            }
                            $container.text(String(_common2.default.ensureDefined(data, "")))
                        }
                    }.bind(this), this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
                })
            },
            _getBindableFields: function() {
                return ["text", "html"]
            },
            _getFieldsMap: function() {
                if (this._displayGetter) {
                    return {
                        text: this._displayGetter
                    }
                }
            },
            _prepareDefaultItemTemplate: function(data, $container) {
                if ((0, _type.isDefined)(data.text)) {
                    $container.text(data.text)
                }
                if ((0, _type.isDefined)(data.html)) {
                    $container.html(data.html)
                }
            },
            _initItemsFromMarkup: function() {
                var _this = this;
                var $items = this.$element().contents().filter(ITEMS_SELECTOR);
                if (!$items.length || this.option("items").length) {
                    return
                }
                var items = [].slice.call($items).map(function(item) {
                    var $item = (0, _renderer2.default)(item);
                    var result = (0, _dom.getElementOptions)(item).dxItem;
                    var isTemplateRequired = $item.html().trim() && !result.template;
                    if (isTemplateRequired) {
                        result.template = _this._prepareItemTemplate($item)
                    } else {
                        $item.remove()
                    }
                    return result
                });
                this.option("items", items)
            },
            _prepareItemTemplate: function($item) {
                var templateId = ITEM_TEMPLATE_ID_PREFIX + new _guid2.default;
                var $template = $item.detach().clone().removeAttr("data-options").addClass(TEMPLATE_WRAPPER_CLASS);
                this._saveTemplate(templateId, $template);
                return templateId
            },
            _dataSourceOptions: function() {
                return {
                    paginate: false
                }
            },
            _cleanRenderedItems: function() {
                this._renderedItemsCount = 0
            },
            _focusTarget: function() {
                return this.$element()
            },
            _focusInHandler: function(e) {
                this.callBase.apply(this, arguments);
                if ((0, _array.inArray)(e.target, this._focusTarget()) === -1) {
                    return
                }
                var $focusedElement = (0, _renderer2.default)(this.option("focusedElement"));
                if ($focusedElement.length) {
                    this._setFocusedItem($focusedElement)
                } else {
                    var $activeItem = this._getActiveItem();
                    if ($activeItem.length) {
                        this.option("focusedElement", (0, _dom.getPublicElement)($activeItem))
                    }
                }
            },
            _focusOutHandler: function() {
                this.callBase.apply(this, arguments);
                var $target = (0, _renderer2.default)(this.option("focusedElement"));
                this._updateFocusedItemState($target, false)
            },
            _getActiveItem: function(last) {
                var $focusedElement = (0, _renderer2.default)(this.option("focusedElement"));
                if ($focusedElement.length) {
                    return $focusedElement
                }
                var index = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0;
                var activeElements = this._getActiveElement();
                var lastIndex = activeElements.length - 1;
                if (index < 0) {
                    index = last ? lastIndex : 0
                }
                return activeElements.eq(index)
            },
            _moveFocus: function(location) {
                var $items = this._getAvailableItems();
                var $newTarget;
                switch (location) {
                    case FOCUS_PAGE_UP:
                    case FOCUS_UP:
                        $newTarget = this._prevItem($items);
                        break;
                    case FOCUS_PAGE_DOWN:
                    case FOCUS_DOWN:
                        $newTarget = this._nextItem($items);
                        break;
                    case FOCUS_RIGHT:
                        $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
                        break;
                    case FOCUS_LEFT:
                        $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
                        break;
                    case FOCUS_FIRST:
                        $newTarget = $items.first();
                        break;
                    case FOCUS_LAST:
                        $newTarget = $items.last();
                        break;
                    default:
                        return false
                }
                if (0 !== $newTarget.length) {
                    this.option("focusedElement", (0, _dom.getPublicElement)($newTarget))
                }
            },
            _getVisibleItems: function($itemElements) {
                $itemElements = $itemElements || this._itemElements();
                return $itemElements.filter(":visible")
            },
            _getAvailableItems: function($itemElements) {
                return this._getVisibleItems($itemElements).not(".dx-state-disabled")
            },
            _prevItem: function($items) {
                var $target = this._getActiveItem();
                var targetIndex = $items.index($target);
                var $last = $items.last();
                var $item = (0, _renderer2.default)($items[targetIndex - 1]);
                var loop = this.option("loopItemFocus");
                if (0 === $item.length && loop) {
                    $item = $last
                }
                return $item
            },
            _nextItem: function($items) {
                var $target = this._getActiveItem(true);
                var targetIndex = $items.index($target);
                var $first = $items.first();
                var $item = (0, _renderer2.default)($items[targetIndex + 1]);
                var loop = this.option("loopItemFocus");
                if (0 === $item.length && loop) {
                    $item = $first
                }
                return $item
            },
            _selectFocusedItem: function($target) {
                this.selectItem($target)
            },
            _updateFocusedItemState: function(target, isFocused, needCleanItemId) {
                var $target = (0, _renderer2.default)(target);
                if ($target.length) {
                    this._refreshActiveDescendant();
                    this._refreshItemId($target, needCleanItemId);
                    this._toggleFocusClass(isFocused, $target)
                }
            },
            _refreshActiveDescendant: function($target) {
                this.setAria("activedescendant", (0, _type.isDefined)(this.option("focusedElement")) ? this.getFocusedItemId() : null, $target)
            },
            _refreshItemId: function($target, needCleanItemId) {
                if (!needCleanItemId && this.option("focusedElement")) {
                    this.setAria("id", this.getFocusedItemId(), $target)
                } else {
                    this.setAria("id", null, $target)
                }
            },
            _setFocusedItem: function($target) {
                if (!$target || !$target.length) {
                    return
                }
                this._updateFocusedItemState($target, true);
                this.onFocusedItemChanged(this.getFocusedItemId());
                if (this.option("selectOnFocus")) {
                    this._selectFocusedItem($target)
                }
            },
            _findItemElementByItem: function(item) {
                var result = (0, _renderer2.default)();
                var that = this;
                this.itemElements().each(function() {
                    var $item = (0, _renderer2.default)(this);
                    if ($item.data(that._itemDataKey()) === item) {
                        result = $item;
                        return false
                    }
                });
                return result
            },
            _getIndexByItem: function(item) {
                return this.option("items").indexOf(item)
            },
            _itemOptionChanged: function(item, property, value, oldValue) {
                var $item = this._findItemElementByItem(item);
                if (!$item.length) {
                    return
                }
                if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value)) {
                    this._refreshItem($item, item)
                }
                var isDisabling = "disabled" === property && value;
                if (isDisabling) {
                    this._resetItemFocus($item)
                }
            },
            _resetItemFocus: function($item) {
                if ($item.is(this.option("focusedElement"))) {
                    this.option("focusedElement", null)
                }
            },
            _refreshItem: function($item) {
                var itemData = this._getItemData($item);
                var index = $item.data(this._itemIndexKey());
                this._renderItem(this._renderedItemsCount + index, itemData, null, $item)
            },
            _optionChanged: function(args) {
                if ("items" === args.name) {
                    var matches = args.fullName.match(ITEM_PATH_REGEX);
                    if (matches && matches.length) {
                        var property = matches[matches.length - 1];
                        var itemPath = args.fullName.replace("." + property, "");
                        var item = this.option(itemPath);
                        this._itemOptionChanged(item, property, args.value, args.previousValue);
                        return
                    }
                }
                switch (args.name) {
                    case "items":
                    case "_itemAttributes":
                    case "itemTemplateProperty":
                    case "showItemDataTitle":
                        this._cleanRenderedItems();
                        this._invalidate();
                        break;
                    case "dataSource":
                        this._refreshDataSource();
                        this._renderEmptyMessage();
                        break;
                    case "noDataText":
                        this._renderEmptyMessage();
                        break;
                    case "itemTemplate":
                        this._invalidate();
                        break;
                    case "onItemRendered":
                        this._createItemRenderAction();
                        break;
                    case "onItemClick":
                        break;
                    case "onItemHold":
                    case "itemHoldTimeout":
                        this._attachHoldEvent();
                        break;
                    case "onItemContextMenu":
                        this._attachContextMenuEvent();
                        break;
                    case "onFocusedItemChanged":
                        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
                        break;
                    case "selectOnFocus":
                    case "loopItemFocus":
                    case "focusOnSelectedItem":
                        break;
                    case "focusedElement":
                        this._updateFocusedItemState(args.previousValue, false, true);
                        this._setFocusedItem((0, _renderer2.default)(args.value));
                        break;
                    case "displayExpr":
                        this._compileDisplayGetter();
                        this._initDefaultItemTemplate();
                        this._invalidate();
                        break;
                    case "visibleExpr":
                    case "disabledExpr":
                        this._invalidate();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _invalidate: function() {
                this.option("focusedElement", null);
                return this.callBase.apply(this, arguments)
            },
            _loadNextPage: function() {
                var dataSource = this._dataSource;
                this._expectNextPageLoading();
                dataSource.pageIndex(1 + dataSource.pageIndex());
                return dataSource.load()
            },
            _expectNextPageLoading: function() {
                this._startIndexForAppendedItems = 0
            },
            _expectLastItemLoading: function() {
                this._startIndexForAppendedItems = -1
            },
            _forgetNextPageLoading: function() {
                this._startIndexForAppendedItems = null
            },
            _dataSourceChangedHandler: function(newItems) {
                var items = this.option("items");
                if (this._initialized && items && this._shouldAppendItems()) {
                    this._renderedItemsCount = items.length;
                    if (!this._isLastPage() || this._startIndexForAppendedItems !== -1) {
                        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems))
                    }
                    this._forgetNextPageLoading();
                    this._refreshContent()
                } else {
                    this.option("items", newItems.slice())
                }
            },
            _refreshContent: function() {
                this._prepareContent();
                this._renderContent()
            },
            _dataSourceLoadErrorHandler: function() {
                this._forgetNextPageLoading();
                this.option("items", this.option("items"))
            },
            _shouldAppendItems: function() {
                return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend()
            },
            _allowDynamicItemsAppend: function() {
                return false
            },
            _clean: function() {
                this._cleanFocusState();
                this._cleanItemContainer()
            },
            _cleanItemContainer: function() {
                (0, _renderer2.default)(this._itemContainer()).empty()
            },
            _dispose: function() {
                this.callBase();
                clearTimeout(this._itemFocusTimeout)
            },
            _refresh: function() {
                this._cleanRenderedItems();
                this.callBase.apply(this, arguments)
            },
            _itemContainer: function() {
                return this.$element()
            },
            _itemClass: function() {
                return ITEM_CLASS
            },
            _itemContentClass: function() {
                return this._itemClass() + CONTENT_CLASS_POSTFIX
            },
            _selectedItemClass: function() {
                return SELECTED_ITEM_CLASS
            },
            _itemResponseWaitClass: function() {
                return ITEM_RESPONSE_WAIT_CLASS
            },
            _itemSelector: function() {
                return "." + this._itemClass()
            },
            _itemDataKey: function() {
                return ITEM_DATA_KEY
            },
            _itemIndexKey: function() {
                return ITEM_INDEX_KEY
            },
            _itemElements: function() {
                return this._itemContainer().find(this._itemSelector())
            },
            _initMarkup: function() {
                this.callBase();
                this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
                this.$element().addClass(COLLECTION_CLASS);
                this._prepareContent()
            },
            _prepareContent: _common2.default.deferRenderer(function() {
                this._renderContentImpl()
            }),
            _renderContent: function() {
                this._fireContentReadyAction()
            },
            _render: function() {
                this.callBase();
                this._attachClickEvent();
                this._attachHoldEvent();
                this._attachContextMenuEvent()
            },
            _attachClickEvent: function() {
                var itemSelector = this._itemSelector();
                var clickEventNamespace = eventUtils.addNamespace(_click2.default.name, this.NAME);
                var pointerDownEventNamespace = eventUtils.addNamespace(_pointer2.default.down, this.NAME);
                var that = this;
                var pointerDownAction = new _action2.default(function(args) {
                    var event = args.event;
                    that._itemPointerDownHandler(event)
                });
                _events_engine2.default.off(this._itemContainer(), clickEventNamespace, itemSelector);
                _events_engine2.default.off(this._itemContainer(), pointerDownEventNamespace, itemSelector);
                _events_engine2.default.on(this._itemContainer(), clickEventNamespace, itemSelector, function(e) {
                    this._itemClickHandler(e)
                }.bind(this));
                _events_engine2.default.on(this._itemContainer(), pointerDownEventNamespace, itemSelector, function(e) {
                    pointerDownAction.execute({
                        element: (0, _renderer2.default)(e.target),
                        event: e
                    })
                })
            },
            _itemClickHandler: function(e, args, config) {
                this._itemDXEventHandler(e, "onItemClick", args, config)
            },
            _itemPointerDownHandler: function(e) {
                if (!this.option("focusStateEnabled")) {
                    return
                }
                this._itemFocusHandler = function() {
                    clearTimeout(this._itemFocusTimeout);
                    this._itemFocusHandler = null;
                    if (e.isDefaultPrevented()) {
                        return
                    }
                    var $target = (0, _renderer2.default)(e.target);
                    var $closestItem = $target.closest(this._itemElements());
                    var $closestFocusable = this._closestFocusable($target);
                    if ($closestItem.length && $closestFocusable && (0, _array.inArray)($closestFocusable.get(0), this._focusTarget()) !== -1) {
                        this.option("focusedElement", (0, _dom.getPublicElement)($closestItem))
                    }
                }.bind(this);
                this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this))
            },
            _closestFocusable: function($target) {
                if ($target.is(_selectors2.default.focusable)) {
                    return $target
                } else {
                    $target = $target.parent();
                    while ($target.length && !_dom_adapter2.default.isDocument($target.get(0))) {
                        if ($target.is(_selectors2.default.focusable)) {
                            return $target
                        }
                        $target = $target.parent()
                    }
                }
            },
            _forcePointerDownFocus: function() {
                this._itemFocusHandler && this._itemFocusHandler()
            },
            _updateFocusState: function() {
                this.callBase.apply(this, arguments);
                this._forcePointerDownFocus()
            },
            _attachHoldEvent: function() {
                var $itemContainer = this._itemContainer();
                var itemSelector = this._itemSelector();
                var eventName = eventUtils.addNamespace(_hold2.default.name, this.NAME);
                _events_engine2.default.off($itemContainer, eventName, itemSelector);
                _events_engine2.default.on($itemContainer, eventName, itemSelector, {
                    timeout: this._getHoldTimeout()
                }, this._itemHoldHandler.bind(this))
            },
            _getHoldTimeout: function() {
                return this.option("itemHoldTimeout")
            },
            _shouldFireHoldEvent: function() {
                return this.hasActionSubscription("onItemHold")
            },
            _itemHoldHandler: function(e) {
                if (this._shouldFireHoldEvent()) {
                    this._itemDXEventHandler(e, "onItemHold")
                } else {
                    e.cancel = true
                }
            },
            _attachContextMenuEvent: function() {
                var $itemContainer = this._itemContainer();
                var itemSelector = this._itemSelector();
                var eventName = eventUtils.addNamespace(_contextmenu2.default.name, this.NAME);
                _events_engine2.default.off($itemContainer, eventName, itemSelector);
                _events_engine2.default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this))
            },
            _shouldFireContextMenuEvent: function() {
                return this.hasActionSubscription("onItemContextMenu")
            },
            _itemContextMenuHandler: function(e) {
                if (this._shouldFireContextMenuEvent()) {
                    this._itemDXEventHandler(e, "onItemContextMenu")
                } else {
                    e.cancel = true
                }
            },
            _renderContentImpl: function() {
                var items = this.option("items") || [];
                if (this._renderedItemsCount) {
                    this._renderItems(items.slice(this._renderedItemsCount))
                } else {
                    this._renderItems(items)
                }
            },
            _renderItems: function(items) {
                if (items.length) {
                    _iterator2.default.each(items, function(index, itemData) {
                        this._renderItem(this._renderedItemsCount + index, itemData)
                    }.bind(this))
                }
                this._renderEmptyMessage()
            },
            _renderItem: function(index, itemData, $container, $itemToReplace) {
                $container = $container || this._itemContainer();
                var $itemFrame = this._renderItemFrame(index, itemData, $container, $itemToReplace);
                this._setElementData($itemFrame, itemData, index);
                $itemFrame.attr(this.option("_itemAttributes"));
                this._attachItemClickEvent(itemData, $itemFrame);
                var $itemContent = this._getItemContent($itemFrame);
                var renderContentPromise = this._renderItemContent({
                    index: index,
                    itemData: itemData,
                    container: (0, _dom.getPublicElement)($itemContent),
                    contentClass: this._itemContentClass(),
                    defaultTemplateName: this.option("itemTemplate")
                });
                var that = this;
                (0, _deferred.when)(renderContentPromise).done(function($itemContent) {
                    that._postprocessRenderItem({
                        itemElement: $itemFrame,
                        itemContent: $itemContent,
                        itemData: itemData,
                        itemIndex: index
                    });
                    that._executeItemRenderAction(index, itemData, (0, _dom.getPublicElement)($itemFrame))
                });
                return $itemFrame
            },
            _getItemContent: function($itemFrame) {
                var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS);
                $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
                return $itemContent
            },
            _attachItemClickEvent: function(itemData, $itemElement) {
                if (!itemData || !itemData.onClick) {
                    return
                }
                _events_engine2.default.on($itemElement, _click2.default.name, function(e) {
                    this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
                        event: e
                    })
                }.bind(this))
            },
            _renderItemContent: function(args) {
                var itemTemplateName = this._getItemTemplateName(args);
                var itemTemplate = this._getTemplate(itemTemplateName);
                this._addItemContentClasses(args);
                var $templateResult = (0, _renderer2.default)(this._createItemByTemplate(itemTemplate, args));
                if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS)) {
                    return args.container
                }
                return this._renderItemContentByNode(args, $templateResult)
            },
            _renderItemContentByNode: function(args, $node) {
                (0, _renderer2.default)(args.container).replaceWith($node);
                args.container = (0, _dom.getPublicElement)($node);
                this._addItemContentClasses(args);
                return $node
            },
            _addItemContentClasses: function(args) {
                var classes = [ITEM_CLASS + CONTENT_CLASS_POSTFIX, args.contentClass];
                (0, _renderer2.default)(args.container).addClass(classes.join(" "))
            },
            _appendItemToContainer: function($container, $itemFrame, index) {
                $itemFrame.appendTo($container)
            },
            _renderItemFrame: function(index, itemData, $container, $itemToReplace) {
                var $itemFrame = (0, _renderer2.default)("<div>");
                new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
                if ($itemToReplace && $itemToReplace.length) {
                    $itemToReplace.replaceWith($itemFrame)
                } else {
                    this._appendItemToContainer.call(this, $container, $itemFrame, index)
                }
                if (this.option("showItemDataTitle")) {
                    var displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
                    $itemFrame.attr("title", displayValue)
                }
                return $itemFrame
            },
            _itemOptions: function() {
                var that = this;
                return {
                    watchMethod: function() {
                        return that.option("integrationOptions.watchMethod")
                    },
                    owner: that,
                    fieldGetter: function(field) {
                        var expr = that.option(field + "Expr");
                        var getter = (0, _data.compileGetter)(expr);
                        return getter
                    }
                }
            },
            _postprocessRenderItem: _common2.default.noop,
            _executeItemRenderAction: function(index, itemData, itemElement) {
                this._getItemRenderAction()({
                    itemElement: itemElement,
                    itemIndex: index,
                    itemData: itemData
                })
            },
            _setElementData: function(element, data, index) {
                element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data).data(this._itemIndexKey(), index)
            },
            _createItemRenderAction: function() {
                return this._itemRenderAction = this._createActionByOption("onItemRendered", {
                    element: this.element(),
                    excludeValidators: ["disabled", "readOnly"],
                    category: "rendering"
                })
            },
            _getItemRenderAction: function() {
                return this._itemRenderAction || this._createItemRenderAction()
            },
            _getItemTemplateName: function(args) {
                var data = args.itemData;
                var templateProperty = args.templateProperty || this.option("itemTemplateProperty");
                var template = data && data[templateProperty];
                return template || args.defaultTemplateName
            },
            _createItemByTemplate: function(itemTemplate, renderArgs) {
                return itemTemplate.render({
                    model: renderArgs.itemData,
                    container: renderArgs.container,
                    index: renderArgs.index
                })
            },
            _emptyMessageContainer: function() {
                return this._itemContainer()
            },
            _renderEmptyMessage: function(items) {
                items = items || this.option("items");
                var noDataText = this.option("noDataText");
                var hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();
                if (hideNoData && this._$noData) {
                    this._$noData.remove();
                    this._$noData = null;
                    this.setAria("label", void 0)
                }
                if (!hideNoData) {
                    this._$noData = this._$noData || (0, _renderer2.default)("<div>").addClass("dx-empty-message");
                    this._$noData.appendTo(this._emptyMessageContainer()).html(noDataText);
                    this.setAria("label", noDataText)
                }
                this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData)
            },
            _itemDXEventHandler: function(dxEvent, handlerOptionName, actionArgs, actionConfig) {
                this._itemEventHandler(dxEvent.target, handlerOptionName, (0, _extend.extend)(actionArgs, {
                    event: dxEvent
                }), actionConfig)
            },
            _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
                var action = this._createActionByOption(handlerOptionName, (0, _extend.extend)({
                    validatingTargetName: "itemElement"
                }, actionConfig));
                return this._itemEventHandlerImpl(initiator, action, actionArgs)
            },
            _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
                var action = this._createAction(handler, (0, _extend.extend)({
                    validatingTargetName: "itemElement"
                }, actionConfig));
                return this._itemEventHandlerImpl(initiator, action, actionArgs)
            },
            _itemEventHandlerImpl: function(initiator, action, actionArgs) {
                var $itemElement = this._closestItemElement((0, _renderer2.default)(initiator));
                var args = (0, _extend.extend)({}, actionArgs);
                return action((0, _extend.extend)(actionArgs, this._extendActionArgs($itemElement), args))
            },
            _extendActionArgs: function($itemElement) {
                return {
                    itemElement: (0, _dom.getPublicElement)($itemElement),
                    itemIndex: this._itemElements().index($itemElement),
                    itemData: this._getItemData($itemElement)
                }
            },
            _closestItemElement: function($element) {
                return (0, _renderer2.default)($element).closest(this._itemSelector())
            },
            _getItemData: function(itemElement) {
                return (0, _renderer2.default)(itemElement).data(this._itemDataKey())
            },
            _getSummaryItemsWidth: function(items, includeMargin) {
                var result = 0;
                if (items) {
                    _iterator2.default.each(items, function(_, item) {
                        result += (0, _renderer2.default)(item).outerWidth(includeMargin || false)
                    })
                }
                return result
            },
            getFocusedItemId: function() {
                if (!this._focusedItemId) {
                    this._focusedItemId = "dx-" + new _guid2.default
                }
                return this._focusedItemId
            },
            itemElements: function() {
                return this._itemElements()
            },
            itemsContainer: function() {
                return this._itemContainer()
            }
        }).include(_data_helper2.default);
        CollectionWidget.ItemClass = _item2.default;
        module.exports = CollectionWidget
    },
    /*!********************************************************************!*\
      !*** ./artifacts/transpiled/data/data_source/operation_manager.js ***!
      \********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _utils = __webpack_require__( /*! ./utils */ 64);

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }
        var OperationManager = function() {
            function OperationManager() {
                _classCallCheck(this, OperationManager);
                this._counter = -1;
                this._deferreds = {}
            }
            _createClass(OperationManager, [{
                key: "add",
                value: function(deferred) {
                    this._counter++;
                    this._deferreds[this._counter] = deferred;
                    return this._counter
                }
            }, {
                key: "remove",
                value: function(operationId) {
                    return delete this._deferreds[operationId]
                }
            }, {
                key: "cancel",
                value: function(operationId) {
                    if (operationId in this._deferreds) {
                        this._deferreds[operationId].reject(_utils.CANCELED_TOKEN);
                        return true
                    }
                    return false
                }
            }, {
                key: "cancelAll",
                value: function() {
                    while (this._counter > -1) {
                        this.cancel(this._counter);
                        this._counter--
                    }
                }
            }]);
            return OperationManager
        }();
        exports.default = OperationManager
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/data/remote_query.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var queryAdapters = __webpack_require__( /*! ./query_adapters */ 190);
        var errorsModule = __webpack_require__( /*! ./errors */ 38);
        var each = __webpack_require__( /*! ../core/utils/iterator */ 4).each;
        var isFunction = __webpack_require__( /*! ../core/utils/type */ 1).isFunction;
        var Deferred = __webpack_require__( /*! ../core/utils/deferred */ 6).Deferred;
        var arrayQueryImpl = __webpack_require__( /*! ./array_query */ 161);
        var remoteQueryImpl = function remoteQueryImpl(url, queryOptions, tasks) {
            tasks = tasks || [];
            queryOptions = queryOptions || {};
            var createTask = function(name, args) {
                return {
                    name: name,
                    args: args
                }
            };
            var exec = function(executorTask) {
                var d = new Deferred;
                var _adapterFactory;
                var _adapter;
                var _taskQueue;
                var _currentTask;
                var _mergedSortArgs;
                var rejectWithNotify = function(error) {
                    var handler = queryOptions.errorHandler;
                    if (handler) {
                        handler(error)
                    }
                    errorsModule._errorHandler(error);
                    d.reject(error)
                };

                function mergeSortTask(task) {
                    switch (task.name) {
                        case "sortBy":
                            _mergedSortArgs = [task.args];
                            return true;
                        case "thenBy":
                            if (!_mergedSortArgs) {
                                throw errorsModule.errors.Error("E4004")
                            }
                            _mergedSortArgs.push(task.args);
                            return true
                    }
                    return false
                }

                function unmergeSortTasks() {
                    var head = _taskQueue[0];
                    var unmergedTasks = [];
                    if (head && "multiSort" === head.name) {
                        _taskQueue.shift();
                        each(head.args[0], function() {
                            unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this))
                        })
                    }
                    _taskQueue = unmergedTasks.concat(_taskQueue)
                }
                try {
                    _adapterFactory = queryOptions.adapter;
                    if (!isFunction(_adapterFactory)) {
                        _adapterFactory = queryAdapters[_adapterFactory]
                    }
                    _adapter = _adapterFactory(queryOptions);
                    _taskQueue = [].concat(tasks).concat(executorTask);
                    var optimize = _adapter.optimize;
                    if (optimize) {
                        optimize(_taskQueue)
                    }
                    while (_taskQueue.length) {
                        _currentTask = _taskQueue[0];
                        if (!mergeSortTask(_currentTask)) {
                            if (_mergedSortArgs) {
                                _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
                                _mergedSortArgs = null;
                                continue
                            }
                            if ("enumerate" !== String(_currentTask.name)) {
                                if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
                                    break
                                }
                            }
                        }
                        _taskQueue.shift()
                    }
                    unmergeSortTasks();
                    _adapter.exec(url).done(function(result, extra) {
                        if (!_taskQueue.length) {
                            d.resolve(result, extra)
                        } else {
                            var clientChain = arrayQueryImpl(result, {
                                errorHandler: queryOptions.errorHandler
                            });
                            each(_taskQueue, function() {
                                clientChain = clientChain[this.name].apply(clientChain, this.args)
                            });
                            clientChain.done(d.resolve).fail(d.reject)
                        }
                    }).fail(rejectWithNotify)
                } catch (x) {
                    rejectWithNotify(x)
                }
                return d.promise()
            };
            var query = {};
            each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
                var name = String(this);
                query[name] = function() {
                    return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name, arguments)))
                }
            });
            each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
                var name = String(this);
                query[name] = function() {
                    return exec.call(this, createTask(name, arguments))
                }
            });
            return query
        };
        module.exports = remoteQueryImpl
    },
    /*!**********************************************************************************!*\
      !*** ./artifacts/transpiled/ui/collection/ui.collection_widget.edit.strategy.js ***!
      \**********************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var $ = __webpack_require__( /*! ../../core/renderer */ 2);
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var equalByValue = __webpack_require__( /*! ../../core/utils/common */ 3).equalByValue;
        var abstract = Class.abstract;
        var EditStrategy = Class.inherit({
            ctor: function(collectionWidget) {
                this._collectionWidget = collectionWidget
            },
            getIndexByItemData: abstract,
            getItemDataByIndex: abstract,
            getKeysByItems: abstract,
            getItemsByKeys: abstract,
            itemsGetter: abstract,
            getKeyByIndex: function(index) {
                var resultIndex = this._denormalizeItemIndex(index);
                return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0]
            },
            _equalKeys: function(key1, key2) {
                if (this._collectionWidget._isKeySpecified()) {
                    return equalByValue(key1, key2)
                } else {
                    return key1 === key2
                }
            },
            beginCache: function() {
                this._cache = {}
            },
            endCache: function() {
                this._cache = null
            },
            getIndexByKey: abstract,
            getNormalizedIndex: function(value) {
                if (this._isNormalizedItemIndex(value)) {
                    return value
                }
                if (this._isItemIndex(value)) {
                    return this._normalizeItemIndex(value)
                }
                if (this._isDOMNode(value)) {
                    return this._getNormalizedItemIndex(value)
                }
                return this._normalizeItemIndex(this.getIndexByItemData(value))
            },
            getIndex: function(value) {
                if (this._isNormalizedItemIndex(value)) {
                    return this._denormalizeItemIndex(value)
                }
                if (this._isItemIndex(value)) {
                    return value
                }
                if (this._isDOMNode(value)) {
                    return this._denormalizeItemIndex(this._getNormalizedItemIndex(value))
                }
                return this.getIndexByItemData(value)
            },
            getItemElement: function(value) {
                if (this._isNormalizedItemIndex(value)) {
                    return this._getItemByNormalizedIndex(value)
                }
                if (this._isItemIndex(value)) {
                    return this._getItemByNormalizedIndex(this._normalizeItemIndex(value))
                }
                if (this._isDOMNode(value)) {
                    return $(value)
                }
                var normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value));
                return this._getItemByNormalizedIndex(normalizedItemIndex)
            },
            deleteItemAtIndex: abstract,
            itemPlacementFunc: function(movingIndex, destinationIndex) {
                return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before"
            },
            moveItemAtIndexToIndex: abstract,
            _isNormalizedItemIndex: function(index) {
                return "number" === typeof index && Math.round(index) === index
            },
            _isDOMNode: function(value) {
                var $value;
                try {
                    $value = $(value)
                } catch (error) {
                    return false
                }
                return $value && $value.length && $value.get(0).nodeType
            },
            _isItemIndex: abstract,
            _getNormalizedItemIndex: abstract,
            _normalizeItemIndex: abstract,
            _denormalizeItemIndex: abstract,
            _getItemByNormalizedIndex: abstract,
            _itemsFromSameParent: abstract
        });
        module.exports = EditStrategy
    },
    /*!**************************************************************************!*\
      !*** ./artifacts/transpiled/ui/selection/selection.strategy.deferred.js ***!
      \**************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var SelectionStrategy = __webpack_require__( /*! ./selection.strategy */ 289);
        var errors = __webpack_require__( /*! ../widget/ui.errors */ 18);
        var dataQuery = __webpack_require__( /*! ../../data/query */ 45);
        var Deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6).Deferred;
        module.exports = SelectionStrategy.inherit({
            getSelectedItems: function() {
                return this._loadFilteredData(this.options.selectionFilter)
            },
            getSelectedItemKeys: function() {
                var d = new Deferred;
                var that = this;
                var key = this.options.key();
                var select = typeUtils.isString(key) ? [key] : key;
                this._loadFilteredData(this.options.selectionFilter, null, select).done(function(items) {
                    var keys = items.map(function(item) {
                        return that.options.keyOf(item)
                    });
                    d.resolve(keys)
                }).fail(d.reject);
                return d.promise()
            },
            selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
                if (isSelectAll) {
                    var filter = this.options.filter();
                    if (!filter) {
                        this._setOption("selectionFilter", isDeselect ? [] : null)
                    } else {
                        this._addSelectionFilter(isDeselect, filter, isSelectAll)
                    }
                } else {
                    if (!preserve) {
                        this._setOption("selectionFilter", [])
                    }
                    for (var i = 0; i < keys.length; i++) {
                        if (isDeselect) {
                            this.removeSelectedItem(keys[i])
                        } else {
                            this.addSelectedItem(keys[i])
                        }
                    }
                }
                this.onSelectionChanged();
                return (new Deferred).resolve()
            },
            setSelectedItems: function(keys) {
                this._setOption("selectionFilter", null);
                for (var i = 0; i < keys.length; i++) {
                    this.addSelectedItem(keys[i])
                }
            },
            isItemDataSelected: function(itemData) {
                return this.isItemKeySelected(itemData)
            },
            isItemKeySelected: function(itemData) {
                var selectionFilter = this.options.selectionFilter;
                if (!selectionFilter) {
                    return true
                }
                return !!dataQuery([itemData]).filter(selectionFilter).toArray().length
            },
            _getFilterByKey: function(key) {
                var keyField = this.options.key();
                var filter = [keyField, "=", key];
                if (Array.isArray(keyField)) {
                    filter = [];
                    for (var i = 0; i < keyField.length; i++) {
                        filter.push([keyField[i], "=", key[keyField[i]]]);
                        if (i !== keyField.length - 1) {
                            filter.push("and")
                        }
                    }
                }
                return filter
            },
            addSelectedItem: function(key) {
                var filter = this._getFilterByKey(key);
                this._addSelectionFilter(false, filter)
            },
            removeSelectedItem: function(key) {
                var filter = this._getFilterByKey(key);
                this._addSelectionFilter(true, filter)
            },
            validate: function() {
                var key = this.options.key;
                if (key && void 0 === key()) {
                    throw errors.Error("E1042", "Deferred selection")
                }
            },
            _findSubFilter: function(selectionFilter, filter) {
                if (!selectionFilter) {
                    return -1
                }
                var filterString = JSON.stringify(filter);
                for (var index = 0; index < selectionFilter.length; index++) {
                    var subFilter = selectionFilter[index];
                    if (subFilter && JSON.stringify(subFilter) === filterString) {
                        return index
                    }
                }
                return -1
            },
            _isLastSubFilter: function(selectionFilter, filter) {
                if (selectionFilter && filter) {
                    return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter)
                }
                return false
            },
            _addFilterOperator: function(selectionFilter, filterOperator) {
                if (selectionFilter.length > 1 && typeUtils.isString(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
                    selectionFilter = [selectionFilter]
                }
                if (selectionFilter.length) {
                    selectionFilter.push(filterOperator)
                }
                return selectionFilter
            },
            _denormalizeFilter: function(filter) {
                if (filter && typeUtils.isString(filter[0])) {
                    filter = [filter]
                }
                return filter
            },
            _addSelectionFilter: function(isDeselect, filter, isSelectAll) {
                var that = this;
                var currentFilter = isDeselect ? ["!", filter] : filter;
                var currentOperation = isDeselect ? "and" : "or";
                var needAddFilter = true;
                var selectionFilter = that.options.selectionFilter || [];
                selectionFilter = that._denormalizeFilter(selectionFilter);
                if (selectionFilter && selectionFilter.length) {
                    that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
                    var filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);
                    var isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
                    needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
                    if (needAddFilter) {
                        selectionFilter = that._addFilterOperator(selectionFilter, currentOperation)
                    }
                }
                if (needAddFilter) {
                    selectionFilter.push(currentFilter)
                }
                selectionFilter = that._normalizeFilter(selectionFilter);
                that._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter)
            },
            _normalizeFilter: function(filter) {
                if (filter && 1 === filter.length) {
                    filter = filter[0]
                }
                return filter
            },
            _removeFilterByIndex: function(filter, filterIndex, isSelectAll) {
                var operation = filter[1];
                if (filterIndex > 0) {
                    filter.splice(filterIndex - 1, 2)
                } else {
                    filter.splice(filterIndex, 2)
                }
                if (isSelectAll && "and" === operation) {
                    filter.splice(0, filter.length)
                }
            },
            _isSimpleKeyFilter: function(filter, key) {
                return 3 === filter.length && filter[0] === key && "=" === filter[1]
            },
            _isKeyFilter: function(filter) {
                if (2 === filter.length && "!" === filter[0]) {
                    return this._isKeyFilter(filter[1])
                }
                var keyField = this.options.key();
                if (Array.isArray(keyField)) {
                    if (filter.length !== 2 * keyField.length - 1) {
                        return false
                    }
                    for (var i = 0; i < keyField.length; i++) {
                        if (i > 0 && "and" !== filter[i]) {
                            return false
                        }
                        if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
                            return false
                        }
                    }
                    return true
                }
                return this._isSimpleKeyFilter(filter, keyField)
            },
            _hasKeyFiltersOnlyStartingFromIndex: function(selectionFilter, filterIndex) {
                if (filterIndex >= 0) {
                    for (var i = filterIndex; i < selectionFilter.length; i++) {
                        if ("string" !== typeof selectionFilter[i] && !this._isKeyFilter(selectionFilter[i])) {
                            return false
                        }
                    }
                    return true
                }
                return false
            },
            _removeSameFilter: function(selectionFilter, filter, inverted, isSelectAll) {
                filter = inverted ? ["!", filter] : filter;
                if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
                    selectionFilter.splice(0, selectionFilter.length);
                    return 0
                }
                var filterIndex = this._findSubFilter(selectionFilter, filter);
                if (filterIndex >= 0) {
                    this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
                    return filterIndex
                } else {
                    for (var i = 0; i < selectionFilter.length; i++) {
                        if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
                            var _filterIndex = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
                            if (_filterIndex >= 0) {
                                if (!selectionFilter[i].length) {
                                    this._removeFilterByIndex(selectionFilter, i, isSelectAll)
                                } else {
                                    if (1 === selectionFilter[i].length) {
                                        selectionFilter[i] = selectionFilter[i][0]
                                    }
                                }
                                return _filterIndex
                            }
                        }
                    }
                    return -1
                }
            },
            getSelectAllState: function() {
                var filter = this.options.filter();
                var selectionFilter = this.options.selectionFilter;
                if (!selectionFilter) {
                    return true
                }
                if (!selectionFilter.length) {
                    return false
                }
                if (!filter || !filter.length) {
                    return
                }
                selectionFilter = this._denormalizeFilter(selectionFilter);
                if (this._isLastSubFilter(selectionFilter, filter)) {
                    return true
                }
                if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
                    return false
                }
                return
            }
        })
    },
    /*!**************************************************************************!*\
      !*** ./artifacts/transpiled/ui/selection/selection.strategy.standard.js ***!
      \**************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var commonUtils = __webpack_require__( /*! ../../core/utils/common */ 3);
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var isDefined = typeUtils.isDefined;
        var getKeyHash = commonUtils.getKeyHash;
        var dataQuery = __webpack_require__( /*! ../../data/query */ 45);
        var deferredUtils = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var SelectionFilterCreator = __webpack_require__( /*! ../../core/utils/selection_filter */ 302).SelectionFilterCreator;
        var when = deferredUtils.when;
        var Deferred = deferredUtils.Deferred;
        var errors = __webpack_require__( /*! ../widget/ui.errors */ 18);
        var SelectionStrategy = __webpack_require__( /*! ./selection.strategy */ 289);
        module.exports = SelectionStrategy.inherit({
            ctor: function(options) {
                this.callBase(options);
                this._initSelectedItemKeyHash()
            },
            _initSelectedItemKeyHash: function() {
                this._setOption("keyHashIndices", this.options.equalByReference ? null : {})
            },
            getSelectedItemKeys: function() {
                return this.options.selectedItemKeys.slice(0)
            },
            getSelectedItems: function() {
                return this.options.selectedItems.slice(0)
            },
            _preserveSelectionUpdate: function(items, isDeselect) {
                var keyOf = this.options.keyOf;
                var keyIndicesToRemoveMap;
                var keyIndex;
                var i;
                if (!keyOf) {
                    return
                }
                var isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
                if (isBatchDeselect) {
                    keyIndicesToRemoveMap = {}
                }
                for (i = 0; i < items.length; i++) {
                    var item = items[i];
                    var key = keyOf(item);
                    if (isDeselect) {
                        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap);
                        if (keyIndicesToRemoveMap && keyIndex >= 0) {
                            keyIndicesToRemoveMap[keyIndex] = true
                        }
                    } else {
                        this.addSelectedItem(key, item)
                    }
                }
                if (isBatchDeselect) {
                    this._batchRemoveSelectedItems(keyIndicesToRemoveMap)
                }
            },
            _batchRemoveSelectedItems: function(keyIndicesToRemoveMap) {
                var selectedItemKeys = this.options.selectedItemKeys.slice(0);
                var selectedItems = this.options.selectedItems.slice(0);
                this.options.selectedItemKeys.length = 0;
                this.options.selectedItems.length = 0;
                for (var i = 0; i < selectedItemKeys.length; i++) {
                    if (!keyIndicesToRemoveMap[i]) {
                        this.options.selectedItemKeys.push(selectedItemKeys[i]);
                        this.options.selectedItems.push(selectedItems[i])
                    }
                }
                this._initSelectedItemKeyHash();
                this.updateSelectedItemKeyHash(this.options.selectedItemKeys)
            },
            _loadSelectedItemsCore: function(keys, isDeselect, isSelectAll) {
                var deferred = new Deferred;
                var key = this.options.key();
                if (!keys.length && !isSelectAll) {
                    deferred.resolve([]);
                    return deferred
                }
                var filter = this.options.filter();
                if (isSelectAll && isDeselect && !filter) {
                    deferred.resolve(this.getSelectedItems());
                    return deferred
                }
                var selectionFilterCreator = new SelectionFilterCreator(keys, isSelectAll);
                var combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter);
                var deselectedItems = [];
                if (isDeselect) {
                    deselectedItems = combinedFilter ? dataQuery(this.options.selectedItems).filter(combinedFilter).toArray() : this.options.selectedItems.slice(0)
                }
                var filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
                var localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
                filteredItems = filteredItems.filter(localFilter);
                if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
                    deferred.resolve(filteredItems)
                } else {
                    deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll)
                }
                return deferred
            },
            _replaceSelectionUpdate: function(items) {
                var internalKeys = [];
                var keyOf = this.options.keyOf;
                if (!keyOf) {
                    return
                }
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var key = keyOf(item);
                    internalKeys.push(key)
                }
                this.setSelectedItems(internalKeys, items)
            },
            _warnOnIncorrectKeys: function(keys) {
                var allowNullValue = this.options.allowNullValue;
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if ((!allowNullValue || null !== key) && !this.isItemKeySelected(key)) {
                        errors.log("W1002", key)
                    }
                }
            },
            _loadSelectedItems: function(keys, isDeselect, isSelectAll) {
                var that = this;
                var deferred = new Deferred;
                when(that._lastLoadDeferred).always(function() {
                    that._loadSelectedItemsCore(keys, isDeselect, isSelectAll).done(deferred.resolve).fail(deferred.reject)
                });
                that._lastLoadDeferred = deferred;
                return deferred
            },
            selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
                var that = this;
                var deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll);
                deferred.done(function(items) {
                    if (preserve) {
                        that._preserveSelectionUpdate(items, isDeselect)
                    } else {
                        that._replaceSelectionUpdate(items)
                    }
                    if (!isSelectAll && !isDeselect) {
                        that._warnOnIncorrectKeys(keys)
                    }
                    that.onSelectionChanged()
                });
                return deferred
            },
            addSelectedItem: function(key, itemData) {
                if (isDefined(itemData) && itemData.disabled) {
                    if (this.options.disabledItemKeys.indexOf(key) === -1) {
                        this.options.disabledItemKeys.push(key)
                    }
                    return
                }
                var keyHash = this._getKeyHash(key);
                if (this._indexOfSelectedItemKey(keyHash) === -1) {
                    if (!typeUtils.isObject(keyHash) && this.options.keyHashIndices) {
                        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length]
                    }
                    this.options.selectedItemKeys.push(key);
                    this.options.addedItemKeys.push(key);
                    this.options.addedItems.push(itemData);
                    this.options.selectedItems.push(itemData)
                }
            },
            _getSelectedIndexByKey: function(key, ignoreIndicesMap) {
                var selectedItemKeys = this.options.selectedItemKeys;
                for (var index = 0; index < selectedItemKeys.length; index++) {
                    if ((!ignoreIndicesMap || !ignoreIndicesMap[index]) && this.equalKeys(selectedItemKeys[index], key)) {
                        return index
                    }
                }
                return -1
            },
            _getSelectedIndexByHash: function(key, ignoreIndicesMap) {
                var indices = this.options.keyHashIndices[key];
                if (indices && indices.length > 1 && ignoreIndicesMap) {
                    indices = indices.filter(function(index) {
                        return !ignoreIndicesMap[index]
                    })
                }
                return indices && indices[0] >= 0 ? indices[0] : -1
            },
            _indexOfSelectedItemKey: function(key, ignoreIndicesMap) {
                var selectedIndex;
                if (this.options.equalByReference) {
                    selectedIndex = this.options.selectedItemKeys.indexOf(key)
                } else {
                    if (typeUtils.isObject(key)) {
                        selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap)
                    } else {
                        selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap)
                    }
                }
                return selectedIndex
            },
            _shiftSelectedKeyIndices: function(keyIndex) {
                for (var currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
                    var currentKey = this.options.selectedItemKeys[currentKeyIndex];
                    var currentKeyHash = getKeyHash(currentKey);
                    var currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
                    if (!currentKeyIndices) {
                        continue
                    }
                    for (var i = 0; i < currentKeyIndices.length; i++) {
                        if (currentKeyIndices[i] > keyIndex) {
                            currentKeyIndices[i]--
                        }
                    }
                }
            },
            removeSelectedItem: function(key, keyIndicesToRemoveMap) {
                var keyHash = this._getKeyHash(key);
                var isBatchDeselect = !!keyIndicesToRemoveMap;
                var keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
                if (keyIndex < 0) {
                    return keyIndex
                }
                this.options.removedItemKeys.push(key);
                this.options.removedItems.push(this.options.selectedItems[keyIndex]);
                if (isBatchDeselect) {
                    return keyIndex
                }
                this.options.selectedItemKeys.splice(keyIndex, 1);
                this.options.selectedItems.splice(keyIndex, 1);
                if (typeUtils.isObject(keyHash) || !this.options.keyHashIndices) {
                    return keyIndex
                }
                var keyIndices = this.options.keyHashIndices[keyHash];
                if (!keyIndices) {
                    return keyIndex
                }
                keyIndices.shift();
                if (!keyIndices.length) {
                    delete this.options.keyHashIndices[keyHash]
                }
                this._shiftSelectedKeyIndices(keyIndex);
                return keyIndex
            },
            _updateAddedItemKeys: function(keys, items) {
                for (var i = 0; i < keys.length; i++) {
                    if (!this.isItemKeySelected(keys[i])) {
                        this.options.addedItemKeys.push(keys[i]);
                        this.options.addedItems.push(items[i])
                    }
                }
            },
            _updateRemovedItemKeys: function(keys, oldSelectedKeys, oldSelectedItems) {
                for (var i = 0; i < oldSelectedKeys.length; i++) {
                    if (!this.isItemKeySelected(oldSelectedKeys[i])) {
                        this.options.removedItemKeys.push(oldSelectedKeys[i]);
                        this.options.removedItems.push(oldSelectedItems[i])
                    }
                }
            },
            _getKeyHash: function(key) {
                return this.options.equalByReference ? key : getKeyHash(key)
            },
            setSelectedItems: function(keys, items) {
                this._updateAddedItemKeys(keys, items);
                var oldSelectedKeys = this.options.selectedItemKeys;
                var oldSelectedItems = this.options.selectedItems;
                if (!this.options.equalByReference) {
                    this._initSelectedItemKeyHash();
                    this.updateSelectedItemKeyHash(keys)
                }
                this._setOption("selectedItemKeys", keys);
                this._setOption("selectedItems", items);
                this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems)
            },
            isItemDataSelected: function(itemData) {
                var key = this.options.keyOf(itemData);
                return this.isItemKeySelected(key)
            },
            isItemKeySelected: function(key) {
                var keyHash = this._getKeyHash(key);
                var index = this._indexOfSelectedItemKey(keyHash);
                return index !== -1
            },
            getSelectAllState: function(visibleOnly) {
                if (visibleOnly) {
                    return this._getVisibleSelectAllState()
                } else {
                    return this._getFullSelectAllState()
                }
            }
        })
    },
    /*!***********************************************************************!*\
      !*** ./artifacts/transpiled/integration/angular/event_registrator.js ***!
      \***********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _event_registrator_callbacks = __webpack_require__( /*! ../../events/core/event_registrator_callbacks */ 130);
        var _event_registrator_callbacks2 = _interopRequireDefault(_event_registrator_callbacks);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _module = __webpack_require__( /*! ./module */ 189);
        var _module2 = _interopRequireDefault(_module);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        _event_registrator_callbacks2.default.add(function(name) {
            var ngEventName = name.slice(0, 2) + name.charAt(2).toUpperCase() + name.slice(3);
            _module2.default.directive(ngEventName, ["$parse", function($parse) {
                return function(scope, element, attr) {
                    var attrValue = attr[ngEventName].trim();
                    var handler;
                    var eventOptions = {};
                    if ("{" === attrValue.charAt(0)) {
                        eventOptions = scope.$eval(attrValue);
                        handler = $parse(eventOptions.execute)
                    } else {
                        handler = $parse(attr[ngEventName])
                    }
                    _events_engine2.default.on(element, name, eventOptions, function(e) {
                        scope.$apply(function() {
                            handler(scope, {
                                $event: e
                            })
                        })
                    })
                }
            }])
        })
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/integration/angular/components.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Callbacks = __webpack_require__( /*! ../../core/utils/callbacks */ 27);
        var ngModule = __webpack_require__( /*! ./module */ 189);
        ngModule.service("dxDigestCallbacks", ["$rootScope", function($rootScope) {
            var begin = Callbacks();
            var prioritizedEnd = Callbacks();
            var end = Callbacks();
            var digestPhase = false;
            $rootScope.$watch(function() {
                if (digestPhase) {
                    return
                }
                digestPhase = true;
                begin.fire();
                $rootScope.$$postDigest(function() {
                    digestPhase = false;
                    prioritizedEnd.fire();
                    end.fire()
                })
            });
            return {
                begin: {
                    add: function(callback) {
                        if (digestPhase) {
                            callback()
                        }
                        begin.add(callback)
                    },
                    remove: begin.remove.bind(begin)
                },
                end: {
                    add: end.add.bind(end),
                    addPrioritized: prioritizedEnd.add.bind(prioritizedEnd),
                    remove: end.remove.bind(end)
                }
            }
        }])
    },
    /*!**********************************************************************!*\
      !*** ./artifacts/transpiled/integration/angular/action_executors.js ***!
      \**********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _action = __webpack_require__( /*! ../../core/action */ 105);
        var _action2 = _interopRequireDefault(_action);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        _action2.default.registerExecutor({
            ngExpression: {
                execute: function(e) {
                    if ("string" === typeof e.action) {
                        e.context.$eval(e.action)
                    }
                }
            }
        })
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var ko = __webpack_require__( /*! knockout */ 62);
        if (ko) {
            var errors = __webpack_require__( /*! ../core/errors */ 22);
            var compareVersion = __webpack_require__( /*! ../core/utils/version */ 60).compare;
            if (compareVersion(ko.version, [2, 3]) < 0) {
                throw errors.Error("E0013")
            }
            __webpack_require__( /*! ./knockout/component_registrator */ 505);
            __webpack_require__( /*! ./knockout/event_registrator */ 507);
            __webpack_require__( /*! ./knockout/components */ 508);
            __webpack_require__( /*! ./knockout/validation */ 509);
            __webpack_require__( /*! ./knockout/variable_wrapper_utils */ 510);
            __webpack_require__( /*! ./knockout/clean_node */ 511);
            __webpack_require__( /*! ./knockout/clean_node_old */ 512)
        }
    },
    /*!****************************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/component_registrator.js ***!
      \****************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _knockout = __webpack_require__( /*! knockout */ 62);
        var _knockout2 = _interopRequireDefault(_knockout);
        var _callbacks = __webpack_require__( /*! ../../core/utils/callbacks */ 27);
        var _callbacks2 = _interopRequireDefault(_callbacks);
        var _errors = __webpack_require__( /*! ../../core/errors */ 22);
        var _errors2 = _interopRequireDefault(_errors);
        var _inflector = __webpack_require__( /*! ../../core/utils/inflector */ 34);
        var _inflector2 = _interopRequireDefault(_inflector);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _component_registrator_callbacks = __webpack_require__( /*! ../../core/component_registrator_callbacks */ 159);
        var _component_registrator_callbacks2 = _interopRequireDefault(_component_registrator_callbacks);
        var _ui = __webpack_require__( /*! ../../ui/widget/ui.widget */ 17);
        var _ui2 = _interopRequireDefault(_ui);
        var _template = __webpack_require__( /*! ./template */ 506);
        var _editor = __webpack_require__( /*! ../../ui/editor/editor */ 48);
        var _editor2 = _interopRequireDefault(_editor);
        var _locker = __webpack_require__( /*! ../../core/utils/locker */ 288);
        var _locker2 = _interopRequireDefault(_locker);
        var _utils = __webpack_require__( /*! ./utils */ 290);
        var _config = __webpack_require__( /*! ../../core/config */ 30);
        var _config2 = _interopRequireDefault(_config);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var LOCKS_DATA_KEY = "dxKoLocks";
        var CREATED_WITH_KO_DATA_KEY = "dxKoCreation";
        var editorsBindingHandlers = [];
        var registerComponentKoBinding = function(componentName, componentClass) {
            if (componentClass.subclassOf(_editor2.default)) {
                editorsBindingHandlers.push(componentName)
            }
            _knockout2.default.bindingHandlers[componentName] = {
                init: function(domNode, valueAccessor) {
                    var $element = (0, _renderer2.default)(domNode);
                    var optionChangedCallbacks = (0, _callbacks2.default)();
                    var optionsByReference = {};
                    var component;
                    var knockoutConfig = (0, _config2.default)().knockout;
                    var isBindingPropertyPredicateName = knockoutConfig && knockoutConfig.isBindingPropertyPredicateName;
                    var isBindingPropertyPredicate;
                    var ctorOptions = {
                        onInitializing: function() {
                            optionsByReference = this._getOptionsByReference();
                            _knockout2.default.computed(function() {
                                var model = _knockout2.default.unwrap(valueAccessor());
                                if (component) {
                                    component.beginUpdate()
                                }
                                isBindingPropertyPredicate = isBindingPropertyPredicateName && model && model[isBindingPropertyPredicateName];
                                unwrapModel(model);
                                if (component) {
                                    component.endUpdate()
                                }
                            }, null, {
                                disposeWhenNodeIsRemoved: domNode
                            });
                            component = this
                        },
                        modelByElement: function($element) {
                            if ($element.length) {
                                var node = (0, _utils.getClosestNodeWithContext)($element.get(0));
                                return _knockout2.default.dataFor(node)
                            }
                        },
                        nestedComponentOptions: function(component) {
                            return {
                                modelByElement: component.option("modelByElement"),
                                nestedComponentOptions: component.option("nestedComponentOptions")
                            }
                        },
                        _optionChangedCallbacks: optionChangedCallbacks,
                        integrationOptions: {
                            watchMethod: function(fn, callback, options) {
                                options = options || {};
                                var skipCallback = options.skipImmediate;
                                var watcher = _knockout2.default.computed(function() {
                                    var newValue = _knockout2.default.unwrap(fn());
                                    if (!skipCallback) {
                                        callback(newValue)
                                    }
                                    skipCallback = false
                                });
                                return function() {
                                    watcher.dispose()
                                }
                            },
                            templates: {
                                "dx-polymorph-widget": {
                                    render: function(options) {
                                        var widgetName = _knockout2.default.utils.unwrapObservable(options.model.widget);
                                        if (!widgetName) {
                                            return
                                        }
                                        if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
                                            var deprecatedName = widgetName;
                                            widgetName = _inflector2.default.camelize("dx-" + widgetName);
                                            _errors2.default.log("W0001", "dxToolbar - 'widget' item field", deprecatedName, "16.1", "Use: '" + widgetName + "' instead")
                                        }
                                        var markup = (0, _renderer2.default)("<div>").attr("data-bind", widgetName + ": options").get(0);
                                        (0, _renderer2.default)(options.container).append(markup);
                                        _knockout2.default.applyBindings(options.model, markup)
                                    }
                                }
                            },
                            createTemplate: function(element) {
                                return new _template.KoTemplate(element)
                            }
                        }
                    };
                    var optionNameToModelMap = {};
                    var applyModelValueToOption = function(optionName, modelValue, unwrap) {
                        var locks = $element.data(LOCKS_DATA_KEY);
                        var optionValue = unwrap ? _knockout2.default.unwrap(modelValue) : modelValue;
                        if (_knockout2.default.isWriteableObservable(modelValue)) {
                            optionNameToModelMap[optionName] = modelValue
                        }
                        if (component) {
                            if (locks.locked(optionName)) {
                                return
                            }
                            locks.obtain(optionName);
                            try {
                                if (_knockout2.default.ignoreDependencies) {
                                    _knockout2.default.ignoreDependencies(component.option, component, [optionName, optionValue])
                                } else {
                                    component.option(optionName, optionValue)
                                }
                            } finally {
                                locks.release(optionName)
                            }
                        } else {
                            ctorOptions[optionName] = optionValue
                        }
                    };
                    var handleOptionChanged = function(args) {
                        var optionName = args.fullName;
                        var optionValue = args.value;
                        if (!(optionName in optionNameToModelMap)) {
                            return
                        }
                        var $element = this._$element;
                        var locks = $element.data(LOCKS_DATA_KEY);
                        if (locks.locked(optionName)) {
                            return
                        }
                        locks.obtain(optionName);
                        try {
                            optionNameToModelMap[optionName](optionValue)
                        } finally {
                            locks.release(optionName)
                        }
                    };
                    var createComponent = function() {
                        optionChangedCallbacks.add(handleOptionChanged);
                        $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new _locker2.default);
                        new componentClass($element, ctorOptions);
                        ctorOptions = null
                    };
                    var unwrapModelValue = function(currentModel, propertyName, propertyPath) {
                        if (propertyPath === isBindingPropertyPredicateName) {
                            return
                        }
                        if (!isBindingPropertyPredicate || isBindingPropertyPredicate(propertyPath, propertyName, currentModel)) {
                            var unwrappedPropertyValue;
                            _knockout2.default.computed(function() {
                                var propertyValue = currentModel[propertyName];
                                applyModelValueToOption(propertyPath, propertyValue, true);
                                unwrappedPropertyValue = _knockout2.default.unwrap(propertyValue)
                            }, null, {
                                disposeWhenNodeIsRemoved: domNode
                            });
                            if ((0, _type.isPlainObject)(unwrappedPropertyValue)) {
                                if (!optionsByReference[propertyPath]) {
                                    unwrapModel(unwrappedPropertyValue, propertyPath)
                                }
                            }
                        } else {
                            applyModelValueToOption(propertyPath, currentModel[propertyName], false)
                        }
                    };

                    function unwrapModel(model, propertyPath) {
                        for (var propertyName in model) {
                            if (Object.prototype.hasOwnProperty.call(model, propertyName)) {
                                unwrapModelValue(model, propertyName, propertyPath ? [propertyPath, propertyName].join(".") : propertyName)
                            }
                        }
                    }
                    createComponent();
                    return {
                        controlsDescendantBindings: componentClass.subclassOf(_ui2.default)
                    }
                }
            };
            if ("dxValidator" === componentName) {
                _knockout2.default.bindingHandlers.dxValidator.after = editorsBindingHandlers
            }
        };
        _component_registrator_callbacks2.default.add(function(name, componentClass) {
            registerComponentKoBinding(name, componentClass)
        })
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/template.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.KoTemplate = void 0;
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _knockout = __webpack_require__( /*! knockout */ 62);
        var _knockout2 = _interopRequireDefault(_knockout);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _template_base = __webpack_require__( /*! ../../core/templates/template_base */ 78);
        var _dom = __webpack_require__( /*! ../../core/utils/dom */ 11);
        var _utils = __webpack_require__( /*! ./utils */ 290);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    descriptor.writable = true
                }
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps)
            }
            if (staticProps) {
                _defineProperties(Constructor, staticProps)
            }
            return Constructor
        }

        function _inherits(subClass, superClass) {
            if ("function" !== typeof superClass && null !== superClass) {
                throw new TypeError("Super expression must either be null or a function")
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) {
                _setPrototypeOf(subClass, superClass)
            }
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o
            };
            return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                    result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (call && ("object" === _typeof(call) || "function" === typeof call)) {
                return call
            }
            return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
            if (void 0 === self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return self
        }

        function _isNativeReflectConstruct() {
            if ("undefined" === typeof Reflect || !Reflect.construct) {
                return false
            }
            if (Reflect.construct.sham) {
                return false
            }
            if ("function" === typeof Proxy) {
                return true
            }
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                return true
            } catch (e) {
                return false
            }
        }

        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
            };
            return _getPrototypeOf(o)
        }
        var getParentContext = function(data) {
            var parentNode = (0, _dom_adapter.createElement)("div");
            _knockout2.default.applyBindingsToNode(parentNode, null, data);
            var parentContext = _knockout2.default.contextFor(parentNode);
            _knockout2.default.cleanNode(parentNode);
            return parentContext
        };
        exports.KoTemplate = function(_TemplateBase) {
            _inherits(KoTemplate, _TemplateBase);
            var _super = _createSuper(KoTemplate);

            function KoTemplate(element) {
                var _this;
                _classCallCheck(this, KoTemplate);
                _this = _super.call(this);
                _this._element = element;
                _this._template = (0, _renderer2.default)("<div>").append((0, _dom.normalizeTemplateElement)(element));
                _this._registerKoTemplate();
                return _this
            }
            _createClass(KoTemplate, [{
                key: "_registerKoTemplate",
                value: function() {
                    var template = this._template.get(0);
                    new _knockout2.default.templateSources.anonymousTemplate(template).nodes(template)
                }
            }, {
                key: "_prepareDataForContainer",
                value: function(data, container) {
                    if (container && container.length) {
                        var node = (0, _utils.getClosestNodeWithContext)(container.get(0));
                        var containerContext = _knockout2.default.contextFor(node);
                        data = void 0 !== data ? data : _knockout2.default.dataFor(node) || {};
                        if (containerContext) {
                            return data === containerContext.$data ? containerContext : containerContext.createChildContext(data)
                        }
                    }
                    return getParentContext(data).createChildContext(data)
                }
            }, {
                key: "_renderCore",
                value: function(options) {
                    var model = this._prepareDataForContainer(options.model, (0, _renderer2.default)(options.container));
                    if ((0, _type.isDefined)(options.index)) {
                        model.$index = options.index
                    }
                    var $placeholder = (0, _renderer2.default)("<div>").appendTo(options.container);
                    var $result;
                    _knockout2.default.renderTemplate(this._template.get(0), model, {
                        afterRender: function(nodes) {
                            $result = (0, _renderer2.default)(nodes)
                        }
                    }, $placeholder.get(0), "replaceNode");
                    return $result
                }
            }, {
                key: "source",
                value: function() {
                    return (0, _renderer2.default)(this._element).clone()
                }
            }, {
                key: "dispose",
                value: function() {
                    this._template.remove()
                }
            }]);
            return KoTemplate
        }(_template_base.TemplateBase)
    },
    /*!************************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/event_registrator.js ***!
      \************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var _renderer = __webpack_require__( /*! ../../core/renderer */ 2);
        var _renderer2 = _interopRequireDefault(_renderer);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _knockout = __webpack_require__( /*! knockout */ 62);
        var _knockout2 = _interopRequireDefault(_knockout);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _event_registrator_callbacks = __webpack_require__( /*! ../../events/core/event_registrator_callbacks */ 130);
        var _event_registrator_callbacks2 = _interopRequireDefault(_event_registrator_callbacks);
        var _utils = __webpack_require__( /*! ../../events/utils */ 8);
        var eventUtils = _interopRequireWildcard(_utils);

        function _getRequireWildcardCache() {
            if ("function" !== typeof WeakMap) {
                return null
            }
            var cache = new WeakMap;
            _getRequireWildcardCache = function() {
                return cache
            };
            return cache
        }

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            }
            if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
                return {
                    "default": obj
                }
            }
            var cache = _getRequireWildcardCache();
            if (cache && cache.has(obj)) {
                return cache.get(obj)
            }
            var newObj = {};
            var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                        Object.defineProperty(newObj, key, desc)
                    } else {
                        newObj[key] = obj[key]
                    }
                }
            }
            newObj.default = obj;
            if (cache) {
                cache.set(obj, newObj)
            }
            return newObj
        }

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        _event_registrator_callbacks2.default.add(function(name) {
            var koBindingEventName = eventUtils.addNamespace(name, name + "Binding");
            _knockout2.default.bindingHandlers[name] = {
                update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                    var $element = (0, _renderer2.default)(element);
                    var unwrappedValue = _knockout2.default.utils.unwrapObservable(valueAccessor());
                    var eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;
                    _events_engine2.default.off($element, koBindingEventName);
                    _events_engine2.default.on($element, koBindingEventName, (0, _type.isPlainObject)(unwrappedValue) ? unwrappedValue : {}, function(e) {
                        eventSource.call(viewModel, viewModel, e)
                    })
                }
            }
        })
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/components.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var ko = __webpack_require__( /*! knockout */ 62);
        var iconUtils = __webpack_require__( /*! ../../core/utils/icon */ 53);
        ko.bindingHandlers.dxControlsDescendantBindings = {
            init: function(_, valueAccessor) {
                return {
                    controlsDescendantBindings: ko.unwrap(valueAccessor())
                }
            }
        };
        ko.bindingHandlers.dxIcon = {
            init: function(element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()) || {};
                var iconElement = iconUtils.getImageContainer(options);
                ko.virtualElements.emptyNode(element);
                if (iconElement) {
                    ko.virtualElements.prepend(element, iconElement.get(0))
                }
            },
            update: function(element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()) || {};
                var iconElement = iconUtils.getImageContainer(options);
                ko.virtualElements.emptyNode(element);
                if (iconElement) {
                    ko.virtualElements.prepend(element, iconElement.get(0))
                }
            }
        };
        ko.virtualElements.allowedBindings.dxIcon = true
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/validation.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _class = __webpack_require__( /*! ../../core/class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _events_strategy = __webpack_require__( /*! ../../core/events_strategy */ 100);
        var _validation_engine = __webpack_require__( /*! ../../ui/validation_engine */ 92);
        var _validation_engine2 = _interopRequireDefault(_validation_engine);
        var _deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var _guid = __webpack_require__( /*! ../../core/guid */ 36);
        var _guid2 = _interopRequireDefault(_guid);
        var _knockout = __webpack_require__( /*! knockout */ 62);
        var _knockout2 = _interopRequireDefault(_knockout);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var VALIDATION_STATUS_VALID = "valid";
        var VALIDATION_STATUS_PENDING = "pending";
        var koDxValidator = _class2.default.inherit({
            ctor: function(target, _ref) {
                var _this = this;
                var name = _ref.name,
                    validationRules = _ref.validationRules;
                this.target = target;
                this.name = name;
                this.isValid = _knockout2.default.observable(true);
                this.validationError = _knockout2.default.observable();
                this.validationErrors = _knockout2.default.observable();
                this.validationStatus = _knockout2.default.observable(VALIDATION_STATUS_VALID);
                this._eventsStrategy = new _events_strategy.EventsStrategy(this);
                this.validationRules = (0, _iterator.map)(validationRules, function(rule, index) {
                    return (0, _extend.extend)({}, rule, {
                        validator: _this,
                        index: index
                    })
                });
                this._validationInfo = {
                    result: null,
                    deferred: null
                }
            },
            _updateValidationResult: function(result) {
                if (!this._validationInfo.result || this._validationInfo.result.id !== result.id) {
                    var complete = this._validationInfo.deferred && this._validationInfo.result.complete;
                    this._validationInfo.result = (0, _extend.extend)({}, result, {
                        complete: complete
                    })
                } else {
                    for (var prop in result) {
                        if ("id" !== prop && "complete" !== prop) {
                            this._validationInfo.result[prop] = result[prop]
                        }
                    }
                }
            },
            validate: function() {
                var _this2 = this;
                var currentResult = this._validationInfo && this._validationInfo.result;
                var value = this.target();
                if (currentResult && currentResult.status === VALIDATION_STATUS_PENDING && currentResult.value === value) {
                    return (0, _extend.extend)({}, currentResult)
                }
                var result = _validation_engine2.default.validate(value, this.validationRules, this.name);
                result.id = (new _guid2.default).toString();
                this._applyValidationResult(result);
                result.complete && result.complete.then(function(res) {
                    if (res.id === _this2._validationInfo.result.id) {
                        _this2._applyValidationResult(res)
                    }
                });
                return (0, _extend.extend)({}, this._validationInfo.result)
            },
            reset: function() {
                this.target(null);
                var result = {
                    id: null,
                    isValid: true,
                    brokenRule: null,
                    pendingRules: null,
                    status: VALIDATION_STATUS_VALID,
                    complete: null
                };
                this._applyValidationResult(result);
                return result
            },
            _applyValidationResult: function(result) {
                result.validator = this;
                this._updateValidationResult(result);
                this.target.dxValidator.isValid(this._validationInfo.result.isValid);
                this.target.dxValidator.validationError(this._validationInfo.result.brokenRule);
                this.target.dxValidator.validationErrors(this._validationInfo.result.brokenRules);
                this.target.dxValidator.validationStatus(this._validationInfo.result.status);
                if (result.status === VALIDATION_STATUS_PENDING) {
                    if (!this._validationInfo.deferred) {
                        this._validationInfo.deferred = new _deferred.Deferred;
                        this._validationInfo.result.complete = this._validationInfo.deferred.promise()
                    }
                    this._eventsStrategy.fireEvent("validating", [this._validationInfo.result]);
                    return
                }
                if (result.status !== VALIDATION_STATUS_PENDING) {
                    this._eventsStrategy.fireEvent("validated", [result]);
                    if (this._validationInfo.deferred) {
                        this._validationInfo.deferred.resolve(result);
                        this._validationInfo.deferred = null
                    }
                }
            },
            on: function(eventName, eventHandler) {
                this._eventsStrategy.on(eventName, eventHandler);
                return this
            },
            off: function(eventName, eventHandler) {
                this._eventsStrategy.off(eventName, eventHandler);
                return this
            }
        });
        _knockout2.default.extenders.dxValidator = function(target, option) {
            target.dxValidator = new koDxValidator(target, option);
            target.subscribe(target.dxValidator.validate.bind(target.dxValidator));
            return target
        };
        _validation_engine2.default.registerModelForValidation = function(model) {
            (0, _iterator.each)(model, function(name, member) {
                if (_knockout2.default.isObservable(member) && member.dxValidator) {
                    _validation_engine2.default.registerValidatorInGroup(model, member.dxValidator)
                }
            })
        };
        _validation_engine2.default.unregisterModelForValidation = function(model) {
            (0, _iterator.each)(model, function(name, member) {
                if (_knockout2.default.isObservable(member) && member.dxValidator) {
                    _validation_engine2.default.removeRegisteredValidator(model, member.dxValidator)
                }
            })
        };
        _validation_engine2.default.validateModel = _validation_engine2.default.validateGroup
    },
    /*!*****************************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/variable_wrapper_utils.js ***!
      \*****************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var ko = __webpack_require__( /*! knockout */ 62);
        var variableWrapper = __webpack_require__( /*! ../../core/utils/variable_wrapper */ 94);
        variableWrapper.inject({
            isWrapped: ko.isObservable,
            isWritableWrapped: ko.isWritableObservable,
            wrap: ko.observable,
            unwrap: function(value) {
                if (ko.isObservable(value)) {
                    return ko.utils.unwrapObservable(value)
                }
                return this.callBase(value)
            },
            assign: function(variable, value) {
                if (ko.isObservable(variable)) {
                    variable(value)
                } else {
                    this.callBase(variable, value)
                }
            }
        })
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/clean_node.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var elementData = __webpack_require__( /*! ../../core/element_data */ 41);
        var afterCleanData = elementData.afterCleanData;
        var strategyChanging = elementData.strategyChanging;
        var ko = __webpack_require__( /*! knockout */ 62);
        var compareVersion = __webpack_require__( /*! ../../core/utils/version */ 60).compare;
        var originalKOCleanExternalData = ko.utils.domNodeDisposal.cleanExternalData;
        var patchCleanData = function() {
            afterCleanData(function(nodes) {
                var i;
                for (i = 0; i < nodes.length; i++) {
                    nodes[i].cleanedByJquery = true
                }
                for (i = 0; i < nodes.length; i++) {
                    if (!nodes[i].cleanedByKo) {
                        ko.cleanNode(nodes[i])
                    }
                    delete nodes[i].cleanedByKo
                }
                for (i = 0; i < nodes.length; i++) {
                    delete nodes[i].cleanedByJquery
                }
            });
            ko.utils.domNodeDisposal.cleanExternalData = function(node) {
                node.cleanedByKo = true;
                if (!node.cleanedByJquery) {
                    elementData.cleanData([node])
                }
            }
        };
        var restoreOriginCleanData = function() {
            afterCleanData(function() {});
            ko.utils.domNodeDisposal.cleanExternalData = originalKOCleanExternalData
        };
        patchCleanData();
        strategyChanging.add(function(strategy) {
            var isJQuery = !!strategy.fn;
            if (isJQuery && compareVersion(strategy.fn.jquery, [2, 0]) < 0) {
                restoreOriginCleanData()
            }
        })
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/integration/knockout/clean_node_old.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var ko = __webpack_require__( /*! knockout */ 62);
        var compareVersion = __webpack_require__( /*! ../../core/utils/version */ 60).compare;
        var strategyChanging = __webpack_require__( /*! ../../core/element_data */ 41).strategyChanging;
        var patchCleanData = function(jQuery) {
            var cleanKoData = function(element, andSelf) {
                var cleanNode = function() {
                    ko.cleanNode(this)
                };
                if (andSelf) {
                    element.each(cleanNode)
                } else {
                    element.find("*").each(cleanNode)
                }
            };
            var originalEmpty = jQuery.fn.empty;
            jQuery.fn.empty = function() {
                cleanKoData(this, false);
                return originalEmpty.apply(this, arguments)
            };
            var originalRemove = jQuery.fn.remove;
            jQuery.fn.remove = function(selector, keepData) {
                if (!keepData) {
                    var subject = this;
                    if (selector) {
                        subject = subject.filter(selector)
                    }
                    cleanKoData(subject, true)
                }
                return originalRemove.call(this, selector, keepData)
            };
            var originalHtml = jQuery.fn.html;
            jQuery.fn.html = function(value) {
                if ("string" === typeof value) {
                    cleanKoData(this, false)
                }
                return originalHtml.apply(this, arguments)
            };
            var originalReplaceWith = jQuery.fn.replaceWith;
            jQuery.fn.replaceWith = function() {
                var result = originalReplaceWith.apply(this, arguments);
                if (!this.parent().length) {
                    cleanKoData(this, true)
                }
                return result
            }
        };
        strategyChanging.add(function(strategy) {
            var isJQuery = !!strategy.fn;
            if (isJQuery && compareVersion(strategy.fn.jquery, [2, 0]) < 0) {
                patchCleanData(strategy)
            }
        })
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/localization/globalize/message.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        __webpack_require__( /*! ./core */ 136);
        var _globalize = __webpack_require__( /*! globalize */ 79);
        var _globalize2 = _interopRequireDefault(_globalize);
        var _message = __webpack_require__( /*! ../message */ 10);
        var _message2 = _interopRequireDefault(_message);
        var _core = __webpack_require__( /*! ../core */ 83);
        var _core2 = _interopRequireDefault(_core);
        __webpack_require__( /*! globalize/message */ 79);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        if (_globalize2.default && _globalize2.default.formatMessage) {
            var DEFAULT_LOCALE = "en";
            var originalLoadMessages = _globalize2.default.loadMessages;
            _globalize2.default.loadMessages = function(messages) {
                _message2.default.load(messages)
            };
            var globalizeMessageLocalization = {
                engine: function() {
                    return "globalize"
                },
                ctor: function() {
                    this.load(this._dictionary)
                },
                load: function(messages) {
                    this.callBase(messages);
                    originalLoadMessages(messages)
                },
                getMessagesByLocales: function() {
                    return _globalize2.default.cldr.get("globalize-messages")
                },
                getFormatter: function(key, locale) {
                    var currentLocale = locale || _core2.default.locale();
                    var formatter = this._getFormatterBase(key, locale);
                    if (!formatter) {
                        formatter = this._formatterByGlobalize(key, locale)
                    }
                    if (!formatter && currentLocale !== DEFAULT_LOCALE) {
                        formatter = this.getFormatter(key, DEFAULT_LOCALE)
                    }
                    return formatter
                },
                _formatterByGlobalize: function(key, locale) {
                    var currentGlobalize = !locale || locale === _core2.default.locale() ? _globalize2.default : new _globalize2.default(locale);
                    var result;
                    if (this._messageLoaded(key, locale)) {
                        result = currentGlobalize.messageFormatter(key)
                    }
                    return result
                },
                _messageLoaded: function(key, locale) {
                    var currentCldr = locale ? new _globalize2.default(locale).cldr : _globalize2.default.locale();
                    var value = currentCldr.get(["globalize-messages/{bundle}", key]);
                    return !!value
                },
                _loadSingle: function(key, value, locale) {
                    var data = {};
                    data[locale] = {};
                    data[locale][key] = value;
                    this.load(data)
                }
            };
            _message2.default.inject(globalizeMessageLocalization)
        }
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/localization/globalize/date.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        __webpack_require__( /*! ./core */ 136);
        __webpack_require__( /*! ./number */ 192);
        __webpack_require__( /*! globalize/date */ 79);
        var _globalize = __webpack_require__( /*! globalize */ 79);
        var _globalize2 = _interopRequireDefault(_globalize);
        var _date = __webpack_require__( /*! ../date */ 35);
        var _date2 = _interopRequireDefault(_date);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _iterator2 = _interopRequireDefault(_iterator);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var timeData = {
            supplemental: {
                version: {
                    _cldrVersion: "28",
                    _unicodeVersion: "8.0.0",
                    _number: "$Revision: 11969 $"
                },
                timeData: {
                    "001": {
                        _allowed: "H h",
                        _preferred: "H"
                    },
                    DE: {
                        _allowed: "H",
                        _preferred: "H"
                    },
                    JP: {
                        _allowed: "H K h",
                        _preferred: "H"
                    },
                    RU: {
                        _allowed: "H",
                        _preferred: "H"
                    },
                    US: {
                        _allowed: "H h",
                        _preferred: "h"
                    }
                }
            }
        };
        var enCaGregorian = {
            main: {
                en: {
                    identity: {
                        version: {
                            _cldrVersion: "28",
                            _number: "$Revision: 11972 $"
                        },
                        language: "en"
                    },
                    dates: {
                        calendars: {
                            gregorian: {
                                months: {
                                    format: {
                                        abbreviated: {
                                            1: "Jan",
                                            2: "Feb",
                                            3: "Mar",
                                            4: "Apr",
                                            5: "May",
                                            6: "Jun",
                                            7: "Jul",
                                            8: "Aug",
                                            9: "Sep",
                                            10: "Oct",
                                            11: "Nov",
                                            12: "Dec"
                                        },
                                        narrow: {
                                            1: "J",
                                            2: "F",
                                            3: "M",
                                            4: "A",
                                            5: "M",
                                            6: "J",
                                            7: "J",
                                            8: "A",
                                            9: "S",
                                            10: "O",
                                            11: "N",
                                            12: "D"
                                        },
                                        wide: {
                                            1: "January",
                                            2: "February",
                                            3: "March",
                                            4: "April",
                                            5: "May",
                                            6: "June",
                                            7: "July",
                                            8: "August",
                                            9: "September",
                                            10: "October",
                                            11: "November",
                                            12: "December"
                                        }
                                    },
                                    "stand-alone": {
                                        abbreviated: {
                                            1: "Jan",
                                            2: "Feb",
                                            3: "Mar",
                                            4: "Apr",
                                            5: "May",
                                            6: "Jun",
                                            7: "Jul",
                                            8: "Aug",
                                            9: "Sep",
                                            10: "Oct",
                                            11: "Nov",
                                            12: "Dec"
                                        },
                                        narrow: {
                                            1: "J",
                                            2: "F",
                                            3: "M",
                                            4: "A",
                                            5: "M",
                                            6: "J",
                                            7: "J",
                                            8: "A",
                                            9: "S",
                                            10: "O",
                                            11: "N",
                                            12: "D"
                                        },
                                        wide: {
                                            1: "January",
                                            2: "February",
                                            3: "March",
                                            4: "April",
                                            5: "May",
                                            6: "June",
                                            7: "July",
                                            8: "August",
                                            9: "September",
                                            10: "October",
                                            11: "November",
                                            12: "December"
                                        }
                                    }
                                },
                                days: {
                                    format: {
                                        abbreviated: {
                                            sun: "Sun",
                                            mon: "Mon",
                                            tue: "Tue",
                                            wed: "Wed",
                                            thu: "Thu",
                                            fri: "Fri",
                                            sat: "Sat"
                                        },
                                        narrow: {
                                            sun: "S",
                                            mon: "M",
                                            tue: "T",
                                            wed: "W",
                                            thu: "T",
                                            fri: "F",
                                            sat: "S"
                                        },
                                        "short": {
                                            sun: "Su",
                                            mon: "Mo",
                                            tue: "Tu",
                                            wed: "We",
                                            thu: "Th",
                                            fri: "Fr",
                                            sat: "Sa"
                                        },
                                        wide: {
                                            sun: "Sunday",
                                            mon: "Monday",
                                            tue: "Tuesday",
                                            wed: "Wednesday",
                                            thu: "Thursday",
                                            fri: "Friday",
                                            sat: "Saturday"
                                        }
                                    },
                                    "stand-alone": {
                                        abbreviated: {
                                            sun: "Sun",
                                            mon: "Mon",
                                            tue: "Tue",
                                            wed: "Wed",
                                            thu: "Thu",
                                            fri: "Fri",
                                            sat: "Sat"
                                        },
                                        narrow: {
                                            sun: "S",
                                            mon: "M",
                                            tue: "T",
                                            wed: "W",
                                            thu: "T",
                                            fri: "F",
                                            sat: "S"
                                        },
                                        "short": {
                                            sun: "Su",
                                            mon: "Mo",
                                            tue: "Tu",
                                            wed: "We",
                                            thu: "Th",
                                            fri: "Fr",
                                            sat: "Sa"
                                        },
                                        wide: {
                                            sun: "Sunday",
                                            mon: "Monday",
                                            tue: "Tuesday",
                                            wed: "Wednesday",
                                            thu: "Thursday",
                                            fri: "Friday",
                                            sat: "Saturday"
                                        }
                                    }
                                },
                                quarters: {
                                    format: {
                                        abbreviated: {
                                            1: "Q1",
                                            2: "Q2",
                                            3: "Q3",
                                            4: "Q4"
                                        },
                                        narrow: {
                                            1: "1",
                                            2: "2",
                                            3: "3",
                                            4: "4"
                                        },
                                        wide: {
                                            1: "1st quarter",
                                            2: "2nd quarter",
                                            3: "3rd quarter",
                                            4: "4th quarter"
                                        }
                                    },
                                    "stand-alone": {
                                        abbreviated: {
                                            1: "Q1",
                                            2: "Q2",
                                            3: "Q3",
                                            4: "Q4"
                                        },
                                        narrow: {
                                            1: "1",
                                            2: "2",
                                            3: "3",
                                            4: "4"
                                        },
                                        wide: {
                                            1: "1st quarter",
                                            2: "2nd quarter",
                                            3: "3rd quarter",
                                            4: "4th quarter"
                                        }
                                    }
                                },
                                dayPeriods: {
                                    format: {
                                        abbreviated: {
                                            midnight: "midnight",
                                            am: "AM",
                                            "am-alt-variant": "am",
                                            noon: "noon",
                                            pm: "PM",
                                            "pm-alt-variant": "pm",
                                            morning1: "in the morning",
                                            afternoon1: "in the afternoon",
                                            evening1: "in the evening",
                                            night1: "at night"
                                        },
                                        narrow: {
                                            midnight: "mi",
                                            am: "a",
                                            "am-alt-variant": "am",
                                            noon: "n",
                                            pm: "p",
                                            "pm-alt-variant": "pm",
                                            morning1: "in the morning",
                                            afternoon1: "in the afternoon",
                                            evening1: "in the evening",
                                            night1: "at night"
                                        },
                                        wide: {
                                            midnight: "midnight",
                                            am: "AM",
                                            "am-alt-variant": "am",
                                            noon: "noon",
                                            pm: "PM",
                                            "pm-alt-variant": "pm",
                                            morning1: "in the morning",
                                            afternoon1: "in the afternoon",
                                            evening1: "in the evening",
                                            night1: "at night"
                                        }
                                    },
                                    "stand-alone": {
                                        abbreviated: {
                                            midnight: "midnight",
                                            am: "AM",
                                            "am-alt-variant": "am",
                                            noon: "noon",
                                            pm: "PM",
                                            "pm-alt-variant": "pm",
                                            morning1: "in the morning",
                                            afternoon1: "in the afternoon",
                                            evening1: "in the evening",
                                            night1: "at night"
                                        },
                                        narrow: {
                                            midnight: "midnight",
                                            am: "AM",
                                            "am-alt-variant": "am",
                                            noon: "noon",
                                            pm: "PM",
                                            "pm-alt-variant": "pm",
                                            morning1: "in the morning",
                                            afternoon1: "in the afternoon",
                                            evening1: "in the evening",
                                            night1: "at night"
                                        },
                                        wide: {
                                            midnight: "midnight",
                                            am: "AM",
                                            "am-alt-variant": "am",
                                            noon: "noon",
                                            pm: "PM",
                                            "pm-alt-variant": "pm",
                                            morning1: "morning",
                                            afternoon1: "afternoon",
                                            evening1: "evening",
                                            night1: "night"
                                        }
                                    }
                                },
                                eras: {
                                    eraNames: {
                                        0: "Before Christ",
                                        "0-alt-variant": "Before Common Era",
                                        1: "Anno Domini",
                                        "1-alt-variant": "Common Era"
                                    },
                                    eraAbbr: {
                                        0: "BC",
                                        "0-alt-variant": "BCE",
                                        1: "AD",
                                        "1-alt-variant": "CE"
                                    },
                                    eraNarrow: {
                                        0: "B",
                                        "0-alt-variant": "BCE",
                                        1: "A",
                                        "1-alt-variant": "CE"
                                    }
                                },
                                dateFormats: {
                                    full: "EEEE, MMMM d, y",
                                    "long": "MMMM d, y",
                                    medium: "MMM d, y",
                                    "short": "M/d/yy"
                                },
                                timeFormats: {
                                    full: "h:mm:ss a zzzz",
                                    "long": "h:mm:ss a z",
                                    medium: "h:mm:ss a",
                                    "short": "h:mm a"
                                },
                                dateTimeFormats: {
                                    full: "{1} 'at' {0}",
                                    "long": "{1} 'at' {0}",
                                    medium: "{1}, {0}",
                                    "short": "{1}, {0}",
                                    availableFormats: {
                                        d: "d",
                                        E: "ccc",
                                        Ed: "d E",
                                        Ehm: "E h:mm a",
                                        EHm: "E HH:mm",
                                        Ehms: "E h:mm:ss a",
                                        EHms: "E HH:mm:ss",
                                        Gy: "y G",
                                        GyMMM: "MMM y G",
                                        GyMMMd: "MMM d, y G",
                                        GyMMMEd: "E, MMM d, y G",
                                        h: "h a",
                                        H: "HH",
                                        hm: "h:mm a",
                                        Hm: "HH:mm",
                                        hms: "h:mm:ss a",
                                        Hms: "HH:mm:ss",
                                        hmsv: "h:mm:ss a v",
                                        Hmsv: "HH:mm:ss v",
                                        hmv: "h:mm a v",
                                        Hmv: "HH:mm v",
                                        M: "L",
                                        Md: "M/d",
                                        MEd: "E, M/d",
                                        MMM: "LLL",
                                        MMMd: "MMM d",
                                        MMMEd: "E, MMM d",
                                        MMMMd: "MMMM d",
                                        ms: "mm:ss",
                                        y: "y",
                                        yM: "M/y",
                                        yMd: "M/d/y",
                                        yMEd: "E, M/d/y",
                                        yMMM: "MMM y",
                                        yMMMd: "MMM d, y",
                                        yMMMEd: "E, MMM d, y",
                                        yMMMM: "MMMM y",
                                        yQQQ: "QQQ y",
                                        yQQQQ: "QQQQ y"
                                    },
                                    appendItems: {
                                        Day: "{0} ({2}: {1})",
                                        "Day-Of-Week": "{0} {1}",
                                        Era: "{0} {1}",
                                        Hour: "{0} ({2}: {1})",
                                        Minute: "{0} ({2}: {1})",
                                        Month: "{0} ({2}: {1})",
                                        Quarter: "{0} ({2}: {1})",
                                        Second: "{0} ({2}: {1})",
                                        Timezone: "{0} {1}",
                                        Week: "{0} ({2}: {1})",
                                        Year: "{0} {1}"
                                    },
                                    intervalFormats: {
                                        intervalFormatFallback: "{0} \u2013 {1}",
                                        d: {
                                            d: "d \u2013 d"
                                        },
                                        h: {
                                            a: "h a \u2013 h a",
                                            h: "h \u2013 h a"
                                        },
                                        H: {
                                            H: "HH \u2013 HH"
                                        },
                                        hm: {
                                            a: "h:mm a \u2013 h:mm a",
                                            h: "h:mm \u2013 h:mm a",
                                            m: "h:mm \u2013 h:mm a"
                                        },
                                        Hm: {
                                            H: "HH:mm \u2013 HH:mm",
                                            m: "HH:mm \u2013 HH:mm"
                                        },
                                        hmv: {
                                            a: "h:mm a \u2013 h:mm a v",
                                            h: "h:mm \u2013 h:mm a v",
                                            m: "h:mm \u2013 h:mm a v"
                                        },
                                        Hmv: {
                                            H: "HH:mm \u2013 HH:mm v",
                                            m: "HH:mm \u2013 HH:mm v"
                                        },
                                        hv: {
                                            a: "h a \u2013 h a v",
                                            h: "h \u2013 h a v"
                                        },
                                        Hv: {
                                            H: "HH \u2013 HH v"
                                        },
                                        M: {
                                            M: "M \u2013 M"
                                        },
                                        Md: {
                                            d: "M/d \u2013 M/d",
                                            M: "M/d \u2013 M/d"
                                        },
                                        MEd: {
                                            d: "E, M/d \u2013 E, M/d",
                                            M: "E, M/d \u2013 E, M/d"
                                        },
                                        MMM: {
                                            M: "MMM \u2013 MMM"
                                        },
                                        MMMd: {
                                            d: "MMM d \u2013 d",
                                            M: "MMM d \u2013 MMM d"
                                        },
                                        MMMEd: {
                                            d: "E, MMM d \u2013 E, MMM d",
                                            M: "E, MMM d \u2013 E, MMM d"
                                        },
                                        y: {
                                            y: "y \u2013 y"
                                        },
                                        yM: {
                                            M: "M/y \u2013 M/y",
                                            y: "M/y \u2013 M/y"
                                        },
                                        yMd: {
                                            d: "M/d/y \u2013 M/d/y",
                                            M: "M/d/y \u2013 M/d/y",
                                            y: "M/d/y \u2013 M/d/y"
                                        },
                                        yMEd: {
                                            d: "E, M/d/y \u2013 E, M/d/y",
                                            M: "E, M/d/y \u2013 E, M/d/y",
                                            y: "E, M/d/y \u2013 E, M/d/y"
                                        },
                                        yMMM: {
                                            M: "MMM \u2013 MMM y",
                                            y: "MMM y \u2013 MMM y"
                                        },
                                        yMMMd: {
                                            d: "MMM d \u2013 d, y",
                                            M: "MMM d \u2013 MMM d, y",
                                            y: "MMM d, y \u2013 MMM d, y"
                                        },
                                        yMMMEd: {
                                            d: "E, MMM d \u2013 E, MMM d, y",
                                            M: "E, MMM d \u2013 E, MMM d, y",
                                            y: "E, MMM d, y \u2013 E, MMM d, y"
                                        },
                                        yMMMM: {
                                            M: "MMMM \u2013 MMMM y",
                                            y: "MMMM y \u2013 MMMM y"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        var weekData = {
            supplemental: {
                version: {
                    _cldrVersion: "28",
                    _unicodeVersion: "8.0.0",
                    _number: "$Revision: 11969 $"
                },
                weekData: {
                    minDays: {
                        "001": "1",
                        US: "1",
                        DE: "4"
                    },
                    firstDay: {
                        "001": "mon",
                        DE: "mon",
                        RU: "mon",
                        JP: "sun",
                        US: "sun"
                    },
                    weekendStart: {
                        "001": "sat"
                    },
                    weekendEnd: {
                        "001": "sun"
                    }
                }
            }
        };
        var ACCEPTABLE_JSON_FORMAT_PROPERTIES = ["skeleton", "date", "time", "datetime", "raw"];
        var RTL_MARKS_REGEX = /[\u200E\u200F]/g;
        if (_globalize2.default && _globalize2.default.formatDate) {
            if ("en" === _globalize2.default.locale().locale) {
                _globalize2.default.load(weekData, timeData, enCaGregorian);
                _globalize2.default.locale("en")
            }
            var formattersCache = {};
            var FORMATS_TO_GLOBALIZE_MAP = {
                shortdate: {
                    path: "dateTimeFormats/availableFormats/yMd"
                },
                shorttime: {
                    path: "timeFormats/short"
                },
                longdate: {
                    path: "dateFormats/full"
                },
                longtime: {
                    path: "timeFormats/medium"
                },
                monthandday: {
                    path: "dateTimeFormats/availableFormats/MMMMd"
                },
                monthandyear: {
                    path: "dateTimeFormats/availableFormats/yMMMM"
                },
                quarterandyear: {
                    path: "dateTimeFormats/availableFormats/yQQQ"
                },
                day: {
                    path: "dateTimeFormats/availableFormats/d"
                },
                year: {
                    path: "dateTimeFormats/availableFormats/y"
                },
                shortdateshorttime: {
                    path: "dateTimeFormats/short",
                    parts: ["shorttime", "shortdate"]
                },
                longdatelongtime: {
                    path: "dateTimeFormats/medium",
                    parts: ["longtime", "longdate"]
                },
                month: {
                    pattern: "LLLL"
                },
                shortyear: {
                    pattern: "yy"
                },
                dayofweek: {
                    pattern: "EEEE"
                },
                quarter: {
                    pattern: "QQQ"
                },
                millisecond: {
                    pattern: "SSS"
                },
                hour: {
                    pattern: "HH"
                },
                minute: {
                    pattern: "mm"
                },
                second: {
                    pattern: "ss"
                }
            };
            var globalizeDateLocalization = {
                engine: function() {
                    return "globalize"
                },
                _getPatternByFormat: function(format) {
                    var that = this;
                    var lowerFormat = format.toLowerCase();
                    var globalizeFormat = FORMATS_TO_GLOBALIZE_MAP[lowerFormat];
                    if ("datetime-local" === lowerFormat) {
                        return "yyyy-MM-ddTHH':'mm':'ss"
                    }
                    if (!globalizeFormat) {
                        return
                    }
                    var result = globalizeFormat.path && that._getFormatStringByPath(globalizeFormat.path) || globalizeFormat.pattern;
                    if (globalizeFormat.parts) {
                        _iterator2.default.each(globalizeFormat.parts, function(index, part) {
                            result = result.replace("{" + index + "}", that._getPatternByFormat(part))
                        })
                    }
                    return result
                },
                _getFormatStringByPath: function(path) {
                    return _globalize2.default.locale().main("dates/calendars/gregorian/" + path)
                },
                getPeriodNames: function() {
                    var json = _globalize2.default.locale().main("dates/calendars/gregorian/dayPeriods/stand-alone/wide");
                    return [json.am, json.pm]
                },
                getMonthNames: function(format, type) {
                    var months = _globalize2.default.locale().main("dates/calendars/gregorian/months/" + ("format" === type ? type : "stand-alone") + "/" + (format || "wide"));
                    return _iterator2.default.map(months, function(month) {
                        return month
                    })
                },
                getDayNames: function(format) {
                    var days = _globalize2.default.locale().main("dates/calendars/gregorian/days/stand-alone/" + (format || "wide"));
                    return _iterator2.default.map(days, function(day) {
                        return day
                    })
                },
                getTimeSeparator: function() {
                    return _globalize2.default.locale().main("numbers/symbols-numberSystem-latn/timeSeparator")
                },
                removeRtlMarks: function(text) {
                    return text.replace(RTL_MARKS_REGEX, "")
                },
                format: function(date, _format) {
                    if (!date) {
                        return
                    }
                    if (!_format) {
                        return date
                    }
                    var formatter;
                    var formatCacheKey;
                    if ("function" === typeof _format) {
                        return _format(date)
                    }
                    if (_format.formatter) {
                        return _format.formatter(date)
                    }
                    _format = _format.type || _format;
                    if ("string" === typeof _format) {
                        formatCacheKey = _globalize2.default.locale().locale + ":" + _format;
                        formatter = formattersCache[formatCacheKey];
                        if (!formatter) {
                            _format = {
                                raw: this._getPatternByFormat(_format) || _format
                            };
                            formatter = formattersCache[formatCacheKey] = _globalize2.default.dateFormatter(_format)
                        }
                    } else {
                        if (!this._isAcceptableFormat(_format)) {
                            return
                        }
                        formatter = _globalize2.default.dateFormatter(_format)
                    }
                    return this.removeRtlMarks(formatter(date))
                },
                parse: function(text, format) {
                    if (!text) {
                        return
                    }
                    if (!format || "function" === typeof format || (0, _type.isObject)(format) && !this._isAcceptableFormat(format)) {
                        if (format) {
                            var parsedValue = this.callBase(text, format);
                            if (parsedValue) {
                                return parsedValue
                            }
                        }
                        return _globalize2.default.parseDate(text)
                    }
                    if (format.parser) {
                        return format.parser(text)
                    }
                    if ("string" === typeof format) {
                        format = {
                            raw: this._getPatternByFormat(format) || format
                        }
                    }
                    return _globalize2.default.parseDate(text, format)
                },
                _isAcceptableFormat: function(format) {
                    if (format.parser) {
                        return true
                    }
                    for (var i = 0; i < ACCEPTABLE_JSON_FORMAT_PROPERTIES.length; i++) {
                        if (Object.prototype.hasOwnProperty.call(format, ACCEPTABLE_JSON_FORMAT_PROPERTIES[i])) {
                            return true
                        }
                    }
                },
                firstDayOfWeekIndex: function() {
                    var firstDay = _globalize2.default.locale().supplemental.weekData.firstDay();
                    return (0, _array.inArray)(firstDay, this._getDayKeys())
                },
                _getDayKeys: function() {
                    var days = _globalize2.default.locale().main("dates/calendars/gregorian/days/format/short");
                    return _iterator2.default.map(days, function(day, key) {
                        return key
                    })
                }
            };
            _date2.default.resetInjection();
            _date2.default.inject(globalizeDateLocalization)
        }
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/localization/globalize/currency.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _open_xml_currency_format = __webpack_require__( /*! ../open_xml_currency_format */ 272);
        var _open_xml_currency_format2 = _interopRequireDefault(_open_xml_currency_format);
        __webpack_require__( /*! ./core */ 136);
        __webpack_require__( /*! ./number */ 192);
        __webpack_require__( /*! ../currency */ 131);
        __webpack_require__( /*! globalize/currency */ 79);
        var _globalize = __webpack_require__( /*! globalize */ 79);
        var _globalize2 = _interopRequireDefault(_globalize);
        var _config = __webpack_require__( /*! ../../core/config */ 30);
        var _config2 = _interopRequireDefault(_config);
        var _number = __webpack_require__( /*! ../number */ 49);
        var _number2 = _interopRequireDefault(_number);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var enCurrencyUSD = {
            main: {
                en: {
                    identity: {
                        version: {
                            _cldrVersion: "28",
                            _number: "$Revision: 11972 $"
                        },
                        language: "en"
                    },
                    numbers: {
                        currencies: {
                            USD: {
                                displayName: "US Dollar",
                                "displayName-count-one": "US dollar",
                                "displayName-count-other": "US dollars",
                                symbol: "$",
                                "symbol-alt-narrow": "$"
                            }
                        }
                    }
                }
            }
        };
        var currencyData = {
            supplemental: {
                version: {
                    _cldrVersion: "28",
                    _unicodeVersion: "8.0.0",
                    _number: "$Revision: 11969 $"
                },
                currencyData: {
                    fractions: {
                        DEFAULT: {
                            _rounding: "0",
                            _digits: "2"
                        }
                    }
                }
            }
        };
        if (_globalize2.default && _globalize2.default.formatCurrency) {
            if ("en" === _globalize2.default.locale().locale) {
                _globalize2.default.load(enCurrencyUSD, currencyData);
                _globalize2.default.locale("en")
            }
            var formattersCache = {};
            var getFormatter = function(currency, format) {
                var formatter;
                var formatCacheKey;
                if ("object" === _typeof(format)) {
                    formatCacheKey = _globalize2.default.locale().locale + ":" + currency + ":" + JSON.stringify(format)
                } else {
                    formatCacheKey = _globalize2.default.locale().locale + ":" + currency + ":" + format
                }
                formatter = formattersCache[formatCacheKey];
                if (!formatter) {
                    formatter = formattersCache[formatCacheKey] = _globalize2.default.currencyFormatter(currency, format)
                }
                return formatter
            };
            var globalizeCurrencyLocalization = {
                _formatNumberCore: function(value, format, formatConfig) {
                    if ("currency" === format) {
                        var currency = formatConfig && formatConfig.currency || (0, _config2.default)().defaultCurrency;
                        return getFormatter(currency, this._normalizeFormatConfig(format, formatConfig, value))(value)
                    }
                    return this.callBase.apply(this, arguments)
                },
                _normalizeFormatConfig: function(format, formatConfig, value) {
                    var config = this.callBase(format, formatConfig, value);
                    if ("currency" === format) {
                        config.style = "accounting"
                    }
                    return config
                },
                format: function(value, _format) {
                    if ("number" !== typeof value) {
                        return value
                    }
                    _format = this._normalizeFormat(_format);
                    if (_format) {
                        if ("default" === _format.currency) {
                            _format.currency = (0, _config2.default)().defaultCurrency
                        }
                        if ("currency" === _format.type) {
                            return this._formatNumber(value, this._parseNumberFormatString("currency"), _format)
                        } else {
                            if (!_format.type && _format.currency) {
                                return getFormatter(_format.currency, _format)(value)
                            }
                        }
                    }
                    return this.callBase.apply(this, arguments)
                },
                getCurrencySymbol: function(currency) {
                    if (!currency) {
                        currency = (0, _config2.default)().defaultCurrency
                    }
                    return _globalize2.default.cldr.main("numbers/currencies/" + currency)
                },
                getOpenXmlCurrencyFormat: function(currency) {
                    var currencySymbol = this.getCurrencySymbol(currency).symbol;
                    var accountingFormat = _globalize2.default.cldr.main("numbers/currencyFormats-numberSystem-latn").accounting;
                    return (0, _open_xml_currency_format2.default)(currencySymbol, accountingFormat)
                }
            };
            _number2.default.inject(globalizeCurrencyLocalization)
        }
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/data/data_source.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./data_source/data_source */ 61).DataSource
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/data/local_store.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventsEngine = __webpack_require__( /*! ../events/core/events_engine */ 5);
        var domAdapter = __webpack_require__( /*! ../core/dom_adapter */ 12);
        var windowUtils = __webpack_require__( /*! ../core/utils/window */ 7);
        var window = windowUtils.getWindow();
        var Class = __webpack_require__( /*! ../core/class */ 16);
        var abstract = Class.abstract;
        var errors = __webpack_require__( /*! ./errors */ 38).errors;
        var ArrayStore = __webpack_require__( /*! ./array_store */ 70);
        var LocalStoreBackend = Class.inherit({
            ctor: function(store, storeOptions) {
                this._store = store;
                this._dirty = !!storeOptions.data;
                this.save();
                var immediate = this._immediate = storeOptions.immediate;
                var flushInterval = Math.max(100, storeOptions.flushInterval || 1e4);
                if (!immediate) {
                    var saveProxy = this.save.bind(this);
                    setInterval(saveProxy, flushInterval);
                    eventsEngine.on(window, "beforeunload", saveProxy);
                    if (window.cordova) {
                        domAdapter.listen(domAdapter.getDocument(), "pause", saveProxy, false)
                    }
                }
            },
            notifyChanged: function() {
                this._dirty = true;
                if (this._immediate) {
                    this.save()
                }
            },
            load: function() {
                this._store._array = this._loadImpl();
                this._dirty = false
            },
            save: function() {
                if (!this._dirty) {
                    return
                }
                this._saveImpl(this._store._array);
                this._dirty = false
            },
            _loadImpl: abstract,
            _saveImpl: abstract
        });
        var DomLocalStoreBackend = LocalStoreBackend.inherit({
            ctor: function(store, storeOptions) {
                var name = storeOptions.name;
                if (!name) {
                    throw errors.Error("E4013")
                }
                this._key = "dx-data-localStore-" + name;
                this.callBase(store, storeOptions)
            },
            _loadImpl: function() {
                var raw = window.localStorage.getItem(this._key);
                if (raw) {
                    return JSON.parse(raw)
                }
                return []
            },
            _saveImpl: function(array) {
                if (!array.length) {
                    window.localStorage.removeItem(this._key)
                } else {
                    window.localStorage.setItem(this._key, JSON.stringify(array))
                }
            }
        });
        var localStoreBackends = {
            dom: DomLocalStoreBackend
        };
        var LocalStore = ArrayStore.inherit({
            ctor: function(options) {
                if ("string" === typeof options) {
                    options = {
                        name: options
                    }
                } else {
                    options = options || {}
                }
                this.callBase(options);
                this._backend = new localStoreBackends[options.backend || "dom"](this, options);
                this._backend.load()
            },
            clear: function() {
                this.callBase();
                this._backend.notifyChanged()
            },
            _insertImpl: function(values) {
                var b = this._backend;
                return this.callBase(values).done(b.notifyChanged.bind(b))
            },
            _updateImpl: function(key, values) {
                var b = this._backend;
                return this.callBase(key, values).done(b.notifyChanged.bind(b))
            },
            _removeImpl: function(key) {
                var b = this._backend;
                return this.callBase(key).done(b.notifyChanged.bind(b))
            }
        }, "local");
        module.exports = LocalStore
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/data/endpoint_selector.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errors = __webpack_require__( /*! ../core/errors */ 22);
        var window = __webpack_require__( /*! ../core/utils/window */ 7).getWindow();
        var proxyUrlFormatter = __webpack_require__( /*! ./proxy_url_formatter */ 292);
        var IS_WINJS_ORIGIN;
        var IS_LOCAL_ORIGIN;

        function isLocalHostName(url) {
            return /^(localhost$|127\.)/i.test(url)
        }
        var EndpointSelector = function(config) {
            this.config = config;
            IS_WINJS_ORIGIN = "ms-appx:" === window.location.protocol;
            IS_LOCAL_ORIGIN = isLocalHostName(window.location.hostname)
        };
        EndpointSelector.prototype = {
            urlFor: function(key) {
                var bag = this.config[key];
                if (!bag) {
                    throw errors.Error("E0006")
                }
                if (proxyUrlFormatter.isProxyUsed()) {
                    return proxyUrlFormatter.formatProxyUrl(bag.local)
                }
                if (bag.production) {
                    if (IS_WINJS_ORIGIN && !Debug.debuggerEnabled || !IS_WINJS_ORIGIN && !IS_LOCAL_ORIGIN) {
                        return bag.production
                    }
                }
                return bag.local
            }
        };
        module.exports = EndpointSelector
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/bundles/modules/data.odata.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        __webpack_require__( /*! ./data */ 291);
        DevExpress.data.ODataStore = __webpack_require__( /*! ../../data/odata/store */ 293);
        DevExpress.data.ODataContext = __webpack_require__( /*! ../../data/odata/context */ 520);
        DevExpress.data.utils = DevExpress.data.utils || {};
        DevExpress.data.utils.odata = {};
        DevExpress.data.utils.odata.keyConverters = __webpack_require__( /*! ../../data/odata/utils */ 96).keyConverters;
        DevExpress.data.EdmLiteral = __webpack_require__( /*! ../../data/odata/utils */ 96).EdmLiteral;
        var ODataUtilsModule = __webpack_require__( /*! ../../data/odata/utils */ 96);
        DevExpress.data.utils.odata.serializePropName = ODataUtilsModule.serializePropName;
        DevExpress.data.utils.odata.serializeValue = ODataUtilsModule.serializeValue;
        DevExpress.data.utils.odata.serializeKey = ODataUtilsModule.serializeKey;
        DevExpress.data.utils.odata.sendRequest = ODataUtilsModule.sendRequest;
        DevExpress.data.OData__internals = ODataUtilsModule.OData__internals;
        DevExpress.data.queryAdapters = DevExpress.data.queryAdapters || {};
        DevExpress.data.queryAdapters.odata = __webpack_require__( /*! ../../data/odata/query_adapter */ 162).odata
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/data/odata/context.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _class = __webpack_require__( /*! ../../core/class */ 16);
        var _class2 = _interopRequireDefault(_class);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _errors = __webpack_require__( /*! ../errors */ 38);
        var _errors2 = _interopRequireDefault(_errors);
        var _store = __webpack_require__( /*! ./store */ 293);
        var _store2 = _interopRequireDefault(_store);
        var _request_dispatcher = __webpack_require__( /*! ./request_dispatcher */ 294);
        var _request_dispatcher2 = _interopRequireDefault(_request_dispatcher);
        var _utils = __webpack_require__( /*! ./utils */ 96);
        var _deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        __webpack_require__( /*! ./query_adapter */ 162);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var ODataContext = _class2.default.inherit({
            ctor: function(options) {
                var _this = this;
                this._requestDispatcher = new _request_dispatcher2.default(options);
                this._errorHandler = options.errorHandler;
                (0, _iterator.each)(options.entities || [], function(entityAlias, entityOptions) {
                    _this[entityAlias] = new _store2.default((0, _extend.extend)({}, options, {
                        url: "".concat(_this._requestDispatcher.url, "/").concat(encodeURIComponent(entityOptions.name || entityAlias))
                    }, entityOptions))
                })
            },
            get: function(operationName, params) {
                return this.invoke(operationName, params, "GET")
            },
            invoke: function(operationName) {
                var params = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                var httpMethod = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "POST";
                httpMethod = httpMethod.toLowerCase();
                var d = new _deferred.Deferred;
                var url = "".concat(this._requestDispatcher.url, "/").concat(encodeURIComponent(operationName));
                var payload;
                if (4 === this.version()) {
                    if ("get" === httpMethod) {
                        url = (0, _utils.formatFunctionInvocationUrl)(url, (0, _utils.escapeServiceOperationParams)(params, this.version()));
                        params = null
                    } else {
                        if ("post" === httpMethod) {
                            payload = params;
                            params = null
                        }
                    }
                }(0, _deferred.when)(this._requestDispatcher.sendRequest(url, httpMethod, (0, _utils.escapeServiceOperationParams)(params, this.version()), payload)).done(function(r) {
                    if ((0, _type.isPlainObject)(r) && operationName in r) {
                        r = r[operationName]
                    }
                    d.resolve(r)
                }).fail(this._errorHandler).fail(_errors2.default._errorHandler).fail(d.reject);
                return d.promise()
            },
            objectLink: function(entityAlias, key) {
                var store = this[entityAlias];
                if (!store) {
                    throw _errors2.default.errors.Error("E4015", entityAlias)
                }
                if (!(0, _type.isDefined)(key)) {
                    return null
                }
                return {
                    __metadata: {
                        uri: store._byKeyUrl(key, true)
                    }
                }
            },
            version: function() {
                return this._requestDispatcher.version
            }
        });
        module.exports = ODataContext
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/bundles/modules/viz.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        __webpack_require__( /*! ./core */ 155);
        module.exports = DevExpress.viz = DevExpress.viz || {}
    },
    /*!*******************************************!*\
      !*** ./artifacts/transpiled/viz/chart.js ***!
      \*******************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _common = __webpack_require__( /*! ../core/utils/common */ 3);
        var _extend2 = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _array = __webpack_require__( /*! ../core/utils/array */ 14);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _component_registrator = __webpack_require__( /*! ../core/component_registrator */ 9);
        var _component_registrator2 = _interopRequireDefault(_component_registrator);
        var _utils = __webpack_require__( /*! ./core/utils */ 13);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _math = __webpack_require__( /*! ../core/utils/math */ 31);
        var _base_chart = __webpack_require__( /*! ./chart_components/base_chart */ 256);
        var _layout_manager = __webpack_require__( /*! ./chart_components/layout_manager */ 421);
        var _layout_manager2 = _interopRequireDefault(_layout_manager);
        var _multi_axes_synchronizer = __webpack_require__( /*! ./chart_components/multi_axes_synchronizer */ 828);
        var _multi_axes_synchronizer2 = _interopRequireDefault(_multi_axes_synchronizer);
        var _advanced_chart = __webpack_require__( /*! ./chart_components/advanced_chart */ 423);
        var _scroll_bar = __webpack_require__( /*! ./chart_components/scroll_bar */ 837);
        var _scroll_bar2 = _interopRequireDefault(_scroll_bar);
        var _crosshair = __webpack_require__( /*! ./chart_components/crosshair */ 429);
        var _crosshair2 = _interopRequireDefault(_crosshair);
        var _range_data_calculator = __webpack_require__( /*! ./series/helpers/range_data_calculator */ 209);
        var _range = __webpack_require__( /*! ./translators/range */ 112);
        var _range2 = _interopRequireDefault(_range);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var DEFAULT_PANE_NAME = "default";
        var VISUAL_RANGE = "VISUAL_RANGE";
        var DEFAULT_PANES = [{
            name: DEFAULT_PANE_NAME,
            border: {}
        }];
        var DISCRETE = "discrete";
        var _isArray = Array.isArray;

        function getFirstAxisNameForPane(axes, paneName, defaultPane) {
            var result;
            for (var i = 0; i < axes.length; i++) {
                if (axes[i].pane === paneName || void 0 === axes[i].pane && paneName === defaultPane) {
                    result = axes[i].name;
                    break
                }
            }
            if (!result) {
                result = axes[0].name
            }
            return result
        }

        function changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility) {
            var gridOpt = axis.getOptions().grid;
            var minorGridOpt = axis.getOptions().minorGrid;
            gridOpt.visible = gridVisibility;
            minorGridOpt && (minorGridOpt.visible = minorGridVisibility)
        }

        function hideGridsOnNonFirstValueAxisForPane(axesForPane) {
            var axisShown = false;
            var hiddenStubAxis = [];
            var minorGridVisibility = axesForPane.some(function(axis) {
                var minorGridOptions = axis.getOptions().minorGrid;
                return minorGridOptions && minorGridOptions.visible
            });
            var gridVisibility = axesForPane.some(function(axis) {
                var gridOptions = axis.getOptions().grid;
                return gridOptions && gridOptions.visible
            });
            if (axesForPane.length > 1) {
                axesForPane.forEach(function(axis) {
                    var gridOpt = axis.getOptions().grid;
                    if (axisShown) {
                        changeVisibilityAxisGrids(axis, false, false)
                    } else {
                        if (gridOpt && gridOpt.visible) {
                            if (axis.getTranslator().getBusinessRange().isEmpty()) {
                                changeVisibilityAxisGrids(axis, false, false);
                                hiddenStubAxis.push(axis)
                            } else {
                                axisShown = true;
                                changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility)
                            }
                        }
                    }
                });
                !axisShown && hiddenStubAxis.length && changeVisibilityAxisGrids(hiddenStubAxis[0], gridVisibility, minorGridVisibility)
            }
        }

        function findAxisOptions(valueAxes, valueAxesOptions, axisName) {
            var result;
            var axInd;
            for (axInd = 0; axInd < valueAxesOptions.length; axInd++) {
                if (valueAxesOptions[axInd].name === axisName) {
                    result = valueAxesOptions[axInd];
                    result.priority = axInd;
                    break
                }
            }
            if (!result) {
                for (axInd = 0; axInd < valueAxes.length; axInd++) {
                    if (valueAxes[axInd].name === axisName) {
                        result = valueAxes[axInd].getOptions();
                        result.priority = valueAxes[axInd].priority;
                        break
                    }
                }
            }
            return result
        }

        function findAxis(paneName, axisName, axes) {
            var axis;
            var i;
            for (i = 0; i < axes.length; i++) {
                axis = axes[i];
                if (axis.name === axisName && axis.pane === paneName) {
                    return axis
                }
            }
            if (paneName) {
                return findAxis(void 0, axisName, axes)
            }
        }

        function compareAxes(a, b) {
            return a.priority - b.priority
        }

        function doesPaneExist(panes, paneName) {
            var found = false;
            (0, _iterator.each)(panes, function(_, pane) {
                if (pane.name === paneName) {
                    found = true;
                    return false
                }
            });
            return found
        }
        var prepareSegmentRectPoints = function(left, top, width, height, borderOptions) {
            var maxSW = ~~((width < height ? width : height) / 2);
            var sw = borderOptions.width || 0;
            var newSW = sw < maxSW ? sw : maxSW;
            left += newSW / 2;
            top += newSW / 2;
            width -= newSW;
            height -= newSW;
            var right = left + width;
            var bottom = top + height;
            var points = [];
            var segments = [];
            var segmentSequence;
            var visiblyOpt = 0;
            var prevSegmentVisibility = 0;
            var allSegment = {
                top: [
                    [left, top],
                    [right, top]
                ],
                right: [
                    [right, top],
                    [right, bottom]
                ],
                bottom: [
                    [right, bottom],
                    [left, bottom]
                ],
                left: [
                    [left, bottom],
                    [left, top]
                ]
            };
            (0, _iterator.each)(allSegment, function(seg) {
                var visibility = !!borderOptions[seg];
                visiblyOpt = 2 * visiblyOpt + ~~visibility
            });
            switch (visiblyOpt) {
                case 13:
                case 9:
                    segmentSequence = ["left", "top", "right", "bottom"];
                    break;
                case 11:
                    segmentSequence = ["bottom", "left", "top", "right"];
                    break;
                default:
                    segmentSequence = ["top", "right", "bottom", "left"]
            }(0, _iterator.each)(segmentSequence, function(_, seg) {
                var segmentVisibility = !!borderOptions[seg];
                if (!prevSegmentVisibility && segments.length) {
                    points.push(segments);
                    segments = []
                }
                if (segmentVisibility) {
                    (0, _iterator.each)(allSegment[seg].slice(prevSegmentVisibility), function(_, segment) {
                        segments = segments.concat(segment)
                    })
                }
                prevSegmentVisibility = ~~segmentVisibility
            });
            segments.length && points.push(segments);
            1 === points.length && (points = points[0]);
            return {
                points: points,
                pathType: 15 === visiblyOpt ? "area" : "line"
            }
        };

        function accumulate(field, src1, src2, auxSpacing) {
            var val1 = src1[field] || 0;
            var val2 = src2[field] || 0;
            return val1 + val2 + (val1 && val2 ? auxSpacing : 0)
        }

        function pickMax(field, src1, src2) {
            return pickMaxValue(src1[field], src2[field])
        }

        function pickMaxValue(val1, val2) {
            return Math.max(val1 || 0, val2 || 0)
        }

        function getAxisMargins(axis) {
            return axis.getMargins()
        }

        function getHorizontalAxesMargins(axes, getMarginsFunc) {
            return axes.reduce(function(margins, axis) {
                var axisMargins = getMarginsFunc(axis);
                var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};
                var spacing = axis.getMultipleAxesSpacing();
                paneMargins.top = accumulate("top", paneMargins, axisMargins, spacing);
                paneMargins.bottom = accumulate("bottom", paneMargins, axisMargins, spacing);
                paneMargins.left = pickMax("left", paneMargins, axisMargins);
                paneMargins.right = pickMax("right", paneMargins, axisMargins);
                margins.top = pickMax("top", paneMargins, margins);
                margins.bottom = pickMax("bottom", paneMargins, margins);
                margins.left = pickMax("left", paneMargins, margins);
                margins.right = pickMax("right", paneMargins, margins);
                return margins
            }, {
                panes: {}
            })
        }

        function getVerticalAxesMargins(axes) {
            return axes.reduce(function(margins, axis) {
                var axisMargins = axis.getMargins();
                var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};
                var spacing = axis.getMultipleAxesSpacing();
                paneMargins.top = pickMax("top", paneMargins, axisMargins);
                paneMargins.bottom = pickMax("bottom", paneMargins, axisMargins);
                paneMargins.left = accumulate("left", paneMargins, axisMargins, spacing);
                paneMargins.right = accumulate("right", paneMargins, axisMargins, spacing);
                margins.top = pickMax("top", paneMargins, margins);
                margins.bottom = pickMax("bottom", paneMargins, margins);
                margins.left = pickMax("left", paneMargins, margins);
                margins.right = pickMax("right", paneMargins, margins);
                return margins
            }, {
                panes: {}
            })
        }

        function performActionOnAxes(axes, action, actionArgument1, actionArgument2, actionArgument3) {
            axes.forEach(function(axis) {
                axis[action](actionArgument1 && actionArgument1[axis.pane], actionArgument2 && actionArgument2[axis.pane] || actionArgument2, actionArgument3)
            })
        }

        function shrinkCanvases(isRotated, canvases, sizes, verticalMargins, horizontalMargins) {
            function getMargin(side, margins, pane) {
                var m = (isRotated ? ["left", "right"] : ["top", "bottom"]).indexOf(side) === -1 ? margins : margins.panes[pane] || {};
                return m[side]
            }

            function getMaxMargin(side, margins1, margins2, pane) {
                return pickMaxValue(getMargin(side, margins1, pane), getMargin(side, margins2, pane))
            }
            var getOriginalField = function(field) {
                return "original".concat(field[0].toUpperCase()).concat(field.slice(1))
            };

            function shrink(canvases, paneNames, sizeField, startMargin, endMargin, oppositeMargins) {
                paneNames = paneNames.sort(function(p1, p2) {
                    return canvases[p2][startMargin] - canvases[p1][startMargin]
                });
                paneNames.forEach(function(pane) {
                    var canvas = canvases[pane];
                    oppositeMargins.forEach(function(margin) {
                        canvas[margin] = canvas[getOriginalField(margin)] + getMaxMargin(margin, verticalMargins, horizontalMargins, pane)
                    })
                });
                var firstPane = canvases[paneNames[0]];
                var emptySpace = paneNames.reduce(function(space, paneName) {
                    space -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, paneName) + getMaxMargin(endMargin, verticalMargins, horizontalMargins, paneName);
                    return space
                }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - canvases[paneNames[paneNames.length - 1]][getOriginalField(startMargin)]) - _utils.PANE_PADDING * (paneNames.length - 1);
                var totalCustomSpace = Object.keys(sizes).reduce(function(prev, key) {
                    return prev + (sizes[key].unit ? sizes[key].height : 0)
                }, 0);
                emptySpace -= totalCustomSpace;
                paneNames.reduce(function(offset, pane) {
                    var canvas = canvases[pane];
                    var paneSize = sizes[pane];
                    offset -= getMaxMargin(endMargin, verticalMargins, horizontalMargins, pane);
                    canvas[endMargin] = firstPane[sizeField] - offset;
                    offset -= paneSize.unit ? paneSize.height : Math.floor(emptySpace * paneSize.height);
                    canvas[startMargin] = offset;
                    offset -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, pane) + _utils.PANE_PADDING;
                    return offset
                }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - (emptySpace < 0 ? emptySpace : 0))
            }
            var paneNames = Object.keys(canvases);
            if (!isRotated) {
                shrink(canvases, paneNames, "height", "top", "bottom", ["left", "right"])
            } else {
                shrink(canvases, paneNames, "width", "left", "right", ["top", "bottom"])
            }
            return canvases
        }

        function drawAxesWithTicks(axes, condition, canvases, panesBorderOptions) {
            if (condition) {
                performActionOnAxes(axes, "createTicks", canvases);
                _multi_axes_synchronizer2.default.synchronize(axes)
            }
            performActionOnAxes(axes, "draw", !condition && canvases, panesBorderOptions)
        }

        function shiftAxis(side1, side2) {
            var shifts = {};
            return function(axis) {
                if (!axis.customPositionIsAvailable() || axis.customPositionEqualsToPredefined()) {
                    var shift = shifts[axis.pane] = shifts[axis.pane] || {
                        top: 0,
                        left: 0,
                        bottom: 0,
                        right: 0
                    };
                    var spacing = axis.getMultipleAxesSpacing();
                    var margins = axis.getMargins();
                    axis.shift(shift);
                    shift[side1] = accumulate(side1, shift, margins, spacing);
                    shift[side2] = accumulate(side2, shift, margins, spacing)
                } else {
                    axis.shift({
                        top: 0,
                        left: 0,
                        bottom: 0,
                        right: 0
                    })
                }
            }
        }

        function getCommonSize(side, margins) {
            var size = 0;
            var pane;
            var paneMargins;
            for (pane in margins.panes) {
                paneMargins = margins.panes[pane];
                size += "height" === side ? paneMargins.top + paneMargins.bottom : paneMargins.left + paneMargins.right
            }
            return size
        }

        function checkUsedSpace(sizeShortage, side, axes, getMarginFunc) {
            var size = 0;
            if (sizeShortage[side] > 0) {
                size = getCommonSize(side, getMarginFunc(axes, getAxisMargins));
                performActionOnAxes(axes, "hideTitle");
                sizeShortage[side] -= size - getCommonSize(side, getMarginFunc(axes, getAxisMargins))
            }
            if (sizeShortage[side] > 0) {
                performActionOnAxes(axes, "hideOuterElements")
            }
        }

        function axisAnimationEnabled(drawOptions, pointsToAnimation) {
            var pointsCount = pointsToAnimation.reduce(function(sum, count) {
                return sum + count
            }, 0) / pointsToAnimation.length;
            return drawOptions.animate && pointsCount <= drawOptions.animationPointsLimit
        }

        function collectMarkersInfoBySeries(allSeries, filteredSeries, argAxis) {
            var points = [];
            var overloadedSeries = {};
            var argVisualRange = argAxis.visualRange();
            var argTranslator = argAxis.getTranslator();
            var argViewPortFilter = (0, _range_data_calculator.getViewPortFilter)(argVisualRange || {});
            filteredSeries.forEach(function(s) {
                var valAxis = s.getValueAxis();
                var valVisualRange = valAxis.getCanvasRange();
                var valTranslator = valAxis.getTranslator();
                var seriesIndex = allSeries.indexOf(s);
                var valViewPortFilter = (0, _range_data_calculator.getViewPortFilter)(valVisualRange || {});
                overloadedSeries[seriesIndex] = {};
                filteredSeries.forEach(function(sr) {
                    return overloadedSeries[seriesIndex][allSeries.indexOf(sr)] = 0
                });
                var seriesPoints = [];
                s.getPoints().filter(function(p) {
                    return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)))
                }).forEach(function(p) {
                    var tp = {
                        seriesIndex: seriesIndex,
                        argument: p.argument,
                        value: p.getMaxValue(true),
                        size: p.bubbleSize || p.getOptions().size
                    };
                    if (p.getMinValue(true) !== p.getMaxValue(true)) {
                        var mp = (0, _extend2.extend)({}, tp);
                        mp.value = p.getMinValue(true);
                        mp.x = argTranslator.to(mp.argument, 1);
                        mp.y = valTranslator.to(mp.value, 1);
                        seriesPoints.push(mp)
                    }
                    tp.x = argTranslator.to(tp.argument, 1);
                    tp.y = valTranslator.to(tp.value, 1);
                    seriesPoints.push(tp)
                });
                overloadedSeries[seriesIndex].pointsCount = seriesPoints.length;
                overloadedSeries[seriesIndex].total = 0;
                overloadedSeries[seriesIndex].continuousSeries = 0;
                points = points.concat(seriesPoints)
            });
            return {
                points: points,
                overloadedSeries: overloadedSeries
            }
        }

        function applyAutoHidePointMarkers(allSeries, filteredSeries, overloadedSeries, argAxis) {
            var argAxisType = argAxis.getOptions().type;
            filteredSeries.forEach(function(s) {
                var seriesIndex = allSeries.indexOf(s);
                s.autoHidePointMarkers = false;
                var tickCount = argAxis.getTicksValues().majorTicksValues.length;
                if (s.autoHidePointMarkersEnabled() && (argAxisType === DISCRETE || overloadedSeries[seriesIndex].pointsCount > tickCount)) {
                    for (var index in overloadedSeries[seriesIndex]) {
                        var i = parseInt(index);
                        if (isNaN(i) || overloadedSeries[seriesIndex].total / overloadedSeries[seriesIndex].continuousSeries < 3) {
                            continue
                        }
                        if (i === seriesIndex) {
                            if (2 * overloadedSeries[i][i] >= overloadedSeries[i].pointsCount) {
                                s.autoHidePointMarkers = true;
                                break
                            }
                        } else {
                            if (overloadedSeries[seriesIndex].total >= overloadedSeries[seriesIndex].pointsCount) {
                                s.autoHidePointMarkers = true;
                                break
                            }
                        }
                    }
                }
            })
        }

        function updateMarkersInfo(_ref) {
            var overloadedSeries = _ref.overloadedSeries,
                points = _ref.points;
            var isContinuousSeries = false;
            for (var i = 0; i < points.length - 1; i++) {
                var curPoint = points[i];
                var size = curPoint.size;
                if ((0, _type.isDefined)(curPoint.x) && (0, _type.isDefined)(curPoint.y)) {
                    for (var j = i + 1; j < points.length; j++) {
                        var nextPoint = points[j];
                        var next_x = null === nextPoint || void 0 === nextPoint ? void 0 : nextPoint.x;
                        var next_y = null === nextPoint || void 0 === nextPoint ? void 0 : nextPoint.y;
                        if (!(0, _type.isDefined)(next_x) || Math.abs(curPoint.x - next_x) >= size) {
                            isContinuousSeries &= j !== i + 1;
                            break
                        } else {
                            var distance = (0, _type.isDefined)(next_x) && (0, _type.isDefined)(next_y) && Math.sqrt(Math.pow(curPoint.x - next_x, 2) + Math.pow(curPoint.y - next_y, 2));
                            if (distance && distance < size) {
                                overloadedSeries[curPoint.seriesIndex][nextPoint.seriesIndex]++;
                                overloadedSeries[curPoint.seriesIndex].total++;
                                if (!isContinuousSeries) {
                                    overloadedSeries[curPoint.seriesIndex].continuousSeries++;
                                    isContinuousSeries = true
                                }
                            }
                        }
                    }
                }
            }
        }
        var dxChart = _advanced_chart.AdvancedChart.inherit({
            _themeSection: "chart",
            _fontFields: ["crosshair.label.font"],
            _setDeprecatedOptions: function() {
                this.callBase.apply(this, arguments);
                (0, _extend2.extend)(this._deprecatedOptions, {
                    useAggregation: {
                        since: "18.1",
                        message: "Use the 'commonSeriesSettings.aggregation.enabled' or 'series.aggregation.enabled' option instead"
                    },
                    "argumentAxis.min": {
                        since: "18.2",
                        message: "Use the 'argumentAxis.visualRange' option instead"
                    },
                    "argumentAxis.max": {
                        since: "18.2",
                        message: "Use the 'argumentAxis.visualRange' option instead"
                    },
                    "valueAxis.min": {
                        since: "18.2",
                        message: "Use the 'valueAxis.visualRange' option instead"
                    },
                    "valueAxis.max": {
                        since: "18.2",
                        message: "Use the 'valueAxis.visualRange' option instead"
                    },
                    zoomingMode: {
                        since: "18.2",
                        message: "Use the 'zoomAndPan' option instead"
                    },
                    scrollingMode: {
                        since: "18.2",
                        message: "Use the 'zoomAndPan' option instead"
                    }
                })
            },
            _initCore: function() {
                this.paneAxis = {};
                this.callBase()
            },
            _correctAxes: function() {
                this._correctValueAxes(true)
            },
            _getExtraOptions: _common.noop,
            _createPanes: function() {
                var that = this;
                var panes = that.option("panes");
                var panesNameCounter = 0;
                var defaultPane;
                if (!panes || _isArray(panes) && !panes.length) {
                    panes = DEFAULT_PANES
                }
                that.callBase();
                defaultPane = that.option("defaultPane");
                panes = (0, _extend2.extend)(true, [], _isArray(panes) ? panes : [panes]);
                (0, _iterator.each)(panes, function(_, pane) {
                    pane.name = !(0, _type.isDefined)(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name
                });
                if ((0, _type.isDefined)(defaultPane)) {
                    if (!doesPaneExist(panes, defaultPane)) {
                        that._incidentOccurred("W2101", [defaultPane]);
                        defaultPane = panes[panes.length - 1].name
                    }
                } else {
                    defaultPane = panes[panes.length - 1].name
                }
                that.defaultPane = defaultPane;
                panes = that._isRotated() ? panes.reverse() : panes;
                return panes
            },
            _getAxisRenderingOptions: function() {
                return {
                    axisType: "xyAxes",
                    drawingType: "linear"
                }
            },
            _prepareAxisOptions: function(typeSelector, userOptions, rotated) {
                return {
                    isHorizontal: "argumentAxis" === typeSelector !== rotated,
                    containerColor: this._themeManager.getOptions("containerBackgroundColor")
                }
            },
            _checkPaneName: function(seriesTheme) {
                var paneList = (0, _utils.map)(this.panes, function(pane) {
                    return pane.name
                });
                seriesTheme.pane = seriesTheme.pane || this.defaultPane;
                return (0, _array.inArray)(seriesTheme.pane, paneList) !== -1
            },
            _initCustomPositioningAxes: function() {
                var that = this;
                var argumentAxis = that.getArgumentAxis();
                var valueAxisName = argumentAxis.getOptions().customPositionAxis;
                var valueAxis = that._valueAxes.filter(function(v) {
                    return v.pane === argumentAxis.pane && (!valueAxisName || valueAxisName === v.name)
                })[0];
                that._valueAxes.forEach(function(v) {
                    if (argumentAxis !== v.getOppositeAxis()) {
                        v.getOppositeAxis = function() {
                            return argumentAxis
                        };
                        v.customPositionIsBoundaryOppositeAxis = function() {
                            return argumentAxis.customPositionIsBoundary()
                        }
                    }
                });
                if ((0, _type.isDefined)(valueAxis) && valueAxis !== argumentAxis.getOppositeAxis()) {
                    argumentAxis.getOppositeAxis = function() {
                        return valueAxis
                    };
                    argumentAxis.customPositionIsBoundaryOppositeAxis = function() {
                        return that._valueAxes.some(function(v) {
                            return v.customPositionIsBoundary()
                        })
                    }
                } else {
                    if ((0, _type.isDefined)(argumentAxis.getOppositeAxis()) && !(0, _type.isDefined)(valueAxis)) {
                        argumentAxis.getOppositeAxis = _common.noop
                    }
                }
            },
            _axesBoundaryPositioning: function() {
                var that = this;
                var allAxes = that._argumentAxes.concat(that._valueAxes);
                var boundaryStateChanged = false;
                allAxes.forEach(function(a) {
                    if (!a.customPositionIsAvailable()) {
                        return false
                    }
                    var prevBoundaryState = a.customPositionIsBoundary();
                    a._customBoundaryPosition = a.getCustomBoundaryPosition();
                    boundaryStateChanged |= prevBoundaryState !== a.customPositionIsBoundary()
                });
                return boundaryStateChanged
            },
            _getValueAxis: function(paneName, axisName) {
                var that = this;
                var valueAxes = that._valueAxes;
                var valueAxisOptions = that.option("valueAxis") || {};
                var valueAxesOptions = _isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions];
                var rotated = that._isRotated();
                var crosshairMargins = that._getCrosshairMargins();
                var axisOptions;
                var axis;
                axisName = axisName || getFirstAxisNameForPane(valueAxes, paneName, that.defaultPane);
                axis = findAxis(paneName, axisName, valueAxes);
                if (!axis) {
                    axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);
                    if (!axisOptions) {
                        that._incidentOccurred("W2102", [axisName]);
                        axisOptions = {
                            name: axisName,
                            priority: valueAxes.length
                        }
                    }
                    axis = that._createAxis(false, that._populateAxesOptions("valueAxis", axisOptions, {
                        pane: paneName,
                        name: axisName,
                        optionPath: _isArray(valueAxisOptions) ? "valueAxis[".concat(axisOptions.priority, "]") : "valueAxis",
                        crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x
                    }, rotated));
                    axis.applyVisualRangeSetter(that._getVisualRangeSetter());
                    valueAxes.push(axis)
                }
                axis.setPane(paneName);
                return axis
            },
            _correctValueAxes: function(needHideGrids) {
                var that = this;
                var synchronizeMultiAxes = that._themeManager.getOptions("synchronizeMultiAxes");
                var valueAxes = that._valueAxes;
                var paneWithAxis = {};
                that.series.forEach(function(series) {
                    var axis = series.getValueAxis();
                    paneWithAxis[axis.pane] = true
                });
                that.panes.forEach(function(pane) {
                    var paneName = pane.name;
                    if (!paneWithAxis[paneName]) {
                        that._getValueAxis(paneName)
                    }
                    if (needHideGrids && synchronizeMultiAxes) {
                        hideGridsOnNonFirstValueAxisForPane(valueAxes.filter(function(axis) {
                            return axis.pane === paneName
                        }))
                    }
                });
                that._valueAxes = valueAxes.filter(function(axis) {
                    if (!axis.pane) {
                        axis.setPane(that.defaultPane)
                    }
                    return doesPaneExist(that.panes, axis.pane)
                }).sort(compareAxes);
                var defaultAxis = this.getValueAxis();
                that._valueAxes.forEach(function(axis) {
                    var optionPath = axis.getOptions().optionPath;
                    if (optionPath) {
                        var axesWithSamePath = that._valueAxes.filter(function(a) {
                            return a.getOptions().optionPath === optionPath
                        });
                        if (axesWithSamePath.length > 1) {
                            if (axesWithSamePath.some(function(a) {
                                    return a === defaultAxis
                                })) {
                                axesWithSamePath.forEach(function(a) {
                                    if (a !== defaultAxis) {
                                        a.getOptions().optionPath = null
                                    }
                                })
                            } else {
                                axesWithSamePath.forEach(function(a, i) {
                                    if (0 !== i) {
                                        a.getOptions().optionPath = null
                                    }
                                })
                            }
                        }
                    }
                })
            },
            _getSeriesForPane: function(paneName) {
                var paneSeries = [];
                (0, _iterator.each)(this.series, function(_, oneSeries) {
                    if (oneSeries.pane === paneName) {
                        paneSeries.push(oneSeries)
                    }
                });
                return paneSeries
            },
            _createPanesBorderOptions: function() {
                var commonBorderOptions = this._themeManager.getOptions("commonPaneSettings").border;
                var panesBorderOptions = {};
                this.panes.forEach(function(pane) {
                    return panesBorderOptions[pane.name] = (0, _extend2.extend)(true, {}, commonBorderOptions, pane.border)
                });
                return panesBorderOptions
            },
            _createScrollBar: function() {
                var that = this;
                var scrollBarOptions = that._themeManager.getOptions("scrollBar") || {};
                var scrollBarGroup = that._scrollBarGroup;
                if (scrollBarOptions.visible) {
                    scrollBarOptions.rotated = that._isRotated();
                    that._scrollBar = (that._scrollBar || new _scroll_bar2.default.ScrollBar(that._renderer, scrollBarGroup)).update(scrollBarOptions)
                } else {
                    scrollBarGroup.linkRemove();
                    that._scrollBar && that._scrollBar.dispose();
                    that._scrollBar = null
                }
            },
            _prepareToRender: function(drawOptions) {
                var panesBorderOptions = this._createPanesBorderOptions();
                this._createPanesBackground();
                this._appendAxesGroups();
                this._adjustViewport();
                return panesBorderOptions
            },
            _adjustViewport: function() {
                var that = this;
                var series = that._getVisibleSeries();
                var argumentAxis = that.getArgumentAxis();
                var useAggregation = series.some(function(s) {
                    return s.useAggregation()
                });
                var adjustOnZoom = that._themeManager.getOptions("adjustOnZoom");
                var alignToBounds = !argumentAxis.dataVisualRangeIsReduced();
                if (!useAggregation && !adjustOnZoom) {
                    return
                }
                that._valueAxes.forEach(function(axis) {
                    return axis.adjust(alignToBounds)
                })
            },
            _recreateSizeDependentObjects: function(isCanvasChanged) {
                var that = this;
                var series = that._getVisibleSeries();
                var useAggregation = series.some(function(s) {
                    return s.useAggregation()
                });
                var zoomChanged = that._isZooming();
                if (!useAggregation) {
                    return
                }
                that._argumentAxes.forEach(function(axis) {
                    axis.updateCanvas(that._canvas, true)
                });
                series.forEach(function(series) {
                    if (series.useAggregation() && (isCanvasChanged || zoomChanged || !series._useAllAggregatedPoints)) {
                        series.createPoints()
                    }
                });
                that._processSeriesFamilies()
            },
            _isZooming: function() {
                var that = this;
                var argumentAxis = that.getArgumentAxis();
                if (!argumentAxis || !argumentAxis.getTranslator()) {
                    return false
                }
                var businessRange = argumentAxis.getTranslator().getBusinessRange();
                var zoomRange = argumentAxis.getViewport();
                var min = zoomRange ? zoomRange.min : 0;
                var max = zoomRange ? zoomRange.max : 0;
                if ("logarithmic" === businessRange.axisType) {
                    min = (0, _utils.getLog)(min, businessRange.base);
                    max = (0, _utils.getLog)(max, businessRange.base)
                }
                var viewportDistance = businessRange.axisType === DISCRETE ? (0, _utils.getCategoriesInfo)(businessRange.categories, min, max).categories.length : Math.abs(max - min);
                var precision = (0, _math.getPrecision)(viewportDistance);
                precision = precision > 1 ? Math.pow(10, precision - 2) : 1;
                var zoomChanged = Math.round((that._zoomLength - viewportDistance) * precision) / precision !== 0;
                that._zoomLength = viewportDistance;
                return zoomChanged
            },
            _handleSeriesDataUpdated: function() {
                var that = this;
                var viewport = new _range2.default.Range;
                that.series.forEach(function(s) {
                    viewport.addRange(s.getArgumentRange())
                });
                that._argumentAxes.forEach(function(axis) {
                    axis.updateCanvas(that._canvas, true);
                    axis.setBusinessRange(viewport, that._axesReinitialized)
                });
                that.callBase()
            },
            _isLegendInside: function() {
                return this._legend && "inside" === this._legend.getPosition()
            },
            _isRotated: function() {
                return this._themeManager.getOptions("rotated")
            },
            _getLayoutTargets: function() {
                return this.panes
            },
            _applyClipRects: function(panesBorderOptions) {
                var that = this;
                that._drawPanesBorders(panesBorderOptions);
                that._createClipRectsForPanes();
                that._applyClipRectsForAxes();
                that._fillPanesBackground()
            },
            _updateLegendPosition: function(drawOptions, legendHasInsidePosition) {
                var that = this;
                if (drawOptions.drawLegend && that._legend && legendHasInsidePosition) {
                    var panes = that.panes;
                    var newCanvas = (0, _extend2.extend)({}, panes[0].canvas);
                    var layoutManager = new _layout_manager2.default.LayoutManager;
                    newCanvas.right = panes[panes.length - 1].canvas.right;
                    newCanvas.bottom = panes[panes.length - 1].canvas.bottom;
                    layoutManager.setOptions({
                        width: 0,
                        height: 0
                    });
                    layoutManager.layoutElements([that._legend], newCanvas, _common.noop, [{
                        canvas: newCanvas
                    }], void 0)
                }
            },
            _allowLegendInsidePosition: function() {
                return true
            },
            _applyExtraSettings: function(series) {
                var that = this;
                var paneIndex = that._getPaneIndex(series.pane);
                var panesClipRects = that._panesClipRects;
                var wideClipRect = panesClipRects.wide[paneIndex];
                series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, that._getPaneBorderVisibility(paneIndex))
            },
            _updatePanesCanvases: function(drawOptions) {
                if (!drawOptions.recreateCanvas) {
                    return
                }(0, _utils.updatePanesCanvases)(this.panes, this._canvas, this._isRotated())
            },
            _normalizePanesHeight: function() {
                (0, _utils.normalizePanesHeight)(this.panes)
            },
            _renderScaleBreaks: function() {
                this._valueAxes.concat(this._argumentAxes).forEach(function(axis) {
                    axis.drawScaleBreaks()
                })
            },
            _getArgFilter: function() {
                return (0, _range_data_calculator.getViewPortFilter)(this.getArgumentAxis().visualRange() || {})
            },
            _applyPointMarkersAutoHiding: function() {
                var that = this;
                var allSeries = that.series;
                if (!that._themeManager.getOptions("autoHidePointMarkers")) {
                    allSeries.forEach(function(s) {
                        return s.autoHidePointMarkers = false
                    });
                    return
                }
                that.panes.forEach(function(_ref2) {
                    var name = _ref2.name;
                    var series = allSeries.filter(function(s) {
                        return s.pane === name && s.usePointsToDefineAutoHiding()
                    });
                    var argAxis = that.getArgumentAxis();
                    var argVisualRange = argAxis.visualRange();
                    var argAxisIsDiscrete = argAxis.getOptions().type === DISCRETE;
                    var markersInfo = collectMarkersInfoBySeries(allSeries, series, argAxis);
                    var sortingCallback = argAxisIsDiscrete ? function(p1, p2) {
                        return argVisualRange.categories.indexOf(p1.argument) - argVisualRange.categories.indexOf(p2.argument)
                    } : function(p1, p2) {
                        return p1.argument - p2.argument
                    };
                    markersInfo.points.sort(sortingCallback);
                    updateMarkersInfo(markersInfo);
                    applyAutoHidePointMarkers(allSeries, series, markersInfo.overloadedSeries, argAxis)
                })
            },
            _renderAxes: function(drawOptions, panesBorderOptions) {
                function calculateTitlesWidth(axes) {
                    return axes.map(function(axis) {
                        if (!axis.getTitle) {
                            return 0
                        }
                        var title = axis.getTitle();
                        return title ? title.bBox.width : 0
                    })
                }
                var that = this;
                var rotated = that._isRotated();
                var synchronizeMultiAxes = that._themeManager.getOptions("synchronizeMultiAxes");
                var scrollBar = that._scrollBar ? [that._scrollBar] : [];
                var extendedArgAxes = that._isArgumentAxisBeforeScrollBar() ? that._argumentAxes.concat(scrollBar) : scrollBar.concat(that._argumentAxes);
                var verticalAxes = rotated ? that._argumentAxes : that._valueAxes;
                var verticalElements = rotated ? extendedArgAxes : that._valueAxes;
                var horizontalAxes = rotated ? that._valueAxes : that._argumentAxes;
                var horizontalElements = rotated ? that._valueAxes : extendedArgAxes;
                var allAxes = verticalAxes.concat(horizontalAxes);
                var allElements = allAxes.concat(scrollBar);
                that._normalizePanesHeight();
                that._updatePanesCanvases(drawOptions);
                var panesCanvases = that.panes.reduce(function(canvases, pane) {
                    canvases[pane.name] = (0, _extend2.extend)({}, pane.canvas);
                    return canvases
                }, {});
                var paneSizes = that.panes.reduce(function(sizes, pane) {
                    sizes[pane.name] = {
                        height: pane.height,
                        unit: pane.unit
                    };
                    return sizes
                }, {});
                var cleanPanesCanvases = (0, _extend2.extend)(true, {}, panesCanvases);
                that._initCustomPositioningAxes();
                var needCustomAdjustAxes = that._axesBoundaryPositioning();
                if (!drawOptions.adjustAxes && !needCustomAdjustAxes) {
                    drawAxesWithTicks(verticalAxes, !rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);
                    drawAxesWithTicks(horizontalAxes, rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);
                    performActionOnAxes(allAxes, "prepareAnimation");
                    that._renderScaleBreaks();
                    return false
                }
                if (needCustomAdjustAxes) {
                    allAxes.forEach(function(a) {
                        return a.customPositionIsAvailable() && a.shift({
                            top: 0,
                            left: 0,
                            bottom: 0,
                            right: 0
                        })
                    })
                }
                if (that._scrollBar) {
                    that._scrollBar.setPane(that.panes)
                }
                var vAxesMargins = {
                    panes: {}
                };
                var hAxesMargins = getHorizontalAxesMargins(horizontalElements, function(axis) {
                    return axis.estimateMargins(panesCanvases[axis.pane])
                });
                panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
                var drawAxesAndSetCanvases = function(isHorizontal) {
                    var axes = isHorizontal ? horizontalAxes : verticalAxes;
                    var condition = (isHorizontal ? rotated : !rotated) && synchronizeMultiAxes;
                    drawAxesWithTicks(axes, condition, panesCanvases, panesBorderOptions);
                    if (isHorizontal) {
                        hAxesMargins = getHorizontalAxesMargins(horizontalElements, getAxisMargins)
                    } else {
                        vAxesMargins = getVerticalAxesMargins(verticalElements)
                    }
                    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins)
                };
                drawAxesAndSetCanvases(false);
                drawAxesAndSetCanvases(true);
                if (that._estimateTickIntervals(verticalAxes, panesCanvases)) {
                    drawAxesAndSetCanvases(false)
                }
                var oldTitlesWidth = calculateTitlesWidth(verticalAxes);
                var visibleSeries = that._getVisibleSeries();
                var pointsToAnimation = that._getPointsToAnimation(visibleSeries);
                performActionOnAxes(allElements, "updateSize", panesCanvases, axisAnimationEnabled(drawOptions, pointsToAnimation));
                horizontalElements.forEach(shiftAxis("top", "bottom"));
                verticalElements.forEach(shiftAxis("left", "right"));
                that._renderScaleBreaks();
                that.panes.forEach(function(pane) {
                    (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name])
                });
                that._valueAxes.forEach(function(axis) {
                    axis.setInitRange()
                });
                verticalAxes.forEach(function(axis, i) {
                    if (axis.hasWrap && axis.hasWrap()) {
                        var title = axis.getTitle();
                        var newTitleWidth = title ? title.bBox.width : 0;
                        var offset = newTitleWidth - oldTitlesWidth[i];
                        if ("right" === axis.getOptions().position) {
                            vAxesMargins.right += offset
                        } else {
                            vAxesMargins.left += offset;
                            that.panes.forEach(function(_ref3) {
                                var name = _ref3.name;
                                return vAxesMargins.panes[name].left += offset
                            })
                        }
                        panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
                        performActionOnAxes(allElements, "updateSize", panesCanvases, false, false);
                        oldTitlesWidth = calculateTitlesWidth(verticalAxes)
                    }
                });
                if (verticalAxes.some(function(v) {
                        return v.customPositionIsAvailable() && v.getCustomPosition() !== v._axisPosition
                    })) {
                    performActionOnAxes(verticalAxes, "updateSize", panesCanvases, axisAnimationEnabled(drawOptions, pointsToAnimation))
                }
                return cleanPanesCanvases
            },
            _estimateTickIntervals: function(axes, canvases) {
                return axes.some(function(axis) {
                    return axis.estimateTickInterval(canvases[axis.pane])
                })
            },
            checkForMoreSpaceForPanesCanvas: function() {
                var that = this;
                var rotated = that._isRotated();
                var panesAreCustomSized = that.panes.filter(function(p) {
                    return p.unit
                }).length === that.panes.length;
                var needSpace = false;
                if (panesAreCustomSized) {
                    var needHorizontalSpace = 0;
                    var needVerticalSpace = 0;
                    if (rotated) {
                        var argAxisRightMargin = that.getArgumentAxis().getMargins().right;
                        var rightPanesIndent = Math.min.apply(Math, that.panes.map(function(p) {
                            return p.canvas.right
                        }));
                        needHorizontalSpace = that._canvas.right + argAxisRightMargin - rightPanesIndent
                    } else {
                        var argAxisBottomMargin = that.getArgumentAxis().getMargins().bottom;
                        var bottomPanesIndent = Math.min.apply(Math, that.panes.map(function(p) {
                            return p.canvas.bottom
                        }));
                        needVerticalSpace = that._canvas.bottom + argAxisBottomMargin - bottomPanesIndent
                    }
                    needSpace = needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
                        width: needHorizontalSpace,
                        height: needVerticalSpace
                    } : false;
                    if (0 !== needVerticalSpace) {
                        var realSize = that.getSize();
                        var customSize = that.option("size");
                        var container = that._$element[0];
                        var containerHasStyledHeight = !!container.style.height || (0, _utils.checkElementHasPropertyFromStyleSheet)(container, "height");
                        if (!rotated && !(customSize && customSize.height) && !containerHasStyledHeight) {
                            that._forceResize(realSize.width, realSize.height + needVerticalSpace);
                            needSpace = false
                        }
                    }
                } else {
                    needSpace = that.layoutManager.needMoreSpaceForPanesCanvas(that._getLayoutTargets(), rotated, function(pane) {
                        return {
                            width: rotated && !!pane.unit,
                            height: !rotated && !!pane.unit
                        }
                    })
                }
                return needSpace
            },
            _forceResize: function(width, height) {
                this._renderer.resize(width, height);
                this._updateSize();
                this._setContentSize();
                this._preserveOriginalCanvas();
                this._updateCanvasClipRect(this._canvas)
            },
            _shrinkAxes: function(sizeShortage, panesCanvases) {
                if (!sizeShortage || !panesCanvases) {
                    return
                }
                this._renderer.stopAllAnimations(true);
                var that = this;
                var rotated = that._isRotated();
                var scrollBar = that._scrollBar ? [that._scrollBar] : [];
                var extendedArgAxes = that._isArgumentAxisBeforeScrollBar() ? that._argumentAxes.concat(scrollBar) : scrollBar.concat(that._argumentAxes);
                var verticalAxes = rotated ? extendedArgAxes : that._valueAxes;
                var horizontalAxes = rotated ? that._valueAxes : extendedArgAxes;
                var allAxes = verticalAxes.concat(horizontalAxes);
                if (sizeShortage.width || sizeShortage.height) {
                    checkUsedSpace(sizeShortage, "height", horizontalAxes, getHorizontalAxesMargins);
                    checkUsedSpace(sizeShortage, "width", verticalAxes, getVerticalAxesMargins);
                    performActionOnAxes(allAxes, "updateSize", panesCanvases);
                    var paneSizes = that.panes.reduce(function(sizes, pane) {
                        sizes[pane.name] = {
                            height: pane.height,
                            unit: pane.unit
                        };
                        return sizes
                    }, {});
                    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, getVerticalAxesMargins(verticalAxes), getHorizontalAxesMargins(horizontalAxes, getAxisMargins));
                    performActionOnAxes(allAxes, "updateSize", panesCanvases);
                    horizontalAxes.forEach(shiftAxis("top", "bottom"));
                    verticalAxes.forEach(shiftAxis("left", "right"));
                    that.panes.forEach(function(pane) {
                        return (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name])
                    })
                }
            },
            _isArgumentAxisBeforeScrollBar: function() {
                var that = this;
                var argumentAxis = that.getArgumentAxis();
                if (that._scrollBar) {
                    var _argumentAxis$getOpti;
                    var argAxisPosition = argumentAxis.getResolvedBoundaryPosition();
                    var argAxisLabelPosition = null === (_argumentAxis$getOpti = argumentAxis.getOptions().label) || void 0 === _argumentAxis$getOpti ? void 0 : _argumentAxis$getOpti.position;
                    var scrollBarPosition = that._scrollBar.getOptions().position;
                    return argumentAxis.hasCustomPosition() || scrollBarPosition === argAxisPosition && argAxisLabelPosition !== scrollBarPosition
                }
                return false
            },
            _getPanesParameters: function() {
                var that = this;
                var panes = that.panes;
                var i;
                var params = [];
                for (i = 0; i < panes.length; i++) {
                    if (that._getPaneBorderVisibility(i)) {
                        params.push({
                            coords: panes[i].borderCoords,
                            clipRect: that._panesClipRects.fixed[i]
                        })
                    }
                }
                return params
            },
            _createCrosshairCursor: function() {
                var that = this;
                var options = that._themeManager.getOptions("crosshair") || {};
                var argumentAxis = that.getArgumentAxis();
                var axes = !that._isRotated() ? [
                    [argumentAxis], that._valueAxes
                ] : [that._valueAxes, [argumentAxis]];
                var parameters = {
                    canvas: that._getCommonCanvas(),
                    panes: that._getPanesParameters(),
                    axes: axes
                };
                if (!options || !options.enabled) {
                    return
                }
                if (!that._crosshair) {
                    that._crosshair = new _crosshair2.default.Crosshair(that._renderer, options, parameters, that._crosshairCursorGroup)
                } else {
                    that._crosshair.update(options, parameters)
                }
                that._crosshair.render()
            },
            _getCommonCanvas: function() {
                var i;
                var canvas;
                var commonCanvas;
                var panes = this.panes;
                for (i = 0; i < panes.length; i++) {
                    canvas = panes[i].canvas;
                    if (!commonCanvas) {
                        commonCanvas = (0, _extend2.extend)({}, canvas)
                    } else {
                        commonCanvas.right = canvas.right;
                        commonCanvas.bottom = canvas.bottom
                    }
                }
                return commonCanvas
            },
            _createPanesBackground: function() {
                var that = this;
                var defaultBackgroundColor = that._themeManager.getOptions("commonPaneSettings").backgroundColor;
                var backgroundColor;
                var renderer = that._renderer;
                var rect;
                var i;
                var rects = [];
                that._panesBackgroundGroup.clear();
                for (i = 0; i < that.panes.length; i++) {
                    backgroundColor = that.panes[i].backgroundColor || defaultBackgroundColor;
                    if (!backgroundColor || "none" === backgroundColor) {
                        rects.push(null);
                        continue
                    }
                    rect = renderer.rect(0, 0, 0, 0).attr({
                        fill: backgroundColor,
                        "stroke-width": 0
                    }).append(that._panesBackgroundGroup);
                    rects.push(rect)
                }
                that.panesBackground = rects
            },
            _fillPanesBackground: function() {
                var that = this;
                var bc;
                (0, _iterator.each)(that.panes, function(i, pane) {
                    bc = pane.borderCoords;
                    if (null !== that.panesBackground[i]) {
                        that.panesBackground[i].attr({
                            x: bc.left,
                            y: bc.top,
                            width: bc.width,
                            height: bc.height
                        })
                    }
                })
            },
            _calcPaneBorderCoords: function(pane) {
                var canvas = pane.canvas;
                var bc = pane.borderCoords = pane.borderCoords || {};
                bc.left = canvas.left;
                bc.top = canvas.top;
                bc.right = canvas.width - canvas.right;
                bc.bottom = canvas.height - canvas.bottom;
                bc.width = Math.max(bc.right - bc.left, 0);
                bc.height = Math.max(bc.bottom - bc.top, 0)
            },
            _drawPanesBorders: function(panesBorderOptions) {
                var that = this;
                var rotated = that._isRotated();
                that._panesBorderGroup.linkRemove().clear();
                (0, _iterator.each)(that.panes, function(i, pane) {
                    var borderOptions = panesBorderOptions[pane.name];
                    var attr = {
                        fill: "none",
                        stroke: borderOptions.color,
                        "stroke-opacity": borderOptions.opacity,
                        "stroke-width": borderOptions.width,
                        dashStyle: borderOptions.dashStyle,
                        "stroke-linecap": "square"
                    };
                    that._calcPaneBorderCoords(pane, rotated);
                    if (!borderOptions.visible) {
                        return
                    }
                    var bc = pane.borderCoords;
                    var segmentRectParams = prepareSegmentRectPoints(bc.left, bc.top, bc.width, bc.height, borderOptions);
                    that._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup)
                });
                that._panesBorderGroup.linkAppend()
            },
            _createClipRect: function(clipArray, index, left, top, width, height) {
                var that = this;
                var clipRect = clipArray[index];
                if (!clipRect) {
                    clipRect = that._renderer.clipRect(left, top, width, height);
                    clipArray[index] = clipRect
                } else {
                    clipRect.attr({
                        x: left,
                        y: top,
                        width: width,
                        height: height
                    })
                }
            },
            _createClipRectsForPanes: function() {
                var that = this;
                var canvas = that._canvas;
                (0, _iterator.each)(that.panes, function(i, pane) {
                    var needWideClipRect = false;
                    var bc = pane.borderCoords;
                    var left = bc.left;
                    var top = bc.top;
                    var width = bc.width;
                    var height = bc.height;
                    var panesClipRects = that._panesClipRects;
                    that._createClipRect(panesClipRects.fixed, i, left, top, width, height);
                    that._createClipRect(panesClipRects.base, i, left, top, width, height);
                    (0, _iterator.each)(that.series, function(_, series) {
                        if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {
                            needWideClipRect = true
                        }
                    });
                    if (needWideClipRect) {
                        if (that._isRotated()) {
                            top = 0;
                            height = canvas.height
                        } else {
                            left = 0;
                            width = canvas.width
                        }
                        that._createClipRect(panesClipRects.wide, i, left, top, width, height)
                    } else {
                        panesClipRects.wide[i] = null
                    }
                })
            },
            _applyClipRectsForAxes: function() {
                var that = this;
                var axes = that._argumentAxes.concat(that._valueAxes);
                var customPositionAxes = axes.filter(function(a) {
                    return a.hasCustomPosition()
                });
                var chartCanvasClipRectID = that._getCanvasClipRectID();
                for (var i = 0; i < axes.length; i++) {
                    var elementsClipRectID = that._getElementsClipRectID(axes[i].pane);
                    var canvasClipRectID = customPositionAxes.indexOf(axes[i]) >= 0 ? elementsClipRectID : chartCanvasClipRectID;
                    axes[i].applyClipRects(elementsClipRectID, canvasClipRectID)
                }
            },
            _getPaneBorderVisibility: function(paneIndex) {
                var commonPaneBorderVisible = this._themeManager.getOptions("commonPaneSettings").border.visible;
                var pane = this.panes[paneIndex] || {};
                var paneBorder = pane.border || {};
                return "visible" in paneBorder ? paneBorder.visible : commonPaneBorderVisible
            },
            _getCanvasForPane: function(paneName) {
                var panes = this.panes;
                var panesNumber = panes.length;
                var i;
                for (i = 0; i < panesNumber; i++) {
                    if (panes[i].name === paneName) {
                        return panes[i].canvas
                    }
                }
            },
            _getTrackerSettings: function() {
                var that = this;
                var themeManager = that._themeManager;
                return (0, _extend2.extend)(this.callBase(), {
                    chart: that,
                    rotated: that._isRotated(),
                    crosshair: that._getCrosshairOptions().enabled ? that._crosshair : null,
                    stickyHovering: themeManager.getOptions("stickyHovering")
                })
            },
            _resolveLabelOverlappingStack: function() {
                var that = this;
                var isRotated = that._isRotated();
                var shiftDirection = isRotated ? function(box, length) {
                    return {
                        x: box.x - length,
                        y: box.y
                    }
                } : function(box, length) {
                    return {
                        x: box.x,
                        y: box.y - length
                    }
                };
                (0, _iterator.each)(that._getStackPoints(), function(_, stacks) {
                    (0, _iterator.each)(stacks, function(_, points) {
                        _base_chart.overlapping.resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated, shiftDirection, function(a, b) {
                            var coordPosition = isRotated ? 1 : 0;
                            var figureCenter1 = a.labels[0].getFigureCenter()[coordPosition];
                            var figureCenter12 = b.labels[0].getFigureCenter()[coordPosition];
                            if (figureCenter1 - figureCenter12 === 0) {
                                return (a.value() - b.value()) * (a.labels[0].getPoint().series.getValueAxis().getTranslator().isInverted() ? -1 : 1)
                            }
                            return 0
                        })
                    })
                })
            },
            _getStackPoints: function() {
                var stackPoints = {};
                var visibleSeries = this._getVisibleSeries();
                (0, _iterator.each)(visibleSeries, function(_, singleSeries) {
                    var points = singleSeries.getPoints();
                    var stackName = singleSeries.getStackName() || null;
                    (0, _iterator.each)(points, function(_, point) {
                        var argument = point.argument;
                        if (!stackPoints[argument]) {
                            stackPoints[argument] = {}
                        }
                        if (!stackPoints[argument][stackName]) {
                            stackPoints[argument][stackName] = []
                        }
                        stackPoints[argument][stackName].push(point)
                    })
                });
                return stackPoints
            },
            _getCrosshairOptions: function() {
                return this._getOption("crosshair")
            },
            zoomArgument: function(min, max) {
                var that = this;
                if (!that._initialized || !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {
                    return
                }
                that.getArgumentAxis().visualRange([min, max])
            },
            resetVisualRange: function() {
                var that = this;
                var axes = that._argumentAxes;
                var nonVirtualArgumentAxis = that.getArgumentAxis();
                axes.forEach(function(axis) {
                    axis.resetVisualRange(nonVirtualArgumentAxis !== axis);
                    that._applyCustomVisualRangeOption(axis)
                });
                that.callBase()
            },
            getVisibleArgumentBounds: function() {
                var translator = this._argumentAxes[0].getTranslator();
                var range = translator.getBusinessRange();
                var isDiscrete = range.axisType === DISCRETE;
                var categories = range.categories;
                return {
                    minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,
                    maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible
                }
            },
            _change_FULL_RENDER: function() {
                this.callBase();
                if (this._changes.has(VISUAL_RANGE)) {
                    this._raiseZoomEndHandlers()
                }
            },
            _getAxesForScaling: function() {
                return [this.getArgumentAxis()].concat(this._valueAxes)
            },
            _applyVisualRangeByVirtualAxes: function(axis, range) {
                var that = this;
                if (axis.isArgumentAxis) {
                    if (axis !== that.getArgumentAxis()) {
                        return true
                    }
                    that._argumentAxes.filter(function(a) {
                        return a !== axis
                    }).forEach(function(a) {
                        return a.visualRange(range, {
                            start: true,
                            end: true
                        })
                    })
                }
                return false
            },
            _raiseZoomEndHandlers: function() {
                this._argumentAxes.forEach(function(axis) {
                    return axis.handleZoomEnd()
                });
                this.callBase()
            },
            _setOptionsByReference: function() {
                this.callBase();
                (0, _extend2.extend)(this._optionsByReference, {
                    "argumentAxis.visualRange": true
                })
            },
            option: function option() {
                var option = this.callBase.apply(this, arguments);
                var valueAxis = this._options.silent("valueAxis");
                if ("array" === (0, _type.type)(valueAxis)) {
                    for (var i = 0; i < valueAxis.length; i++) {
                        var optionPath = "valueAxis[".concat(i, "].visualRange");
                        this._optionsByReference[optionPath] = true
                    }
                }
                return option
            },
            _notifyVisualRange: function() {
                var that = this;
                var argAxis = that._argumentAxes[0];
                var argumentVisualRange = (0, _utils.convertVisualRangeObject)(argAxis.visualRange(), !_isArray(that.option("argumentAxis.visualRange")));
                if (!argAxis.skipEventRising || !(0, _utils.rangesAreEqual)(argumentVisualRange, that.option("argumentAxis.visualRange"))) {
                    that.option("argumentAxis.visualRange", argumentVisualRange)
                } else {
                    argAxis.skipEventRising = null
                }
                that.callBase()
            }
        });
        dxChart.addPlugin(__webpack_require__( /*! ./chart_components/shutter_zoom */ 838));
        dxChart.addPlugin(__webpack_require__( /*! ./chart_components/zoom_and_pan */ 839));
        dxChart.addPlugin(__webpack_require__( /*! ./core/annotations */ 212).plugins.core);
        dxChart.addPlugin(__webpack_require__( /*! ./core/annotations */ 212).plugins.chart);
        (0, _component_registrator2.default)("dxChart", dxChart);
        module.exports = dxChart;
        module.exports._test_prepareSegmentRectPoints = function() {
            var original = prepareSegmentRectPoints.original || prepareSegmentRectPoints;
            if (arguments[0]) {
                prepareSegmentRectPoints = arguments[0]
            }
            prepareSegmentRectPoints.original = original;
            prepareSegmentRectPoints.restore = function() {
                prepareSegmentRectPoints = original
            };
            return prepareSegmentRectPoints
        }
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/generic.light.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var WHITE = "#ffffff";
        var BLACK = "#000000";
        var LIGHT_GREY = "#d3d3d3";
        var GREY_GREEN = "#303030";
        var SOME_GREY = "#2b2b2b";
        var RED = "#ff0000";
        var PRIMARY_TITLE_COLOR = "#232323";
        var SECONDARY_TITLE_COLOR = "#767676";
        var NONE = "none";
        var SOLID = "solid";
        var TOP = "top";
        var RIGHT = "right";
        var BOTTOM = "bottom";
        var LEFT = "left";
        var CENTER = "center";
        var INSIDE = "inside";
        var OUTSIDE = "outside";
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        registerTheme({
            name: "generic.light",
            isDefault: true,
            font: {
                color: SECONDARY_TITLE_COLOR,
                family: "'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana, sans-serif",
                weight: 400,
                size: 12,
                cursor: "default"
            },
            redrawOnResize: true,
            backgroundColor: WHITE,
            primaryTitleColor: PRIMARY_TITLE_COLOR,
            secondaryTitleColor: SECONDARY_TITLE_COLOR,
            gridColor: LIGHT_GREY,
            axisColor: SECONDARY_TITLE_COLOR,
            title: {
                backgroundColor: WHITE,
                font: {
                    size: 28,
                    family: "'Segoe UI Light', 'Helvetica Neue Light', 'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana, sans-serif",
                    weight: 200
                },
                subtitle: {
                    font: {
                        size: 16
                    },
                    offset: 0,
                    wordWrap: "normal",
                    textOverflow: "ellipsis"
                },
                wordWrap: "normal",
                textOverflow: "ellipsis"
            },
            loadingIndicator: {
                text: "Loading..."
            },
            "export": {
                backgroundColor: WHITE,
                margin: 10,
                font: {
                    size: 14,
                    color: PRIMARY_TITLE_COLOR,
                    weight: 400
                },
                button: {
                    margin: {
                        top: 8,
                        left: 10,
                        right: 10,
                        bottom: 8
                    },
                    "default": {
                        color: "#333",
                        borderColor: "#ddd",
                        backgroundColor: WHITE
                    },
                    hover: {
                        color: "#333",
                        borderColor: "#bebebe",
                        backgroundColor: "#e6e6e6"
                    },
                    focus: {
                        color: BLACK,
                        borderColor: "#9d9d9d",
                        backgroundColor: "#e6e6e6"
                    },
                    active: {
                        color: "#333",
                        borderColor: "#9d9d9d",
                        backgroundColor: "#d4d4d4"
                    }
                },
                shadowColor: LIGHT_GREY
            },
            tooltip: {
                enabled: false,
                border: {
                    width: 1,
                    color: LIGHT_GREY,
                    dashStyle: SOLID,
                    visible: true
                },
                font: {
                    color: PRIMARY_TITLE_COLOR
                },
                color: WHITE,
                arrowLength: 10,
                paddingLeftRight: 18,
                paddingTopBottom: 15,
                textAlignment: "center",
                shared: false,
                location: CENTER,
                shadow: {
                    opacity: .4,
                    offsetX: 0,
                    offsetY: 4,
                    blur: 2,
                    color: BLACK
                },
                interactive: false
            },
            legend: {
                hoverMode: "includePoints",
                verticalAlignment: TOP,
                horizontalAlignment: RIGHT,
                position: OUTSIDE,
                visible: true,
                margin: 10,
                markerSize: 12,
                border: {
                    visible: false,
                    width: 1,
                    cornerRadius: 0,
                    dashStyle: SOLID
                },
                paddingLeftRight: 20,
                paddingTopBottom: 15,
                columnCount: 0,
                rowCount: 0,
                columnItemSpacing: 20,
                rowItemSpacing: 8,
                title: {
                    backgroundColor: WHITE,
                    margin: {
                        left: 0,
                        bottom: 9,
                        right: 0,
                        top: 0
                    },
                    font: {
                        size: 18,
                        weight: 200
                    },
                    subtitle: {
                        offset: 0,
                        font: {
                            size: 14
                        },
                        wordWrap: "none",
                        textOverflow: "ellipsis"
                    },
                    wordWrap: "none",
                    textOverflow: "ellipsis"
                }
            },
            "chart:common": {
                animation: {
                    enabled: true,
                    duration: 1e3,
                    easing: "easeOutCubic",
                    maxPointCountSupported: 300
                },
                commonSeriesSettings: {
                    border: {
                        visible: false,
                        width: 2
                    },
                    showInLegend: true,
                    visible: true,
                    hoverMode: "nearestPoint",
                    selectionMode: "includePoints",
                    hoverStyle: {
                        hatching: {
                            direction: RIGHT,
                            width: 2,
                            step: 6,
                            opacity: .75
                        },
                        border: {
                            visible: false,
                            width: 3
                        }
                    },
                    selectionStyle: {
                        hatching: {
                            direction: RIGHT,
                            width: 2,
                            step: 6,
                            opacity: .5
                        },
                        border: {
                            visible: false,
                            width: 3
                        }
                    },
                    valueErrorBar: {
                        displayMode: "auto",
                        value: 1,
                        color: BLACK,
                        lineWidth: 2,
                        edgeLength: 8
                    },
                    label: {
                        visible: false,
                        alignment: CENTER,
                        rotationAngle: 0,
                        horizontalOffset: 0,
                        verticalOffset: 0,
                        radialOffset: 0,
                        showForZeroValues: true,
                        customizeText: void 0,
                        maxLabelCount: void 0,
                        position: OUTSIDE,
                        font: {
                            color: WHITE
                        },
                        border: {
                            visible: false,
                            width: 1,
                            color: LIGHT_GREY,
                            dashStyle: SOLID
                        },
                        connector: {
                            visible: false,
                            width: 1
                        }
                    }
                },
                seriesSelectionMode: "single",
                pointSelectionMode: "single",
                equalRowHeight: true,
                dataPrepareSettings: {
                    checkTypeForAllData: false,
                    convertToAxisDataType: true,
                    sortingMethod: true
                },
                title: {
                    margin: 10
                },
                adaptiveLayout: {
                    width: 80,
                    height: 80,
                    keepLabels: true
                },
                _rtl: {
                    legend: {
                        itemTextPosition: LEFT
                    }
                },
                resolveLabelOverlapping: NONE
            },
            "chart:common:axis": {
                visible: true,
                valueMarginsEnabled: true,
                placeholderSize: null,
                logarithmBase: 10,
                discreteAxisDivisionMode: "betweenLabels",
                width: 1,
                label: {
                    visible: true
                },
                grid: {
                    visible: false,
                    width: 1
                },
                minorGrid: {
                    visible: false,
                    width: 1,
                    opacity: .3
                },
                tick: {
                    visible: true,
                    width: 1,
                    length: 7,
                    shift: 3
                },
                minorTick: {
                    visible: false,
                    width: 1,
                    opacity: .3,
                    length: 7,
                    shift: 3
                },
                stripStyle: {
                    paddingLeftRight: 10,
                    paddingTopBottom: 5
                },
                constantLineStyle: {
                    width: 1,
                    color: BLACK,
                    dashStyle: SOLID,
                    label: {
                        visible: true,
                        position: INSIDE
                    }
                },
                marker: {
                    label: {}
                }
            },
            "chart:common:annotation": {
                font: {
                    color: "#333333"
                },
                tooltipEnabled: true,
                border: {
                    width: 1,
                    color: "#dddddd",
                    dashStyle: SOLID,
                    visible: true
                },
                color: WHITE,
                opacity: .9,
                arrowLength: 14,
                arrowWidth: 14,
                paddingLeftRight: 10,
                paddingTopBottom: 10,
                shadow: {
                    opacity: .15,
                    offsetX: 0,
                    offsetY: 1,
                    blur: 4,
                    color: BLACK
                },
                image: {
                    width: 30,
                    height: 30
                },
                wordWrap: "normal",
                textOverflow: "ellipsis",
                allowDragging: false
            },
            chart: {
                commonSeriesSettings: {
                    type: "line",
                    stack: "default",
                    aggregation: {
                        enabled: void 0
                    },
                    point: {
                        visible: true,
                        symbol: "circle",
                        size: 12,
                        border: {
                            visible: false,
                            width: 1
                        },
                        hoverMode: "onlyPoint",
                        selectionMode: "onlyPoint",
                        hoverStyle: {
                            border: {
                                visible: true,
                                width: 4
                            }
                        },
                        selectionStyle: {
                            border: {
                                visible: true,
                                width: 4
                            }
                        }
                    },
                    scatter: {},
                    line: {
                        width: 2,
                        dashStyle: SOLID,
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        }
                    },
                    stackedline: {
                        width: 2,
                        dashStyle: SOLID,
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        }
                    },
                    stackedspline: {
                        width: 2,
                        dashStyle: SOLID,
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        }
                    },
                    fullstackedline: {
                        width: 2,
                        dashStyle: SOLID,
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        }
                    },
                    fullstackedspline: {
                        width: 2,
                        dashStyle: SOLID,
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        }
                    },
                    stepline: {
                        width: 2,
                        dashStyle: SOLID,
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        }
                    },
                    area: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    stackedarea: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    fullstackedarea: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    fullstackedsplinearea: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    steparea: {
                        border: {
                            visible: true,
                            width: 2
                        },
                        point: {
                            visible: false
                        },
                        hoverStyle: {
                            border: {
                                visible: true,
                                width: 3
                            }
                        },
                        selectionStyle: {
                            border: {
                                visible: true,
                                width: 3
                            }
                        },
                        opacity: .5
                    },
                    spline: {
                        width: 2,
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        }
                    },
                    splinearea: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    stackedsplinearea: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    bar: {
                        cornerRadius: 0,
                        point: {
                            hoverStyle: {
                                border: {
                                    visible: false
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: false
                                }
                            }
                        }
                    },
                    stackedbar: {
                        cornerRadius: 0,
                        point: {
                            hoverStyle: {
                                border: {
                                    visible: false
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: false
                                }
                            }
                        },
                        label: {
                            position: INSIDE
                        }
                    },
                    fullstackedbar: {
                        cornerRadius: 0,
                        point: {
                            hoverStyle: {
                                border: {
                                    visible: false
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: false
                                }
                            }
                        },
                        label: {
                            position: INSIDE
                        }
                    },
                    rangebar: {
                        cornerRadius: 0,
                        point: {
                            hoverStyle: {
                                border: {
                                    visible: false
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: false
                                }
                            }
                        }
                    },
                    rangearea: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    rangesplinearea: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    bubble: {
                        opacity: .5,
                        point: {
                            hoverStyle: {
                                border: {
                                    visible: false
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: false
                                }
                            }
                        }
                    },
                    candlestick: {
                        width: 1,
                        reduction: {
                            color: RED
                        },
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        },
                        point: {
                            border: {
                                visible: true
                            }
                        }
                    },
                    stock: {
                        width: 1,
                        reduction: {
                            color: RED
                        },
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        },
                        point: {
                            border: {
                                visible: true
                            }
                        }
                    }
                },
                crosshair: {
                    enabled: false,
                    color: "#f05b41",
                    width: 1,
                    dashStyle: SOLID,
                    label: {
                        visible: false,
                        font: {
                            color: WHITE,
                            size: 12
                        }
                    },
                    verticalLine: {
                        visible: true
                    },
                    horizontalLine: {
                        visible: true
                    }
                },
                commonAxisSettings: {
                    multipleAxesSpacing: 5,
                    forceUserTickInterval: false,
                    breakStyle: {
                        width: 5,
                        color: "#ababab",
                        line: "waved"
                    },
                    label: {
                        displayMode: "standard",
                        overlappingBehavior: "hide",
                        indentFromAxis: 10,
                        wordWrap: "normal",
                        textOverflow: "none"
                    },
                    title: {
                        font: {
                            size: 16
                        },
                        margin: 6,
                        alignment: CENTER
                    },
                    constantLineStyle: {
                        paddingLeftRight: 10,
                        paddingTopBottom: 10
                    }
                },
                horizontalAxis: {
                    position: BOTTOM,
                    axisDivisionFactor: 70,
                    label: {
                        rotationAngle: 90,
                        staggeringSpacing: 5,
                        alignment: CENTER
                    },
                    stripStyle: {
                        label: {
                            horizontalAlignment: CENTER,
                            verticalAlignment: TOP
                        }
                    },
                    constantLineStyle: {
                        label: {
                            horizontalAlignment: RIGHT,
                            verticalAlignment: TOP
                        }
                    },
                    constantLines: []
                },
                verticalAxis: {
                    position: LEFT,
                    axisDivisionFactor: 40,
                    label: {
                        alignment: RIGHT
                    },
                    stripStyle: {
                        label: {
                            horizontalAlignment: LEFT,
                            verticalAlignment: CENTER
                        }
                    },
                    constantLineStyle: {
                        label: {
                            horizontalAlignment: LEFT,
                            verticalAlignment: TOP
                        }
                    },
                    constantLines: []
                },
                argumentAxis: {
                    endOnTick: false,
                    workWeek: [1, 2, 3, 4, 5]
                },
                valueAxis: {
                    grid: {
                        visible: true
                    },
                    autoBreaksEnabled: false,
                    maxAutoBreakCount: 4
                },
                commonPaneSettings: {
                    backgroundColor: NONE,
                    border: {
                        color: LIGHT_GREY,
                        width: 1,
                        visible: false,
                        top: true,
                        bottom: true,
                        left: true,
                        right: true,
                        dashStyle: SOLID
                    }
                },
                scrollBar: {
                    visible: false,
                    offset: 5,
                    color: "gray",
                    width: 10
                },
                adjustOnZoom: true,
                autoHidePointMarkers: true,
                rotated: false,
                zoomingMode: NONE,
                scrollingMode: NONE,
                synchronizeMultiAxes: true,
                stickyHovering: true,
                equalBarWidth: true,
                barGroupPadding: .3,
                minBubbleSize: 12,
                maxBubbleSize: .2,
                zoomAndPan: {
                    dragBoxStyle: {
                        color: "#2a2a2a",
                        opacity: .2
                    },
                    panKey: "shift",
                    allowMouseWheel: true,
                    allowTouchGestures: true
                }
            },
            pie: {
                innerRadius: .5,
                minDiameter: .5,
                type: "pie",
                dataPrepareSettings: {
                    _skipArgumentSorting: true
                },
                commonSeriesSettings: {
                    pie: {
                        border: {
                            visible: false,
                            width: 2,
                            color: WHITE
                        },
                        hoverStyle: {
                            hatching: {
                                direction: RIGHT,
                                width: 4,
                                step: 10,
                                opacity: .75
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                direction: RIGHT,
                                width: 4,
                                step: 10,
                                opacity: .5
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        }
                    },
                    doughnut: {
                        border: {
                            visible: false,
                            width: 2,
                            color: WHITE
                        },
                        hoverStyle: {
                            hatching: {
                                direction: RIGHT,
                                width: 4,
                                step: 10,
                                opacity: .75
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                direction: RIGHT,
                                width: 4,
                                step: 10,
                                opacity: .5
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        }
                    },
                    donut: {
                        border: {
                            visible: false,
                            width: 2,
                            color: WHITE
                        },
                        hoverStyle: {
                            hatching: {
                                direction: RIGHT,
                                width: 4,
                                step: 10,
                                opacity: .75
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                direction: RIGHT,
                                width: 4,
                                step: 10,
                                opacity: .5
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        }
                    },
                    label: {
                        textOverflow: "ellipsis",
                        wordWrap: "normal"
                    }
                },
                legend: {
                    hoverMode: "allArgumentPoints",
                    backgroundColor: NONE
                },
                adaptiveLayout: {
                    keepLabels: false
                }
            },
            gauge: {
                scale: {
                    tick: {
                        visible: true,
                        length: 5,
                        width: 2,
                        opacity: 1
                    },
                    minorTick: {
                        visible: false,
                        length: 3,
                        width: 1,
                        opacity: 1
                    },
                    label: {
                        visible: true,
                        alignment: CENTER,
                        hideFirstOrLast: "last",
                        overlappingBehavior: "hide"
                    },
                    position: TOP,
                    endOnTick: false
                },
                rangeContainer: {
                    offset: 0,
                    width: 5,
                    backgroundColor: "#808080"
                },
                valueIndicators: {
                    _default: {
                        color: "#c2c2c2"
                    },
                    rangebar: {
                        space: 2,
                        size: 10,
                        color: "#cbc5cf",
                        backgroundColor: NONE,
                        text: {
                            indent: 0,
                            font: {
                                size: 14,
                                color: null
                            }
                        }
                    },
                    twocolorneedle: {
                        secondColor: "#e18e92"
                    },
                    trianglemarker: {
                        space: 2,
                        length: 14,
                        width: 13,
                        color: "#8798a5"
                    },
                    textcloud: {
                        arrowLength: 5,
                        horizontalOffset: 6,
                        verticalOffset: 3,
                        color: "#679ec5",
                        text: {
                            font: {
                                color: WHITE,
                                size: 18
                            }
                        }
                    }
                },
                indicator: {
                    hasPositiveMeaning: true,
                    layout: {
                        horizontalAlignment: CENTER,
                        verticalAlignment: BOTTOM
                    },
                    text: {
                        font: {
                            size: 18
                        }
                    }
                },
                _circular: {
                    scale: {
                        scaleDivisionFactor: 17,
                        orientation: OUTSIDE,
                        label: {
                            indentFromTick: 10
                        }
                    },
                    rangeContainer: {
                        orientation: OUTSIDE
                    },
                    valueIndicatorType: "rectangleneedle",
                    subvalueIndicatorType: "trianglemarker",
                    valueIndicators: {
                        _type: "rectangleneedle",
                        _default: {
                            offset: 20,
                            indentFromCenter: 0,
                            width: 2,
                            spindleSize: 14,
                            spindleGapSize: 10,
                            beginAdaptingAtRadius: 50
                        },
                        triangleneedle: {
                            width: 4
                        },
                        twocolorneedle: {
                            space: 2,
                            secondFraction: .4
                        },
                        rangebar: {
                            offset: 30
                        },
                        trianglemarker: {
                            offset: 6
                        },
                        textcloud: {
                            offset: -6
                        }
                    }
                },
                _linear: {
                    scale: {
                        scaleDivisionFactor: 25,
                        horizontalOrientation: RIGHT,
                        verticalOrientation: BOTTOM,
                        label: {
                            indentFromTick: -10
                        }
                    },
                    rangeContainer: {
                        horizontalOrientation: RIGHT,
                        verticalOrientation: BOTTOM
                    },
                    valueIndicatorType: "rangebar",
                    subvalueIndicatorType: "trianglemarker",
                    valueIndicators: {
                        _type: "rectangle",
                        _default: {
                            offset: 2.5,
                            length: 15,
                            width: 15
                        },
                        rectangle: {
                            width: 10
                        },
                        rangebar: {
                            offset: 10,
                            horizontalOrientation: RIGHT,
                            verticalOrientation: BOTTOM
                        },
                        trianglemarker: {
                            offset: 10,
                            horizontalOrientation: LEFT,
                            verticalOrientation: TOP
                        },
                        textcloud: {
                            offset: -1,
                            horizontalOrientation: LEFT,
                            verticalOrientation: TOP
                        }
                    }
                }
            },
            barGauge: {
                backgroundColor: "#e0e0e0",
                relativeInnerRadius: .3,
                barSpacing: 4,
                resolveLabelOverlapping: "hide",
                label: {
                    indent: 20,
                    connectorWidth: 2,
                    font: {
                        size: 16
                    }
                },
                legend: {
                    visible: false
                },
                indicator: {
                    hasPositiveMeaning: true,
                    layout: {
                        horizontalAlignment: CENTER,
                        verticalAlignment: BOTTOM
                    },
                    text: {
                        font: {
                            size: 18
                        }
                    }
                }
            },
            rangeSelector: {
                scale: {
                    valueMarginsEnabled: true,
                    width: 1,
                    color: BLACK,
                    opacity: .1,
                    showCustomBoundaryTicks: true,
                    label: {
                        overlappingBehavior: "hide",
                        alignment: CENTER,
                        visible: true,
                        topIndent: 7,
                        font: {
                            size: 11
                        }
                    },
                    tick: {
                        width: 1,
                        color: BLACK,
                        opacity: .17,
                        visible: true,
                        length: 12
                    },
                    minorTick: {
                        width: 1,
                        color: BLACK,
                        opacity: .05,
                        visible: true,
                        length: 12
                    },
                    marker: {
                        width: 1,
                        color: "#000000",
                        opacity: .1,
                        visible: true,
                        separatorHeight: 33,
                        topIndent: 10,
                        textLeftIndent: 7,
                        textTopIndent: 11,
                        label: {}
                    },
                    logarithmBase: 10,
                    workWeek: [1, 2, 3, 4, 5],
                    breakStyle: {
                        width: 5,
                        color: "#ababab",
                        line: "waved"
                    },
                    endOnTick: false
                },
                selectedRangeColor: "#606060",
                sliderMarker: {
                    visible: true,
                    paddingTopBottom: 2,
                    paddingLeftRight: 4,
                    color: "#606060",
                    invalidRangeColor: RED,
                    font: {
                        color: WHITE,
                        size: 11
                    }
                },
                sliderHandle: {
                    width: 1,
                    color: BLACK,
                    opacity: .2
                },
                shutter: {
                    opacity: .75
                },
                background: {
                    color: "#c0bae1",
                    visible: true,
                    image: {
                        location: "full"
                    }
                },
                behavior: {
                    snapToTicks: true,
                    animationEnabled: true,
                    moveSelectedRangeByClick: true,
                    manualRangeSelectionEnabled: true,
                    allowSlidersSwap: true,
                    callValueChanged: "onMovingComplete"
                },
                redrawOnResize: true,
                chart: {
                    equalBarWidth: true,
                    barGroupPadding: .3,
                    minBubbleSize: 12,
                    maxBubbleSize: .2,
                    topIndent: .1,
                    bottomIndent: 0,
                    valueAxis: {
                        inverted: false,
                        logarithmBase: 10
                    },
                    commonSeriesSettings: {
                        type: "area",
                        aggregation: {
                            enabled: void 0
                        },
                        point: {
                            visible: false
                        },
                        scatter: {
                            point: {
                                visible: true
                            }
                        }
                    }
                }
            },
            map: {
                title: {
                    margin: 10
                },
                background: {
                    borderWidth: 1,
                    borderColor: "#cacaca"
                },
                layer: {
                    label: {
                        enabled: false,
                        stroke: WHITE,
                        "stroke-width": 1,
                        "stroke-opacity": .7,
                        font: {
                            color: SOME_GREY,
                            size: 12
                        }
                    }
                },
                "layer:area": {
                    borderWidth: 1,
                    borderColor: WHITE,
                    color: "#d2d2d2",
                    hoveredBorderColor: GREY_GREEN,
                    selectedBorderWidth: 2,
                    selectedBorderColor: GREY_GREEN,
                    label: {
                        "stroke-width": 2,
                        font: {
                            size: 16
                        }
                    }
                },
                "layer:line": {
                    borderWidth: 2,
                    color: "#ba8365",
                    hoveredColor: "#a94813",
                    selectedBorderWidth: 3,
                    selectedColor: "#e55100",
                    label: {
                        "stroke-width": 2,
                        font: {
                            size: 16
                        }
                    }
                },
                "layer:marker": {
                    label: {
                        enabled: true,
                        "stroke-width": 1,
                        font: {
                            size: 12
                        }
                    }
                },
                "layer:marker:dot": {
                    borderWidth: 2,
                    borderColor: WHITE,
                    size: 8,
                    selectedStep: 2,
                    backStep: 18,
                    backColor: WHITE,
                    backOpacity: .32,
                    shadow: true
                },
                "layer:marker:bubble": {
                    minSize: 20,
                    maxSize: 50,
                    hoveredBorderWidth: 1,
                    hoveredBorderColor: GREY_GREEN,
                    selectedBorderWidth: 2,
                    selectedBorderColor: GREY_GREEN
                },
                "layer:marker:pie": {
                    size: 50,
                    hoveredBorderWidth: 1,
                    hoveredBorderColor: GREY_GREEN,
                    selectedBorderWidth: 2,
                    selectedBorderColor: GREY_GREEN
                },
                "layer:marker:image": {
                    size: 20
                },
                legend: {
                    verticalAlignment: BOTTOM,
                    horizontalAlignment: RIGHT,
                    position: INSIDE,
                    backgroundOpacity: .65,
                    border: {
                        visible: true
                    },
                    paddingLeftRight: 16,
                    paddingTopBottom: 12
                },
                controlBar: {
                    borderColor: "#5d5d5d",
                    borderWidth: 3,
                    color: WHITE,
                    margin: 20,
                    opacity: .3
                },
                _rtl: {
                    legend: {
                        itemTextPosition: LEFT
                    }
                }
            },
            treeMap: {
                tile: {
                    border: {
                        width: 1,
                        opacity: .2,
                        color: "#000000"
                    },
                    color: "#5f8b95",
                    hoverStyle: {
                        hatching: {
                            opacity: .75,
                            step: 6,
                            width: 2,
                            direction: "right"
                        },
                        border: {}
                    },
                    selectionStyle: {
                        hatching: {
                            opacity: .5,
                            step: 6,
                            width: 2,
                            direction: "right"
                        },
                        border: {
                            opacity: 1
                        }
                    },
                    label: {
                        visible: true,
                        paddingLeftRight: 5,
                        paddingTopBottom: 4,
                        font: {
                            color: "#ffffff",
                            weight: 600
                        },
                        shadow: {
                            opacity: .6,
                            offsetX: 0,
                            offsetY: 1,
                            blur: 2,
                            color: "#000000"
                        },
                        wordWrap: "normal",
                        textOverflow: "ellipsis"
                    }
                },
                group: {
                    padding: 4,
                    border: {
                        width: 1
                    },
                    color: "#eeeeee",
                    hoverStyle: {
                        hatching: {
                            opacity: 0,
                            step: 6,
                            width: 2,
                            direction: "right"
                        },
                        border: {}
                    },
                    selectionStyle: {
                        hatching: {
                            opacity: 0,
                            step: 6,
                            width: 2,
                            direction: "right"
                        },
                        border: {}
                    },
                    label: {
                        visible: true,
                        paddingLeftRight: 5,
                        paddingTopBottom: 4,
                        font: {
                            color: SECONDARY_TITLE_COLOR,
                            weight: 600
                        },
                        textOverflow: "ellipsis"
                    }
                },
                title: {
                    subtitle: {}
                },
                tooltip: {},
                loadingIndicator: {}
            },
            sparkline: {
                lineColor: "#666666",
                lineWidth: 2,
                areaOpacity: .2,
                minColor: "#e8c267",
                maxColor: "#e55253",
                barPositiveColor: "#a9a9a9",
                barNegativeColor: "#d7d7d7",
                winColor: "#a9a9a9",
                lossColor: "#d7d7d7",
                firstLastColor: "#666666",
                pointSymbol: "circle",
                pointColor: WHITE,
                pointSize: 4,
                type: "line",
                argumentField: "arg",
                valueField: "val",
                winlossThreshold: 0,
                showFirstLast: true,
                showMinMax: false,
                tooltip: {
                    enabled: true
                }
            },
            bullet: {
                color: "#e8c267",
                targetColor: "#666666",
                targetWidth: 4,
                showTarget: true,
                showZeroLevel: true,
                tooltip: {
                    enabled: true
                }
            },
            polar: {
                commonSeriesSettings: {
                    type: "scatter",
                    closed: true,
                    point: {
                        visible: true,
                        symbol: "circle",
                        size: 12,
                        border: {
                            visible: false,
                            width: 1
                        },
                        hoverMode: "onlyPoint",
                        selectionMode: "onlyPoint",
                        hoverStyle: {
                            border: {
                                visible: true,
                                width: 4
                            },
                            size: 12
                        },
                        selectionStyle: {
                            border: {
                                visible: true,
                                width: 4
                            },
                            size: 12
                        }
                    },
                    scatter: {},
                    line: {
                        width: 2,
                        dashStyle: SOLID,
                        hoverStyle: {
                            width: 3,
                            hatching: {
                                direction: NONE
                            }
                        },
                        selectionStyle: {
                            width: 3
                        }
                    },
                    area: {
                        point: {
                            visible: false
                        },
                        opacity: .5
                    },
                    stackedline: {
                        width: 2
                    },
                    bar: {
                        opacity: .8
                    },
                    stackedbar: {
                        opacity: .8
                    }
                },
                adaptiveLayout: {
                    width: 80,
                    height: 80,
                    keepLabels: true
                },
                equalBarWidth: true,
                barGroupPadding: .3,
                commonAxisSettings: {
                    visible: true,
                    forceUserTickInterval: false,
                    label: {
                        overlappingBehavior: "hide",
                        indentFromAxis: 5
                    },
                    grid: {
                        visible: true
                    },
                    minorGrid: {
                        visible: true
                    },
                    tick: {
                        visible: true
                    },
                    title: {
                        font: {
                            size: 16
                        },
                        margin: 10
                    }
                },
                argumentAxis: {
                    startAngle: 0,
                    firstPointOnStartAngle: false,
                    period: void 0
                },
                valueAxis: {
                    endOnTick: false,
                    tick: {
                        visible: false
                    }
                },
                horizontalAxis: {
                    position: TOP,
                    axisDivisionFactor: 50,
                    label: {
                        alignment: CENTER
                    }
                },
                verticalAxis: {
                    position: TOP,
                    axisDivisionFactor: 30,
                    label: {
                        alignment: RIGHT
                    }
                }
            },
            funnel: {
                sortData: true,
                valueField: "val",
                colorField: "color",
                argumentField: "arg",
                hoverEnabled: true,
                selectionMode: "single",
                item: {
                    border: {
                        visible: false,
                        width: 2,
                        color: WHITE
                    },
                    hoverStyle: {
                        hatching: {
                            opacity: .75,
                            step: 6,
                            width: 2,
                            direction: RIGHT
                        },
                        border: {}
                    },
                    selectionStyle: {
                        hatching: {
                            opacity: .5,
                            step: 6,
                            width: 2,
                            direction: RIGHT
                        },
                        border: {}
                    }
                },
                title: {
                    margin: 10
                },
                adaptiveLayout: {
                    width: 80,
                    height: 80,
                    keepLabels: true
                },
                legend: {
                    visible: false
                },
                _rtl: {
                    legend: {
                        itemTextPosition: LEFT
                    }
                },
                tooltip: {
                    customizeTooltip: function(info) {
                        return {
                            text: info.item.argument + " " + info.valueText
                        }
                    }
                },
                inverted: false,
                algorithm: "dynamicSlope",
                neckWidth: 0,
                neckHeight: 0,
                resolveLabelOverlapping: "shift",
                label: {
                    textOverflow: "ellipsis",
                    wordWrap: "normal",
                    visible: true,
                    horizontalAlignment: RIGHT,
                    horizontalOffset: 0,
                    verticalOffset: 0,
                    showForZeroValues: false,
                    customizeText: function(info) {
                        return info.item.argument + " " + info.valueText
                    },
                    position: "columns",
                    font: {
                        color: WHITE
                    },
                    border: {
                        visible: false,
                        width: 1,
                        color: LIGHT_GREY,
                        dashStyle: SOLID
                    },
                    connector: {
                        visible: true,
                        width: 1,
                        opacity: .5
                    }
                }
            },
            sankey: {
                sourceField: "source",
                targetField: "target",
                weightField: "weight",
                hoverEnabled: true,
                alignment: CENTER,
                adaptiveLayout: {
                    width: 80,
                    height: 80,
                    keepLabels: true
                },
                label: {
                    visible: true,
                    horizontalOffset: 8,
                    verticalOffset: 0,
                    overlappingBehavior: "ellipsis",
                    useNodeColors: false,
                    font: {
                        color: BLACK,
                        weight: 500
                    },
                    border: {
                        visible: false,
                        width: 2,
                        color: WHITE
                    },
                    customizeText: function(info) {
                        return info.title
                    },
                    shadow: {
                        opacity: .2,
                        offsetX: 0,
                        offsetY: 1,
                        blur: 1,
                        color: WHITE
                    }
                },
                title: {
                    margin: 10,
                    font: {
                        size: 28,
                        weight: 200
                    },
                    subtitle: {
                        font: {
                            size: 16
                        }
                    }
                },
                tooltip: {
                    enabled: true
                },
                node: {
                    padding: 30,
                    width: 8,
                    opacity: 1,
                    border: {
                        color: WHITE,
                        width: 1,
                        visible: false
                    },
                    hoverStyle: {
                        hatching: {
                            opacity: .75,
                            step: 6,
                            width: 2,
                            direction: RIGHT
                        },
                        border: {}
                    }
                },
                link: {
                    color: "#888888",
                    colorMode: "none",
                    opacity: .3,
                    border: {
                        color: WHITE,
                        width: 1,
                        visible: false
                    },
                    hoverStyle: {
                        opacity: .5,
                        hatching: {
                            opacity: .75,
                            step: 6,
                            width: 2,
                            direction: RIGHT
                        },
                        border: {}
                    }
                }
            }
        });
        registerThemeAlias("generic.light.compact", "generic.light")
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/generic.dark.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        var WHITE = "#ffffff";
        var BLACK = "#000000";
        var SOME_GREY = "#2b2b2b";
        var RANGE_COLOR = "#b5b5b5";
        var GREY_GREEN = "#303030";
        var AREA_LAYER_COLOR = "#686868";
        var LINE_COLOR = "#c7c7c7";
        var TARGET_COLOR = "#8e8e8e";
        var POSITIVE_COLOR = "#b8b8b8";
        var BORDER_COLOR = "#494949";
        registerTheme({
            name: "generic.dark",
            font: {
                color: "#808080"
            },
            backgroundColor: "#2a2a2a",
            primaryTitleColor: "#dedede",
            secondaryTitleColor: "#a3a3a3",
            gridColor: "#555555",
            axisColor: "#a3a3a3",
            "export": {
                backgroundColor: "#2a2a2a",
                font: {
                    color: "#dbdbdb"
                },
                button: {
                    "default": {
                        color: "#dedede",
                        borderColor: "#4d4d4d",
                        backgroundColor: "#2e2e2e"
                    },
                    hover: {
                        color: "#dedede",
                        borderColor: "#6c6c6c",
                        backgroundColor: "#444"
                    },
                    focus: {
                        color: "#dedede",
                        borderColor: "#8d8d8d",
                        backgroundColor: "#444444"
                    },
                    active: {
                        color: "#dedede",
                        borderColor: "#8d8d8d",
                        backgroundColor: "#555555"
                    }
                },
                shadowColor: "#292929"
            },
            tooltip: {
                color: SOME_GREY,
                border: {
                    color: BORDER_COLOR
                },
                font: {
                    color: "#929292"
                }
            },
            "chart:common": {
                commonSeriesSettings: {
                    label: {
                        border: {
                            color: BORDER_COLOR
                        }
                    },
                    valueErrorBar: {
                        color: WHITE
                    }
                }
            },
            "chart:common:axis": {
                constantLineStyle: {
                    color: WHITE
                }
            },
            "chart:common:annotation": {
                font: {
                    color: "#929292"
                },
                border: {
                    color: BORDER_COLOR
                },
                color: SOME_GREY,
                shadow: {
                    opacity: .008,
                    offsetY: 4,
                    blur: 8
                }
            },
            chart: {
                commonPaneSettings: {
                    border: {
                        color: BORDER_COLOR
                    }
                },
                commonAxisSettings: {
                    breakStyle: {
                        color: "#818181"
                    }
                },
                zoomAndPan: {
                    dragBoxStyle: {
                        color: WHITE
                    }
                }
            },
            gauge: {
                rangeContainer: {
                    backgroundColor: RANGE_COLOR
                },
                valueIndicators: {
                    _default: {
                        color: RANGE_COLOR
                    },
                    rangebar: {
                        color: "#84788b"
                    },
                    twocolorneedle: {
                        secondColor: "#ba544d"
                    },
                    trianglemarker: {
                        color: "#b7918f"
                    },
                    textcloud: {
                        color: "#ba544d"
                    }
                }
            },
            barGauge: {
                backgroundColor: "#3c3c3c"
            },
            rangeSelector: {
                scale: {
                    tick: {
                        color: WHITE,
                        opacity: .32
                    },
                    minorTick: {
                        color: WHITE,
                        opacity: .1
                    },
                    breakStyle: {
                        color: "#818181"
                    }
                },
                selectedRangeColor: RANGE_COLOR,
                sliderMarker: {
                    color: RANGE_COLOR,
                    font: {
                        color: GREY_GREEN
                    }
                },
                sliderHandle: {
                    color: WHITE,
                    opacity: .2
                },
                shutter: {
                    color: SOME_GREY,
                    opacity: .9
                }
            },
            map: {
                background: {
                    borderColor: "#3f3f3f"
                },
                layer: {
                    label: {
                        stroke: BLACK,
                        font: {
                            color: WHITE
                        }
                    }
                },
                "layer:area": {
                    borderColor: GREY_GREEN,
                    color: AREA_LAYER_COLOR,
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE
                },
                "layer:line": {
                    color: "#c77244",
                    hoveredColor: "#ff5d04",
                    selectedColor: "#ff784f"
                },
                "layer:marker:bubble": {
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE
                },
                "layer:marker:pie": {
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE
                },
                legend: {
                    border: {
                        color: "#3f3f3f"
                    },
                    font: {
                        color: WHITE
                    }
                },
                controlBar: {
                    borderColor: LINE_COLOR,
                    color: GREY_GREEN
                }
            },
            treeMap: {
                group: {
                    color: "#4c4c4c",
                    label: {
                        font: {
                            color: "#a3a3a3"
                        }
                    }
                }
            },
            sparkline: {
                lineColor: LINE_COLOR,
                firstLastColor: LINE_COLOR,
                barPositiveColor: POSITIVE_COLOR,
                barNegativeColor: TARGET_COLOR,
                winColor: POSITIVE_COLOR,
                lossColor: TARGET_COLOR,
                pointColor: GREY_GREEN
            },
            bullet: {
                targetColor: TARGET_COLOR
            },
            funnel: {
                item: {
                    border: {
                        color: "#2a2a2a"
                    }
                }
            },
            sankey: {
                label: {
                    font: {
                        color: WHITE
                    },
                    shadow: {
                        opacity: 0
                    }
                },
                node: {
                    border: {
                        color: "#2a2a2a"
                    }
                },
                link: {
                    color: "#888888",
                    border: {
                        color: "#2a2a2a"
                    },
                    hoverStyle: {
                        color: "#bbbbbb"
                    }
                }
            }
        }, "generic.light");
        registerThemeAlias("generic.dark.compact", "generic.dark")
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/generic.contrast.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        var WHITE = "#ffffff";
        var BLACK = "#000000";
        var CONTRAST_ACTIVE = "#cf00da";
        var MARKER_COLOR = "#f8ca00";
        var AREA_LAYER_COLOR = "#686868";
        registerTheme({
            name: "generic.contrast",
            defaultPalette: "Bright",
            font: {
                color: WHITE
            },
            backgroundColor: BLACK,
            primaryTitleColor: WHITE,
            secondaryTitleColor: WHITE,
            gridColor: WHITE,
            axisColor: WHITE,
            "export": {
                backgroundColor: BLACK,
                font: {
                    color: WHITE
                },
                button: {
                    "default": {
                        color: WHITE,
                        borderColor: WHITE,
                        backgroundColor: BLACK
                    },
                    hover: {
                        color: WHITE,
                        borderColor: WHITE,
                        backgroundColor: "#cf00d7"
                    },
                    focus: {
                        color: WHITE,
                        borderColor: "#cf00d7",
                        backgroundColor: BLACK
                    },
                    active: {
                        color: BLACK,
                        borderColor: WHITE,
                        backgroundColor: WHITE
                    }
                },
                borderColor: WHITE,
                menuButtonColor: BLACK,
                activeBackgroundColor: WHITE,
                activeColor: BLACK,
                selectedBorderColor: CONTRAST_ACTIVE,
                selectedColor: CONTRAST_ACTIVE,
                shadowColor: "none"
            },
            tooltip: {
                border: {
                    color: WHITE
                },
                font: {
                    color: WHITE
                },
                color: BLACK
            },
            "chart:common": {
                commonSeriesSettings: {
                    valueErrorBar: {
                        color: WHITE
                    },
                    hoverStyle: {
                        hatching: {
                            opacity: .5
                        }
                    },
                    selectionStyle: {
                        hatching: {
                            opacity: .35
                        }
                    },
                    label: {
                        font: {
                            color: WHITE
                        },
                        border: {
                            color: WHITE
                        }
                    }
                }
            },
            "chart:common:axis": {
                constantLineStyle: {
                    color: WHITE
                }
            },
            "chart:common:annotation": {
                font: {
                    color: WHITE
                },
                border: {
                    color: WHITE
                },
                color: BLACK
            },
            chart: {
                commonSeriesSettings: {},
                crosshair: {
                    color: "#cf00d7"
                },
                commonPaneSettings: {
                    backgroundColor: BLACK,
                    border: {
                        color: WHITE
                    }
                },
                scrollBar: {
                    color: WHITE
                },
                commonAxisSettings: {
                    breakStyle: {
                        color: "#cf00d7"
                    }
                },
                zoomAndPan: {
                    dragBoxStyle: {
                        color: WHITE,
                        opacity: .7
                    }
                }
            },
            pie: {
                commonSeriesSettings: {
                    pie: {
                        hoverStyle: {
                            hatching: {
                                opacity: .5
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                opacity: .35
                            }
                        }
                    },
                    doughnut: {
                        hoverStyle: {
                            hatching: {
                                opacity: .5
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                opacity: .35
                            }
                        }
                    },
                    donut: {
                        hoverStyle: {
                            hatching: {
                                opacity: .5
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                opacity: .35
                            }
                        }
                    }
                }
            },
            gauge: {
                rangeContainer: {
                    backgroundColor: WHITE
                },
                valueIndicators: {
                    _default: {
                        color: WHITE
                    },
                    rangebar: {
                        color: WHITE,
                        backgroundColor: BLACK
                    },
                    twocolorneedle: {
                        secondColor: WHITE
                    },
                    trianglemarker: {
                        color: WHITE
                    },
                    textcloud: {
                        color: WHITE,
                        text: {
                            font: {
                                color: BLACK
                            }
                        }
                    }
                }
            },
            barGauge: {
                backgroundColor: "#3c3c3c"
            },
            rangeSelector: {
                scale: {
                    tick: {
                        color: WHITE,
                        opacity: .4
                    },
                    minorTick: {
                        color: WHITE,
                        opacity: .12
                    },
                    breakStyle: {
                        color: "#cf00d7"
                    }
                },
                selectedRangeColor: CONTRAST_ACTIVE,
                sliderMarker: {
                    color: CONTRAST_ACTIVE
                },
                sliderHandle: {
                    color: CONTRAST_ACTIVE,
                    opacity: 1
                },
                shutter: {
                    opacity: .75
                },
                background: {
                    color: BLACK
                }
            },
            map: {
                background: {
                    borderColor: WHITE
                },
                layer: {
                    label: {
                        stroke: BLACK,
                        font: {
                            color: WHITE
                        }
                    }
                },
                "layer:area": {
                    borderColor: BLACK,
                    color: AREA_LAYER_COLOR,
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE,
                    label: {
                        font: {
                            opacity: 1
                        }
                    }
                },
                "layer:line": {
                    color: "#267cff",
                    hoveredColor: "#f613ff",
                    selectedColor: WHITE
                },
                "layer:marker:dot": {
                    borderColor: BLACK,
                    color: MARKER_COLOR,
                    backColor: BLACK,
                    backOpacity: .32
                },
                "layer:marker:bubble": {
                    color: MARKER_COLOR,
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE
                },
                "layer:marker:pie": {
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE
                },
                controlBar: {
                    borderColor: WHITE,
                    color: BLACK,
                    opacity: .3
                }
            },
            treeMap: {
                tile: {
                    color: "#70c92f"
                },
                group: {
                    color: "#797979",
                    label: {
                        font: {
                            color: WHITE
                        }
                    }
                }
            },
            sparkline: {
                pointColor: BLACK
            },
            bullet: {},
            polar: {
                commonSeriesSettings: {}
            },
            funnel: {
                label: {
                    connector: {
                        opacity: 1
                    }
                }
            },
            sankey: {
                label: {
                    font: {
                        color: WHITE
                    },
                    shadow: {
                        opacity: 0
                    }
                },
                node: {
                    border: {
                        visible: true,
                        width: 1,
                        color: WHITE
                    }
                },
                link: {
                    opacity: .5,
                    border: {
                        visible: true,
                        width: 1,
                        color: WHITE
                    },
                    hoverStyle: {
                        opacity: .9
                    }
                }
            }
        }, "generic.light");
        registerThemeAlias("generic.contrast.compact", "generic.contrast")
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/generic.carmine.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        var ACCENT_COLOR = "#f05b41";
        var BACKGROUND_COLOR = "#fff";
        var TITLE_COLOR = "#333";
        var SUBTITLE_COLOR = "#8899a8";
        var TEXT_COLOR = "#707070";
        var BORDER_COLOR = "#dee1e3";
        registerTheme({
            name: "generic.carmine",
            defaultPalette: "Carmine",
            backgroundColor: BACKGROUND_COLOR,
            primaryTitleColor: TITLE_COLOR,
            secondaryTitleColor: SUBTITLE_COLOR,
            gridColor: BORDER_COLOR,
            axisColor: TEXT_COLOR,
            "export": {
                backgroundColor: BACKGROUND_COLOR,
                font: {
                    color: TITLE_COLOR
                },
                button: {
                    "default": {
                        color: TITLE_COLOR,
                        borderColor: "#b1b7bd",
                        backgroundColor: BACKGROUND_COLOR
                    },
                    hover: {
                        color: TITLE_COLOR,
                        borderColor: "#b1b7bd",
                        backgroundColor: "#faf2f0"
                    },
                    focus: {
                        color: TITLE_COLOR,
                        borderColor: "#6d7781",
                        backgroundColor: "#faf2f0"
                    },
                    active: {
                        color: TITLE_COLOR,
                        borderColor: "#6d7781",
                        backgroundColor: "#f5e7e4"
                    }
                }
            },
            legend: {
                font: {
                    color: TEXT_COLOR
                }
            },
            tooltip: {
                color: BACKGROUND_COLOR,
                border: {
                    color: BORDER_COLOR
                },
                font: {
                    color: TITLE_COLOR
                }
            },
            "chart:common": {
                commonSeriesSettings: {
                    label: {
                        border: {
                            color: BORDER_COLOR
                        }
                    }
                }
            },
            "chart:common:annotation": {
                font: {
                    color: TITLE_COLOR
                },
                border: {
                    color: BORDER_COLOR
                },
                color: BACKGROUND_COLOR
            },
            chart: {
                commonPaneSettings: {
                    border: {
                        color: BORDER_COLOR
                    }
                },
                commonAxisSettings: {
                    breakStyle: {
                        color: "#c1c5c7"
                    }
                }
            },
            rangeSelector: {
                scale: {
                    breakStyle: {
                        color: "#c1c5c7"
                    },
                    tick: {
                        opacity: .12
                    }
                },
                selectedRangeColor: ACCENT_COLOR,
                sliderMarker: {
                    color: ACCENT_COLOR
                },
                sliderHandle: {
                    color: ACCENT_COLOR,
                    opacity: .5
                }
            },
            sparkline: {
                pointColor: BACKGROUND_COLOR,
                minColor: "#f0ad4e",
                maxColor: "#f74d61"
            },
            treeMap: {
                group: {
                    color: BORDER_COLOR,
                    label: {
                        font: {
                            color: SUBTITLE_COLOR
                        }
                    }
                }
            },
            bullet: {
                color: ACCENT_COLOR
            },
            gauge: {
                valueIndicators: {
                    rangebar: {
                        color: ACCENT_COLOR
                    },
                    textcloud: {
                        color: ACCENT_COLOR
                    }
                }
            }
        }, "generic.light");
        registerThemeAlias("generic.carmine.compact", "generic.carmine")
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/generic.darkmoon.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        var ACCENT_COLOR = "#3debd3";
        var BACKGROUND_COLOR = "#465672";
        var TITLE_COLOR = "#fff";
        var SUBTITLE_COLOR = "#919bac";
        var TEXT_COLOR = "#c7ccd4";
        var BORDER_COLOR = "#596980";
        registerTheme({
            name: "generic.darkmoon",
            defaultPalette: "Dark Moon",
            backgroundColor: BACKGROUND_COLOR,
            primaryTitleColor: TITLE_COLOR,
            secondaryTitleColor: SUBTITLE_COLOR,
            gridColor: BORDER_COLOR,
            axisColor: TEXT_COLOR,
            "export": {
                backgroundColor: BACKGROUND_COLOR,
                font: {
                    color: TITLE_COLOR
                },
                button: {
                    "default": {
                        color: TITLE_COLOR,
                        borderColor: "#7a889e",
                        backgroundColor: BACKGROUND_COLOR
                    },
                    hover: {
                        color: TITLE_COLOR,
                        borderColor: "#9da8b8",
                        backgroundColor: "#596e92"
                    },
                    focus: {
                        color: TITLE_COLOR,
                        borderColor: "#c4cad4",
                        backgroundColor: "#596e92"
                    },
                    active: {
                        color: TITLE_COLOR,
                        borderColor: "#c4cad4",
                        backgroundColor: "#6b80a4"
                    }
                }
            },
            legend: {
                font: {
                    color: TEXT_COLOR
                }
            },
            tooltip: {
                color: "#62789e",
                border: {
                    color: BORDER_COLOR
                },
                font: {
                    color: TITLE_COLOR
                }
            },
            "chart:common": {
                commonSeriesSettings: {
                    label: {
                        border: {
                            color: BORDER_COLOR
                        }
                    }
                }
            },
            "chart:common:annotation": {
                font: {
                    color: TITLE_COLOR
                },
                border: {
                    color: BORDER_COLOR
                },
                color: "#62789e"
            },
            chart: {
                commonPaneSettings: {
                    border: {
                        color: BORDER_COLOR
                    }
                },
                commonAxisSettings: {
                    breakStyle: {
                        color: "#73869e"
                    }
                }
            },
            gauge: {
                valueIndicators: {
                    rangebar: {
                        color: ACCENT_COLOR
                    },
                    textcloud: {
                        color: ACCENT_COLOR,
                        text: {
                            font: {
                                color: BACKGROUND_COLOR
                            }
                        }
                    }
                }
            },
            barGauge: {
                backgroundColor: "#526280"
            },
            funnel: {
                item: {
                    border: {
                        color: BACKGROUND_COLOR
                    }
                }
            },
            sparkline: {
                pointColor: BACKGROUND_COLOR,
                minColor: "#f0ad4e",
                maxColor: "#f9517e"
            },
            treeMap: {
                group: {
                    color: BORDER_COLOR,
                    label: {
                        font: {
                            color: TITLE_COLOR
                        }
                    }
                }
            },
            map: {
                background: {
                    borderColor: BORDER_COLOR
                },
                "layer:area": {
                    color: "#97a3b6",
                    borderColor: BACKGROUND_COLOR
                }
            },
            rangeSelector: {
                shutter: {
                    color: BACKGROUND_COLOR
                },
                scale: {
                    breakStyle: {
                        color: "#73869e"
                    },
                    tick: {
                        opacity: .2
                    }
                },
                selectedRangeColor: ACCENT_COLOR,
                sliderMarker: {
                    color: ACCENT_COLOR,
                    font: {
                        color: "#000"
                    }
                },
                sliderHandle: {
                    color: ACCENT_COLOR,
                    opacity: .5
                }
            },
            bullet: {
                color: ACCENT_COLOR
            },
            sankey: {
                link: {
                    border: {
                        color: BACKGROUND_COLOR
                    }
                },
                node: {
                    border: {
                        color: BACKGROUND_COLOR
                    }
                }
            }
        }, "generic.dark");
        registerThemeAlias("generic.darkmoon.compact", "generic.darkmoon")
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/generic.softblue.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        var ACCENT_COLOR = "#7ab8eb";
        var BACKGROUND_COLOR = "#fff";
        var TITLE_COLOR = "#333";
        var SUBTITLE_COLOR = "#99a1a8";
        var TEXT_COLOR = "#707070";
        var BORDER_COLOR = "#e8eaeb";
        registerTheme({
            name: "generic.softblue",
            defaultPalette: "Soft Blue",
            backgroundColor: BACKGROUND_COLOR,
            primaryTitleColor: TITLE_COLOR,
            secondaryTitleColor: SUBTITLE_COLOR,
            gridColor: BORDER_COLOR,
            axisColor: TEXT_COLOR,
            "export": {
                backgroundColor: BACKGROUND_COLOR,
                font: {
                    color: TITLE_COLOR
                },
                button: {
                    "default": {
                        color: TITLE_COLOR,
                        borderColor: "#c9d0d4",
                        backgroundColor: BACKGROUND_COLOR
                    },
                    hover: {
                        color: TITLE_COLOR,
                        borderColor: "#a7b2b9",
                        backgroundColor: "#e6e6e6"
                    },
                    focus: {
                        color: TITLE_COLOR,
                        borderColor: "#82929b",
                        backgroundColor: "#e6e6e6"
                    },
                    active: {
                        color: TITLE_COLOR,
                        borderColor: "#82929b",
                        backgroundColor: "#d4d4d4"
                    }
                }
            },
            legend: {
                font: {
                    color: TEXT_COLOR
                }
            },
            tooltip: {
                color: BACKGROUND_COLOR,
                border: {
                    color: BORDER_COLOR
                },
                font: {
                    color: TITLE_COLOR
                }
            },
            "chart:common": {
                commonSeriesSettings: {
                    label: {
                        border: {
                            color: BORDER_COLOR
                        }
                    }
                }
            },
            "chart:common:annotation": {
                color: BACKGROUND_COLOR,
                border: {
                    color: BORDER_COLOR
                },
                font: {
                    color: TITLE_COLOR
                }
            },
            chart: {
                commonPaneSettings: {
                    border: {
                        color: BORDER_COLOR
                    }
                },
                commonAxisSettings: {
                    breakStyle: {
                        color: "#cfd2d3"
                    }
                }
            },
            rangeSelector: {
                scale: {
                    breakStyle: {
                        color: "#cfd2d3"
                    },
                    tick: {
                        opacity: .12
                    }
                },
                selectedRangeColor: ACCENT_COLOR,
                sliderMarker: {
                    color: ACCENT_COLOR
                },
                sliderHandle: {
                    color: ACCENT_COLOR,
                    opacity: .5
                }
            },
            sparkline: {
                pointColor: BACKGROUND_COLOR,
                minColor: "#f0ad4e",
                maxColor: "#d9534f"
            },
            treeMap: {
                group: {
                    color: BORDER_COLOR,
                    label: {
                        font: {
                            color: SUBTITLE_COLOR
                        }
                    }
                }
            },
            bullet: {
                color: ACCENT_COLOR
            },
            gauge: {
                valueIndicators: {
                    rangebar: {
                        color: ACCENT_COLOR
                    },
                    textcloud: {
                        color: ACCENT_COLOR
                    }
                }
            }
        }, "generic.light");
        registerThemeAlias("generic.softblue.compact", "generic.softblue")
    },
    /*!********************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/generic.darkviolet.js ***!
      \********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        var ACCENT_COLOR = "#9c63ff";
        var BACKGROUND_COLOR = "#17171f";
        var TITLE_COLOR = "#f5f6f7";
        var SUBTITLE_COLOR = "#fff";
        var TEXT_COLOR = "#b2b2b6";
        var BORDER_COLOR = "#343840";
        registerTheme({
            name: "generic.darkviolet",
            defaultPalette: "Dark Violet",
            backgroundColor: BACKGROUND_COLOR,
            primaryTitleColor: TITLE_COLOR,
            secondaryTitleColor: SUBTITLE_COLOR,
            gridColor: BORDER_COLOR,
            axisColor: TEXT_COLOR,
            "export": {
                backgroundColor: BACKGROUND_COLOR,
                font: {
                    color: TITLE_COLOR
                },
                button: {
                    "default": {
                        color: TITLE_COLOR,
                        borderColor: "#414152",
                        backgroundColor: BACKGROUND_COLOR
                    },
                    hover: {
                        color: TITLE_COLOR,
                        borderColor: "#5c5c74",
                        backgroundColor: "#2d2d3c"
                    },
                    focus: {
                        color: TITLE_COLOR,
                        borderColor: "#7c7c97",
                        backgroundColor: "#2d2d3c"
                    },
                    active: {
                        color: TITLE_COLOR,
                        borderColor: "#7c7c97",
                        backgroundColor: "#3c3c51"
                    }
                }
            },
            legend: {
                font: {
                    color: TEXT_COLOR
                }
            },
            tooltip: {
                color: BACKGROUND_COLOR,
                border: {
                    color: "#414152"
                },
                font: {
                    color: TITLE_COLOR
                }
            },
            "chart:common": {
                commonSeriesSettings: {
                    label: {
                        border: {
                            color: BORDER_COLOR
                        }
                    }
                }
            },
            "chart:common:annotation": {
                font: {
                    color: TITLE_COLOR
                },
                border: {
                    color: "#414152"
                },
                color: BACKGROUND_COLOR
            },
            chart: {
                commonPaneSettings: {
                    border: {
                        color: BORDER_COLOR
                    }
                },
                commonAxisSettings: {
                    breakStyle: {
                        color: "#575e6b"
                    }
                }
            },
            funnel: {
                item: {
                    border: {
                        color: BACKGROUND_COLOR
                    }
                }
            },
            sparkline: {
                pointColor: BACKGROUND_COLOR,
                minColor: "#f0ad4e",
                maxColor: "#d9534f"
            },
            treeMap: {
                group: {
                    color: BORDER_COLOR,
                    label: {
                        font: {
                            color: SUBTITLE_COLOR
                        }
                    }
                }
            },
            rangeSelector: {
                shutter: {
                    color: BACKGROUND_COLOR
                },
                scale: {
                    breakStyle: {
                        color: "#575e6b"
                    },
                    tick: {
                        opacity: .2
                    }
                },
                selectedRangeColor: ACCENT_COLOR,
                sliderMarker: {
                    color: ACCENT_COLOR,
                    font: {
                        color: "#fff"
                    }
                },
                sliderHandle: {
                    color: ACCENT_COLOR,
                    opacity: .5
                }
            },
            bullet: {
                color: ACCENT_COLOR
            },
            gauge: {
                valueIndicators: {
                    rangebar: {
                        color: ACCENT_COLOR
                    },
                    textcloud: {
                        color: ACCENT_COLOR
                    }
                }
            },
            sankey: {
                link: {
                    border: {
                        color: BACKGROUND_COLOR
                    }
                },
                node: {
                    border: {
                        color: BACKGROUND_COLOR
                    }
                }
            }
        }, "generic.dark");
        registerThemeAlias("generic.darkviolet.compact", "generic.darkviolet")
    },
    /*!*******************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/generic.greenmist.js ***!
      \*******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        var ACCENT_COLOR = "#3cbab2";
        var BACKGROUND_COLOR = "#f5f5f5";
        var TITLE_COLOR = "#28484f";
        var SUBTITLE_COLOR = "#7eb2be";
        var TEXT_COLOR = "#657c80";
        var BORDER_COLOR = "#dedede";
        registerTheme({
            name: "generic.greenmist",
            defaultPalette: "Green Mist",
            backgroundColor: BACKGROUND_COLOR,
            primaryTitleColor: TITLE_COLOR,
            secondaryTitleColor: SUBTITLE_COLOR,
            gridColor: BORDER_COLOR,
            axisColor: TEXT_COLOR,
            "export": {
                backgroundColor: BACKGROUND_COLOR,
                font: {
                    color: TITLE_COLOR
                },
                button: {
                    "default": {
                        color: TITLE_COLOR,
                        borderColor: "#a2b4b8",
                        backgroundColor: BACKGROUND_COLOR
                    },
                    hover: {
                        color: TITLE_COLOR,
                        borderColor: "#7f989e",
                        backgroundColor: "rgba(222, 222, 222, 0.4)"
                    },
                    focus: {
                        color: TITLE_COLOR,
                        borderColor: "#5f777c",
                        backgroundColor: "rgba(222, 222, 222, 0.4)"
                    },
                    active: {
                        color: TITLE_COLOR,
                        borderColor: "#5f777c",
                        backgroundColor: "rgba(222, 222, 222, 0.8)"
                    }
                }
            },
            legend: {
                font: {
                    color: TEXT_COLOR
                }
            },
            tooltip: {
                color: "#fff",
                border: {
                    color: BORDER_COLOR
                },
                font: {
                    color: TITLE_COLOR
                }
            },
            "chart:common": {
                commonSeriesSettings: {
                    label: {
                        border: {
                            color: BORDER_COLOR
                        }
                    }
                }
            },
            "chart:common:annotation": {
                color: "#fff",
                border: {
                    color: BORDER_COLOR
                },
                font: {
                    color: TITLE_COLOR
                }
            },
            chart: {
                commonPaneSettings: {
                    border: {
                        color: BORDER_COLOR
                    }
                },
                commonAxisSettings: {
                    breakStyle: {
                        color: "#c1c1c1"
                    }
                }
            },
            funnel: {
                item: {
                    border: {
                        color: BACKGROUND_COLOR
                    }
                }
            },
            sparkline: {
                pointColor: BACKGROUND_COLOR,
                minColor: "#ffc852",
                maxColor: "#f74a5e"
            },
            treeMap: {
                group: {
                    color: BORDER_COLOR,
                    label: {
                        font: {
                            color: SUBTITLE_COLOR
                        }
                    }
                }
            },
            rangeSelector: {
                shutter: {
                    color: BACKGROUND_COLOR
                },
                scale: {
                    breakStyle: {
                        color: "#c1c1c1"
                    },
                    tick: {
                        opacity: .12
                    }
                },
                selectedRangeColor: ACCENT_COLOR,
                sliderMarker: {
                    color: ACCENT_COLOR
                },
                sliderHandle: {
                    color: ACCENT_COLOR,
                    opacity: .5
                }
            },
            bullet: {
                color: ACCENT_COLOR
            },
            gauge: {
                valueIndicators: {
                    rangebar: {
                        color: ACCENT_COLOR
                    },
                    textcloud: {
                        color: ACCENT_COLOR
                    }
                }
            }
        }, "generic.light");
        registerThemeAlias("generic.greenmist.compact", "generic.greenmist")
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/material.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var registerTheme = themeModule.registerTheme;
        var registerThemeAlias = themeModule.registerThemeAlias;
        var FONT_FAMILY = "'Roboto', 'RobotoFallback', 'Helvetica', 'Arial', sans-serif";
        var LIGHT_TITLE_COLOR = "rgba(0,0,0,0.87)";
        var LIGHT_LABEL_COLOR = "rgba(0,0,0,0.54)";
        var DARK_TITLE_COLOR = "rgba(255,255,255,0.87)";
        var DARK_LABEL_COLOR = "rgba(255,255,255,0.54)";
        var DARK_BACKGROUND_COLOR = "#363640";
        var WHITE = "#ffffff";
        var BLACK = "#000000";
        var RANGE_COLOR = "#b5b5b5";
        var AREA_LAYER_COLOR = "#686868";
        var LINE_COLOR = "#c7c7c7";
        var TARGET_COLOR = "#8e8e8e";
        var POSITIVE_COLOR = "#b8b8b8";
        var LABEL_BORDER_COLOR = "#494949";
        var BREAK_STYLE_COLOR = "#818181";
        registerTheme({
            name: "material",
            defaultPalette: "Material",
            font: {
                family: FONT_FAMILY
            },
            title: {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 0,
                    right: 0
                },
                font: {
                    size: 20,
                    family: FONT_FAMILY,
                    weight: 500
                },
                horizontalAlignment: "left",
                subtitle: {
                    font: {
                        size: 14
                    },
                    horizontalAlignment: "left"
                }
            },
            tooltip: {
                shadow: {
                    opacity: 0
                },
                border: {
                    visible: false
                },
                paddingLeftRight: 8,
                paddingTopBottom: 6,
                arrowLength: 0,
                location: "edge",
                color: "#616161",
                font: {
                    color: WHITE
                },
                cornerRadius: 4
            },
            chart: {
                commonAxisSettings: {
                    minorTick: {
                        opacity: .5
                    },
                    label: {
                        font: {
                            size: 11
                        }
                    }
                },
                commonAnnotationSettings: {
                    font: {
                        color: WHITE
                    },
                    border: {
                        color: "#616161"
                    },
                    color: "#616161",
                    arrowLength: 14,
                    arrowWidth: 0,
                    shadow: {
                        opacity: .08,
                        offsetY: 4,
                        blur: 8
                    },
                    cornerRadius: 4
                }
            },
            pie: {
                title: {
                    horizontalAlignment: "center",
                    subtitle: {
                        horizontalAlignment: "center"
                    }
                }
            },
            polar: {
                commonAxisSettings: {
                    minorTick: {
                        opacity: .5
                    }
                },
                title: {
                    horizontalAlignment: "center",
                    subtitle: {
                        horizontalAlignment: "center"
                    }
                }
            },
            funnel: {
                title: {
                    horizontalAlignment: "center",
                    subtitle: {
                        horizontalAlignment: "center"
                    }
                }
            },
            gauge: {
                title: {
                    horizontalAlignment: "center",
                    subtitle: {
                        horizontalAlignment: "center"
                    }
                }
            },
            barGauge: {
                title: {
                    horizontalAlignment: "center",
                    subtitle: {
                        horizontalAlignment: "center"
                    }
                }
            },
            rangeSelector: {
                sliderHandle: {
                    opacity: .5
                }
            },
            treeMap: {
                group: {
                    label: {
                        font: {
                            weight: 500
                        }
                    }
                }
            }
        }, "generic.light");
        registerTheme({
            name: "material.light",
            gridColor: "#e0e0e0",
            axisColor: LIGHT_LABEL_COLOR,
            primaryTitleColor: LIGHT_TITLE_COLOR,
            legend: {
                font: {
                    color: LIGHT_LABEL_COLOR
                }
            },
            chart: {
                scrollBar: {
                    color: "#bfbfbf",
                    opacity: .7
                }
            },
            gauge: {
                rangeContainer: {
                    backgroundColor: "rgba(0,0,0,0.2)"
                }
            },
            barGauge: {
                backgroundColor: "#efefef"
            }
        }, "material");
        registerTheme({
            name: "material.dark",
            gridColor: "#515159",
            backgroundColor: DARK_BACKGROUND_COLOR,
            axisColor: DARK_LABEL_COLOR,
            font: {
                color: DARK_LABEL_COLOR
            },
            primaryTitleColor: DARK_TITLE_COLOR,
            secondaryTitleColor: DARK_TITLE_COLOR,
            tooltip: {
                color: "#000"
            },
            "export": {
                backgroundColor: DARK_BACKGROUND_COLOR,
                font: {
                    color: "#dbdbdb"
                },
                button: {
                    "default": {
                        color: "#dedede",
                        borderColor: "#4d4d4d",
                        backgroundColor: DARK_BACKGROUND_COLOR
                    },
                    hover: {
                        color: "#dedede",
                        borderColor: "#6c6c6c",
                        backgroundColor: "#3f3f4b"
                    },
                    focus: {
                        color: "#dedede",
                        borderColor: "#8d8d8d",
                        backgroundColor: "#494956"
                    },
                    active: {
                        color: "#dedede",
                        borderColor: "#8d8d8d",
                        backgroundColor: "#494956"
                    }
                },
                shadowColor: "#292929"
            },
            "chart:common": {
                commonSeriesSettings: {
                    label: {
                        border: {
                            color: LABEL_BORDER_COLOR
                        }
                    },
                    valueErrorBar: {
                        color: WHITE
                    }
                }
            },
            "chart:common:axis": {
                constantLineStyle: {
                    color: WHITE
                }
            },
            "chart:common:annotation": {
                border: {
                    color: "#000"
                },
                color: "#000"
            },
            chart: {
                commonPaneSettings: {
                    border: {
                        color: LABEL_BORDER_COLOR
                    }
                },
                commonAxisSettings: {
                    breakStyle: {
                        color: BREAK_STYLE_COLOR
                    }
                },
                zoomAndPan: {
                    dragBoxStyle: {
                        color: WHITE
                    }
                }
            },
            gauge: {
                rangeContainer: {
                    backgroundColor: RANGE_COLOR
                },
                valueIndicators: {
                    _default: {
                        color: RANGE_COLOR
                    },
                    rangebar: {
                        color: "#84788b"
                    },
                    twocolorneedle: {
                        secondColor: "#ba544d"
                    },
                    trianglemarker: {
                        color: "#b7918f"
                    },
                    textcloud: {
                        color: "#ba544d"
                    }
                }
            },
            barGauge: {
                backgroundColor: "#3c3c3c"
            },
            rangeSelector: {
                scale: {
                    tick: {
                        color: WHITE,
                        opacity: .32
                    },
                    minorTick: {
                        color: WHITE,
                        opacity: .1
                    },
                    breakStyle: {
                        color: BREAK_STYLE_COLOR
                    }
                },
                selectedRangeColor: RANGE_COLOR,
                sliderMarker: {
                    color: RANGE_COLOR,
                    font: {
                        color: DARK_BACKGROUND_COLOR
                    }
                },
                sliderHandle: {
                    color: WHITE,
                    opacity: .2
                },
                shutter: {
                    color: WHITE,
                    opacity: .1
                }
            },
            map: {
                background: {
                    borderColor: "#3f3f3f"
                },
                layer: {
                    label: {
                        stroke: BLACK,
                        font: {
                            color: WHITE
                        }
                    }
                },
                "layer:area": {
                    borderColor: DARK_BACKGROUND_COLOR,
                    color: AREA_LAYER_COLOR,
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE
                },
                "layer:line": {
                    color: "#c77244",
                    hoveredColor: "#ff5d04",
                    selectedColor: "#ff784f"
                },
                "layer:marker:bubble": {
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE
                },
                "layer:marker:pie": {
                    hoveredBorderColor: WHITE,
                    selectedBorderColor: WHITE
                },
                legend: {
                    border: {
                        color: "#3f3f3f"
                    },
                    font: {
                        color: WHITE
                    }
                },
                controlBar: {
                    borderColor: LINE_COLOR,
                    color: DARK_BACKGROUND_COLOR
                }
            },
            treeMap: {
                group: {
                    color: "#4c4c4c",
                    label: {
                        font: {
                            color: "#a3a3a3"
                        }
                    }
                }
            },
            sparkline: {
                lineColor: LINE_COLOR,
                firstLastColor: LINE_COLOR,
                barPositiveColor: POSITIVE_COLOR,
                barNegativeColor: TARGET_COLOR,
                winColor: POSITIVE_COLOR,
                lossColor: TARGET_COLOR,
                pointColor: DARK_BACKGROUND_COLOR
            },
            bullet: {
                targetColor: TARGET_COLOR
            },
            funnel: {
                item: {
                    border: {
                        color: DARK_BACKGROUND_COLOR
                    }
                }
            },
            sankey: {
                label: {
                    font: {
                        color: WHITE
                    }
                }
            }
        }, "material");

        function registerMaterialColorScheme(accentName, themeName, accentColor) {
            registerTheme({
                name: "material." + accentName + "." + themeName,
                rangeSelector: {
                    selectedRangeColor: accentColor,
                    sliderMarker: {
                        color: accentColor
                    },
                    sliderHandle: {
                        color: accentColor
                    }
                },
                map: {
                    "layer:marker:dot": {
                        color: accentColor
                    },
                    "layer:marker:bubble": {
                        color: accentColor
                    },
                    legend: {
                        markerColor: accentColor
                    }
                },
                bullet: {
                    color: accentColor
                },
                gauge: {
                    valueIndicators: {
                        rangebar: {
                            color: accentColor
                        },
                        textcloud: {
                            color: accentColor
                        }
                    }
                }
            }, "material." + themeName)
        }
        var materialAccents = {
            blue: "#03a9f4",
            lime: "#cddc39",
            orange: "#ff5722",
            purple: "#9c27b0",
            teal: "#009688"
        };
        for (var accent in materialAccents) {
            if (Object.prototype.hasOwnProperty.call(materialAccents, accent)) {
                var color = materialAccents[accent];
                registerMaterialColorScheme(accent, "light", color);
                registerMaterialColorScheme(accent, "dark", color);
                registerThemeAlias("material.".concat(accent, ".light.compact"), "material.".concat(accent, ".light"));
                registerThemeAlias("material.".concat(accent, ".dark.compact"), "material.".concat(accent, ".dark"))
            }
        }
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/viz/core/themes/ios.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var themeModule = __webpack_require__( /*! ../../themes */ 50);
        var IOS7_DEFAULT = "ios7.default";
        var SECONDARY_TEXT_COLOR = "#767676";
        var BORDER_COLOR = "#d3d3d3";
        var BLACK = "#000000";
        themeModule.registerTheme({
            name: IOS7_DEFAULT,
            backgroundColor: "#ffffff",
            primaryTitleColor: BLACK,
            secondaryTitleColor: SECONDARY_TEXT_COLOR,
            gridColor: "#ececec",
            axisColor: SECONDARY_TEXT_COLOR,
            legend: {
                font: {
                    color: BLACK
                }
            },
            tooltip: {
                font: {
                    color: SECONDARY_TEXT_COLOR
                }
            },
            "chart:common": {
                commonSeriesSettings: {
                    label: {
                        border: {
                            color: BORDER_COLOR
                        }
                    }
                }
            },
            chart: {
                commonPaneSettings: {
                    border: {
                        color: BORDER_COLOR
                    }
                }
            },
            rangeSelector: {
                scale: {
                    tick: {
                        color: BLACK,
                        opacity: .1
                    },
                    minorTick: {
                        color: BLACK,
                        opacity: .03
                    }
                }
            },
            treeMap: {
                group: {
                    label: {
                        font: {
                            color: SECONDARY_TEXT_COLOR
                        }
                    }
                }
            }
        }, "generic.light")
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/core/errors_warnings.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var errorUtils = __webpack_require__( /*! ../../core/utils/error */ 138);
        var errors = __webpack_require__( /*! ../../core/errors */ 22);
        module.exports = errorUtils(errors.ERROR_MESSAGES, {
            E2001: "Invalid data source",
            E2002: "Axis type and data type are incompatible",
            E2003: 'The "{0}" data source field contains data of unsupported type',
            E2004: 'The "{0}" data source field is inconsistent',
            E2005: 'The value field "{0}" is absent in the data source or all its values are negative',
            E2006: "A cycle is detected in provided data",
            E2007: 'The value field "{0}" is absent in the data source',
            E2008: 'The value field "{0}" must be a string',
            E2009: 'The value field "{0}" must be a positive numeric value',
            E2101: "Unknown series type: {0}",
            E2102: "Ambiguity occurred between two value axes with the same name",
            E2103: 'The "{0}" option is given an invalid value. Assign a function instead',
            E2104: "Invalid logarithm base",
            E2105: 'Invalid value of a "{0}"',
            E2106: "Invalid visible range",
            E2202: "Invalid {0} scale value",
            E2203: "The range you are trying to set is invalid",
            W2002: "The {0} series cannot be drawn because the {1} data field is missing",
            W2003: "Tick interval is too small",
            W2101: 'The "{0}" pane does not exist; the last pane is used by default',
            W2102: 'A value axis with the "{0}" name was created automatically',
            W2103: "The chart title was hidden due to the container size",
            W2104: "The legend was hidden due to the container size",
            W2105: 'The title of the "{0}" axis was hidden due to the container size',
            W2106: 'The labels of the "{0}" axis were hidden due to the container size',
            W2107: "The export menu was hidden due to the container size",
            W2108: "The browser does not support exporting images to {0} format.",
            W2301: "Invalid value range"
        })
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/viz/core/renderers/animation.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var animationFrame = __webpack_require__( /*! ../../../animation/frame */ 117);
        var noop = function() {};
        var easingFunctions = {
            easeOutCubic: function(pos, start, end) {
                return 1 === pos ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start
            },
            linear: function(pos, start, end) {
                return 1 === pos ? end : pos * (end - start) + +start
            }
        };
        exports.easingFunctions = easingFunctions;
        var animationSvgStep = {
            segments: function segments(elem, params, progress, easing, currentParams) {
                var from = params.from;
                var to = params.to;
                var curSeg;
                var seg;
                var i;
                var j;
                var segments = [];
                for (i = 0; i < from.length; i++) {
                    curSeg = from[i];
                    seg = [curSeg[0]];
                    if (curSeg.length > 1) {
                        for (j = 1; j < curSeg.length; j++) {
                            seg.push(easing(progress, curSeg[j], to[i][j]))
                        }
                    }
                    segments.push(seg)
                }
                currentParams.segments = params.end && 1 === progress ? params.end : segments;
                elem.attr({
                    segments: segments
                })
            },
            arc: function(elem, params, progress, easing) {
                var from = params.from;
                var to = params.to;
                var current = {};
                for (var i in from) {
                    current[i] = easing(progress, from[i], to[i])
                }
                elem.attr(current)
            },
            transform: function(elem, params, progress, easing, currentParams) {
                var from = params.from;
                var to = params.to;
                var current = {};
                for (var i in from) {
                    current[i] = currentParams[i] = easing(progress, from[i], to[i])
                }
                elem.attr(current)
            },
            base: function(elem, params, progress, easing, currentParams, attributeName) {
                var obj = {};
                obj[attributeName] = currentParams[attributeName] = easing(progress, params.from, params.to);
                elem.attr(obj)
            },
            _: noop,
            complete: function(element, currentSettings) {
                element.attr(currentSettings)
            }
        };

        function step(now) {
            var that = this;
            var animateStep = that._animateStep;
            var attrName;
            that._progress = that._calcProgress(now);
            for (attrName in that.params) {
                var anim = animateStep[attrName] || animateStep.base;
                anim(that.element, that.params[attrName], that._progress, that._easing, that._currentParams, attrName)
            }
            that.options.step && that.options.step(that._easing(that._progress, 0, 1), that._progress);
            if (1 === that._progress) {
                return that.stop()
            }
            return true
        }

        function delayTick(now) {
            if (now - this._startTime >= this.delay) {
                this.tick = step
            }
            return true
        }

        function start(now) {
            this._startTime = now;
            this.tick = this.delay ? delayTick : step;
            return true
        }

        function Animation(element, params, options) {
            var that = this;
            that._progress = 0;
            that.element = element;
            that.params = params;
            that.options = options;
            that.duration = options.partitionDuration ? options.duration * options.partitionDuration : options.duration;
            that.delay = options.delay && options.duration * options.delay || 0;
            that._animateStep = options.animateStep || animationSvgStep;
            that._easing = easingFunctions[options.easing] || easingFunctions.easeOutCubic;
            that._currentParams = {};
            that.tick = start
        }
        Animation.prototype = {
            _calcProgress: function(now) {
                return Math.min(1, (now - this.delay - this._startTime) / this.duration)
            },
            stop: function(disableComplete) {
                var that = this;
                var options = that.options;
                var animateStep = that._animateStep;
                that.stop = that.tick = noop;
                animateStep.complete && animateStep.complete(that.element, that._currentParams);
                options.complete && !disableComplete && options.complete()
            }
        };

        function AnimationController(element) {
            var that = this;
            that._animationCount = 0;
            that._timerId = null;
            that._animations = {};
            that.element = element
        }
        exports.AnimationController = AnimationController;
        AnimationController.prototype = {
            _loop: function() {
                var that = this;
                var animations = that._animations;
                var activeAnimation = 0;
                var now = (new Date).getTime();
                var an;
                var endAnimation = that._endAnimation;
                for (an in animations) {
                    if (!animations[an].tick(now)) {
                        delete animations[an]
                    }
                    activeAnimation++
                }
                if (0 === activeAnimation) {
                    that.stop();
                    that._endAnimationTimer = endAnimation && setTimeout(function() {
                        if (0 === that._animationCount) {
                            endAnimation();
                            that._endAnimation = null
                        }
                    });
                    return
                }
                that._timerId = animationFrame.requestAnimationFrame.call(null, function() {
                    that._loop()
                }, that.element)
            },
            addAnimation: function(animation) {
                var that = this;
                that._animations[that._animationCount++] = animation;
                clearTimeout(that._endAnimationTimer);
                if (!that._timerId) {
                    clearTimeout(that._startDelay);
                    that._startDelay = setTimeout(function() {
                        that._timerId = 1;
                        that._loop()
                    }, 0)
                }
            },
            animateElement: function(elem, params, options) {
                if (elem && params && options) {
                    elem.animation && elem.animation.stop();
                    this.addAnimation(elem.animation = new Animation(elem, params, options))
                }
            },
            onEndAnimation: function(endAnimation) {
                this._animationCount ? this._endAnimation = endAnimation : endAnimation()
            },
            dispose: function() {
                this.stop();
                this.element = null
            },
            stop: function() {
                var that = this;
                that._animations = {};
                that._animationCount = 0;
                animationFrame.cancelAnimationFrame(that._timerId);
                clearTimeout(that._startDelay);
                clearTimeout(that._endAnimationTimer);
                that._timerId = null
            },
            lock: function() {
                var an;
                var animations = this._animations;
                var unstoppable;
                var hasUnstoppableInAnimations;
                for (an in animations) {
                    unstoppable = animations[an].options.unstoppable;
                    hasUnstoppableInAnimations = hasUnstoppableInAnimations || unstoppable;
                    if (!unstoppable) {
                        animations[an].stop(true);
                        delete animations[an]
                    }
                }!hasUnstoppableInAnimations && this.stop()
            }
        };
        exports.animationSvgStep = animationSvgStep;
        exports.Animation = Animation;
        exports.noop = noop
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/viz/core/layout.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _normalizeEnum = __webpack_require__( /*! ./utils */ 13).normalizeEnum;
        var _min = Math.min;
        var _max = Math.max;
        var _round = Math.round;
        var ALIGN_START = 0;
        var ALIGN_MIDDLE = 1;
        var ALIGN_END = 2;
        var horizontalAlignmentMap = {
            left: ALIGN_START,
            center: ALIGN_MIDDLE,
            right: ALIGN_END
        };
        var verticalAlignmentMap = {
            top: ALIGN_START,
            center: ALIGN_MIDDLE,
            bottom: ALIGN_END
        };
        var sideMap = {
            horizontal: 0,
            vertical: 1
        };
        var slicersMap = {};
        var BBOX_CEIL_CORRECTION = 2;
        slicersMap[ALIGN_START] = function(a, b, size) {
            return [a, _min(b, a + size)]
        };
        slicersMap[ALIGN_MIDDLE] = function(a, b, size) {
            return [_max(a, (a + b - size) / 2), _min(b, (a + b + size) / 2)]
        };
        slicersMap[ALIGN_END] = function(a, b, size) {
            return [_max(a, b - size), b]
        };

        function pickValue(value, map, defaultValue) {
            var val = _normalizeEnum(value);
            return val in map ? map[val] : defaultValue
        }

        function normalizeLayoutOptions(options) {
            var side = pickValue(options.side, sideMap, 1);
            var alignment = [pickValue(options.horizontalAlignment, horizontalAlignmentMap, ALIGN_MIDDLE), pickValue(options.verticalAlignment, verticalAlignmentMap, ALIGN_START)];
            return {
                side: side,
                primary: bringToEdge(alignment[side]),
                secondary: alignment[1 - side],
                weak: options.weak,
                priority: options.priority || 0,
                header: options.header,
                position: options.position
            }
        }

        function bringToEdge(primary) {
            return primary < 2 ? 0 : 2
        }

        function getConjugateSide(side) {
            return 1 - side
        }

        function getSlice(alignment, a, b, size) {
            return slicersMap[alignment](a, b, size)
        }

        function getShrink(alignment, size) {
            return (alignment > 0 ? -1 : 1) * size
        }

        function processForward(item, rect, minSize) {
            var side = item.side;
            var size = item.element.measure([rect[2] - rect[0], rect[3] - rect[1]]);
            var minSide = "indside" === item.position ? 0 : minSize[side];
            var isValid = size[side] < rect[2 + side] - rect[side] - minSide;
            if (isValid) {
                if ("inside" !== item.position) {
                    rect[item.primary + side] += getShrink(item.primary, size[side])
                }
                item.size = size
            }
            return isValid
        }

        function processRectBackward(item, rect, alignmentRect) {
            var primarySide = item.side;
            var secondarySide = getConjugateSide(primarySide);
            var itemRect = [];
            var secondary = getSlice(item.secondary, alignmentRect[secondarySide], alignmentRect[2 + secondarySide], item.size[secondarySide]);
            itemRect[primarySide] = _round(itemRect[2 + primarySide] = rect[item.primary + primarySide] + ("inside" === item.position ? getShrink(item.primary, item.size[primarySide]) : 0));
            itemRect[item.primary + primarySide] = _round(rect[item.primary + primarySide] - getShrink(item.primary, item.size[primarySide]));
            if ("inside" !== item.position) {
                rect[item.primary + primarySide] = itemRect[item.primary + primarySide]
            }
            itemRect[secondarySide] = _round(secondary[0]);
            itemRect[2 + secondarySide] = _round(secondary[1]);
            return itemRect
        }

        function processBackward(item, rect, alignmentRect, fitRect, size, targetRect) {
            var itemRect = processRectBackward(item, rect, alignmentRect);
            var itemFitRect = processRectBackward(item, fitRect, fitRect);
            if (size[item.side] > 0) {
                size[item.side] -= item.size[item.side];
                targetRect[item.primary + item.side] = itemRect[item.primary + item.side];
                item.element.freeSpace()
            } else {
                item.element.move(itemRect, itemFitRect)
            }
        }

        function Layout() {
            this._targets = []
        }
        Layout.prototype = {
            constructor: Layout,
            dispose: function() {
                this._targets = null
            },
            add: function(target) {
                this._targets.push(target)
            },
            forward: function(targetRect, minSize) {
                var rect = targetRect.slice();
                var targets = createTargets(this._targets);
                var i;
                var ii = targets.length;
                var cache = [];
                for (i = 0; i < ii; ++i) {
                    if (processForward(targets[i], rect, minSize)) {
                        cache.push(targets[i])
                    } else {
                        targets[i].element.freeSpace()
                    }
                }
                this._cache = cache.reverse();
                return rect
            },
            backward: function(targetRect, alignmentRect) {
                var size = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [0, 0];
                var backwardRect = targetRect.slice();
                var fitRect = targetRect.slice();
                var targets = this._cache;
                var targetSide = 0;
                var target;
                var i;
                var ii = targets.length;
                for (i = 0; i < ii; ++i) {
                    target = targets[i];
                    if (target.side !== targetSide) {
                        backwardRect = targetRect.slice()
                    }
                    processBackward(target, backwardRect, alignmentRect, fitRect, size, targetRect);
                    targetSide = target.side
                }
                return size
            }
        };

        function createTargets(targets) {
            var i;
            var ii = targets.length;
            var collection = [];
            var layout;
            for (i = 0; i < ii; ++i) {
                layout = targets[i].layoutOptions();
                if (layout) {
                    layout = normalizeLayoutOptions(layout);
                    layout.element = targets[i];
                    collection.push(layout)
                }
            }
            collection.sort(function(a, b) {
                return b.side - a.side || a.priority - b.priority
            });
            collection = processWeakItems(collection);
            return collection
        }

        function processWeakItems(collection) {
            var weakItem = collection.filter(function(item) {
                return true === item.weak
            })[0];
            var headerItem;
            if (weakItem) {
                headerItem = collection.filter(function(item) {
                    return weakItem.primary === item.primary && item.side === weakItem.side && item !== weakItem
                })[0]
            }
            if (weakItem && headerItem) {
                return [makeHeader(headerItem, weakItem)].concat(collection.filter(function(item) {
                    return !(item === headerItem || item === weakItem)
                }))
            }
            return collection
        }

        function processBackwardHeaderRect(element, rect) {
            var rectCopy = rect.slice();
            var itemRect = processRectBackward(element, rectCopy, rectCopy);
            itemRect[element.side] = rect[element.side];
            itemRect[2 + element.side] = rect[2 + element.side];
            return itemRect
        }

        function makeHeader(header, weakElement) {
            var side = header.side;
            var primary = header.primary;
            var secondary = header.secondary;
            return {
                side: side,
                primary: primary,
                secondary: secondary,
                priority: 0,
                element: {
                    measure: function(targetSize) {
                        var result = targetSize.slice();
                        var weakSize = weakElement.element.measure(targetSize.slice());
                        targetSize[primary] -= weakSize[primary];
                        var headerSize = header.element.measure(targetSize.slice());
                        result[side] = weakSize[side] = headerSize[side] = Math.max(headerSize[side], weakSize[side]);
                        weakElement.size = weakSize;
                        header.size = headerSize;
                        return result
                    },
                    move: function(rect, fitRect) {
                        if (fitRect[2] - fitRect[0] < header.size[0] + weakElement.size[0] - BBOX_CEIL_CORRECTION) {
                            this.freeSpace();
                            return
                        }
                        var weakRect = processBackwardHeaderRect(weakElement, fitRect, fitRect);
                        fitRect[2 + weakElement.primary] = weakRect[weakElement.primary];
                        var headerFitReact = processBackwardHeaderRect(header, fitRect, fitRect);
                        if (fitRect[2 + weakElement.primary] < rect[2 + weakElement.primary] && header.size[header.primary] > rect[2 + header.primary] - rect[header.primary]) {
                            rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary]
                        }
                        var headerRect = processBackwardHeaderRect(header, rect, rect);
                        if (headerRect[2 + weakElement.primary] > fitRect[2 + weakElement.primary]) {
                            rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];
                            headerRect = processBackwardHeaderRect(header, rect, rect)
                        }
                        weakElement.element.move(weakRect);
                        header.element.move(headerRect, headerFitReact)
                    },
                    freeSpace: function() {
                        header.element.freeSpace();
                        weakElement.element.freeSpace()
                    }
                }
            }
        }
        module.exports = Layout
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/base_point.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var mixins = {};
        var statesConsts = __webpack_require__( /*! ../../components/consts */ 125).states;
        var symbolPoint = __webpack_require__( /*! ./symbol_point */ 126);
        var barPoint = __webpack_require__( /*! ./bar_point */ 208);
        var bubblePoint = __webpack_require__( /*! ./bubble_point */ 818);
        var piePoint = __webpack_require__( /*! ./pie_point */ 417);
        var rangeSymbolPoint = __webpack_require__( /*! ./range_symbol_point */ 418);
        var rangeBarPoint = __webpack_require__( /*! ./range_bar_point */ 819);
        var candlestickPoint = __webpack_require__( /*! ./candlestick_point */ 419);
        var stockPoint = __webpack_require__( /*! ./stock_point */ 820);
        var polarPoints = __webpack_require__( /*! ./polar_point */ 821);
        var _normalizeEnum = __webpack_require__( /*! ../../core/utils */ 13).normalizeEnum;
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var _extend = extend;
        var _isDefined = __webpack_require__( /*! ../../../core/utils/type */ 1).isDefined;
        var _noop = __webpack_require__( /*! ../../../core/utils/common */ 3).noop;
        var SYMBOL_POINT = "symbolPoint";
        var POLAR_SYMBOL_POINT = "polarSymbolPoint";
        var BAR_POINT = "barPoint";
        var POLAR_BAR_POINT = "polarBarPoint";
        var PIE_POINT = "piePoint";
        var SELECTED_STATE = statesConsts.selectedMark;
        var HOVER_STATE = statesConsts.hoverMark;
        var NORMAL_STATE = statesConsts.normalMark;
        var HOVER = statesConsts.hover;
        var NORMAL = statesConsts.normal;
        var SELECTION = statesConsts.selection;
        var pointTypes = {
            chart: {
                scatter: SYMBOL_POINT,
                line: SYMBOL_POINT,
                spline: SYMBOL_POINT,
                stepline: SYMBOL_POINT,
                stackedline: SYMBOL_POINT,
                fullstackedline: SYMBOL_POINT,
                stackedspline: SYMBOL_POINT,
                fullstackedspline: SYMBOL_POINT,
                stackedsplinearea: SYMBOL_POINT,
                fullstackedsplinearea: SYMBOL_POINT,
                area: SYMBOL_POINT,
                splinearea: SYMBOL_POINT,
                steparea: SYMBOL_POINT,
                stackedarea: SYMBOL_POINT,
                fullstackedarea: SYMBOL_POINT,
                rangearea: "rangeSymbolPoint",
                bar: BAR_POINT,
                stackedbar: BAR_POINT,
                fullstackedbar: BAR_POINT,
                rangebar: "rangeBarPoint",
                bubble: "bubblePoint",
                stock: "stockPoint",
                candlestick: "candlestickPoint"
            },
            pie: {
                pie: PIE_POINT,
                doughnut: PIE_POINT,
                donut: PIE_POINT
            },
            polar: {
                scatter: POLAR_SYMBOL_POINT,
                line: POLAR_SYMBOL_POINT,
                area: POLAR_SYMBOL_POINT,
                bar: POLAR_BAR_POINT,
                stackedbar: POLAR_BAR_POINT
            }
        };

        function isNoneMode(mode) {
            return "none" === _normalizeEnum(mode)
        }

        function Point(series, dataItem, options) {
            this.fullState = NORMAL_STATE;
            this.series = series;
            this.update(dataItem, options);
            this._viewCounters = {
                hover: 0,
                selection: 0
            };
            this._emptySettings = {
                fill: null,
                stroke: null,
                dashStyle: null
            }
        }
        exports.Point = Point;
        mixins.symbolPoint = symbolPoint;
        mixins.barPoint = barPoint;
        mixins.bubblePoint = bubblePoint;
        mixins.piePoint = piePoint;
        mixins.rangeSymbolPoint = rangeSymbolPoint;
        mixins.rangeBarPoint = rangeBarPoint;
        mixins.candlestickPoint = candlestickPoint;
        mixins.stockPoint = stockPoint;
        mixins.polarSymbolPoint = polarPoints.polarSymbolPoint;
        mixins.polarBarPoint = polarPoints.polarBarPoint;
        Point.prototype = {
            constructor: Point,
            getColor: function() {
                if (!this.hasValue() && !this._styles.usePointCustomOptions) {
                    this.series.customizePoint(this, this._dataItem)
                }
                return this._styles.normal.fill || this.series.getColor()
            },
            _getStyle: function() {
                return this._styles[this._currentStyle || "normal"]
            },
            update: function(dataItem, options) {
                this.updateOptions(options);
                this.updateData(dataItem)
            },
            updateData: function(dataItem) {
                var that = this;
                var argumentWasChanged = that.argument !== dataItem.argument;
                that.argument = that.initialArgument = that.originalArgument = dataItem.argument;
                that.tag = dataItem.tag;
                that.index = dataItem.index;
                that._dataItem = dataItem;
                that.data = dataItem.data;
                that.lowError = dataItem.lowError;
                that.highError = dataItem.highError;
                that.aggregationInfo = dataItem.aggregationInfo;
                that._updateData(dataItem, argumentWasChanged);
                !that.hasValue() && that.setInvisibility();
                that._fillStyle();
                that._updateLabelData()
            },
            deleteMarker: function() {
                var that = this;
                if (that.graphic) {
                    that.graphic.dispose()
                }
                that.graphic = null
            },
            draw: function(renderer, groups, animationEnabled, firstDrawing) {
                var that = this;
                if (that._needDeletingOnDraw || that.series.autoHidePointMarkers && !that.isSelected()) {
                    that.deleteMarker();
                    that._needDeletingOnDraw = false
                }
                if (that._needClearingOnDraw) {
                    that.clearMarker();
                    that._needClearingOnDraw = false
                }
                if (!that._hasGraphic()) {
                    that.getMarkerVisibility() && !that.series.autoHidePointMarkers && that._drawMarker(renderer, groups.markers, animationEnabled, firstDrawing)
                } else {
                    that._updateMarker(animationEnabled, this._getStyle(), groups.markers)
                }
                that._drawLabel();
                that._drawErrorBar(renderer, groups.errorBars, animationEnabled);
                return that
            },
            _getViewStyle: function() {
                var state = NORMAL_STATE;
                var fullState = this.fullState;
                var styles = [NORMAL, HOVER, SELECTION, SELECTION];
                if (this._viewCounters.hover) {
                    state |= HOVER_STATE
                }
                if (this._viewCounters.selection) {
                    state |= SELECTED_STATE
                }
                if (isNoneMode(this.getOptions().selectionMode)) {
                    fullState &= ~SELECTED_STATE
                }
                if (isNoneMode(this.getOptions().hoverMode)) {
                    fullState &= ~HOVER_STATE
                }
                state |= fullState;
                return styles[state]
            },
            applyView: function(legendCallback) {
                var style = this._getViewStyle();
                var that = this;
                that._currentStyle = style;
                if (!that.graphic && that.series.autoHidePointMarkers && (style === SELECTION || style === HOVER)) {
                    that._drawMarker(that.series.getRenderer(), that.series.getMarkersGroup())
                }
                if (that.graphic) {
                    if (that.series.autoHidePointMarkers && style !== SELECTION && style !== HOVER) {
                        that.deleteMarker()
                    } else {
                        if ("normal" === style) {
                            that.clearMarker()
                        } else {
                            that.graphic.toForeground()
                        }
                        that._updateMarker(true, that._styles[style], void 0, legendCallback)
                    }
                }
            },
            setView: function(style) {
                this._viewCounters[style]++;
                this.applyView()
            },
            resetView: function(style) {
                var viewCounters = this._viewCounters;
                --viewCounters[style];
                if (viewCounters[style] < 0) {
                    viewCounters[style] = 0
                }
                this.applyView()
            },
            releaseHoverState: function() {
                var that = this;
                if (that.graphic && !that.isSelected()) {
                    that.graphic.toBackground()
                }
            },
            select: function() {
                this.series.selectPoint(this)
            },
            clearSelection: function() {
                this.series.deselectPoint(this)
            },
            hover: function() {
                this.series.hoverPoint(this)
            },
            clearHover: function() {
                this.series.clearPointHover()
            },
            showTooltip: function() {
                this.series.showPointTooltip(this)
            },
            hideTooltip: function() {
                this.series.hidePointTooltip(this)
            },
            _checkLabelsChanging: function(oldType, newType) {
                var isNewRange = ~newType.indexOf("range");
                var isOldRange = ~oldType.indexOf("range");
                return isOldRange && !isNewRange || !isOldRange && isNewRange
            },
            updateOptions: function(newOptions) {
                if (!newOptions) {
                    return
                }
                var that = this;
                var oldOptions = that._options;
                var widgetType = newOptions.widgetType;
                var oldType = oldOptions && oldOptions.type;
                var newType = newOptions.type;
                var newPointTypeMixin = pointTypes[widgetType][newType];
                if (oldType !== newType) {
                    that._needDeletingOnDraw = true;
                    that._needClearingOnDraw = false;
                    if (oldType) {
                        that._checkLabelsChanging(oldType, newType) && that.deleteLabel();
                        that._resetType(mixins[pointTypes[oldType]])
                    }
                    that._setType(mixins[newPointTypeMixin])
                } else {
                    that._needDeletingOnDraw = that._checkSymbol(oldOptions, newOptions);
                    that._needClearingOnDraw = that._checkCustomize(oldOptions, newOptions)
                }
                that._options = newOptions;
                that._fillStyle();
                that._updateLabelOptions(newPointTypeMixin)
            },
            translate: function() {
                if (this.hasValue()) {
                    this._translate();
                    this.translated = true
                }
            },
            _checkCustomize: function(oldOptions, newOptions) {
                return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions
            },
            _getCustomLabelVisibility: function() {
                return this._styles.useLabelCustomOptions ? !!this._options.label.visible : null
            },
            getBoundingRect: function() {
                return this._getGraphicBBox()
            },
            _resetType: function(methods) {
                for (var methodName in methods) {
                    delete this[methodName]
                }
            },
            _setType: function(methods) {
                for (var methodName in methods) {
                    this[methodName] = methods[methodName]
                }
            },
            isInVisibleArea: function() {
                return this.inVisibleArea
            },
            isSelected: function() {
                return !!(this.fullState & SELECTED_STATE)
            },
            isHovered: function() {
                return !!(this.fullState & HOVER_STATE)
            },
            getOptions: function() {
                return this._options
            },
            animate: function(complete, settings, partitionDuration) {
                if (!this.graphic) {
                    complete && complete();
                    return
                }
                this.graphic.animate(settings, {
                    partitionDuration: partitionDuration
                }, complete)
            },
            getCoords: function(min) {
                var that = this;
                if (!min) {
                    return {
                        x: that.x,
                        y: that.y
                    }
                }
                if (!that._options.rotated) {
                    return {
                        x: that.x,
                        y: that.minY + (that.y - that.minY ? 0 : 1)
                    }
                }
                return {
                    x: that.minX - (that.x - that.minX ? 0 : 1),
                    y: that.y
                }
            },
            getDefaultCoords: function() {
                var that = this;
                return !that._options.rotated ? {
                    x: that.x,
                    y: that.defaultY
                } : {
                    x: that.defaultX,
                    y: that.y
                }
            },
            setDefaultCoords: function() {
                var coords = this.getDefaultCoords();
                this.x = coords.x;
                this.y = coords.y
            },
            _getVisibleArea: function() {
                return this.series.getVisibleArea()
            },
            _getArgTranslator: function() {
                return this.series.getArgumentAxis().getTranslator()
            },
            _getValTranslator: function() {
                return this.series.getValueAxis().getTranslator()
            },
            _calculateVisibility: function(x, y, width, height) {
                var that = this;
                var visibleArea = that._getVisibleArea();
                var rotated = that._options.rotated;
                if (visibleArea.minX > x + (width || 0) || visibleArea.maxX < x || visibleArea.minY > y + (height || 0) || visibleArea.maxY < y || rotated && _isDefined(width) && 0 !== width && (visibleArea.minX === x + width || visibleArea.maxX === x) || !rotated && _isDefined(height) && 0 !== height && (visibleArea.minY === y + height || visibleArea.maxY === y)) {
                    that.inVisibleArea = false
                } else {
                    that.inVisibleArea = true
                }
            },
            isArgumentCorrect: function() {
                return this.series._argumentChecker(this.argument)
            },
            isValueCorrect: function() {
                var valueChecker = this.series._valueChecker;
                return valueChecker(this.getMinValue()) && valueChecker(this.getMaxValue())
            },
            hasValue: function() {
                return null !== this.value && null !== this.minValue && this.isArgumentCorrect() && this.isValueCorrect()
            },
            hasCoords: _noop,
            correctPosition: _noop,
            correctRadius: _noop,
            correctLabelRadius: _noop,
            getCrosshairData: _noop,
            getPointRadius: _noop,
            _populatePointShape: _noop,
            _checkSymbol: _noop,
            getMarkerCoords: _noop,
            hide: _noop,
            show: _noop,
            hideMarker: _noop,
            setInvisibility: _noop,
            clearVisibility: _noop,
            isVisible: _noop,
            resetCorrection: _noop,
            correctValue: _noop,
            resetValue: _noop,
            setPercentValue: _noop,
            correctCoordinates: _noop,
            coordsIn: _noop,
            getTooltipParams: _noop,
            applyWordWrap: _noop,
            setLabelTrackerData: _noop,
            updateLabelCoord: _noop,
            drawLabel: _noop,
            correctLabelPosition: _noop,
            getMinValue: _noop,
            getMaxValue: _noop,
            _drawErrorBar: _noop,
            getMarkerVisibility: _noop,
            dispose: function() {
                var that = this;
                that.deleteMarker();
                that.deleteLabel();
                that._errorBar && this._errorBar.dispose();
                that._options = that._styles = that.series = that._errorBar = null
            },
            getTooltipFormatObject: function(tooltip, stackPoints) {
                var that = this;
                var tooltipFormatObject = that._getFormatObject(tooltip);
                var sharedTooltipValuesArray = [];
                var tooltipStackPointsFormatObject = [];
                if (stackPoints) {
                    stackPoints.forEach(function(point) {
                        if (!point.isVisible()) {
                            return
                        }
                        var formatObject = point._getFormatObject(tooltip);
                        tooltipStackPointsFormatObject.push(formatObject);
                        sharedTooltipValuesArray.push(formatObject.seriesName + ": " + formatObject.valueText)
                    });
                    _extend(tooltipFormatObject, {
                        points: tooltipStackPointsFormatObject,
                        valueText: sharedTooltipValuesArray.join("\n"),
                        stackName: that.series.getStackName() || null
                    })
                }
                var aggregationInfo = that.aggregationInfo;
                if (aggregationInfo) {
                    var axis = that.series.getArgumentAxis();
                    var rangeText = axis.formatRange(aggregationInfo.intervalStart, aggregationInfo.intervalEnd, aggregationInfo.aggregationInterval);
                    if (rangeText) {
                        tooltipFormatObject.valueText += "\n".concat(rangeText)
                    }
                }
                return tooltipFormatObject
            },
            setHole: function(holeValue, position) {
                var that = this;
                var minValue = isFinite(that.minValue) ? that.minValue : 0;
                if (_isDefined(holeValue)) {
                    if ("left" === position) {
                        that.leftHole = that.value - holeValue;
                        that.minLeftHole = minValue - holeValue
                    } else {
                        that.rightHole = that.value - holeValue;
                        that.minRightHole = minValue - holeValue
                    }
                }
            },
            resetHoles: function() {
                this.leftHole = null;
                this.minLeftHole = null;
                this.rightHole = null;
                this.minRightHole = null
            },
            getLabel: function() {
                return this._label
            },
            getLabels: function() {
                return [this._label]
            },
            getCenterCoord: function() {
                return {
                    x: this.x,
                    y: this.y
                }
            }
        }
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/bubble_point.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var symbolPoint = __webpack_require__( /*! ./symbol_point */ 126);
        var _extend = extend;
        var MIN_BUBBLE_HEIGHT = 20;
        module.exports = _extend({}, symbolPoint, {
            correctCoordinates: function(diameter) {
                this.bubbleSize = diameter / 2
            },
            _drawMarker: function(renderer, group, animationEnabled) {
                var that = this;
                var attr = _extend({
                    translateX: that.x,
                    translateY: that.y
                }, that._getStyle());
                that.graphic = renderer.circle(0, 0, animationEnabled ? 0 : that.bubbleSize).smartAttr(attr).data({
                    "chart-data-point": that
                }).append(group)
            },
            getTooltipParams: function(location) {
                var that = this;
                var graphic = that.graphic;
                if (!graphic) {
                    return
                }
                var height = graphic.getBBox().height;
                return {
                    x: that.x,
                    y: that.y,
                    offset: height < MIN_BUBBLE_HEIGHT || "edge" === location ? height / 2 : 0
                }
            },
            _getLabelFormatObject: function() {
                var formatObject = symbolPoint._getLabelFormatObject.call(this);
                formatObject.size = this.initialSize;
                return formatObject
            },
            _updateData: function(data) {
                symbolPoint._updateData.call(this, data);
                this.size = this.initialSize = data.size
            },
            _getGraphicBBox: function() {
                var that = this;
                return that._getSymbolBBox(that.x, that.y, that.bubbleSize)
            },
            _updateMarker: function(animationEnabled, style) {
                var that = this;
                if (!animationEnabled) {
                    style = _extend({
                        r: that.bubbleSize,
                        translateX: that.x,
                        translateY: that.y
                    }, style)
                }
                that.graphic.smartAttr(style)
            },
            _getFormatObject: function(tooltip) {
                var formatObject = symbolPoint._getFormatObject.call(this, tooltip);
                formatObject.sizeText = tooltip.formatValue(this.initialSize);
                return formatObject
            },
            _storeTrackerR: function() {
                return this.bubbleSize
            },
            _getLabelCoords: function(label) {
                var coords;
                if ("inside" === label.getLayoutOptions().position) {
                    coords = this._getLabelCoordOfPosition(label, "inside")
                } else {
                    coords = symbolPoint._getLabelCoords.call(this, label)
                }
                return coords
            }
        })
    },
    /*!*******************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/range_bar_point.js ***!
      \*******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var noop = __webpack_require__( /*! ../../../core/utils/common */ 3).noop;
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var barPoint = __webpack_require__( /*! ./bar_point */ 208);
        var rangeSymbolPointMethods = __webpack_require__( /*! ./range_symbol_point */ 418);
        var _extend = extend;
        module.exports = _extend({}, barPoint, {
            deleteLabel: rangeSymbolPointMethods.deleteLabel,
            _getFormatObject: rangeSymbolPointMethods._getFormatObject,
            clearVisibility: function() {
                var graphic = this.graphic;
                if (graphic && graphic.attr("visibility")) {
                    graphic.attr({
                        visibility: null
                    })
                }
            },
            setInvisibility: function() {
                var graphic = this.graphic;
                if (graphic && "hidden" !== graphic.attr("visibility")) {
                    graphic.attr({
                        visibility: "hidden"
                    })
                }
                this._topLabel.draw(false);
                this._bottomLabel.draw(false)
            },
            getTooltipParams: function(location) {
                var that = this;
                var edgeLocation = "edge" === location;
                var x;
                var y;
                if (that._options.rotated) {
                    x = edgeLocation ? that.x + that.width : that.x + that.width / 2;
                    y = that.y + that.height / 2
                } else {
                    x = that.x + that.width / 2;
                    y = edgeLocation ? that.y : that.y + that.height / 2
                }
                return {
                    x: x,
                    y: y,
                    offset: 0
                }
            },
            _translate: function() {
                var that = this;
                var barMethods = barPoint;
                barMethods._translate.call(that);
                if (that._options.rotated) {
                    that.width = that.width || 1
                } else {
                    that.height = that.height || 1
                }
            },
            hasCoords: rangeSymbolPointMethods.hasCoords,
            _updateData: rangeSymbolPointMethods._updateData,
            _getLabelPosition: rangeSymbolPointMethods._getLabelPosition,
            _getLabelMinFormatObject: rangeSymbolPointMethods._getLabelMinFormatObject,
            _updateLabelData: rangeSymbolPointMethods._updateLabelData,
            _updateLabelOptions: rangeSymbolPointMethods._updateLabelOptions,
            getCrosshairData: rangeSymbolPointMethods.getCrosshairData,
            _createLabel: rangeSymbolPointMethods._createLabel,
            _checkOverlay: rangeSymbolPointMethods._checkOverlay,
            _checkLabelsOverlay: rangeSymbolPointMethods._checkLabelsOverlay,
            _getOverlayCorrections: rangeSymbolPointMethods._getOverlayCorrections,
            _drawLabel: rangeSymbolPointMethods._drawLabel,
            _getLabelCoords: rangeSymbolPointMethods._getLabelCoords,
            getLabel: rangeSymbolPointMethods.getLabel,
            getLabels: rangeSymbolPointMethods.getLabels,
            getBoundingRect: noop,
            getMinValue: rangeSymbolPointMethods.getMinValue,
            getMaxValue: rangeSymbolPointMethods.getMaxValue
        })
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/stock_point.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var isNumeric = __webpack_require__( /*! ../../../core/utils/type */ 1).isNumeric;
        var candlestickPoint = __webpack_require__( /*! ./candlestick_point */ 419);
        var _extend = extend;
        var _isNumeric = isNumeric;
        module.exports = _extend({}, candlestickPoint, {
            _getPoints: function() {
                var that = this;
                var createPoint = that._options.rotated ? function(x, y) {
                    return [y, x]
                } : function(x, y) {
                    return [x, y]
                };
                var openYExist = _isNumeric(that.openY);
                var closeYExist = _isNumeric(that.closeY);
                var x = that.x;
                var width = that.width;
                var points = [].concat(createPoint(x, that.highY));
                openYExist && (points = points.concat(createPoint(x, that.openY)));
                openYExist && (points = points.concat(createPoint(x - width / 2, that.openY)));
                openYExist && (points = points.concat(createPoint(x, that.openY)));
                closeYExist && (points = points.concat(createPoint(x, that.closeY)));
                closeYExist && (points = points.concat(createPoint(x + width / 2, that.closeY)));
                closeYExist && (points = points.concat(createPoint(x, that.closeY)));
                points = points.concat(createPoint(x, that.lowY));
                return points
            },
            _drawMarkerInGroup: function(group, attributes, renderer) {
                this.graphic = renderer.path(this._getPoints(), "line").attr({
                    "stroke-linecap": "square"
                }).attr(attributes).data({
                    "chart-data-point": this
                }).sharp().append(group)
            },
            _getMinTrackerWidth: function() {
                var width = 2 + this._styles.normal["stroke-width"];
                return width + width % 2
            }
        })
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/points/polar_point.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../../core/utils/extend */ 0).extend;
        var _extend = extend;
        var symbolPoint = __webpack_require__( /*! ./symbol_point */ 126);
        var barPoint = __webpack_require__( /*! ./bar_point */ 208);
        var piePoint = __webpack_require__( /*! ./pie_point */ 417);
        var isDefined = __webpack_require__( /*! ../../../core/utils/type */ 1).isDefined;
        var vizUtils = __webpack_require__( /*! ../../core/utils */ 13);
        var normalizeAngle = vizUtils.normalizeAngle;
        var _math = Math;
        var _max = _math.max;
        var RADIAL_LABEL_INDENT = __webpack_require__( /*! ../../components/consts */ 125).radialLabelIndent;
        var ERROR_BARS_ANGLE_OFFSET = 90;
        var CANVAS_POSITION_END = "canvas_position_end";
        var CANVAS_POSITION_DEFAULT = "canvas_position_default";
        exports.polarSymbolPoint = _extend({}, symbolPoint, {
            _getLabelCoords: piePoint._getLabelCoords,
            _moveLabelOnCanvas: function(coord, visibleArea, labelBBox) {
                var x = coord.x;
                var y = coord.y;
                if (visibleArea.minX > x) {
                    x = visibleArea.minX
                }
                if (visibleArea.maxX < x + labelBBox.width) {
                    x = visibleArea.maxX - labelBBox.width
                }
                if (visibleArea.minY > y) {
                    y = visibleArea.minY
                }
                if (visibleArea.maxY < y + labelBBox.height) {
                    y = visibleArea.maxY - labelBBox.height
                }
                return {
                    x: x,
                    y: y
                }
            },
            _getLabelPosition: function() {
                return "outside"
            },
            _getCoords: function(argument, value) {
                var axis = this.series.getValueAxis();
                var startAngle = axis.getAngles()[0];
                var angle = this._getArgTranslator().translate(argument);
                var radius = this._getValTranslator().translate(value);
                var coords = vizUtils.convertPolarToXY(axis.getCenter(), axis.getAngles()[0], angle, radius);
                coords.angle = angle + startAngle - 90, coords.radius = radius;
                return coords
            },
            _translate: function() {
                var that = this;
                var center = that.series.getValueAxis().getCenter();
                var coord = that._getCoords(that.argument, that.value);
                var maxRadius = that._getValTranslator().translate(CANVAS_POSITION_END);
                var normalizedRadius = isDefined(coord.radius) && coord.radius >= 0 ? coord.radius : null;
                that.vx = normalizeAngle(coord.angle);
                that.vy = that.radiusOuter = that.radiusLabels = normalizedRadius;
                that.radiusLabels += RADIAL_LABEL_INDENT;
                that.radius = normalizedRadius;
                that.middleAngle = -coord.angle;
                that.angle = -coord.angle;
                that.x = coord.x;
                that.y = coord.y;
                that.defaultX = that.centerX = center.x;
                that.defaultY = that.centerY = center.y;
                that._translateErrorBars();
                that.inVisibleArea = that._checkRadiusForVisibleArea(normalizedRadius, maxRadius)
            },
            _checkRadiusForVisibleArea: function(radius, maxRadius) {
                return isDefined(radius) && radius <= maxRadius
            },
            _translateErrorBars: function() {
                var that = this;
                var errorBars = that._options.errorBars;
                var translator = that._getValTranslator();
                if (!errorBars) {
                    return
                }
                isDefined(that.lowError) && (that._lowErrorCoord = that.centerY - translator.translate(that.lowError));
                isDefined(that.highError) && (that._highErrorCoord = that.centerY - translator.translate(that.highError));
                that._errorBarPos = that.centerX;
                that._baseErrorBarPos = "stdDeviation" === errorBars.type ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : that.centerY - that.radius
            },
            _getTranslates: function(animationEnabled) {
                return animationEnabled ? this.getDefaultCoords() : {
                    x: this.x,
                    y: this.y
                }
            },
            getDefaultCoords: function() {
                var cosSin = vizUtils.getCosAndSin(-this.angle);
                var radius = this._getValTranslator().translate(CANVAS_POSITION_DEFAULT);
                var x = this.defaultX + radius * cosSin.cos;
                var y = this.defaultY + radius * cosSin.sin;
                return {
                    x: x,
                    y: y
                }
            },
            _addLabelAlignmentAndOffset: function(label, coord) {
                return coord
            },
            _checkLabelPosition: function(label, coord) {
                var that = this;
                var visibleArea = that._getVisibleArea();
                var graphicBBox = that._getGraphicBBox();
                if (that._isPointInVisibleArea(visibleArea, graphicBBox)) {
                    coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect())
                }
                return coord
            },
            _getErrorBarSettings: function(errorBarOptions, animationEnabled) {
                var settings = symbolPoint._getErrorBarSettings.call(this, errorBarOptions, animationEnabled);
                settings.rotate = ERROR_BARS_ANGLE_OFFSET - this.angle;
                settings.rotateX = this.centerX;
                settings.rotateY = this.centerY;
                return settings
            },
            getCoords: function(min) {
                return min ? this.getDefaultCoords() : {
                    x: this.x,
                    y: this.y
                }
            }
        });
        exports.polarBarPoint = _extend({}, barPoint, {
            _translateErrorBars: exports.polarSymbolPoint._translateErrorBars,
            _getErrorBarSettings: exports.polarSymbolPoint._getErrorBarSettings,
            _moveLabelOnCanvas: exports.polarSymbolPoint._moveLabelOnCanvas,
            _getLabelCoords: piePoint._getLabelCoords,
            _getLabelConnector: piePoint._getLabelConnector,
            getTooltipParams: piePoint.getTooltipParams,
            _getLabelPosition: piePoint._getLabelPosition,
            _getCoords: exports.polarSymbolPoint._getCoords,
            _translate: function() {
                var that = this;
                var translator = that._getValTranslator();
                var businessRange = translator.getBusinessRange();
                var maxRadius = translator.translate(CANVAS_POSITION_END);
                that.radiusInner = translator.translate(that.minValue);
                exports.polarSymbolPoint._translate.call(that);
                if (null === that.radiusInner) {
                    that.radiusInner = that.radius = maxRadius
                } else {
                    if (null === that.radius) {
                        that.radius = that.value >= businessRange.minVisible ? maxRadius : 0
                    } else {
                        if (that.radius > maxRadius) {
                            that.radius = maxRadius
                        }
                    }
                }
                that.radiusOuter = that.radiusLabels = _max(that.radiusInner, that.radius);
                that.radiusLabels += RADIAL_LABEL_INDENT;
                that.radiusInner = that.defaultRadius = _math.min(that.radiusInner, that.radius);
                that.middleAngle = that.angle = -normalizeAngle(that.middleAngleCorrection - that.angle)
            },
            _checkRadiusForVisibleArea: function(radius) {
                return isDefined(radius) || this._getValTranslator().translate(this.minValue) > 0
            },
            _getErrorBarBaseEdgeLength: function() {
                var coord = this.getMarkerCoords();
                return _math.PI * coord.outerRadius * _math.abs(coord.startAngle - coord.endAngle) / 180
            },
            getMarkerCoords: function() {
                return {
                    x: this.centerX,
                    y: this.centerY,
                    outerRadius: this.radiusOuter,
                    innerRadius: this.defaultRadius,
                    startAngle: this.middleAngle - this.interval / 2,
                    endAngle: this.middleAngle + this.interval / 2
                }
            },
            _drawMarker: function(renderer, group, animationEnabled) {
                var that = this;
                var styles = that._getStyle();
                var coords = that.getMarkerCoords();
                var innerRadius = coords.innerRadius;
                var outerRadius = coords.outerRadius;
                var start = that._getCoords(that.argument, CANVAS_POSITION_DEFAULT);
                var x = coords.x;
                var y = coords.y;
                if (animationEnabled) {
                    innerRadius = 0;
                    outerRadius = 0;
                    x = start.x;
                    y = start.y
                }
                that.graphic = renderer.arc(x, y, innerRadius, outerRadius, coords.startAngle, coords.endAngle).attr(styles).data({
                    "chart-data-point": that
                }).append(group)
            },
            _checkLabelPosition: function(label, coord) {
                var that = this;
                var visibleArea = that._getVisibleArea();
                var angleFunctions = vizUtils.getCosAndSin(that.middleAngle);
                var x = that.centerX + that.defaultRadius * angleFunctions.cos;
                var y = that.centerY - that.defaultRadius * angleFunctions.sin;
                if (x > visibleArea.minX && x < visibleArea.maxX && y > visibleArea.minY && y < visibleArea.maxY) {
                    coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect())
                }
                return coord
            },
            _addLabelAlignmentAndOffset: function(label, coord) {
                return coord
            },
            correctCoordinates: function(correctOptions) {
                this.middleAngleCorrection = correctOptions.offset;
                this.interval = correctOptions.width
            },
            coordsIn: function(x, y) {
                var val = vizUtils.convertXYToPolar(this.series.getValueAxis().getCenter(), x, y);
                var coords = this.getMarkerCoords();
                var isBetweenAngles = coords.startAngle < coords.endAngle ? -val.phi >= coords.startAngle && -val.phi <= coords.endAngle : -val.phi <= coords.startAngle && -val.phi >= coords.endAngle;
                return val.r >= coords.innerRadius && val.r <= coords.outerRadius && isBetweenAngles
            }
        })
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/viz/series/range_series.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var _extend = extend;
        var _isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var _map = __webpack_require__( /*! ../core/utils */ 13).map;
        var _noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var scatterSeries = __webpack_require__( /*! ./scatter_series */ 110).chart;
        var barSeries = __webpack_require__( /*! ./bar_series */ 151).chart.bar;
        var areaSeries = __webpack_require__( /*! ./area_series */ 174).chart.area;
        exports.chart = {};
        var baseRangeSeries = {
            areErrorBarsVisible: _noop,
            _createErrorBarGroup: _noop,
            _checkData: function(data, skippedFields) {
                var valueFields = this.getValueFields();
                return scatterSeries._checkData.call(this, data, skippedFields, {
                    minValue: valueFields[0],
                    value: valueFields[1]
                }) && data.minValue === data.minValue
            },
            getValueRangeInitialValue: scatterSeries.getValueRangeInitialValue,
            _getPointDataSelector: function(data) {
                var _this = this;
                var valueFields = this.getValueFields();
                var val1Field = valueFields[0];
                var val2Field = valueFields[1];
                var tagField = this.getTagField();
                var argumentField = this.getArgumentField();
                return function(data) {
                    return {
                        tag: data[tagField],
                        minValue: _this._processEmptyValue(data[val1Field]),
                        value: _this._processEmptyValue(data[val2Field]),
                        argument: data[argumentField],
                        data: data
                    }
                }
            },
            _defaultAggregator: "range",
            _aggregators: {
                range: function(_ref, series) {
                    var _data$reduce;
                    var intervalStart = _ref.intervalStart,
                        data = _ref.data;
                    if (!data.length) {
                        return
                    }
                    var valueFields = series.getValueFields();
                    var val1Field = valueFields[0];
                    var val2Field = valueFields[1];
                    var result = data.reduce(function(result, item) {
                        var val1 = item[val1Field];
                        var val2 = item[val2Field];
                        if (!_isDefined(val1) || !_isDefined(val2)) {
                            return result
                        }
                        result[val1Field] = Math.min(result[val1Field], Math.min(val1, val2));
                        result[val2Field] = Math.max(result[val2Field], Math.max(val1, val2));
                        return result
                    }, (_data$reduce = {}, _defineProperty(_data$reduce, val1Field, 1 / 0), _defineProperty(_data$reduce, val2Field, -(1 / 0)), _defineProperty(_data$reduce, series.getArgumentField(), intervalStart), _data$reduce));
                    if (!isFinite(result[val1Field]) || !isFinite(result[val2Field])) {
                        if (data.filter(function(i) {
                                return null === i[val1Field] && null === i[val2Field]
                            }).length === data.length) {
                            result[val1Field] = result[val2Field] = null
                        } else {
                            return
                        }
                    }
                    return result
                }
            },
            getValueFields: function() {
                return [this._options.rangeValue1Field || "val1", this._options.rangeValue2Field || "val2"]
            },
            getSeriesPairCoord: function(coord, isArgument) {
                var oppositeCoord = null;
                var rotated = this._options.rotated;
                var isOpposite = !isArgument && !rotated || isArgument && rotated;
                var coordName = isOpposite ? "vy" : "vx";
                var minCoordName = rotated ? "minX" : "minY";
                var oppositeCoordName = isOpposite ? "vx" : "vy";
                var points = this.getPoints();
                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    var tmpCoord = void 0;
                    if (isArgument) {
                        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0
                    } else {
                        var coords = [Math.min(p[coordName], p[minCoordName]), Math.max(p[coordName], p[minCoordName])];
                        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p[oppositeCoordName] : void 0
                    }
                    if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
                        oppositeCoord = tmpCoord;
                        break
                    }
                }
                return oppositeCoord
            }
        };
        exports.chart.rangebar = _extend({}, barSeries, baseRangeSeries);
        exports.chart.rangearea = _extend({}, areaSeries, {
            _drawPoint: function(options) {
                var point = options.point;
                if (point.isInVisibleArea()) {
                    point.clearVisibility();
                    point.draw(this._renderer, options.groups);
                    this._drawnPoints.push(point);
                    if (!point.visibleTopMarker) {
                        point.hideMarker("top")
                    }
                    if (!point.visibleBottomMarker) {
                        point.hideMarker("bottom")
                    }
                } else {
                    point.setInvisibility()
                }
            },
            _prepareSegment: function(points, rotated) {
                var processedPoints = this._processSinglePointsAreaSegment(points, rotated);
                var processedMinPointsCoords = _map(processedPoints, function(pt) {
                    return pt.getCoords(true)
                });
                return {
                    line: processedPoints,
                    bottomLine: processedMinPointsCoords,
                    area: _map(processedPoints, function(pt) {
                        return pt.getCoords()
                    }).concat(processedMinPointsCoords.slice().reverse()),
                    singlePointSegment: processedPoints !== points
                }
            },
            _getDefaultSegment: function(segment) {
                var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);
                defaultSegment.bottomLine = defaultSegment.line;
                return defaultSegment
            },
            _removeElement: function(element) {
                areaSeries._removeElement.call(this, element);
                element.bottomLine && element.bottomLine.remove()
            },
            _drawElement: function(segment, group) {
                var that = this;
                var drawnElement = areaSeries._drawElement.call(that, segment, group);
                drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, {
                    "stroke-width": that._styles.normal.border["stroke-width"]
                }).append(that._bordersGroup);
                return drawnElement
            },
            _applyStyle: function(style) {
                var that = this;
                var elementsGroup = that._elementsGroup;
                var bordersGroup = that._bordersGroup;
                elementsGroup && elementsGroup.smartAttr(style.elements);
                bordersGroup && bordersGroup.attr(style.border);
                (that._graphics || []).forEach(function(graphic) {
                    graphic.line && graphic.line.attr({
                        "stroke-width": style.border["stroke-width"]
                    });
                    graphic.bottomLine && graphic.bottomLine.attr({
                        "stroke-width": style.border["stroke-width"]
                    })
                })
            },
            _updateElement: function(element, segment, animate, complete) {
                var bottomLineParams = {
                    points: segment.bottomLine
                };
                var bottomBorderElement = element.bottomLine;
                areaSeries._updateElement.apply(this, arguments);
                if (bottomBorderElement) {
                    animate ? bottomBorderElement.animate(bottomLineParams) : bottomBorderElement.attr(bottomLineParams)
                }
            }
        }, baseRangeSeries)
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/series/bubble_series.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var lineSeries = __webpack_require__( /*! ./line_series */ 210).chart.line;
        var scatterSeries = __webpack_require__( /*! ./scatter_series */ 110).chart;
        var areaSeries = __webpack_require__( /*! ./area_series */ 174).chart.area;
        var barSeries = __webpack_require__( /*! ./bar_series */ 151);
        var chartBarSeries = barSeries.chart.bar;
        var polarBarSeries = barSeries.polar.bar;
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var _extend = extend;
        var _each = each;
        var _noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        exports.chart = {};
        exports.chart.bubble = _extend({}, scatterSeries, {
            _calculateErrorBars: _noop,
            _getMainColor: chartBarSeries._getMainColor,
            _createPointStyles: chartBarSeries._createPointStyles,
            _updatePointsVisibility: chartBarSeries._updatePointsVisibility,
            _getOptionsForPoint: chartBarSeries._getOptionsForPoint,
            _applyMarkerClipRect: lineSeries._applyElementsClipRect,
            _parsePointStyle: polarBarSeries._parsePointStyle,
            _createLegendState: areaSeries._createLegendState,
            _setMarkerGroupSettings: polarBarSeries._setMarkerGroupSettings,
            areErrorBarsVisible: _noop,
            _createErrorBarGroup: _noop,
            _checkData: function(data, skippedFields) {
                return scatterSeries._checkData.call(this, data, skippedFields, {
                    value: this.getValueFields()[0],
                    size: this.getSizeField()
                })
            },
            _getPointDataSelector: function(data, options) {
                var sizeField = this.getSizeField();
                var baseGetter = scatterSeries._getPointDataSelector.call(this);
                return function(data) {
                    var pointData = baseGetter(data);
                    pointData.size = data[sizeField];
                    return pointData
                }
            },
            _aggregators: {
                avg: function(_ref, series) {
                    var _ref2;
                    var data = _ref.data,
                        intervalStart = _ref.intervalStart;
                    if (!data.length) {
                        return
                    }
                    var valueField = series.getValueFields()[0];
                    var sizeField = series.getSizeField();
                    var aggregate = data.reduce(function(result, item) {
                        result[0] += item[valueField];
                        result[1] += item[sizeField];
                        result[2]++;
                        return result
                    }, [0, 0, 0]);
                    return _ref2 = {}, _defineProperty(_ref2, valueField, aggregate[0] / aggregate[2]), _defineProperty(_ref2, sizeField, aggregate[1] / aggregate[2]), _defineProperty(_ref2, series.getArgumentField(), intervalStart), _ref2
                }
            },
            getValueFields: function() {
                return [this._options.valueField || "val"]
            },
            getSizeField: function() {
                return this._options.sizeField || "size"
            },
            _animate: function() {
                var that = this;
                var lastPointIndex = that._drawnPoints.length - 1;
                var labelsGroup = that._labelsGroup;
                var labelAnimFunc = function() {
                    labelsGroup && labelsGroup.animate({
                        opacity: 1
                    }, {
                        duration: that._defaultDuration
                    })
                };
                _each(that._drawnPoints || [], function(i, p) {
                    p.animate(i === lastPointIndex ? labelAnimFunc : void 0, {
                        r: p.bubbleSize,
                        translateX: p.x,
                        translateY: p.y
                    })
                })
            },
            _patchMarginOptions: function(options) {
                options.processBubbleSize = true;
                return options
            }
        })
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/series/pie_series.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var scatterSeries = __webpack_require__( /*! ./scatter_series */ 110);
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var chartScatterSeries = scatterSeries.chart;
        var barSeries = __webpack_require__( /*! ./bar_series */ 151).chart.bar;
        var _extend = extend;
        var _each = each;
        var _noop = noop;
        var _map = vizUtils.map;
        var _isFinite = isFinite;
        var _max = Math.max;
        var ANIMATION_DURATION = .7;
        var INSIDE = "inside";
        exports.pie = _extend({}, barSeries, {
            _setGroupsSettings: function() {
                chartScatterSeries._setGroupsSettings.apply(this, arguments);
                this._labelsGroup.attr({
                    "pointer-events": null
                })
            },
            _createErrorBarGroup: _noop,
            _drawPoint: function(options) {
                var point = options.point;
                var legendCallback = this._legendCallback;
                chartScatterSeries._drawPoint.call(this, options);
                !point.isVisible() && point.setInvisibility();
                point.isSelected() && legendCallback()
            },
            _getOldPoint: function(data, oldPointsByArgument, index) {
                var point = (this._points || [])[index];
                if (point) {
                    oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function(p) {
                        return p !== point
                    })
                }
                return point
            },
            adjustLabels: function(moveLabelsFromCenter) {
                return (this._points || []).reduce(function(r, p) {
                    if (p._label.isVisible()) {
                        p.setLabelTrackerData();
                        r = p.applyWordWrap(moveLabelsFromCenter) || r;
                        p.updateLabelCoord(moveLabelsFromCenter);
                        return r
                    }
                }, false)
            },
            _applyElementsClipRect: _noop,
            getColor: _noop,
            areErrorBarsVisible: _noop,
            drawLabelsWOPoints: function() {
                var that = this;
                if (that._options.label.position === INSIDE) {
                    return false
                }
                that._labelsGroup.append(that._extGroups.labelsGroup);
                (that._points || []).forEach(function(point) {
                    point.drawLabel()
                });
                return true
            },
            getPointsCount: function() {
                var _this = this;
                return this._data.filter(function(d) {
                    return _this._checkData(d)
                }).length
            },
            setMaxPointsCount: function(count) {
                this._pointsCount = count
            },
            _getCreatingPointOptions: function(data, dataIndex) {
                return this._getPointOptions(data, dataIndex)
            },
            _updateOptions: function(options) {
                this.labelSpace = 0;
                this.innerRadius = "pie" === this.type ? 0 : options.innerRadius
            },
            _checkData: function(data, skippedFields) {
                var base = barSeries._checkData.call(this, data, skippedFields, {
                    value: this.getValueFields()[0]
                });
                return this._options.paintNullPoints ? base : base && null !== data.value
            },
            _createGroups: chartScatterSeries._createGroups,
            _setMarkerGroupSettings: function() {
                this._markersGroup.attr({
                    "class": "dxc-markers"
                })
            },
            _getMainColor: function(data, point) {
                var pointsByArg = this.getPointsByArg(data.argument);
                var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;
                return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount)
            },
            _getPointOptions: function(data) {
                return this._parsePointOptions(this._preparePointOptions(), this._options.label, data)
            },
            _getRangeData: function() {
                return this._rangeData
            },
            _createPointStyles: function(pointOptions, data, point) {
                var that = this;
                var mainColor = pointOptions.color || that._getMainColor(data, point);
                return {
                    normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
                    hover: that._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),
                    selection: that._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),
                    legendStyles: {
                        normal: that._createLegendState(pointOptions, mainColor),
                        hover: that._createLegendState(pointOptions.hoverStyle, mainColor),
                        selection: that._createLegendState(pointOptions.selectionStyle, mainColor)
                    }
                }
            },
            _getArrangeMinShownValue: function(points, total) {
                var minSegmentSize = this._options.minSegmentSize;
                var totalMinSegmentSize = 0;
                var totalNotMinValues = 0;
                total = total || points.length;
                _each(points, function(_, point) {
                    if (point.isVisible()) {
                        if (point.normalInitialValue < minSegmentSize * total / 360) {
                            totalMinSegmentSize += minSegmentSize
                        } else {
                            totalNotMinValues += point.normalInitialValue
                        }
                    }
                });
                return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0
            },
            _applyArrangeCorrection: function(points, minShownValue, total) {
                var options = this._options;
                var isClockWise = "anticlockwise" !== options.segmentsDirection;
                var shiftedAngle = _isFinite(options.startAngle) ? vizUtils.normalizeAngle(options.startAngle) : 0;
                var minSegmentSize = options.minSegmentSize;
                var percent;
                var correction = 0;
                var zeroTotalCorrection = 0;
                if (0 === total) {
                    total = points.filter(function(el) {
                        return el.isVisible()
                    }).length;
                    zeroTotalCorrection = 1
                }
                _each(isClockWise ? points : points.concat([]).reverse(), function(_, point) {
                    var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;
                    var updatedZeroValue;
                    if (minSegmentSize && point.isVisible() && val < minShownValue) {
                        updatedZeroValue = minShownValue
                    }
                    percent = val / total;
                    point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));
                    point.shiftedAngle = shiftedAngle;
                    correction += updatedZeroValue || val
                });
                this._rangeData = {
                    val: {
                        min: 0,
                        max: correction
                    }
                }
            },
            _removePoint: function(point) {
                var points = this.getPointsByArg(point.argument);
                points.splice(points.indexOf(point), 1);
                point.dispose()
            },
            arrangePoints: function() {
                var that = this;
                var originalPoints = that._points || [];
                var minSegmentSize = that._options.minSegmentSize;
                var minShownValue;
                var isAllPointsNegative = true;
                var i = 0;
                var len = originalPoints.length;
                while (i < len && isAllPointsNegative) {
                    isAllPointsNegative = originalPoints[i].value <= 0;
                    i++
                }
                var points = that._points = _map(originalPoints, function(point) {
                    if (null === point.value || !isAllPointsNegative && point.value < 0) {
                        that._removePoint(point);
                        return null
                    } else {
                        return point
                    }
                });
                var maxValue = points.reduce(function(max, p) {
                    return _max(max, Math.abs(p.initialValue))
                }, 0);
                points.forEach(function(p) {
                    p.normalInitialValue = p.initialValue / (0 !== maxValue ? maxValue : 1)
                });
                var total = points.reduce(function(total, point) {
                    return total + (point.isVisible() ? point.normalInitialValue : 0)
                }, 0);
                if (minSegmentSize) {
                    minShownValue = this._getArrangeMinShownValue(points, total)
                }
                that._applyArrangeCorrection(points, minShownValue, total)
            },
            correctPosition: function(correction, canvas) {
                var debug = __webpack_require__( /*! ../../core/utils/console */ 65).debug;
                debug.assert(correction, "correction was not passed");
                debug.assertParam(correction.centerX, "correction.centerX was not passed");
                debug.assertParam(correction.centerY, "correction.centerY was not passed");
                debug.assertParam(correction.radiusInner, "correction.radiusInner was not passed");
                debug.assertParam(correction.radiusOuter, "correction.radiusOuter was not passed");
                debug.assertParam(canvas, "correction.canvas was not passed");
                _each(this._points, function(_, point) {
                    point.correctPosition(correction)
                });
                this.setVisibleArea(canvas)
            },
            correctRadius: function(correction) {
                this._points.forEach(function(point) {
                    point.correctRadius(correction)
                })
            },
            correctLabelRadius: function(labelRadius) {
                this._points.forEach(function(point) {
                    point.correctLabelRadius(labelRadius)
                })
            },
            setVisibleArea: function(canvas) {
                this._visibleArea = {
                    minX: canvas.left,
                    maxX: canvas.width - canvas.right,
                    minY: canvas.top,
                    maxY: canvas.height - canvas.bottom
                }
            },
            _applyVisibleArea: _noop,
            _animate: function(firstDrawing) {
                var that = this;
                var points = that._points;
                var pointsCount = points && points.length;
                var completeFunc = function() {
                    that._animateComplete()
                };
                var animatePoint;
                if (firstDrawing) {
                    animatePoint = function(p, i) {
                        p.animate(i === pointsCount - 1 ? completeFunc : void 0, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1))
                    }
                } else {
                    animatePoint = function(p, i) {
                        p.animate(i === pointsCount - 1 ? completeFunc : void 0)
                    }
                }
                points.forEach(animatePoint)
            },
            getVisiblePoints: function() {
                return _map(this._points, function(p) {
                    return p.isVisible() ? p : null
                })
            },
            getPointsByKeys: function(arg, argumentIndex) {
                var pointsByArg = this.getPointsByArg(arg);
                return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || []
            }
        });
        exports.doughnut = exports.donut = exports.pie
    },
    /*!*************************************************************!*\
      !*** ./artifacts/transpiled/viz/series/financial_series.js ***!
      \*************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var scatterSeries = __webpack_require__( /*! ./scatter_series */ 110).chart;
        var barSeries = __webpack_require__( /*! ./bar_series */ 151).chart.bar;
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var _isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var _noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var DEFAULT_FINANCIAL_POINT_SIZE = 10;
        exports.stock = _extend({}, scatterSeries, {
            _animate: _noop,
            _applyMarkerClipRect: function(settings) {
                settings["clip-path"] = this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID
            },
            _updatePointsVisibility: barSeries._updatePointsVisibility,
            _getOptionsForPoint: barSeries._getOptionsForPoint,
            _createErrorBarGroup: _noop,
            areErrorBarsVisible: _noop,
            _createGroups: scatterSeries._createGroups,
            _setMarkerGroupSettings: function() {
                var that = this;
                var markersGroup = that._markersGroup;
                var styles = that._createPointStyles(that._getMarkerGroupOptions());
                var defaultStyle = _extend(styles.normal, {
                    "class": "default-markers"
                });
                var defaultPositiveStyle = _extend(styles.positive.normal, {
                    "class": "default-positive-markers"
                });
                var reductionStyle = _extend(styles.reduction.normal, {
                    "class": "reduction-markers"
                });
                var reductionPositiveStyle = _extend(styles.reductionPositive.normal, {
                    "class": "reduction-positive-markers"
                });
                var markerSettings = {
                    "class": "dxc-markers"
                };
                that._applyMarkerClipRect(markerSettings);
                markersGroup.attr(markerSettings);
                that._createGroup("defaultMarkersGroup", markersGroup, markersGroup, defaultStyle);
                that._createGroup("reductionMarkersGroup", markersGroup, markersGroup, reductionStyle);
                that._createGroup("defaultPositiveMarkersGroup", markersGroup, markersGroup, defaultPositiveStyle);
                that._createGroup("reductionPositiveMarkersGroup", markersGroup, markersGroup, reductionPositiveStyle)
            },
            _setGroupsSettings: function() {
                scatterSeries._setGroupsSettings.call(this, false)
            },
            _getCreatingPointOptions: function() {
                var that = this;
                var defaultPointOptions;
                var creatingPointOptions = that._predefinedPointOptions;
                if (!creatingPointOptions) {
                    defaultPointOptions = this._getPointOptions();
                    that._predefinedPointOptions = creatingPointOptions = _extend(true, {
                        styles: {}
                    }, defaultPointOptions);
                    creatingPointOptions.styles.normal = creatingPointOptions.styles.positive.normal = creatingPointOptions.styles.reduction.normal = creatingPointOptions.styles.reductionPositive.normal = {
                        "stroke-width": defaultPointOptions.styles && defaultPointOptions.styles.normal && defaultPointOptions.styles.normal["stroke-width"]
                    }
                }
                return creatingPointOptions
            },
            _checkData: function(data, skippedFields) {
                var valueFields = this.getValueFields();
                return scatterSeries._checkData.call(this, data, skippedFields, {
                    openValue: valueFields[0],
                    highValue: valueFields[1],
                    lowValue: valueFields[2],
                    closeValue: valueFields[3]
                }) && data.highValue === data.highValue && data.lowValue === data.lowValue
            },
            _getPointDataSelector: function(data, options) {
                var _this = this;
                var that = this;
                var level;
                var valueFields = that.getValueFields();
                var argumentField = that.getArgumentField();
                var openValueField = valueFields[0];
                var highValueField = valueFields[1];
                var lowValueField = valueFields[2];
                var closeValueField = valueFields[3];
                that.level = that._options.reduction.level;
                switch (_normalizeEnum(that.level)) {
                    case "open":
                        level = openValueField;
                        break;
                    case "high":
                        level = highValueField;
                        break;
                    case "low":
                        level = lowValueField;
                        break;
                    default:
                        level = closeValueField;
                        that.level = "close"
                }
                var prevLevelValue;
                return function(data) {
                    var reductionValue = data[level];
                    var isReduction = false;
                    if (_isDefined(reductionValue)) {
                        if (_isDefined(prevLevelValue)) {
                            isReduction = reductionValue < prevLevelValue
                        }
                        prevLevelValue = reductionValue
                    }
                    return {
                        argument: data[argumentField],
                        highValue: _this._processEmptyValue(data[highValueField]),
                        lowValue: _this._processEmptyValue(data[lowValueField]),
                        closeValue: _this._processEmptyValue(data[closeValueField]),
                        openValue: _this._processEmptyValue(data[openValueField]),
                        reductionValue: reductionValue,
                        tag: data[that.getTagField()],
                        isReduction: isReduction,
                        data: data
                    }
                }
            },
            _parsePointStyle: function(style, defaultColor, innerColor) {
                return {
                    stroke: style.color || defaultColor,
                    "stroke-width": style.width,
                    fill: style.color || innerColor
                }
            },
            _getDefaultStyle: function(options) {
                var that = this;
                var mainPointColor = options.color || that._options.mainSeriesColor;
                return {
                    normal: that._parsePointStyle(options, mainPointColor, mainPointColor),
                    hover: that._parsePointStyle(options.hoverStyle, mainPointColor, mainPointColor),
                    selection: that._parsePointStyle(options.selectionStyle, mainPointColor, mainPointColor)
                }
            },
            _getReductionStyle: function(options) {
                var that = this;
                var reductionColor = options.reduction.color;
                return {
                    normal: that._parsePointStyle({
                        color: reductionColor,
                        width: options.width,
                        hatching: options.hatching
                    }, reductionColor, reductionColor),
                    hover: that._parsePointStyle(options.hoverStyle, reductionColor, reductionColor),
                    selection: that._parsePointStyle(options.selectionStyle, reductionColor, reductionColor)
                }
            },
            _createPointStyles: function(pointOptions) {
                var that = this;
                var innerColor = that._options.innerColor;
                var styles = that._getDefaultStyle(pointOptions);
                var positiveStyle = _extend(true, {}, styles);
                var reductionStyle = that._getReductionStyle(pointOptions);
                var reductionPositiveStyle = _extend(true, {}, reductionStyle);
                positiveStyle.normal.fill = positiveStyle.hover.fill = positiveStyle.selection.fill = innerColor;
                reductionPositiveStyle.normal.fill = reductionPositiveStyle.hover.fill = reductionPositiveStyle.selection.fill = innerColor;
                styles.positive = positiveStyle;
                styles.reduction = reductionStyle;
                styles.reductionPositive = reductionPositiveStyle;
                return styles
            },
            _endUpdateData: function() {
                delete this._predefinedPointOptions
            },
            _defaultAggregator: "ohlc",
            _aggregators: {
                ohlc: function(_ref, series) {
                    var intervalStart = _ref.intervalStart,
                        data = _ref.data;
                    if (!data.length) {
                        return
                    }
                    var result = {};
                    var valueFields = series.getValueFields();
                    var highValueField = valueFields[1];
                    var lowValueField = valueFields[2];
                    result[highValueField] = -(1 / 0);
                    result[lowValueField] = 1 / 0;
                    result = data.reduce(function(result, item) {
                        if (null !== item[highValueField]) {
                            result[highValueField] = Math.max(result[highValueField], item[highValueField])
                        }
                        if (null !== item[lowValueField]) {
                            result[lowValueField] = Math.min(result[lowValueField], item[lowValueField])
                        }
                        return result
                    }, result);
                    result[valueFields[0]] = data[0][valueFields[0]];
                    result[valueFields[3]] = data[data.length - 1][valueFields[3]];
                    if (!isFinite(result[highValueField])) {
                        result[highValueField] = null
                    }
                    if (!isFinite(result[lowValueField])) {
                        result[lowValueField] = null
                    }
                    result[series.getArgumentField()] = intervalStart;
                    return result
                }
            },
            getValueFields: function() {
                var options = this._options;
                return [options.openValueField || "open", options.highValueField || "high", options.lowValueField || "low", options.closeValueField || "close"]
            },
            getArgumentField: function() {
                return this._options.argumentField || "date"
            },
            _patchMarginOptions: function(options) {
                var pointOptions = this._getCreatingPointOptions();
                var styles = pointOptions.styles;
                var border = [styles.normal, styles.hover, styles.selection].reduce(function(max, style) {
                    return Math.max(max, style["stroke-width"])
                }, 0);
                options.size = DEFAULT_FINANCIAL_POINT_SIZE + border;
                options.sizePointNormalState = DEFAULT_FINANCIAL_POINT_SIZE;
                return options
            },
            getSeriesPairCoord: function(coord, isArgument) {
                var oppositeCoord = null;
                var points = this.getVisiblePoints();
                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    var tmpCoord = void 0;
                    if (isArgument) {
                        tmpCoord = p.vx === coord ? (p.openY + p.closeY) / 2 : void 0
                    } else {
                        var coords = [Math.min(p.lowY, p.highY), Math.max(p.lowY, p.highY)];
                        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p.vx : void 0
                    }
                    if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
                        oppositeCoord = tmpCoord;
                        break
                    }
                }
                return oppositeCoord
            },
            usePointsToDefineAutoHiding: function() {
                return false
            }
        });
        exports.candlestick = _extend({}, exports.stock, {
            _parsePointStyle: function(style, defaultColor, innerColor) {
                var color = style.color || innerColor;
                var base = exports.stock._parsePointStyle.call(this, style, defaultColor, color);
                base.fill = color;
                base.hatching = style.hatching;
                return base
            }
        })
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/series/stacked_series.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var areaSeries = __webpack_require__( /*! ./area_series */ 174).chart;
        var chartAreaSeries = areaSeries.area;
        var barSeries = __webpack_require__( /*! ./bar_series */ 151);
        var chartBarSeries = barSeries.chart.bar;
        var lineSeries = __webpack_require__( /*! ./line_series */ 210).chart;
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var objectUtils = __webpack_require__( /*! ../../core/utils/object */ 47);
        var baseStackedSeries = {
            _calculateErrorBars: _noop,
            _updateOptions: function(options) {
                this._stackName = "axis_" + (options.axis || "default")
            }
        };
        exports.chart = {};
        exports.polar = {};
        exports.chart.stackedline = _extend({}, lineSeries.line, baseStackedSeries, {});
        exports.chart.stackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {});
        exports.chart.fullstackedline = _extend({}, lineSeries.line, baseStackedSeries, {
            getValueRangeInitialValue: areaSeries.area.getValueRangeInitialValue
        });
        exports.chart.fullstackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {
            getValueRangeInitialValue: areaSeries.area.getValueRangeInitialValue
        });
        var stackedBar = exports.chart.stackedbar = _extend({}, chartBarSeries, baseStackedSeries, {
            _updateOptions: function(options) {
                baseStackedSeries._updateOptions.call(this, options);
                this._stackName = this._stackName + "_stack_" + (options.stack || "default")
            }
        });
        exports.chart.fullstackedbar = _extend({}, chartBarSeries, baseStackedSeries, {
            _updateOptions: stackedBar._updateOptions
        });

        function clonePoint(point, value, minValue, position) {
            point = objectUtils.clone(point);
            point.value = value;
            point.minValue = minValue;
            point.translate();
            point.argument = point.argument + position;
            return point
        }

        function preparePointsForStackedAreaSegment(points) {
            var i = 0;
            var p;
            var result = [];
            var array;
            var len = points.length;
            while (i < len) {
                p = points[i];
                array = [p];
                if (p.leftHole) {
                    array = [clonePoint(p, p.leftHole, p.minLeftHole, "left"), p]
                }
                if (p.rightHole) {
                    array.push(clonePoint(p, p.rightHole, p.minRightHole, "right"))
                }
                result.push(array);
                i++
            }
            return [].concat.apply([], result)
        }
        exports.chart.stackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {
            _prepareSegment: function(points, rotated) {
                return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points), rotated)
            },
            _appendInGroup: function() {
                this._group.append(this._extGroups.seriesGroup).toBackground()
            }
        });

        function getPointsByArgFromPrevSeries(prevSeries, argument) {
            var result;
            while (!result && prevSeries) {
                result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument];
                prevSeries = prevSeries._prevSeries
            }
            return result
        }
        exports.chart.stackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {
            _prepareSegment: function(points, rotated) {
                var that = this;
                var areaSegment;
                points = preparePointsForStackedAreaSegment(points);
                if (!this._prevSeries || 1 === points.length) {
                    areaSegment = areaSeries.splinearea._prepareSegment.call(this, points, rotated)
                } else {
                    var forwardPoints = lineSeries.spline._calculateBezierPoints(points, rotated);
                    var backwardPoints = vizUtils.map(points, function(p) {
                        var point = p.getCoords(true);
                        point.argument = p.argument;
                        return point
                    });
                    var prevSeriesForwardPoints = [];
                    var pointByArg = {};
                    var i = 0;
                    var len = that._prevSeries._segments.length;
                    while (i < len) {
                        prevSeriesForwardPoints = prevSeriesForwardPoints.concat(that._prevSeries._segments[i].line);
                        i++
                    }
                    each(prevSeriesForwardPoints, function(_, p) {
                        if (null !== p.argument) {
                            var argument = p.argument.valueOf();
                            if (!pointByArg[argument]) {
                                pointByArg[argument] = [p]
                            } else {
                                pointByArg[argument].push(p)
                            }
                        }
                    });
                    that._prevSeries._segmentByArg = pointByArg;
                    backwardPoints = lineSeries.spline._calculateBezierPoints(backwardPoints, rotated);
                    each(backwardPoints, function(i, p) {
                        var argument = p.argument.valueOf();
                        var prevSeriesPoints;
                        if (i % 3 === 0) {
                            prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);
                            if (prevSeriesPoints) {
                                backwardPoints[i - 1] && prevSeriesPoints[0] && (backwardPoints[i - 1] = prevSeriesPoints[0]);
                                backwardPoints[i + 1] && (backwardPoints[i + 1] = prevSeriesPoints[2] || p)
                            }
                        }
                    });
                    areaSegment = {
                        line: forwardPoints,
                        area: forwardPoints.concat(backwardPoints.reverse())
                    };
                    that._areaPointsToSplineAreaPoints(areaSegment.area)
                }
                return areaSegment
            },
            _appendInGroup: exports.chart.stackedarea._appendInGroup
        });
        exports.chart.fullstackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {
            _prepareSegment: exports.chart.stackedarea._prepareSegment,
            _appendInGroup: exports.chart.stackedarea._appendInGroup
        });
        exports.chart.fullstackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {
            _prepareSegment: exports.chart.stackedsplinearea._prepareSegment,
            _appendInGroup: exports.chart.stackedarea._appendInGroup
        });
        exports.polar.stackedbar = _extend({}, barSeries.polar.bar, baseStackedSeries, {})
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/tracker.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _click = __webpack_require__( /*! ../../events/click */ 19);
        var _click2 = _interopRequireDefault(_click);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _consts = __webpack_require__( /*! ../components/consts */ 125);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _pointer = __webpack_require__( /*! ../../events/pointer */ 23);
        var _pointer2 = _interopRequireDefault(_pointer);
        var _utils2 = __webpack_require__( /*! ../../events/utils */ 8);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _floor = Math.floor;
        var HOVER_STATE = _consts.states.hoverMark;
        var NORMAL_STATE = _consts.states.normalMark;
        var EVENT_NS = "dxChartTracker";
        var DOT_EVENT_NS = "." + EVENT_NS;
        var POINTER_ACTION = (0, _utils2.addNamespace)([_pointer2.default.down, _pointer2.default.move], EVENT_NS);
        var LEGEND_CLICK = "legendClick";
        var SERIES_CLICK = "seriesClick";
        var POINT_CLICK = "pointClick";
        var POINT_DATA = "chart-data-point";
        var SERIES_DATA = "chart-data-series";
        var ARG_DATA = "chart-data-argument";
        var DELAY = 100;
        var HOLD_TIMEOUT = 300;
        var NONE_MODE = "none";
        var ALL_ARGUMENT_POINTS_MODE = "allargumentpoints";
        var INCLUDE_POINTS_MODE = "includepoints";
        var EXLUDE_POINTS_MODE = "excludepoints";
        var LEGEND_HOVER_MODES = [INCLUDE_POINTS_MODE, EXLUDE_POINTS_MODE, NONE_MODE];

        function getData(event, dataKey) {
            var target = event.target;
            return ("tspan" === target.tagName ? target.parentNode : target)[dataKey]
        }

        function eventCanceled(event, target) {
            return event.cancel || !target.getOptions()
        }

        function correctLegendHoverMode(mode) {
            if (LEGEND_HOVER_MODES.indexOf(mode) > -1) {
                return mode
            } else {
                return INCLUDE_POINTS_MODE
            }
        }

        function correctHoverMode(target) {
            var mode = target.getOptions().hoverMode;
            return mode === NONE_MODE ? mode : ALL_ARGUMENT_POINTS_MODE
        }
        var baseTrackerPrototype = {
            ctor: function(options) {
                var that = this;
                var data = {
                    tracker: that
                };
                that._renderer = options.renderer;
                that._legend = options.legend;
                that._tooltip = options.tooltip;
                that._eventTrigger = options.eventTrigger;
                that._seriesGroup = options.seriesGroup;
                options.seriesGroup.off(DOT_EVENT_NS).on((0, _utils2.addNamespace)(_consts.events.showPointTooltip, EVENT_NS), data, that._showPointTooltip).on((0, _utils2.addNamespace)(_consts.events.hidePointTooltip, EVENT_NS), data, that._hidePointTooltip);
                that._renderer.root.off(DOT_EVENT_NS).on(POINTER_ACTION, data, that._pointerHandler).on((0, _utils2.addNamespace)(_pointer2.default.up, EVENT_NS), function() {
                    return clearTimeout(that._holdTimer)
                }).on((0, _utils2.addNamespace)(_click2.default.name, EVENT_NS), data, that._clickHandler)
            },
            update: function(options) {
                this._chart = options.chart
            },
            updateSeries: function(series, resetDecorations) {
                var that = this;
                var noHoveredSeries = !((null === series || void 0 === series ? void 0 : series.some(function(s) {
                    return s === that.hoveredSeries
                })) || that._hoveredPoint && that._hoveredPoint.series);
                if (that._storedSeries !== series) {
                    that._storedSeries = series || []
                }
                if (noHoveredSeries) {
                    that._clean();
                    that._renderer.initHatching()
                }
                if (resetDecorations) {
                    that.clearSelection();
                    if (!noHoveredSeries) {
                        that._hideTooltip(that.pointAtShownTooltip);
                        that.clearHover()
                    }
                }
            },
            setCanvases: function(mainCanvas, paneCanvases) {
                this._mainCanvas = mainCanvas;
                this._canvases = paneCanvases
            },
            repairTooltip: function() {
                var point = this.pointAtShownTooltip;
                if (!point || !point.series || !point.isVisible()) {
                    this._hideTooltip(point, true)
                } else {
                    this._showTooltip(point)
                }
            },
            _setHoveredPoint: function(point) {
                if (point === this._hoveredPoint) {
                    return
                }
                this._releaseHoveredPoint();
                point.hover();
                this._hoveredPoint = point
            },
            _releaseHoveredPoint: function() {
                if (this._hoveredPoint && this._hoveredPoint.getOptions()) {
                    this._hoveredPoint.clearHover();
                    this._hoveredPoint = null;
                    if (this._tooltip.isEnabled()) {
                        this._hideTooltip(this._hoveredPoint)
                    }
                }
            },
            _setHoveredSeries: function(series, mode) {
                this._releaseHoveredSeries();
                this._releaseHoveredPoint();
                series.hover(mode);
                this.hoveredSeries = series
            },
            _releaseHoveredSeries: function() {
                if (this.hoveredSeries) {
                    this.hoveredSeries.clearHover();
                    this.hoveredSeries = null
                }
            },
            clearSelection: function() {
                this._storedSeries.forEach(function(series) {
                    if (series) {
                        series.clearSelection();
                        series.getPoints().forEach(function(point) {
                            return point.clearSelection()
                        })
                    }
                })
            },
            _clean: function() {
                var that = this;
                that.hoveredPoint = that.hoveredSeries = that._hoveredArgumentPoints = null;
                that._hideTooltip(that.pointAtShownTooltip)
            },
            clearHover: function() {
                this._resetHoveredArgument();
                this._releaseHoveredSeries();
                this._releaseHoveredPoint()
            },
            _hideTooltip: function(point, silent) {
                var that = this;
                if (!that._tooltip || point && that.pointAtShownTooltip !== point) {
                    return
                }
                if (!silent && that.pointAtShownTooltip) {
                    that.pointAtShownTooltip = null
                }
                that._tooltip.hide()
            },
            _showTooltip: function(point) {
                var that = this;
                var tooltipFormatObject;
                var eventData;
                if (null === point || void 0 === point ? void 0 : point.getOptions()) {
                    tooltipFormatObject = point.getTooltipFormatObject(that._tooltip, that._tooltip.isShared() && that._chart.getStackedPoints(point));
                    if (!(0, _type.isDefined)(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible()) {
                        return
                    }
                    if (!that.pointAtShownTooltip || that.pointAtShownTooltip !== point) {
                        eventData = {
                            target: point
                        }
                    }
                    var coords = point.getTooltipParams(that._tooltip.getLocation());
                    var rootOffset = that._renderer.getRootOffset();
                    coords.x += rootOffset.left;
                    coords.y += rootOffset.top;
                    if (!that._tooltip.show(tooltipFormatObject, coords, eventData)) {
                        return
                    }
                    that.pointAtShownTooltip = point
                }
            },
            _showPointTooltip: function(event, point) {
                var that = event.data.tracker;
                var pointWithTooltip = that.pointAtShownTooltip;
                if (pointWithTooltip && pointWithTooltip !== point) {
                    that._hideTooltip(pointWithTooltip)
                }
                that._showTooltip(point)
            },
            _hidePointTooltip: function(event, point) {
                event.data.tracker._hideTooltip(point)
            },
            _enableOutHandler: function() {
                if (this._outHandler) {
                    return
                }
                var that = this;
                var handler = function(e) {
                    var rootOffset = that._renderer.getRootOffset();
                    var x = _floor(e.pageX - rootOffset.left);
                    var y = _floor(e.pageY - rootOffset.top);
                    if (!(0, _utils.pointInCanvas)(that._mainCanvas, x, y)) {
                        that._pointerOut();
                        that._disableOutHandler()
                    }
                };
                _events_engine2.default.on(_dom_adapter2.default.getDocument(), POINTER_ACTION, handler);
                this._outHandler = handler
            },
            _disableOutHandler: function() {
                this._outHandler && _events_engine2.default.off(_dom_adapter2.default.getDocument(), POINTER_ACTION, this._outHandler);
                this._outHandler = null
            },
            stopCurrentHandling: function() {
                this._pointerOut(true)
            },
            _pointerOut: function(force) {
                this.clearHover();
                (force || this._tooltip.isEnabled()) && this._hideTooltip(this.pointAtShownTooltip)
            },
            _triggerLegendClick: function(eventArgs, elementClick) {
                var eventTrigger = this._eventTrigger;
                eventTrigger(LEGEND_CLICK, eventArgs, function() {
                    !eventCanceled(eventArgs.event, eventArgs.target) && eventTrigger(elementClick, eventArgs)
                })
            },
            _hoverLegendItem: function(x, y) {
                var that = this;
                var item = that._legend.getItemByCoord(x, y);
                var series;
                var legendHoverMode = correctLegendHoverMode(that._legend.getOptions().hoverMode);
                if (item) {
                    series = that._storedSeries[item.id];
                    if (!series.isHovered() || series.lastHoverMode !== legendHoverMode) {
                        that._setHoveredSeries(series, legendHoverMode)
                    }
                    that._tooltip.isEnabled() && that._hideTooltip(that.pointAtShownTooltip)
                } else {
                    that.clearHover()
                }
            },
            _hoverArgument: function(argument, argumentIndex) {
                var that = this;
                var hoverMode = that._getArgumentHoverMode();
                if ((0, _type.isDefined)(argument)) {
                    that._releaseHoveredPoint();
                    that._hoveredArgument = argument;
                    that._argumentIndex = argumentIndex;
                    that._notifySeries({
                        action: "pointHover",
                        notifyLegend: that._notifyLegendOnHoverArgument,
                        target: {
                            argument: argument,
                            fullState: HOVER_STATE,
                            argumentIndex: argumentIndex,
                            getOptions: function() {
                                return {
                                    hoverMode: hoverMode
                                }
                            }
                        }
                    })
                }
            },
            _resetHoveredArgument: function() {
                var that = this;
                var hoverMode;
                if ((0, _type.isDefined)(that._hoveredArgument)) {
                    hoverMode = that._getArgumentHoverMode();
                    that._notifySeries({
                        action: "clearPointHover",
                        notifyLegend: that._notifyLegendOnHoverArgument,
                        target: {
                            fullState: NORMAL_STATE,
                            argumentIndex: that._argumentIndex,
                            argument: that._hoveredArgument,
                            getOptions: function() {
                                return {
                                    hoverMode: hoverMode
                                }
                            }
                        }
                    });
                    that._hoveredArgument = null
                }
            },
            _notifySeries: function(data) {
                this._storedSeries.forEach(function(series) {
                    series.notify(data)
                })
            },
            _pointerHandler: function(e) {
                var _series;
                var that = e.data.tracker;
                var rootOffset = that._renderer.getRootOffset();
                var x = _floor(e.pageX - rootOffset.left);
                var y = _floor(e.pageY - rootOffset.top);
                var canvas = that._getCanvas(x, y);
                var series = getData(e, SERIES_DATA);
                var point = getData(e, POINT_DATA) || (null === (_series = series) || void 0 === _series ? void 0 : _series.getPointByCoord(x, y));
                that._isHolding = false;
                clearTimeout(that._holdTimer);
                if (e.type === _pointer2.default.down) {
                    that._holdTimer = setTimeout(function() {
                        return that._isHolding = true
                    }, HOLD_TIMEOUT)
                }
                if (point && !point.getMarkerVisibility()) {
                    point = void 0
                }
                that._enableOutHandler();
                if (that._legend.coordsIn(x, y)) {
                    that._hoverLegendItem(x, y);
                    return
                }
                if (that.hoveredSeries && that.hoveredSeries !== that._stuckSeries) {
                    that._releaseHoveredSeries()
                }
                if (that._hoverArgumentAxis(x, y, e)) {
                    return
                }
                if (that._isPointerOut(canvas, point)) {
                    that._pointerOut()
                }
                if (!canvas && !point) {
                    return
                }
                if (series && !point) {
                    point = series.getNeighborPoint(x, y);
                    if (!that._stickyHovering && point && !point.coordsIn(x, y)) {
                        point = null
                    }
                    if (series !== that.hoveredSeries) {
                        that._setTimeout(function() {
                            that._setHoveredSeries(series);
                            that._setStuckSeries(e, series, x, y);
                            that._pointerComplete(point, x, y)
                        }, series);
                        return
                    }
                } else {
                    if (point) {
                        if (e.type !== _pointer2.default.move && "touch" !== e.pointerType) {
                            return
                        }
                        if (that.hoveredSeries) {
                            that._setTimeout(function() {
                                return that._pointerOnPoint(point, x, y, e)
                            }, point)
                        } else {
                            that._pointerOnPoint(point, x, y, e)
                        }
                        return
                    } else {
                        if (that._setStuckSeries(e, void 0, x, y) && that._stickyHovering) {
                            var _point;
                            series = that._stuckSeries;
                            point = series.getNeighborPoint(x, y);
                            that._releaseHoveredSeries();
                            (null === (_point = point) || void 0 === _point ? void 0 : _point.getMarkerVisibility()) && that._setHoveredPoint(point)
                        } else {
                            if (!that._stickyHovering) {
                                that._pointerOut()
                            }
                        }
                    }
                }
                that._pointerComplete(point, x, y)
            },
            _pointerOnPoint: function(point, x, y) {
                this._resetHoveredArgument();
                this._setHoveredPoint(point);
                this._pointerComplete(point, x, y)
            },
            _pointerComplete: function(point) {
                this.pointAtShownTooltip !== point && this._tooltip.isEnabled() && this._showTooltip(point)
            },
            _clickHandler: function(e) {
                var _point2;
                var that = e.data.tracker;
                if (that._isHolding) {
                    return
                }
                var rootOffset = that._renderer.getRootOffset();
                var x = _floor(e.pageX - rootOffset.left);
                var y = _floor(e.pageY - rootOffset.top);
                var point = getData(e, POINT_DATA);
                var series = that._stuckSeries || getData(e, SERIES_DATA) || (null === (_point2 = point) || void 0 === _point2 ? void 0 : _point2.series);
                var axis = that._argumentAxis;
                if (that._legend.coordsIn(x, y)) {
                    var item = that._legend.getItemByCoord(x, y);
                    if (item) {
                        that._legendClick(item, e)
                    }
                } else {
                    if (null === axis || void 0 === axis ? void 0 : axis.coordsIn(x, y)) {
                        var argument = getData(e, ARG_DATA);
                        if ((0, _type.isDefined)(argument)) {
                            that._eventTrigger("argumentAxisClick", {
                                argument: argument,
                                event: e
                            })
                        }
                    } else {
                        if (series) {
                            var _point3;
                            point = point || series.getPointByCoord(x, y);
                            if (null === (_point3 = point) || void 0 === _point3 ? void 0 : _point3.getMarkerVisibility()) {
                                that._pointClick(point, e)
                            } else {
                                getData(e, SERIES_DATA) && that._eventTrigger(SERIES_CLICK, {
                                    target: series,
                                    event: e
                                })
                            }
                        }
                    }
                }
            },
            dispose: function() {
                var that = this;
                that._disableOutHandler();
                that._renderer.root.off(DOT_EVENT_NS);
                that._seriesGroup.off(DOT_EVENT_NS)
            }
        };
        var ChartTracker = function(options) {
            this.ctor(options)
        };
        (0, _extend.extend)(ChartTracker.prototype, baseTrackerPrototype, {
            _pointClick: function(point, event) {
                var that = this;
                var eventTrigger = that._eventTrigger;
                var series = point.series;
                eventTrigger(POINT_CLICK, {
                    target: point,
                    event: event
                }, function() {
                    !eventCanceled(event, series) && eventTrigger(SERIES_CLICK, {
                        target: series,
                        event: event
                    })
                })
            },
            __trackerDelay: DELAY,
            update: function(options) {
                var that = this;
                baseTrackerPrototype.update.call(this, options);
                that._argumentAxis = options.argumentAxis || {};
                that._axisHoverEnabled = that._argumentAxis && (0, _utils.normalizeEnum)(that._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENT_POINTS_MODE;
                that._rotated = options.rotated;
                that._crosshair = options.crosshair;
                that._stickyHovering = options.stickyHovering
            },
            _getCanvas: function(x, y) {
                var that = this;
                var canvases = that._canvases || [];
                for (var i = 0; i < canvases.length; i++) {
                    var c = canvases[i];
                    if ((0, _utils.pointInCanvas)(c, x, y)) {
                        return c
                    }
                }
                return null
            },
            _isPointerOut: function(canvas) {
                return !canvas && this._stuckSeries
            },
            _hideCrosshair: function() {
                var _this$_crosshair;
                null === (_this$_crosshair = this._crosshair) || void 0 === _this$_crosshair ? void 0 : _this$_crosshair.hide()
            },
            _moveCrosshair: function(point, x, y) {
                if (this._crosshair && (null === point || void 0 === point ? void 0 : point.isVisible())) {
                    this._crosshair.show({
                        point: point,
                        x: x,
                        y: y
                    })
                }
            },
            _clean: function() {
                var that = this;
                baseTrackerPrototype._clean.call(that);
                that._resetTimer();
                that._stuckSeries = null
            },
            _getSeriesForShared: function(x, y) {
                var _point4;
                var that = this;
                var points = [];
                var point = null;
                var distance = 1 / 0;
                if (that._tooltip.isShared() && !that.hoveredSeries) {
                    (0, _iterator.each)(that._storedSeries, function(_, series) {
                        var point = series.getNeighborPoint(x, y);
                        point && points.push(point)
                    });
                    (0, _iterator.each)(points, function(_, p) {
                        var coords = p.getCrosshairData(x, y);
                        var d = (0, _utils.getDistance)(x, y, coords.x, coords.y);
                        if (d < distance) {
                            point = p;
                            distance = d
                        }
                    })
                }
                return null === (_point4 = point) || void 0 === _point4 ? void 0 : _point4.series
            },
            _setTimeout: function(callback, keeper) {
                var that = this;
                if (that._timeoutKeeper !== keeper) {
                    that._resetTimer();
                    that._hoverTimeout = setTimeout(function() {
                        callback();
                        that._timeoutKeeper = null
                    }, DELAY);
                    that._timeoutKeeper = keeper
                }
            },
            _resetTimer: function() {
                clearTimeout(this._hoverTimeout);
                this._timeoutKeeper = this._hoverTimeout = null
            },
            _stopEvent: function(e) {
                if (!(0, _type.isDefined)(e.cancelable) || e.cancelable) {
                    e.preventDefault();
                    e.stopPropagation()
                }
            },
            _setStuckSeries: function(e, series, x, y) {
                if ("mouse" !== e.pointerType) {
                    this._stuckSeries = null
                } else {
                    this._stuckSeries = series || this._stuckSeries || this._getSeriesForShared(x, y)
                }
                return !!this._stuckSeries
            },
            _pointerOut: function() {
                var that = this;
                that._stuckSeries = null;
                that._hideCrosshair();
                that._resetTimer();
                baseTrackerPrototype._pointerOut.apply(that, arguments)
            },
            _hoverArgumentAxis: function(x, y, e) {
                var that = this;
                that._resetHoveredArgument();
                if (that._axisHoverEnabled && that._argumentAxis.coordsIn(x, y)) {
                    that._hoverArgument(getData(e, ARG_DATA));
                    return true
                }
            },
            _pointerComplete: function(point, x, y) {
                var that = this;
                that.hoveredSeries && that.hoveredSeries.updateHover(x, y);
                that._resetTimer();
                that._moveCrosshair(point, x, y);
                baseTrackerPrototype._pointerComplete.call(that, point)
            },
            _legendClick: function(item, e) {
                var series = this._storedSeries[item.id];
                this._triggerLegendClick({
                    target: series,
                    event: e
                }, SERIES_CLICK)
            },
            _hoverLegendItem: function(x, y) {
                this._stuckSeries = null;
                this._hideCrosshair();
                baseTrackerPrototype._hoverLegendItem.call(this, x, y)
            },
            _pointerOnPoint: function(point, x, y, e) {
                this._setStuckSeries(e, point.series, x, y);
                this._releaseHoveredSeries();
                baseTrackerPrototype._pointerOnPoint.call(this, point, x, y, e)
            },
            _notifyLegendOnHoverArgument: false,
            _getArgumentHoverMode: function() {
                return correctHoverMode(this._argumentAxis)
            },
            dispose: function() {
                this._resetTimer();
                baseTrackerPrototype.dispose.call(this)
            }
        });
        var PieTracker = function(options) {
            this.ctor(options)
        };
        (0, _extend.extend)(PieTracker.prototype, baseTrackerPrototype, {
            _isPointerOut: function(_, point) {
                return !point
            },
            _legendClick: function(item, e) {
                var that = this;
                var points = [];
                that._storedSeries.forEach(function(s) {
                    return points.push.apply(points, s.getPointsByKeys(item.argument, item.argumentIndex))
                });
                that._eventTrigger(LEGEND_CLICK, {
                    target: item.argument,
                    points: points,
                    event: e
                })
            },
            _pointClick: function(point, e) {
                this._eventTrigger(POINT_CLICK, {
                    target: point,
                    event: e
                })
            },
            _hoverLegendItem: function(x, y) {
                var that = this;
                var item = that._legend.getItemByCoord(x, y);
                if (item && that._hoveredArgument !== item.argument) {
                    that._resetHoveredArgument();
                    that._hoverArgument(item.argument, item.argumentIndex)
                } else {
                    if (!item) {
                        that.clearHover()
                    }
                }
            },
            _getArgumentHoverMode: function() {
                return correctHoverMode(this._legend)
            },
            _hoverArgumentAxis: _common.noop,
            _setStuckSeries: _common.noop,
            _getCanvas: _common.noop,
            _notifyLegendOnHoverArgument: true
        });
        exports.ChartTracker = ChartTracker;
        exports.PieTracker = PieTracker
    },
    /*!******************************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/multi_axes_synchronizer.js ***!
      \******************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _console = __webpack_require__( /*! ../../core/utils/console */ 65);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _math2 = __webpack_require__( /*! ../../core/utils/math */ 31);
        var _math = Math;
        var _floor = _math.floor;
        var _max = _math.max;
        var _abs = _math.abs;

        function getValueAxesPerPanes(valueAxes) {
            var result = {};
            valueAxes.forEach(function(axis) {
                var pane = axis.pane;
                if (!result[pane]) {
                    result[pane] = []
                }
                result[pane].push(axis)
            });
            return result
        }
        var linearConverter = {
            transform: function(v, b) {
                return (0, _math2.adjust)((0, _utils.getLog)(v, b))
            },
            addInterval: function(v, i) {
                return (0, _math2.adjust)(v + i)
            },
            getInterval: function(base, tickInterval) {
                return tickInterval
            }
        };
        var logConverter = {
            transform: function(v, b) {
                return (0, _math2.adjust)((0, _utils.raiseTo)(v, b))
            },
            addInterval: function(v, i) {
                return (0, _math2.adjust)(v * i)
            },
            getInterval: function(base, tickInterval) {
                return _math.pow(base, tickInterval)
            }
        };

        function convertAxisInfo(axisInfo, converter) {
            if (!axisInfo.isLogarithmic) {
                return
            }
            var base = axisInfo.logarithmicBase;
            var tickValues = axisInfo.tickValues;
            var tick;
            var ticks = [];
            axisInfo.minValue = converter.transform(axisInfo.minValue, base);
            axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);
            axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);
            axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);
            axisInfo.tickInterval = _math.round(axisInfo.tickInterval);
            if (axisInfo.tickInterval < 1) {
                axisInfo.tickInterval = 1
            }
            var interval = converter.getInterval(base, axisInfo.tickInterval);
            tick = converter.transform(tickValues[0], base);
            while (ticks.length < tickValues.length) {
                ticks.push(tick);
                tick = converter.addInterval(tick, interval)
            }
            ticks.tickInterval = axisInfo.tickInterval;
            axisInfo.tickValues = ticks
        }

        function populateAxesInfo(axes) {
            return axes.reduce(function(result, axis) {
                var ticksValues = axis.getTicksValues();
                var majorTicks = ticksValues.majorTicksValues;
                var options = axis.getOptions();
                var businessRange = axis.getTranslator().getBusinessRange();
                var visibleArea = axis.getVisibleArea();
                var axisInfo;
                var tickInterval = axis._tickInterval;
                var synchronizedValue = options.synchronizedValue;
                if (majorTicks && majorTicks.length > 0 && (0, _type.isNumeric)(majorTicks[0]) && "discrete" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && "zoom" !== axis.getViewport().action) {
                    axis.applyMargins();
                    var startValue = axis.getTranslator().from(visibleArea[0]);
                    var endValue = axis.getTranslator().from(visibleArea[1]);
                    var minValue = startValue < endValue ? startValue : endValue;
                    var maxValue = startValue < endValue ? endValue : startValue;
                    if (minValue === maxValue && (0, _type.isDefined)(synchronizedValue)) {
                        tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;
                        minValue = majorTicks[0] - tickInterval;
                        maxValue = majorTicks[0] + tickInterval
                    }
                    axisInfo = {
                        axis: axis,
                        isLogarithmic: "logarithmic" === options.type,
                        logarithmicBase: businessRange.base,
                        tickValues: majorTicks,
                        minorValues: ticksValues.minorTicksValues,
                        minorTickInterval: axis._minorTickInterval,
                        minValue: minValue,
                        oldMinValue: minValue,
                        maxValue: maxValue,
                        oldMaxValue: maxValue,
                        inverted: businessRange.invert,
                        tickInterval: tickInterval,
                        synchronizedValue: synchronizedValue
                    };
                    convertAxisInfo(axisInfo, linearConverter);
                    result.push(axisInfo);
                    _console.debug.assert(axisInfo.minValue === axisInfo.maxValue && (!(0, _type.isDefined)(axisInfo.tickInterval) || (0, _type.isDefined)(options.tickInterval)) || (0, _type.isDefined)(axisInfo.tickInterval), "tickInterval was not provided")
                }
                return result
            }, [])
        }

        function updateTickValues(axesInfo) {
            var maxTicksCount = axesInfo.reduce(function(max, axisInfo) {
                return _max(max, axisInfo.tickValues.length)
            }, 0);
            axesInfo.forEach(function(axisInfo) {
                var ticksMultiplier;
                var ticksCount;
                var additionalStartTicksCount = 0;
                var synchronizedValue = axisInfo.synchronizedValue;
                var tickValues = axisInfo.tickValues;
                var tickInterval = axisInfo.tickInterval;
                if ((0, _type.isDefined)(synchronizedValue)) {
                    axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;
                    axisInfo.tickValues = [axisInfo.baseTickValue]
                } else {
                    if (tickValues.length > 1 && tickInterval) {
                        ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);
                        ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
                        additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);
                        while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {
                            tickValues.unshift((0, _math2.adjust)(tickValues[0] - tickInterval));
                            additionalStartTicksCount--
                        }
                        while (tickValues.length < ticksCount) {
                            tickValues.push((0, _math2.adjust)(tickValues[tickValues.length - 1] + tickInterval))
                        }
                        axisInfo.tickInterval = tickInterval / ticksMultiplier
                    }
                    axisInfo.baseTickValue = tickValues[0];
                    axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1]
                }
            })
        }

        function getAxisRange(axisInfo) {
            return axisInfo.maxValue - axisInfo.minValue || 1
        }

        function getMainAxisInfo(axesInfo) {
            for (var i = 0; i < axesInfo.length; i++) {
                if (!axesInfo[i].stubData) {
                    return axesInfo[i]
                }
            }
            return null
        }

        function correctMinMaxValues(axesInfo) {
            var mainAxisInfo = getMainAxisInfo(axesInfo);
            var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;
            axesInfo.forEach(function(axisInfo) {
                var scale;
                var move;
                var mainAxisBaseValueOffset;
                var valueFromAxisInfo;
                if (axisInfo !== mainAxisInfo) {
                    if (mainAxisInfoTickInterval && axisInfo.tickInterval) {
                        if (axisInfo.stubData && (0, _type.isDefined)(axisInfo.synchronizedValue)) {
                            axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
                            axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval
                        }
                        scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);
                        axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale
                    }
                    if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {
                        mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue
                    } else {
                        mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue
                    }
                    valueFromAxisInfo = getAxisRange(axisInfo);
                    move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;
                    axisInfo.minValue -= move;
                    axisInfo.maxValue -= move
                }
            })
        }

        function calculatePaddings(axesInfo) {
            var minPadding;
            var maxPadding;
            var startPadding = 0;
            var endPadding = 0;
            axesInfo.forEach(function(axisInfo) {
                var inverted = axisInfo.inverted;
                minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;
                maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;
                startPadding = _max(startPadding, inverted ? maxPadding : minPadding);
                endPadding = _max(endPadding, inverted ? minPadding : maxPadding)
            });
            return {
                start: startPadding,
                end: endPadding
            }
        }

        function correctMinMaxValuesByPaddings(axesInfo, paddings) {
            axesInfo.forEach(function(info) {
                var range = getAxisRange(info);
                var inverted = info.inverted;
                info.minValue = (0, _math2.adjust)(info.minValue - paddings[inverted ? "end" : "start"] * range);
                info.maxValue = (0, _math2.adjust)(info.maxValue + paddings[inverted ? "start" : "end"] * range)
            })
        }

        function updateTickValuesIfSynchronizedValueUsed(axesInfo) {
            var hasSynchronizedValue = false;
            axesInfo.forEach(function(info) {
                hasSynchronizedValue = hasSynchronizedValue || (0, _type.isDefined)(info.synchronizedValue)
            });
            axesInfo.forEach(function(info) {
                var tickInterval = info.tickInterval;
                var tickValues = info.tickValues;
                var maxValue = info.maxValue;
                var minValue = info.minValue;
                var tick;
                if (hasSynchronizedValue && tickInterval) {
                    while ((tick = (0, _math2.adjust)(tickValues[0] - tickInterval)) >= minValue) {
                        tickValues.unshift(tick)
                    }
                    tick = tickValues[tickValues.length - 1];
                    while ((tick = (0, _math2.adjust)(tick + tickInterval)) <= maxValue) {
                        tickValues.push(tick)
                    }
                }
                while (tickValues[0] + tickInterval / 10 < minValue) {
                    tickValues.shift()
                }
                while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {
                    tickValues.pop()
                }
            })
        }

        function applyMinMaxValues(axesInfo) {
            axesInfo.forEach(function(info) {
                var axis = info.axis;
                var range = axis.getTranslator().getBusinessRange();
                if (range.min === range.minVisible) {
                    range.min = info.minValue
                }
                if (range.max === range.maxVisible) {
                    range.max = info.maxValue
                }
                range.minVisible = info.minValue;
                range.maxVisible = info.maxValue;
                if (range.min > range.minVisible) {
                    range.min = range.minVisible
                }
                if (range.max < range.maxVisible) {
                    range.max = range.maxVisible
                }
                axis.getTranslator().updateBusinessRange(range);
                axis.setTicks({
                    majorTicks: info.tickValues,
                    minorTicks: info.minorValues
                })
            })
        }

        function correctAfterSynchronize(axesInfo) {
            var invalidAxisInfo = [];
            var correctValue;
            axesInfo.forEach(function(info) {
                if (info.oldMaxValue - info.oldMinValue === 0) {
                    invalidAxisInfo.push(info)
                } else {
                    if (!(0, _type.isDefined)(correctValue) && !(0, _type.isDefined)(info.synchronizedValue)) {
                        correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue))
                    }
                }
            });
            if (!(0, _type.isDefined)(correctValue)) {
                return
            }
            invalidAxisInfo.forEach(function(info) {
                var firstTick = info.tickValues[0];
                var correctedTick = firstTick * correctValue;
                if (firstTick > 0) {
                    info.maxValue = correctedTick;
                    info.minValue = 0
                } else {
                    if (firstTick < 0) {
                        info.minValue = correctedTick;
                        info.maxValue = 0
                    }
                }
            })
        }

        function updateMinorTicks(axesInfo) {
            axesInfo.forEach(function(axisInfo) {
                if (!axisInfo.minorTickInterval) {
                    return
                }
                var ticks = [];
                var interval = axisInfo.minorTickInterval;
                var tickCount = axisInfo.tickInterval / interval - 1;
                for (var i = 1; i < axisInfo.tickValues.length; i++) {
                    var tick = axisInfo.tickValues[i - 1];
                    for (var j = 0; j < tickCount; j++) {
                        tick += interval;
                        ticks.push(tick)
                    }
                }
                axisInfo.minorValues = ticks
            })
        }
        var multiAxesSynchronizer = {
            synchronize: function(valueAxes) {
                (0, _iterator.each)(getValueAxesPerPanes(valueAxes), function(_, axes) {
                    var axesInfo;
                    var paddings;
                    if (axes.length > 1) {
                        axesInfo = populateAxesInfo(axes);
                        if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {
                            return
                        }
                        updateTickValues(axesInfo);
                        correctMinMaxValues(axesInfo);
                        paddings = calculatePaddings(axesInfo);
                        correctMinMaxValuesByPaddings(axesInfo, paddings);
                        correctAfterSynchronize(axesInfo);
                        updateTickValuesIfSynchronizedValueUsed(axesInfo);
                        updateMinorTicks(axesInfo);
                        axesInfo.forEach(function(info) {
                            convertAxisInfo(info, logConverter)
                        });
                        applyMinMaxValues(axesInfo)
                    }
                })
            }
        };
        module.exports = multiAxesSynchronizer
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/viz/translators/category_translator.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var adjust = __webpack_require__( /*! ../../core/utils/math */ 31).adjust;
        var round = Math.round;

        function getValue(value) {
            return value
        }
        module.exports = {
            translate: function(category, directionOffset) {
                var that = this;
                var canvasOptions = that._canvasOptions;
                var categoryIndex = that._categoriesToPoints[category.valueOf()];
                var specialValue = that.translateSpecialCase(category);
                var startPointIndex = canvasOptions.startPointIndex || 0;
                var stickInterval = that._options.stick ? 0 : .5;
                if (isDefined(specialValue)) {
                    return round(specialValue)
                }
                if (!categoryIndex && 0 !== categoryIndex) {
                    return null
                }
                directionOffset = directionOffset || 0;
                var stickDelta = categoryIndex + stickInterval - startPointIndex + .5 * directionOffset;
                return round(that._calculateProjection(canvasOptions.interval * stickDelta))
            },
            getInterval: function() {
                return this._canvasOptions.interval
            },
            getEventScale: function(zoomEvent) {
                var scale = zoomEvent.deltaScale || 1;
                return 1 - (1 - scale) / (.75 + this.visibleCategories.length / this._categories.length)
            },
            zoom: function(translate, scale) {
                var that = this;
                var categories = that._categories;
                var canvasOptions = that._canvasOptions;
                var stick = that._options.stick;
                var invert = canvasOptions.invert;
                var interval = canvasOptions.interval * scale;
                var translateCategories = translate / interval;
                var visibleCount = (that.visibleCategories || []).length;
                var startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + .5);
                var categoriesLength = parseInt(adjust(canvasOptions.canvasLength / interval) + (stick ? 1 : 0)) || 1;
                var endCategoryIndex;
                if (invert) {
                    startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + visibleCount - translateCategories + .5) - categoriesLength
                }
                if (startCategoryIndex < 0) {
                    startCategoryIndex = 0
                }
                endCategoryIndex = startCategoryIndex + categoriesLength;
                if (endCategoryIndex > categories.length) {
                    endCategoryIndex = categories.length;
                    startCategoryIndex = endCategoryIndex - categoriesLength;
                    if (startCategoryIndex < 0) {
                        startCategoryIndex = 0
                    }
                }
                var newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));
                var newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);
                scale = newInterval / canvasOptions.interval;
                translate = that.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));
                return {
                    min: newVisibleCategories[0],
                    max: newVisibleCategories[newVisibleCategories.length - 1],
                    translate: translate,
                    scale: scale
                }
            },
            getMinScale: function(zoom) {
                var that = this;
                var canvasOptions = that._canvasOptions;
                var categoriesLength = (that.visibleCategories || that._categories).length;
                categoriesLength += (parseInt(.1 * categoriesLength) || 1) * (zoom ? -2 : 2);
                return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval)
            },
            getScale: function(min, max) {
                var that = this;
                var canvasOptions = that._canvasOptions;
                var visibleArea = that.getCanvasVisibleArea();
                var stickOffset = !that._options.stick && 1;
                var minPoint = isDefined(min) ? that.translate(min, -stickOffset) : null;
                var maxPoint = isDefined(max) ? that.translate(max, +stickOffset) : null;
                if (null === minPoint) {
                    minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min
                }
                if (null === maxPoint) {
                    maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max
                }
                return that.canvasLength / Math.abs(maxPoint - minPoint)
            },
            isValid: function(value) {
                return isDefined(value) ? this._categoriesToPoints[value.valueOf()] >= 0 : false
            },
            getCorrectValue: getValue,
            to: function(value, direction) {
                var canvasOptions = this._canvasOptions;
                var categoryIndex = this._categoriesToPoints[value.valueOf()];
                var startPointIndex = canvasOptions.startPointIndex || 0;
                var stickDelta = categoryIndex + (this._options.stick ? 0 : .5) - startPointIndex + (this._businessRange.invert ? -1 : 1) * direction * .5;
                return round(this._calculateProjection(canvasOptions.interval * stickDelta))
            },
            from: function(position) {
                var direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                var canvasOptions = this._canvasOptions;
                var startPoint = canvasOptions.startPoint;
                var categories = this.visibleCategories || this._categories;
                var categoriesLength = categories.length;
                var stickInterval = this._options.stick ? .5 : 0;
                var result = round((position - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * direction);
                if (result >= categoriesLength) {
                    result = categoriesLength - 1
                }
                if (result < 0) {
                    result = 0
                }
                if (canvasOptions.invert) {
                    result = categoriesLength - result - 1
                }
                return categories[result]
            },
            _add: function() {
                return NaN
            },
            _toValue: getValue,
            isValueProlonged: true
        }
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/viz/translators/interval_translator.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var typeUtils = __webpack_require__( /*! ../../core/utils/type */ 1);
        var isNumber = typeUtils.isNumeric;
        var isDefined = typeUtils.isDefined;
        var dateUtils = __webpack_require__( /*! ../../core/utils/date */ 24);
        var addInterval = dateUtils.addInterval;
        var dateToMilliseconds = dateUtils.dateToMilliseconds;
        var floor = Math.floor;
        var adjust = __webpack_require__( /*! ../../core/utils/math */ 31).adjust;
        module.exports = {
            _intervalize: function(value, interval) {
                if (!isDefined(value)) {
                    return
                }
                if ("datetime" === this._businessRange.dataType) {
                    if (isNumber(value)) {
                        value = new Date(value)
                    } else {
                        value = new Date(value.getTime())
                    }
                    value = dateUtils.correctDateWithUnitBeginning(value, interval, null, this._options.firstDayOfWeek)
                } else {
                    value = adjust(floor(adjust(value / interval)) * interval, interval)
                }
                return value
            },
            translate: function(bp, direction, interval) {
                var that = this;
                var specialValue = that.translateSpecialCase(bp);
                if (isDefined(specialValue)) {
                    return Math.round(specialValue)
                }
                interval = interval || that._options.interval;
                if (!that.isValid(bp, interval)) {
                    return null
                }
                return that.to(bp, direction, interval)
            },
            getInterval: function() {
                return Math.round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)))
            },
            zoom: function() {},
            getMinScale: function() {},
            getScale: function() {},
            _parse: function(value) {
                return "datetime" === this._businessRange.dataType ? new Date(value) : Number(value)
            },
            _fromValue: function(value) {
                return this._parse(value)
            },
            _toValue: function(value) {
                return this._parse(value)
            },
            isValid: function(value, interval) {
                var that = this;
                var co = that._canvasOptions;
                var rangeMin = co.rangeMin;
                var rangeMax = co.rangeMax;
                interval = interval || that._options.interval;
                if (null === value || isNaN(value)) {
                    return false
                }
                value = "datetime" === that._businessRange.dataType && isNumber(value) ? new Date(value) : value;
                if (interval !== that._options.interval) {
                    rangeMin = that._intervalize(rangeMin, interval);
                    rangeMax = that._intervalize(rangeMax, interval)
                }
                if (value.valueOf() < rangeMin || value.valueOf() >= addInterval(rangeMax, interval)) {
                    return false
                }
                return true
            },
            to: function(bp, direction, interval) {
                var that = this;
                interval = interval || that._options.interval;
                var v1 = that._intervalize(bp, interval);
                var v2 = addInterval(v1, interval);
                var res = that._to(v1);
                var p2 = that._to(v2);
                if (!direction) {
                    res = floor((res + p2) / 2)
                } else {
                    if (direction > 0) {
                        res = p2
                    }
                }
                return res
            },
            _to: function(value) {
                var co = this._canvasOptions;
                var rMin = co.rangeMinVisible;
                var rMax = co.rangeMaxVisible;
                var offset = value - rMin;
                if (value < rMin) {
                    offset = 0
                } else {
                    if (value > rMax) {
                        offset = addInterval(rMax, this._options.interval) - rMin
                    }
                }
                return this._conversionValue(this._calculateProjection(offset * this._canvasOptions.ratioOfCanvasRange))
            },
            from: function(position, direction) {
                var that = this;
                var origInterval = that._options.interval;
                var interval = origInterval;
                var co = that._canvasOptions;
                var rMin = co.rangeMinVisible;
                var rMax = co.rangeMaxVisible;
                var value;
                if ("datetime" === that._businessRange.dataType) {
                    interval = dateToMilliseconds(origInterval)
                }
                value = that._calculateUnProjection((position - that._canvasOptions.startPoint) / that._canvasOptions.ratioOfCanvasRange);
                value = that._intervalize(addInterval(value, interval / 2, direction > 0), origInterval);
                if (value < rMin) {
                    value = rMin
                } else {
                    if (value > rMax) {
                        value = rMax
                    }
                }
                return value
            },
            _add: function() {
                return NaN
            },
            isValueProlonged: true
        }
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/viz/translators/datetime_translator.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function parse(value) {
            return null !== value ? new Date(value) : value
        }
        module.exports = {
            _fromValue: parse,
            _toValue: parse,
            _add: __webpack_require__( /*! ../../core/utils/date */ 24).addDateInterval
        }
    },
    /*!************************************************************************!*\
      !*** ./artifacts/transpiled/viz/translators/logarithmic_translator.js ***!
      \************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var raiseTo = vizUtils.raiseToExt;
        var getLog = vizUtils.getLogExt;
        module.exports = {
            _fromValue: function(value) {
                return null !== value ? getLog(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value
            },
            _toValue: function(value) {
                return null !== value ? raiseTo(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value
            },
            getMinBarSize: function(minBarSize) {
                var visibleArea = this.getCanvasVisibleArea();
                var minValue = this.from(visibleArea.min + minBarSize);
                var canvasOptions = this._canvasOptions;
                return Math.pow(canvasOptions.base, canvasOptions.rangeMinVisible + this._fromValue(this.from(visibleArea.min)) - this._fromValue(!isDefined(minValue) ? this.from(visibleArea.max) : minValue))
            },
            checkMinBarSize: function(initialValue, minShownValue, stackValue) {
                var canvasOptions = this._canvasOptions;
                var prevValue = stackValue - initialValue;
                var baseMethod = this.constructor.prototype.checkMinBarSize;
                var minBarSize;
                var updateValue;
                if (isDefined(minShownValue) && prevValue > 0) {
                    minBarSize = baseMethod(this._fromValue(stackValue / prevValue), this._fromValue(minShownValue) - canvasOptions.rangeMinVisible);
                    updateValue = Math.pow(canvasOptions.base, this._fromValue(prevValue) + minBarSize) - prevValue
                } else {
                    updateValue = baseMethod(initialValue, minShownValue)
                }
                return updateValue
            }
        }
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/datetime_breaks.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _date = __webpack_require__( /*! ../../core/utils/date */ 24);
        var _date2 = _interopRequireDefault(_date);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var days = [0, 1, 2, 3, 4, 5, 6];

        function getWeekendDays(workdays) {
            return days.filter(function(day) {
                return !workdays.some(function(workDay) {
                    return workDay === day
                })
            })
        }

        function getNextDayIndex(dayIndex) {
            return (dayIndex + 1) % 7
        }

        function dayBetweenWeekend(weekend, day) {
            var start = weekend.start;
            var end = weekend.end;
            while (start !== end) {
                if (start === day) {
                    return true
                }
                start = getNextDayIndex(start)
            }
            return false
        }

        function getDaysDistance(day, end) {
            var length = 0;
            while (day !== end) {
                day = getNextDayIndex(day);
                length++
            }
            return length
        }

        function separateBreak(scaleBreak, day) {
            var result = [];
            var dayEnd = new Date(day);
            dayEnd.setDate(day.getDate() + 1);
            if (day > scaleBreak.from) {
                result.push({
                    from: scaleBreak.from,
                    to: day
                })
            }
            if (dayEnd < scaleBreak.to) {
                result.push({
                    from: dayEnd,
                    to: scaleBreak.to
                })
            }
            return result
        }

        function getWeekEndDayIndices(workDays) {
            var indices = getWeekendDays(workDays);
            if (indices.length < 7) {
                while (getNextDayIndex(indices[indices.length - 1]) === indices[0]) {
                    indices.unshift(indices.pop())
                }
            }
            return indices
        }

        function generateDateBreaksForWeekend(min, max, weekendDayIndices) {
            var day = min.getDate();
            var breaks = [];
            var weekends = weekendDayIndices.reduce(function(obj, day) {
                var currentWeekEnd = obj[1];
                if (void 0 === currentWeekEnd.start) {
                    currentWeekEnd = {
                        start: day,
                        end: getNextDayIndex(day)
                    };
                    obj[0].push(currentWeekEnd);
                    return [obj[0], currentWeekEnd]
                } else {
                    if (currentWeekEnd.end === day) {
                        currentWeekEnd.end = getNextDayIndex(day);
                        return obj
                    }
                }
                currentWeekEnd = {
                    start: day,
                    end: getNextDayIndex(day)
                };
                obj[0].push(currentWeekEnd);
                return [obj[0], currentWeekEnd]
            }, [
                [], {}
            ]);
            weekends[0].forEach(function(weekend) {
                var currentDate = new Date(min);
                currentDate = _date2.default.trimTime(currentDate);
                while (currentDate < max) {
                    day = currentDate.getDay();
                    var date = currentDate.getDate();
                    if (dayBetweenWeekend(weekend, day)) {
                        var from = new Date(currentDate);
                        currentDate.setDate(date + getDaysDistance(day, weekend.end));
                        var to = new Date(currentDate);
                        breaks.push({
                            from: from,
                            to: to
                        })
                    }
                    currentDate.setDate(currentDate.getDate() + 1)
                }
            });
            return breaks
        }

        function excludeWorkDaysFromWeekEndBreaks(breaks, exactWorkDays) {
            var result = breaks.slice();
            var i;
            var processWorkDay = function(workday) {
                workday = _date2.default.trimTime(new Date(workday));
                if (result[i].from <= workday && result[i].to > workday) {
                    var separatedBreak = separateBreak(result[i], workday);
                    if (2 === separatedBreak.length) {
                        result.splice(i, 1, separatedBreak[0], separatedBreak[1])
                    } else {
                        if (1 === separatedBreak.length) {
                            result.splice(i, 1, separatedBreak[0])
                        } else {
                            result.splice(i, 1)
                        }
                    }
                }
            };
            for (i = 0; i < result.length; i++) {
                exactWorkDays.forEach(processWorkDay)
            }
            return result
        }

        function generateBreaksForHolidays(min, max, holidays, weekendDayIndices) {
            var day;
            var dayInWeekend = function(dayIndex) {
                return dayIndex === day
            };
            var adjustedMin = _date2.default.trimTime(min);
            var adjustedMax = _date2.default.trimTime(max);
            adjustedMax.setDate(max.getDate() + 1);
            return holidays.reduce(function(breaks, holiday) {
                var holidayStart;
                var holidayEnd;
                holiday = new Date(holiday);
                day = holiday.getDay();
                if (!weekendDayIndices.some(dayInWeekend) && holiday >= adjustedMin && holiday <= adjustedMax) {
                    holidayStart = _date2.default.trimTime(holiday);
                    holidayEnd = new Date(holidayStart);
                    holidayEnd.setDate(holidayStart.getDate() + 1);
                    breaks.push({
                        from: holidayStart,
                        to: holidayEnd
                    })
                }
                return breaks
            }, [])
        }

        function calculateGaps(breaks) {
            return breaks.map(function(b) {
                return {
                    from: b.from,
                    to: b.to,
                    gapSize: _date2.default.convertMillisecondsToDateUnits(b.to - b.from)
                }
            })
        }
        exports.generateDateBreaks = function(min, max, workWeek, singleWorkdays, holidays) {
            var weekendDayIndices = getWeekEndDayIndices(workWeek);
            var breaks = generateDateBreaksForWeekend(min, max, weekendDayIndices);
            breaks.push.apply(breaks, generateBreaksForHolidays(min, max, holidays || [], weekendDayIndices));
            return calculateGaps(excludeWorkDaysFromWeekEndBreaks(breaks, singleWorkdays || []))
        }
    },
    /*!*****************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/polar_axes.js ***!
      \*****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _axes_constants = __webpack_require__( /*! ./axes_constants */ 263);
        var _axes_constants2 = _interopRequireDefault(_axes_constants);
        var _xy_axes = __webpack_require__( /*! ./xy_axes */ 427);
        var _tick = __webpack_require__( /*! ./tick */ 426);
        var _base_axis = __webpack_require__( /*! ./base_axis */ 211);
        var _base_axis2 = _interopRequireDefault(_base_axis);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var PI = Math.PI,
            abs = Math.abs,
            atan = Math.atan,
            round = Math.round;
        var _min = Math.min;
        var _max = Math.max;
        var HALF_PI_ANGLE = 90;

        function getPolarQuarter(angle) {
            var quarter;
            angle = (0, _utils.normalizeAngle)(angle);
            if (angle >= 315 && angle <= 360 || angle < 45 && angle >= 0) {
                quarter = 1
            } else {
                if (angle >= 45 && angle < 135) {
                    quarter = 2
                } else {
                    if (angle >= 135 && angle < 225) {
                        quarter = 3
                    } else {
                        if (angle >= 225 && angle < 315) {
                            quarter = 4
                        }
                    }
                }
            }
            return quarter
        }
        var polarAxes = exports;
        var circularAxes = polarAxes.circular = {
            _calculateValueMargins: function(ticks) {
                var _this$_getViewportRan = this._getViewportRange(),
                    minVisible = _this$_getViewportRan.minVisible,
                    maxVisible = _this$_getViewportRan.maxVisible;
                if (ticks && ticks.length > 1) {
                    minVisible = minVisible < ticks[0].value ? minVisible : ticks[0].value;
                    maxVisible = minVisible > ticks[ticks.length - 1].value ? maxVisible : ticks[ticks.length - 1].value
                }
                return {
                    minValue: minVisible,
                    maxValue: maxVisible
                }
            },
            applyMargins: function() {
                var margins = this._calculateValueMargins(this._majorTicks);
                var br = this._translator.getBusinessRange();
                br.addRange({
                    minVisible: margins.minValue,
                    maxVisible: margins.maxValue,
                    interval: this._calculateRangeInterval(br.interval)
                });
                this._translator.updateBusinessRange(br)
            },
            _getTranslatorOptions: function() {
                return {
                    isHorizontal: true,
                    conversionValue: true,
                    addSpiderCategory: this._getSpiderCategoryOption(),
                    stick: this._getStick()
                }
            },
            getCenter: function() {
                return this._center
            },
            getRadius: function() {
                return this._radius
            },
            getAngles: function() {
                var options = this._options;
                return [options.startAngle, options.endAngle]
            },
            _updateRadius: function(canvas) {
                var rad = _min(canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom) / 2;
                this._radius = rad < 0 ? 0 : rad
            },
            _updateCenter: function(canvas) {
                this._center = {
                    x: canvas.left + (canvas.width - canvas.right - canvas.left) / 2,
                    y: canvas.top + (canvas.height - canvas.top - canvas.bottom) / 2
                }
            },
            _processCanvas: function(canvas) {
                this._updateRadius(canvas);
                this._updateCenter(canvas);
                return {
                    left: 0,
                    right: 0,
                    width: this._getScreenDelta()
                }
            },
            _createAxisElement: function() {
                return this._renderer.circle()
            },
            _updateAxisElementPosition: function() {
                var center = this.getCenter();
                this._axisElement.attr({
                    cx: center.x,
                    cy: center.y,
                    r: this.getRadius()
                })
            },
            _boundaryTicksVisibility: {
                min: true
            },
            _getSpiderCategoryOption: function() {
                return this._options.firstPointOnStartAngle
            },
            _validateOptions: function(options) {
                var that = this;
                var originValue = options.originValue;
                var wholeRange = options.wholeRange = {};
                var period = options.period;
                if ((0, _type.isDefined)(originValue)) {
                    originValue = that.validateUnit(originValue)
                }
                if (period > 0 && options.argumentType === _axes_constants2.default.numeric) {
                    originValue = originValue || 0;
                    wholeRange.endValue = originValue + period;
                    that._viewport = (0, _utils.getVizRangeObject)([originValue, wholeRange.endValue])
                }
                if ((0, _type.isDefined)(originValue)) {
                    wholeRange.startValue = originValue
                }
            },
            getMargins: function() {
                var tickOptions = this._options.tick;
                var tickOuterLength = _max(tickOptions.visible ? tickOptions.length / 2 + tickOptions.shift : 0, 0);
                var radius = this.getRadius();
                var _this$_center = this._center,
                    x = _this$_center.x,
                    y = _this$_center.y;
                var labelBoxes = this._majorTicks.map(function(t) {
                    return t.label && t.label.getBBox()
                }).filter(function(b) {
                    return b
                });
                var canvas = (0, _extend.extend)({}, this._canvas, {
                    left: x - radius,
                    top: y - radius,
                    right: this._canvas.width - (x + radius),
                    bottom: this._canvas.height - (y + radius)
                });
                var margins = _base_axis2.default.calculateCanvasMargins(labelBoxes, canvas);
                Object.keys(margins).forEach(function(k) {
                    return margins[k] = margins[k] < tickOuterLength ? tickOuterLength : margins[k]
                });
                return margins
            },
            updateSize: function() {
                var that = this;
                _base_axis2.default.Axis.prototype.updateSize.apply(that, arguments);
                _base_axis2.default.measureLabels(that._majorTicks);
                that._adjustLabelsCoord(0, 0, true);
                this._checkBoundedLabelsOverlapping(this._majorTicks, this._majorTicks.map(function(t) {
                    return t.labelBBox
                }))
            },
            _setVisualRange: _common.noop,
            applyVisualRangeSetter: _common.noop,
            _getStick: function() {
                return this._options.firstPointOnStartAngle || this._options.type !== _axes_constants2.default.discrete
            },
            _getTranslatedCoord: function(value, offset) {
                return this._translator.translate(value, offset) - HALF_PI_ANGLE
            },
            _getCanvasStartEnd: function() {
                return {
                    start: 0 - HALF_PI_ANGLE,
                    end: 360 - HALF_PI_ANGLE
                }
            },
            _getStripGraphicAttributes: function(fromAngle, toAngle) {
                var center = this.getCenter();
                var angle = this.getAngles()[0];
                var r = this.getRadius();
                return {
                    x: center.x,
                    y: center.y,
                    innerRadius: 0,
                    outerRadius: r,
                    startAngle: -toAngle - angle,
                    endAngle: -fromAngle - angle
                }
            },
            _createStrip: function(coords) {
                return this._renderer.arc(coords.x, coords.y, coords.innerRadius, coords.outerRadius, coords.startAngle, coords.endAngle)
            },
            _getStripLabelCoords: function(from, to) {
                var that = this;
                var coords = that._getStripGraphicAttributes(from, to);
                var angle = coords.startAngle + (coords.endAngle - coords.startAngle) / 2;
                var cosSin = (0, _utils.getCosAndSin)(angle);
                var halfRad = that.getRadius() / 2;
                var center = that.getCenter();
                var x = round(center.x + halfRad * cosSin.cos);
                var y = round(center.y - halfRad * cosSin.sin);
                return {
                    x: x,
                    y: y,
                    align: _axes_constants2.default.center
                }
            },
            _getConstantLineGraphicAttributes: function(value) {
                var center = this.getCenter();
                var r = this.getRadius();
                return {
                    points: [center.x, center.y, center.x + r, center.y]
                }
            },
            _createConstantLine: function(value, attr) {
                return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr)
            },
            _rotateConstantLine: function(line, value) {
                var _this$getCenter = this.getCenter(),
                    x = _this$getCenter.x,
                    y = _this$getCenter.y;
                line.rotate(value + this.getAngles()[0], x, y)
            },
            _getConstantLineLabelsCoords: function(value) {
                var that = this;
                var cosSin = (0, _utils.getCosAndSin)(-value - that.getAngles()[0]);
                var halfRad = that.getRadius() / 2;
                var center = that.getCenter();
                var x = round(center.x + halfRad * cosSin.cos);
                var y = round(center.y - halfRad * cosSin.sin);
                return {
                    x: x,
                    y: y
                }
            },
            _checkAlignmentConstantLineLabels: _common.noop,
            _adjustDivisionFactor: function(val) {
                return 180 * val / (this.getRadius() * PI)
            },
            _getScreenDelta: function() {
                var angles = this.getAngles();
                return abs(angles[0] - angles[1])
            },
            _getTickMarkPoints: function(coords, length, _ref) {
                var _ref$shift = _ref.shift,
                    shift = void 0 === _ref$shift ? 0 : _ref$shift;
                var center = this.getCenter();
                var corrections = {
                    inside: -1,
                    center: -.5,
                    outside: 0
                };
                var radiusWithTicks = this.getRadius() + length * corrections[this._options.tickOrientation || "center"];
                return [center.x + radiusWithTicks + shift, center.y, center.x + radiusWithTicks + length + shift, center.y]
            },
            _getLabelAdjustedCoord: function(tick, _offset, _maxWidth, checkCanvas) {
                var that = this;
                var labelCoords = tick.labelCoords;
                var labelY = labelCoords.y;
                var labelAngle = labelCoords.angle;
                var cosSin = (0, _utils.getCosAndSin)(labelAngle);
                var cos = cosSin.cos;
                var sin = cosSin.sin;
                var box = tick.labelBBox;
                var halfWidth = box.width / 2;
                var halfHeight = box.height / 2;
                var indentFromAxis = that._options.label.indentFromAxis || 0;
                var x = labelCoords.x + indentFromAxis * cos;
                var y = labelY + (labelY - box.y - halfHeight) + indentFromAxis * sin;
                var shiftX = 0;
                var shiftY = 0;
                switch (getPolarQuarter(labelAngle)) {
                    case 1:
                        shiftX = halfWidth;
                        shiftY = halfHeight * sin;
                        break;
                    case 2:
                        shiftX = halfWidth * cos;
                        shiftY = halfHeight;
                        break;
                    case 3:
                        shiftX = -halfWidth;
                        shiftY = halfHeight * sin;
                        break;
                    case 4:
                        shiftX = halfWidth * cos;
                        shiftY = -halfHeight
                }
                if (checkCanvas) {
                    var canvas = that._canvas;
                    var boxShiftX = x - labelCoords.x + shiftX;
                    var boxShiftY = y - labelCoords.y + shiftY;
                    if (box.x + boxShiftX < canvas.originalLeft) {
                        shiftX -= box.x + boxShiftX - canvas.originalLeft
                    }
                    if (box.x + box.width + boxShiftX > canvas.width - canvas.originalRight) {
                        shiftX -= box.x + box.width + boxShiftX - (canvas.width - canvas.originalRight)
                    }
                    if (box.y + boxShiftY < canvas.originalTop) {
                        shiftY -= box.y + boxShiftY - canvas.originalTop
                    }
                    if (box.y + box.height + boxShiftY > canvas.height - canvas.originalBottom) {
                        shiftY -= box.y + box.height + boxShiftY - (canvas.height - canvas.originalBottom)
                    }
                }
                return {
                    x: x + shiftX,
                    y: y + shiftY
                }
            },
            _getGridLineDrawer: function() {
                var that = this;
                return function(tick, gridStyle) {
                    var center = that.getCenter();
                    return that._createPathElement(that._getGridPoints().points, gridStyle).rotate(tick.coords.angle, center.x, center.y)
                }
            },
            _getGridPoints: function() {
                var r = this.getRadius();
                var center = this.getCenter();
                return {
                    points: [center.x, center.y, center.x + r, center.y]
                }
            },
            _getTranslatedValue: function(value, offset) {
                var startAngle = this.getAngles()[0];
                var angle = this._translator.translate(value, -offset);
                var coords = (0, _utils.convertPolarToXY)(this.getCenter(), startAngle, angle, this.getRadius());
                return {
                    x: coords.x,
                    y: coords.y,
                    angle: this.getTranslatedAngle(angle)
                }
            },
            _getAdjustedStripLabelCoords: function(strip) {
                var box = strip.labelBBox;
                return {
                    translateY: strip.label.attr("y") - box.y - box.height / 2
                }
            },
            coordsIn: function(x, y) {
                return (0, _utils.convertXYToPolar)(this.getCenter(), x, y).r > this.getRadius()
            },
            _rotateTick: function(element, coords) {
                var center = this.getCenter();
                element.rotate(coords.angle, center.x, center.y)
            },
            _validateOverlappingMode: function(mode) {
                return _axes_constants2.default.validateOverlappingMode(mode)
            },
            _validateDisplayMode: function() {
                return "standard"
            },
            _getStep: function(boxes) {
                var that = this;
                var radius = that.getRadius() + (that._options.label.indentFromAxis || 0);
                var maxLabelBox = boxes.reduce(function(prevValue, box) {
                    var curValue = prevValue;
                    if (prevValue.width < box.width) {
                        curValue.width = box.width
                    }
                    if (prevValue.height < box.height) {
                        curValue.height = box.height
                    }
                    return curValue
                }, {
                    width: 0,
                    height: 0
                });
                var angle1 = abs(2 * atan(maxLabelBox.height / (2 * radius - maxLabelBox.width)) * 180 / PI);
                var angle2 = abs(2 * atan(maxLabelBox.width / (2 * radius - maxLabelBox.height)) * 180 / PI);
                return _axes_constants2.default.getTicksCountInRange(that._majorTicks, "angle", _max(angle1, angle2))
            },
            _checkBoundedLabelsOverlapping: function(majorTicks, boxes, mode) {
                var labelOpt = this._options.label;
                mode = mode || this._validateOverlappingMode(labelOpt.overlappingBehavior);
                if ("hide" !== mode) {
                    return
                }
                var lastVisibleLabelIndex = majorTicks.reduce(function(lastVisibleLabelIndex, tick, index) {
                    return tick.label ? index : lastVisibleLabelIndex
                }, null);
                if (!lastVisibleLabelIndex) {
                    return
                }
                if (_axes_constants2.default.areLabelsOverlap(boxes[0], boxes[lastVisibleLabelIndex], labelOpt.minSpacing, _axes_constants2.default.center)) {
                    "first" === labelOpt.hideFirstOrLast ? majorTicks[0].label.remove() : majorTicks[lastVisibleLabelIndex].label.remove()
                }
            },
            shift: function(margins) {
                this._axisGroup.attr({
                    translateX: margins.right,
                    translateY: margins.bottom
                })
            },
            getTranslatedAngle: function(angle) {
                var startAngle = this.getAngles()[0];
                return angle + startAngle - HALF_PI_ANGLE
            }
        };
        polarAxes.circularSpider = (0, _extend.extend)({}, circularAxes, {
            _createAxisElement: function() {
                return this._renderer.path([], "area")
            },
            _updateAxisElementPosition: function() {
                this._axisElement.attr({
                    points: (0, _utils.map)(this.getSpiderTicks(), function(tick) {
                        return {
                            x: tick.coords.x,
                            y: tick.coords.y
                        }
                    })
                })
            },
            _getStick: function() {
                return true
            },
            _getSpiderCategoryOption: function() {
                return true
            },
            getSpiderTicks: function() {
                var that = this;
                var ticks = that.getFullTicks();
                that._spiderTicks = ticks.map((0, _tick.tick)(that, that.renderer, {}, {}, that._getSkippedCategory(ticks), true));
                that._spiderTicks.forEach(function(tick) {
                    tick.initCoords()
                });
                return that._spiderTicks
            },
            _getStripGraphicAttributes: function(fromAngle, toAngle) {
                var center = this.getCenter();
                var spiderTicks = this.getSpiderTicks();
                var firstTick;
                var lastTick;
                var nextTick;
                var tick;
                var points = [];
                var i = 0;
                var len = spiderTicks.length;
                while (i < len) {
                    tick = spiderTicks[i].coords;
                    if (tick.angle >= fromAngle && tick.angle <= toAngle) {
                        if (!firstTick) {
                            firstTick = (spiderTicks[i - 1] || spiderTicks[spiderTicks.length - 1]).coords;
                            points.push((tick.x + firstTick.x) / 2, (tick.y + firstTick.y) / 2)
                        }
                        points.push(tick.x, tick.y);
                        nextTick = (spiderTicks[i + 1] || spiderTicks[0]).coords;
                        lastTick = {
                            x: (tick.x + nextTick.x) / 2,
                            y: (tick.y + nextTick.y) / 2
                        }
                    }
                    i++
                }
                points.push(lastTick.x, lastTick.y);
                points.push(center.x, center.y);
                return {
                    points: points
                }
            },
            _createStrip: function(_ref2) {
                var points = _ref2.points;
                return this._renderer.path(points, "area")
            },
            _getTranslatedCoord: function(value, offset) {
                return this._translator.translate(value, offset) - HALF_PI_ANGLE
            },
            _setTickOffset: function() {
                this._tickOffset = false
            }
        });
        polarAxes.linear = {
            _resetMargins: function() {
                this._reinitTranslator(this._getViewportRange())
            },
            _getStick: _xy_axes.linear._getStick,
            _getSpiderCategoryOption: _common.noop,
            _getTranslatorOptions: function() {
                return {
                    isHorizontal: true,
                    stick: this._getStick()
                }
            },
            getRadius: circularAxes.getRadius,
            getCenter: circularAxes.getCenter,
            getAngles: circularAxes.getAngles,
            _updateRadius: circularAxes._updateRadius,
            _updateCenter: circularAxes._updateCenter,
            _processCanvas: function(canvas) {
                this._updateRadius(canvas);
                this._updateCenter(canvas);
                return {
                    left: 0,
                    right: 0,
                    startPadding: canvas.startPadding,
                    endPadding: canvas.endPadding,
                    width: this.getRadius()
                }
            },
            _createAxisElement: _xy_axes.linear._createAxisElement,
            _updateAxisElementPosition: function() {
                var centerCoord = this.getCenter();
                this._axisElement.attr({
                    points: [centerCoord.x, centerCoord.y, centerCoord.x + this.getRadius(), centerCoord.y]
                }).rotate(this.getAngles()[0] - HALF_PI_ANGLE, centerCoord.x, centerCoord.y)
            },
            _getScreenDelta: function() {
                return this.getRadius()
            },
            _getTickMarkPoints: function(coords, length) {
                return [coords.x - length / 2, coords.y, coords.x + length / 2, coords.y]
            },
            _getLabelAdjustedCoord: function(tick) {
                var that = this;
                var labelCoords = tick.labelCoords;
                var labelY = labelCoords.y;
                var cosSin = (0, _utils.getCosAndSin)(labelCoords.angle);
                var indentFromAxis = that._options.label.indentFromAxis || 0;
                var box = tick.labelBBox;
                var x = labelCoords.x - abs(indentFromAxis * cosSin.sin) + abs(box.width / 2 * cosSin.cos) - box.width / 2;
                var y = labelY + (labelY - box.y) - abs(box.height / 2 * cosSin.sin) + abs(indentFromAxis * cosSin.cos);
                return {
                    x: x,
                    y: y
                }
            },
            _getGridLineDrawer: function() {
                var that = this;
                return function(tick, gridStyle) {
                    var grid = that._getGridPoints(tick.coords);
                    return that._renderer.circle(grid.cx, grid.cy, grid.r).attr(gridStyle).sharp()
                }
            },
            _getGridPoints: function(coords) {
                var pos = this.getCenter();
                var radius = (0, _utils.getDistance)(pos.x, pos.y, coords.x, coords.y);
                if (radius > this.getRadius()) {
                    return {
                        cx: null,
                        cy: null,
                        r: null
                    }
                }
                return {
                    cx: pos.x,
                    cy: pos.y,
                    r: radius
                }
            },
            _getTranslatedValue: function(value, offset) {
                var startAngle = this.getAngles()[0];
                var xy = (0, _utils.convertPolarToXY)(this.getCenter(), startAngle, 0, this._translator.translate(value, offset));
                return {
                    x: xy.x,
                    y: xy.y,
                    angle: startAngle - HALF_PI_ANGLE
                }
            },
            _getTranslatedCoord: function(value, offset) {
                return this._translator.translate(value, offset)
            },
            _getCanvasStartEnd: function() {
                var invert = this.getTranslator().getBusinessRange().invert;
                var coords = [0, this.getRadius()];
                invert && coords.reverse();
                return {
                    start: coords[0],
                    end: coords[1]
                }
            },
            _getStripGraphicAttributes: function(fromPoint, toPoint) {
                var center = this.getCenter();
                return {
                    x: center.x,
                    y: center.y,
                    innerRadius: fromPoint,
                    outerRadius: toPoint
                }
            },
            _createStrip: function(attrs) {
                return this._renderer.arc(attrs.x, attrs.y, attrs.innerRadius, attrs.outerRadius, 0, 360)
            },
            _getAdjustedStripLabelCoords: circularAxes._getAdjustedStripLabelCoords,
            _getStripLabelCoords: function(from, to) {
                var that = this;
                var labelPos = from + (to - from) / 2;
                var center = that.getCenter();
                var y = round(center.y - labelPos);
                return {
                    x: center.x,
                    y: y,
                    align: _axes_constants2.default.center
                }
            },
            _getConstantLineGraphicAttributes: function(value) {
                var center = this.getCenter();
                return {
                    cx: center.x,
                    cy: center.y,
                    r: value
                }
            },
            _createConstantLine: function(value, attr) {
                var attrs = this._getConstantLineGraphicAttributes(value);
                return this._renderer.circle(attrs.cx, attrs.cy, attrs.r).attr(attr).sharp()
            },
            _getConstantLineLabelsCoords: function(value) {
                var that = this;
                var center = that.getCenter();
                var y = round(center.y - value);
                return {
                    x: center.x,
                    y: y
                }
            },
            _checkAlignmentConstantLineLabels: _common.noop,
            _rotateTick: function(element, coords, isGridLine) {
                !isGridLine && element.rotate(coords.angle + HALF_PI_ANGLE, coords.x, coords.y)
            },
            _validateOverlappingMode: circularAxes._validateOverlappingMode,
            _validateDisplayMode: circularAxes._validateDisplayMode,
            _getStep: function(boxes) {
                var quarter = getPolarQuarter(this.getAngles()[0]);
                var spacing = this._options.label.minSpacing;
                var func = 2 === quarter || 4 === quarter ? function(box) {
                    return box.width + spacing
                } : function(box) {
                    return box.height
                };
                var maxLabelLength = boxes.reduce(function(prevValue, box) {
                    return _max(prevValue, func(box))
                }, 0);
                return _axes_constants2.default.getTicksCountInRange(this._majorTicks, 2 === quarter || 4 === quarter ? "x" : "y", maxLabelLength)
            }
        };
        polarAxes.linearSpider = (0, _extend.extend)({}, polarAxes.linear, {
            _createPathElement: function(points, attr) {
                return this._renderer.path(points, "area").attr(attr).sharp()
            },
            setSpiderTicks: function(ticks) {
                this._spiderTicks = ticks
            },
            _getGridLineDrawer: function() {
                var that = this;
                return function(tick, gridStyle) {
                    return that._createPathElement(that._getGridPoints(tick.coords).points, gridStyle)
                }
            },
            _getGridPoints: function(coords) {
                var pos = this.getCenter();
                var radius = (0, _utils.getDistance)(pos.x, pos.y, coords.x, coords.y);
                return this._getGridPointsByRadius(radius)
            },
            _getGridPointsByRadius: function(radius) {
                var pos = this.getCenter();
                if (radius > this.getRadius()) {
                    return {
                        points: null
                    }
                }
                return {
                    points: (0, _utils.map)(this._spiderTicks, function(tick) {
                        var cosSin = (0, _utils.getCosAndSin)(tick.coords.angle);
                        return {
                            x: round(pos.x + radius * cosSin.cos),
                            y: round(pos.y + radius * cosSin.sin)
                        }
                    })
                }
            },
            _getStripGraphicAttributes: function(fromPoint, toPoint) {
                var innerPoints = this._getGridPointsByRadius(toPoint).points;
                var outerPoints = this._getGridPointsByRadius(fromPoint).points;
                return {
                    points: [outerPoints, innerPoints.reverse()]
                }
            },
            _createStrip: polarAxes.circularSpider._createStrip,
            _getConstantLineGraphicAttributes: function(value) {
                return this._getGridPointsByRadius(value)
            },
            _createConstantLine: function(value, attr) {
                return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr)
            }
        })
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/constant_line.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = createConstantLine;
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);

        function createConstantLine(axis, options) {
            var labelOptions = options.label || {};
            var labelPosition = labelOptions.position || "inside";
            var parsedValue;
            var valueIsParsed = false;
            axis._checkAlignmentConstantLineLabels(labelOptions);
            var storedCoord;
            return {
                options: options,
                labelOptions: labelOptions,
                labelPosition: labelPosition,
                label: null,
                line: null,
                getParsedValue: function() {
                    if (!valueIsParsed) {
                        parsedValue = axis.validateUnit(options.value, "E2105", "constantLine");
                        valueIsParsed = true;
                        return parsedValue
                    }
                    return parsedValue
                },
                draw: function() {
                    if (!(0, _type.isDefined)(options.value) || axis._translator.getBusinessRange().isEmpty()) {
                        return this
                    }
                    var canvas = axis._getCanvasStartEnd();
                    var parsedValue = this.getParsedValue();
                    this.coord = axis._getConstantLinePos(parsedValue, canvas.start, canvas.end);
                    var rootGroup = options.displayBehindSeries ? axis._axisConstantLineGroups.under : axis._axisConstantLineGroups.above;
                    var group = rootGroup[labelPosition];
                    if (!group) {
                        var side = axis._isHorizontal ? labelOptions.verticalAlignment : labelOptions.horizontalAlignment;
                        group = rootGroup[side]
                    }
                    if (!(0, _type.isDefined)(this.coord)) {
                        return this
                    }
                    var path = axis._createConstantLine(this.coord, {
                        stroke: options.color,
                        "stroke-width": options.width,
                        dashStyle: options.dashStyle
                    });
                    this.line = path.append(rootGroup.inside);
                    this.label = labelOptions.visible ? axis._drawConstantLineLabels(parsedValue, labelOptions, this.coord, group) : null;
                    this.updatePosition();
                    return this
                },
                removeLabel: function() {
                    this.label && this.label.remove()
                },
                updatePosition: function(animate) {
                    var canvas = axis._getCanvasStartEnd();
                    var coord = axis._getConstantLinePos(this.getParsedValue(), canvas.start, canvas.end);
                    if (!(0, _type.isDefined)(coord)) {
                        return
                    }
                    this.coord = coord;
                    if (animate && storedCoord) {
                        this.label && this.label.attr(axis._getConstantLineLabelsCoords(storedCoord, this.labelOptions));
                        this.line && this.line.attr(axis._getConstantLineGraphicAttributes(storedCoord));
                        this.label && this.label.animate(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));
                        this.line && this.line.animate(axis._getConstantLineGraphicAttributes(this.coord))
                    } else {
                        this.label && this.label.attr(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));
                        this.line && this.line.attr(axis._getConstantLineGraphicAttributes(this.coord));
                        axis._rotateConstantLine(this.line, this.coord)
                    }
                },
                saveCoords: function() {
                    storedCoord = this.coord
                }
            }
        }
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/viz/axes/strip.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = createStrip;
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);

        function createStrip(axis, options) {
            var storedCoord;
            var labelOptions = options.label || {};
            return {
                options: options,
                label: null,
                rect: null,
                _getCoord: function() {
                    var canvas = axis._getCanvasStartEnd();
                    var range = axis._translator.getBusinessRange();
                    return axis._getStripPos(options.startValue, options.endValue, canvas.start, canvas.end, range)
                },
                _drawLabel: function(coords) {
                    return axis._renderer.text(labelOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)((0, _extend.extend)({}, axis.getOptions().label.font, labelOptions.font))).attr({
                        align: "center",
                        "class": labelOptions.cssClass
                    }).append(axis._axisStripLabelGroup)
                },
                draw: function() {
                    if (axis._translator.getBusinessRange().isEmpty()) {
                        return
                    }
                    if (((0, _type.isDefined)(options.startValue) || (0, _type.isDefined)(options.endValue)) && (0, _type.isDefined)(options.color)) {
                        var stripPos = this._getCoord();
                        this.labelCoords = labelOptions.text ? axis._getStripLabelCoords(stripPos.from, stripPos.to, labelOptions) : null;
                        if (stripPos.to - stripPos.from === 0 || !(0, _type.isDefined)(stripPos.to) || !(0, _type.isDefined)(stripPos.from)) {
                            return
                        }
                        this.rect = axis._createStrip(axis._getStripGraphicAttributes(stripPos.from, stripPos.to)).attr({
                            fill: options.color
                        }).append(axis._axisStripGroup);
                        this.label = labelOptions.text ? this._drawLabel(this.labelCoords) : null
                    }
                },
                removeLabel: function() {},
                updatePosition: function(animate) {
                    var stripPos = this._getCoord();
                    if (animate && storedCoord) {
                        this.label && this.label.attr(axis._getStripLabelCoords(storedCoord.from, storedCoord.to, options.label));
                        this.rect && this.rect.attr(axis._getStripGraphicAttributes(storedCoord.from, storedCoord.to));
                        this.label && this.label.animate(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));
                        this.rect && this.rect.animate(axis._getStripGraphicAttributes(stripPos.from, stripPos.to))
                    } else {
                        this.label && this.label.attr(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));
                        this.rect && this.rect.attr(axis._getStripGraphicAttributes(stripPos.from, stripPos.to))
                    }
                },
                saveCoords: function() {
                    storedCoord = this._getCoord()
                }
            }
        }
    },
    /*!*****************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/scroll_bar.js ***!
      \*****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _utils = __webpack_require__( /*! ../../events/utils */ 8);
        var eventUtils = _interopRequireWildcard(_utils);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _translator2d = __webpack_require__( /*! ../translators/translator2d */ 264);
        var _translator2d2 = _interopRequireDefault(_translator2d);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _drag = __webpack_require__( /*! ../../events/drag */ 69);
        var _drag2 = _interopRequireDefault(_drag);

        function _getRequireWildcardCache() {
            if ("function" !== typeof WeakMap) {
                return null
            }
            var cache = new WeakMap;
            _getRequireWildcardCache = function() {
                return cache
            };
            return cache
        }

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            }
            if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
                return {
                    "default": obj
                }
            }
            var cache = _getRequireWildcardCache();
            if (cache && cache.has(obj)) {
                return cache.get(obj)
            }
            var newObj = {};
            var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                        Object.defineProperty(newObj, key, desc)
                    } else {
                        newObj[key] = obj[key]
                    }
                }
            }
            newObj.default = obj;
            if (cache) {
                cache.set(obj, newObj)
            }
            return newObj
        }

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _min = Math.min;
        var _max = Math.max;
        var MIN_SCROLL_BAR_SIZE = 2;
        var ScrollBar = function(renderer, group) {
            this._translator = new _translator2d2.default.Translator2D({}, {}, {});
            this._scroll = renderer.rect().append(group);
            this._addEvents()
        };

        function _getXCoord(canvas, pos, offset, width) {
            var x = 0;
            if ("right" === pos) {
                x = canvas.width - canvas.right + offset
            } else {
                if ("left" === pos) {
                    x = canvas.left - offset - width
                }
            }
            return x
        }

        function _getYCoord(canvas, pos, offset, width) {
            var y = 0;
            if ("top" === pos) {
                y = canvas.top - offset
            } else {
                if ("bottom" === pos) {
                    y = canvas.height - canvas.bottom + width + offset
                }
            }
            return y
        }
        ScrollBar.prototype = {
            _addEvents: function() {
                var _this = this;
                var scrollElement = this._scroll.element;
                _events_engine2.default.on(scrollElement, _drag2.default.start, function(e) {
                    eventUtils.fireEvent({
                        type: "dxc-scroll-start",
                        originalEvent: e,
                        target: scrollElement
                    })
                });
                _events_engine2.default.on(scrollElement, _drag2.default.move, function(e) {
                    var dX = -e.offset.x * _this._scale;
                    var dY = -e.offset.y * _this._scale;
                    var lx = _this._offset - (_this._layoutOptions.vertical ? dY : dX) / _this._scale;
                    _this._applyPosition(lx, lx + _this._translator.canvasLength / _this._scale);
                    eventUtils.fireEvent({
                        type: "dxc-scroll-move",
                        originalEvent: e,
                        target: scrollElement,
                        offset: {
                            x: dX,
                            y: dY
                        }
                    })
                });
                _events_engine2.default.on(scrollElement, _drag2.default.end, function(e) {
                    eventUtils.fireEvent({
                        type: "dxc-scroll-end",
                        originalEvent: e,
                        target: scrollElement,
                        offset: {
                            x: -e.offset.x * _this._scale,
                            y: -e.offset.y * _this._scale
                        }
                    })
                })
            },
            update: function(options) {
                var that = this;
                var position = options.position;
                var isVertical = options.rotated;
                var defaultPosition = isVertical ? "right" : "top";
                var secondaryPosition = isVertical ? "left" : "bottom";
                if (position !== defaultPosition && position !== secondaryPosition) {
                    position = defaultPosition
                }
                that._scroll.attr({
                    rotate: !options.rotated ? -90 : 0,
                    rotateX: 0,
                    rotateY: 0,
                    fill: options.color,
                    width: options.width,
                    opacity: options.opacity
                });
                that._layoutOptions = {
                    width: options.width,
                    offset: options.offset,
                    vertical: isVertical,
                    position: position
                };
                return that
            },
            init: function(range, stick) {
                var that = this;
                var isDiscrete = "discrete" === range.axisType;
                that._translateWithOffset = isDiscrete && !stick && 1 || 0;
                that._translator.update((0, _extend.extend)({}, range, {
                    minVisible: null,
                    maxVisible: null,
                    visibleCategories: null
                }, isDiscrete && {
                    min: null,
                    max: null
                } || {}), that._canvas, {
                    isHorizontal: !that._layoutOptions.vertical,
                    stick: stick
                });
                return that
            },
            getOptions: function() {
                return this._layoutOptions
            },
            setPane: function(panes) {
                var position = this._layoutOptions.position;
                var pane;
                if ("left" === position || "top" === position) {
                    pane = panes[0]
                } else {
                    pane = panes[panes.length - 1]
                }
                this.pane = pane.name;
                return this
            },
            updateSize: function(canvas) {
                this._canvas = (0, _extend.extend)({}, canvas);
                var options = this._layoutOptions;
                var pos = options.position;
                var offset = options.offset;
                var width = options.width;
                this._scroll.attr({
                    translateX: _getXCoord(canvas, pos, offset, width),
                    translateY: _getYCoord(canvas, pos, offset, width)
                })
            },
            getMultipleAxesSpacing: function() {
                return 0
            },
            estimateMargins: function() {
                return this.getMargins()
            },
            getMargins: function() {
                var options = this._layoutOptions;
                var margins = {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                };
                margins[options.position] = options.width + options.offset;
                return margins
            },
            shift: function shift(margins) {
                var _that$_scroll$attr, _that$_scroll$attr2;
                var that = this;
                var options = that._layoutOptions;
                var side = options.position;
                var isVertical = options.vertical;
                var attr = {
                    translateX: null !== (_that$_scroll$attr = that._scroll.attr("translateX")) && void 0 !== _that$_scroll$attr ? _that$_scroll$attr : 0,
                    translateY: null !== (_that$_scroll$attr2 = that._scroll.attr("translateY")) && void 0 !== _that$_scroll$attr2 ? _that$_scroll$attr2 : 0
                };
                var shift = margins[side];
                attr[isVertical ? "translateX" : "translateY"] += ("left" === side || "top" === side ? -1 : 1) * shift;
                that._scroll.attr(attr)
            },
            hideTitle: _common.noop,
            hideOuterElements: _common.noop,
            setPosition: function(min, max) {
                var that = this;
                var translator = that._translator;
                var minPoint = (0, _type.isDefined)(min) ? translator.translate(min, -that._translateWithOffset) : translator.translate("canvas_position_start");
                var maxPoint = (0, _type.isDefined)(max) ? translator.translate(max, that._translateWithOffset) : translator.translate("canvas_position_end");
                that._offset = _min(minPoint, maxPoint);
                that._scale = translator.getScale(min, max);
                that._applyPosition(_min(minPoint, maxPoint), _max(minPoint, maxPoint))
            },
            customPositionIsAvailable: function() {
                return false
            },
            dispose: function() {
                this._scroll.dispose();
                this._scroll = this._translator = null
            },
            _applyPosition: function(x1, x2) {
                var that = this;
                var visibleArea = that._translator.getCanvasVisibleArea();
                x1 = _max(x1, visibleArea.min);
                x1 = _min(x1, visibleArea.max);
                x2 = _min(x2, visibleArea.max);
                x2 = _max(x2, visibleArea.min);
                var height = Math.abs(x2 - x1);
                that._scroll.attr({
                    y: x1,
                    height: height < MIN_SCROLL_BAR_SIZE ? MIN_SCROLL_BAR_SIZE : height
                })
            }
        };
        exports.ScrollBar = ScrollBar
    },
    /*!*******************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/shutter_zoom.js ***!
      \*******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dragEvents = __webpack_require__( /*! ../../events/drag */ 69);
        var SHUTTER_EVENTS_NS = ".shutter-zoom";
        var DRAG_START_EVENT_NAME = dragEvents.start + SHUTTER_EVENTS_NS;
        var DRAG_UPDATE_EVENT_NAME = dragEvents.move + SHUTTER_EVENTS_NS;
        var DRAG_END_EVENT_NAME = dragEvents.end + SHUTTER_EVENTS_NS;

        function getPointerCoord(rootOffset, canvas, rotated, e) {
            var coord = Math.floor(rotated ? e.pageY - rootOffset.top : e.pageX - rootOffset.left);
            var min = rotated ? canvas.y1 : canvas.x1;
            var max = rotated ? canvas.y2 : canvas.x2;
            if (coord < min) {
                coord = min
            } else {
                if (coord > max) {
                    coord = max
                }
            }
            return coord
        }

        function checkCoords(rootOffset, canvas, e) {
            var x = e.pageX - rootOffset.left;
            var y = e.pageY - rootOffset.top;
            return x >= canvas.x1 && x <= canvas.x2 && y >= canvas.y1 && y <= canvas.y2
        }

        function dragStartHandler(ctx) {
            return function(e) {
                var offset = ctx.getRootOffset();
                var canvas = ctx.getCanvas();
                if (!checkCoords(offset, canvas, e)) {
                    e.cancel = true;
                    return
                }
                ctx.rootOffset = offset;
                ctx.canvas = canvas;
                ctx.startCoord = getPointerCoord(offset, canvas, ctx.rotated, e);
                ctx.triggerStart();
                ctx.rect.attr({
                    x: canvas.x1,
                    y: canvas.y1,
                    width: canvas.width,
                    height: canvas.height
                }).append(ctx.root)
            }
        }

        function dragHandler(ctx) {
            return function(e) {
                var curCoord = getPointerCoord(ctx.rootOffset, ctx.canvas, ctx.rotated, e);
                var attr = {};
                ctx.curCoord = curCoord;
                attr[ctx.rotated ? "y" : "x"] = Math.min(ctx.startCoord, curCoord);
                attr[ctx.rotated ? "height" : "width"] = Math.abs(ctx.startCoord - curCoord);
                ctx.rect.attr(attr)
            }
        }

        function dragEndHandler(ctx) {
            return function(e) {
                ctx.triggerEnd();
                ctx.rect.remove()
            }
        }

        function shutterZoom(options) {
            var chart = options.chart;
            var renderer = options.renderer;
            var rotated = options.rotated;
            var rect = renderer.rect(0, 0, 0, 0).attr(options.shutterOptions);
            var shutter = {
                rect: rect,
                root: renderer.root,
                rotated: rotated,
                triggerStart: function() {
                    chart._eventTrigger("zoomStart")
                },
                triggerEnd: function() {
                    var tr = chart._argumentAxes[0].getTranslator();
                    var rangeStart = Math.min(this.startCoord, this.curCoord);
                    var rangeEnd = Math.max(this.startCoord, this.curCoord);
                    chart._eventTrigger("zoomEnd", {
                        rangeStart: tr.from(rangeStart),
                        rangeEnd: tr.from(rangeEnd)
                    })
                },
                dispose: function() {
                    renderer.root.off(SHUTTER_EVENTS_NS);
                    rect.dispose()
                },
                getRootOffset: function() {
                    return renderer.getRootOffset()
                },
                getCanvas: function() {
                    var canvas = chart._canvas;
                    var panes = chart.panes;
                    var firstPane = panes[0].canvas;
                    var lastPane = panes[panes.length - 1].canvas;
                    return {
                        x1: firstPane.left,
                        y1: firstPane.top,
                        x2: canvas.width - lastPane.right,
                        y2: canvas.height - lastPane.bottom,
                        width: canvas.width - firstPane.left - lastPane.right,
                        height: canvas.height - firstPane.top - lastPane.bottom
                    }
                }
            };
            renderer.root.off(SHUTTER_EVENTS_NS).on(DRAG_START_EVENT_NAME, {
                direction: rotated ? "vertical" : "horizontal",
                immediate: true
            }, dragStartHandler(shutter)).on(DRAG_UPDATE_EVENT_NAME, dragHandler(shutter)).on(DRAG_END_EVENT_NAME, dragEndHandler(shutter));
            return shutter
        }
        module.exports = {
            name: "shutter_zoom",
            init: function() {
                var options = this.option("shutterZoom") || {};
                if (!options.enabled) {
                    return
                }
                this._shutterZoom = shutterZoom({
                    chart: this,
                    renderer: this._renderer,
                    rotated: this.option("rotated"),
                    shutterOptions: options
                })
            },
            dispose: function() {
                this._shutterZoom && this._shutterZoom.dispose()
            }
        }
    },
    /*!*******************************************************************!*\
      !*** ./artifacts/transpiled/viz/chart_components/zoom_and_pan.js ***!
      \*******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _wheel = __webpack_require__( /*! ../../events/core/wheel */ 133);
        var _transform = __webpack_require__( /*! ../../events/transform */ 303);
        var _transform2 = _interopRequireDefault(_transform);
        var _drag = __webpack_require__( /*! ../../events/drag */ 69);
        var _drag2 = _interopRequireDefault(_drag);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var EVENTS_NS = ".zoomAndPanNS";
        var DRAG_START_EVENT_NAME = _drag2.default.start + EVENTS_NS;
        var DRAG_EVENT_NAME = _drag2.default.move + EVENTS_NS;
        var DRAG_END_EVENT_NAME = _drag2.default.end + EVENTS_NS;
        var PINCH_START_EVENT_NAME = _transform2.default.pinchstart + EVENTS_NS;
        var PINCH_EVENT_NAME = _transform2.default.pinch + EVENTS_NS;
        var PINCH_END_EVENT_NAME = _transform2.default.pinchend + EVENTS_NS;
        var SCROLL_BAR_START_EVENT_NAME = "dxc-scroll-start" + EVENTS_NS;
        var SCROLL_BAR_MOVE_EVENT_NAME = "dxc-scroll-move" + EVENTS_NS;
        var SCROLL_BAR_END_EVENT_NAME = "dxc-scroll-end" + EVENTS_NS;
        var GESTURE_TIMEOUT = 300;
        var MIN_DRAG_DELTA = 5;
        var _min = Math.min;
        var _max = Math.max;
        var _abs = Math.abs;

        function canvasToRect(canvas) {
            return {
                x: canvas.left,
                y: canvas.top,
                width: canvas.width - canvas.left - canvas.right,
                height: canvas.height - canvas.top - canvas.bottom
            }
        }

        function checkCoords(rect, coords) {
            var x = coords.x;
            var y = coords.y;
            return x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.height + rect.y
        }

        function sortAxes(axes, onlyAxisToNotify) {
            if (onlyAxisToNotify) {
                axes = axes.sort(function(a, b) {
                    if (a === onlyAxisToNotify) {
                        return -1
                    }
                    if (b === onlyAxisToNotify) {
                        return 1
                    }
                    return 0
                })
            }
            return axes
        }

        function isNotEmptyAxisBusinessRange(axis) {
            return !axis.getTranslator().getBusinessRange().isEmpty()
        }
        module.exports = {
            name: "zoom_and_pan",
            init: function() {
                var chart = this;
                var renderer = this._renderer;

                function cancelEvent(e) {
                    if (e.originalEvent) {
                        cancelEvent(e.originalEvent)
                    }
                    if (false !== e.cancelable) {
                        e.cancel = true
                    }
                }

                function startAxesViewportChanging(zoomAndPan, actionField, e) {
                    var options = zoomAndPan.options;
                    var actionData = zoomAndPan.actionData;
                    var axes = [];
                    if (options.argumentAxis[actionField]) {
                        axes.push(chart.getArgumentAxis())
                    }
                    if (options.valueAxis[actionField]) {
                        axes = axes.concat(actionData.valueAxes)
                    }
                    axes.reduce(function(isPrevented, axis) {
                        if (isPrevented) {
                            return isPrevented
                        }
                        if (isNotEmptyAxisBusinessRange(axis)) {
                            return axis.handleZooming(null, {
                                end: true
                            }, e, actionField).isPrevented
                        }
                        return isPrevented
                    }, false) && cancelEvent(e)
                }

                function axesViewportChanging(zoomAndPan, actionField, e, offsetCalc, centerCalc) {
                    function zoomAxes(axes, criteria, coordField, e, actionData) {
                        var zoom = {
                            zoomed: false
                        };
                        criteria && axes.filter(isNotEmptyAxisBusinessRange).forEach(function(axis) {
                            var options = axis.getOptions();
                            var viewport = axis.visualRange();
                            var scale = axis.getTranslator().getEventScale(e);
                            var translate = -offsetCalc(e, actionData, coordField, scale);
                            zoom = (0, _extend.extend)(true, zoom, axis.getTranslator().zoom(translate, scale, axis.getZoomBounds()));
                            var range = axis.adjustRange((0, _utils.getVizRangeObject)([zoom.min, zoom.max]));
                            var isMinZoom = axis.isZoomingLowerLimitOvercome(actionField, scale, range);
                            if (!(0, _type.isDefined)(viewport) || viewport.startValue.valueOf() !== range.startValue.valueOf() || viewport.endValue.valueOf() !== range.endValue.valueOf()) {
                                axis.handleZooming(isMinZoom ? null : range, {
                                    start: true,
                                    end: true
                                }, e, actionField);
                                if (!isMinZoom) {
                                    zoom.zoomed = true;
                                    zoom.deltaTranslate = translate - zoom.translate
                                }
                            } else {
                                if ("touch" === e.pointerType && "discrete" === options.type) {
                                    var isMinPosition = axis.isExtremePosition(false);
                                    var isMaxPosition = axis.isExtremePosition(true);
                                    var zoomInEnabled = scale > 1 && !isMinZoom;
                                    var zoomOutEnabled = scale < 1 && (!isMinPosition || !isMaxPosition);
                                    var panningEnabled = 1 === scale && !(isMinPosition && (translate < 0 && !options.inverted || translate > 0 && options.inverted) || isMaxPosition && (translate > 0 && !options.inverted || translate < 0 && options.inverted));
                                    zoom.enabled = zoomInEnabled || zoomOutEnabled || panningEnabled
                                }
                            }
                        });
                        return zoom
                    }

                    function storeOffset(e, actionData, zoom, coordField) {
                        if (zoom.zoomed) {
                            actionData.offset[coordField] = (e.offset ? e.offset[coordField] : actionData.offset[coordField]) + zoom.deltaTranslate
                        }
                    }

                    function storeCenter(center, actionData, zoom, coordField) {
                        if (zoom.zoomed) {
                            actionData.center[coordField] = center[coordField] + zoom.deltaTranslate
                        }
                    }
                    var rotated = chart.option("rotated");
                    var actionData = zoomAndPan.actionData;
                    var options = zoomAndPan.options;
                    var argZoom = {};
                    var valZoom = {};
                    if (!actionData.fallback) {
                        argZoom = zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? "y" : "x", e, actionData);
                        valZoom = zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? "x" : "y", e, actionData);
                        chart._requestChange(["VISUAL_RANGE"]);
                        storeOffset(e, actionData, argZoom, rotated ? "y" : "x");
                        storeOffset(e, actionData, valZoom, rotated ? "x" : "y")
                    }
                    var center = centerCalc(e);
                    storeCenter(center, actionData, argZoom, rotated ? "y" : "x");
                    storeCenter(center, actionData, valZoom, rotated ? "x" : "y");
                    if (!argZoom.zoomed && !valZoom.zoomed) {
                        actionData.center = center
                    }
                    return argZoom.zoomed || valZoom.zoomed || actionData.fallback || argZoom.enabled || valZoom.enabled
                }

                function finishAxesViewportChanging(zoomAndPan, actionField, e, offsetCalc) {
                    function zoomAxes(axes, criteria, coordField, e, actionData, onlyAxisToNotify) {
                        var zoomStarted = false;
                        criteria && axes.forEach(function(axis) {
                            var silent = onlyAxisToNotify && axis !== onlyAxisToNotify;
                            var scale = e.scale || 1;
                            var zoom = axis.getTranslator().zoom(-offsetCalc(e, actionData, coordField, scale), scale, axis.getZoomBounds());
                            var range = {
                                startValue: zoom.min,
                                endValue: zoom.max
                            };
                            var isMinZoom = axis.isZoomingLowerLimitOvercome(actionField, scale, range);
                            axis.handleZooming(isMinZoom ? null : range, {
                                start: true,
                                end: silent
                            }, e, actionField);
                            isMinZoom ? axis.handleZoomEnd() : zoomStarted = true
                        });
                        return zoomStarted
                    }
                    var rotated = chart.option("rotated");
                    var actionData = zoomAndPan.actionData;
                    var options = zoomAndPan.options;
                    var zoomStarted = true;
                    if (actionData.fallback) {
                        zoomStarted &= zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? "y" : "x", e, actionData, chart.getArgumentAxis());
                        zoomStarted |= zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? "x" : "y", e, actionData)
                    } else {
                        var axes = [];
                        if (options.argumentAxis[actionField]) {
                            axes.push(chart.getArgumentAxis())
                        }
                        if (options.valueAxis[actionField]) {
                            axes = axes.concat(actionData.valueAxes)
                        }
                        axes.filter(isNotEmptyAxisBusinessRange).forEach(function(axis) {
                            axis.handleZooming(null, {
                                start: true
                            }, e, actionField)
                        });
                        zoomStarted = zoomStarted && axes.length
                    }
                    zoomStarted && chart._requestChange(["VISUAL_RANGE"])
                }

                function prepareActionData(coords, action) {
                    var axes = chart._argumentAxes.filter(function(axis) {
                        return checkCoords(canvasToRect(axis.getCanvas()), coords)
                    });
                    return {
                        fallback: chart._lastRenderingTime > GESTURE_TIMEOUT,
                        cancel: !axes.length || !(0, _type.isDefined)(action),
                        action: action,
                        curAxisRect: axes.length && canvasToRect(axes[0].getCanvas()),
                        valueAxes: axes.length && chart._valueAxes.filter(function(axis) {
                            return checkCoords(canvasToRect(axis.getCanvas()), coords)
                        }),
                        offset: {
                            x: 0,
                            y: 0
                        },
                        center: coords,
                        startCenter: coords
                    }
                }

                function getPointerCoord(rect, e) {
                    var rootOffset = renderer.getRootOffset();
                    return {
                        x: _min(_max(e.pageX - rootOffset.left, rect.x), rect.width + rect.x),
                        y: _min(_max(e.pageY - rootOffset.top, rect.y), rect.height + rect.y)
                    }
                }

                function calcCenterForPinch(e) {
                    var rootOffset = renderer.getRootOffset();
                    var x1 = e.pointers[0].pageX;
                    var x2 = e.pointers[1].pageX;
                    var y1 = e.pointers[0].pageY;
                    var y2 = e.pointers[1].pageY;
                    return {
                        x: _min(x1, x2) + _abs(x2 - x1) / 2 - rootOffset.left,
                        y: _min(y1, y2) + _abs(y2 - y1) / 2 - rootOffset.top
                    }
                }

                function calcCenterForDrag(e) {
                    var rootOffset = renderer.getRootOffset();
                    return {
                        x: e.pageX - rootOffset.left,
                        y: e.pageY - rootOffset.top
                    }
                }

                function calcOffsetForDrag(e, actionData, coordField) {
                    return e.offset[coordField] - actionData.offset[coordField]
                }

                function preventDefaults(e) {
                    if (false !== e.cancelable) {
                        e.preventDefault();
                        e.stopPropagation()
                    }
                    chart._stopCurrentHandling()
                }
                var zoomAndPan = {
                    dragStartHandler: function(e) {
                        var options = zoomAndPan.options;
                        var isTouch = "touch" === e.pointerType;
                        var wantPan = options.argumentAxis.pan || options.valueAxis.pan;
                        var wantZoom = options.argumentAxis.zoom || options.valueAxis.zoom;
                        var panKeyPressed = (0, _type.isDefined)(options.panKey) && e[(0, _utils.normalizeEnum)(options.panKey) + "Key"];
                        var dragToZoom = options.dragToZoom;
                        var action;
                        e._cancelPreventDefault = true;
                        if (isTouch) {
                            if (options.allowTouchGestures && wantPan) {
                                var cancelPanning = !zoomAndPan.panningVisualRangeEnabled() || zoomAndPan.skipEvent;
                                action = cancelPanning ? null : "pan"
                            }
                        } else {
                            if (dragToZoom && wantPan && panKeyPressed) {
                                action = "pan"
                            } else {
                                if (!dragToZoom && wantPan) {
                                    action = "pan"
                                } else {
                                    if (dragToZoom && wantZoom) {
                                        action = "zoom"
                                    }
                                }
                            }
                        }
                        var actionData = prepareActionData(calcCenterForDrag(e), action);
                        if (actionData.cancel) {
                            zoomAndPan.skipEvent = false;
                            if (false !== e.cancelable) {
                                e.cancel = true
                            }
                            return
                        }
                        zoomAndPan.actionData = actionData;
                        if ("zoom" === action) {
                            actionData.startCoords = getPointerCoord(actionData.curAxisRect, e);
                            actionData.rect = renderer.rect(0, 0, 0, 0).attr(options.dragBoxStyle).append(renderer.root)
                        } else {
                            startAxesViewportChanging(zoomAndPan, "pan", e)
                        }
                    },
                    dragHandler: function(e) {
                        var rotated = chart.option("rotated");
                        var options = zoomAndPan.options;
                        var actionData = zoomAndPan.actionData;
                        var isTouch = "touch" === e.pointerType;
                        e._cancelPreventDefault = true;
                        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled()) {
                            return
                        }
                        if ("zoom" === actionData.action) {
                            preventDefaults(e);
                            var curCanvas = actionData.curAxisRect;
                            var startCoords = actionData.startCoords;
                            var curCoords = getPointerCoord(curCanvas, e);
                            var zoomArg = options.argumentAxis.zoom;
                            var zoomVal = options.valueAxis.zoom;
                            var rect = {
                                x: _min(startCoords.x, curCoords.x),
                                y: _min(startCoords.y, curCoords.y),
                                width: _abs(startCoords.x - curCoords.x),
                                height: _abs(startCoords.y - curCoords.y)
                            };
                            if (!zoomArg || !zoomVal) {
                                if (!zoomArg && !rotated || !zoomVal && rotated) {
                                    rect.x = curCanvas.x;
                                    rect.width = curCanvas.width
                                } else {
                                    rect.y = curCanvas.y;
                                    rect.height = curCanvas.height
                                }
                            }
                            actionData.rect.attr(rect)
                        } else {
                            if ("pan" === actionData.action) {
                                axesViewportChanging(zoomAndPan, "pan", e, calcOffsetForDrag, function(e) {
                                    return e.offset
                                });
                                var deltaOffsetY = Math.abs(e.offset.y - actionData.offset.y);
                                var deltaOffsetX = Math.abs(e.offset.x - actionData.offset.x);
                                if (isTouch && (deltaOffsetY > MIN_DRAG_DELTA && deltaOffsetY > Math.abs(actionData.offset.x) || deltaOffsetX > MIN_DRAG_DELTA && deltaOffsetX > Math.abs(actionData.offset.y))) {
                                    return
                                }
                                preventDefaults(e)
                            }
                        }
                    },
                    dragEndHandler: function(e) {
                        var rotated = chart.option("rotated");
                        var options = zoomAndPan.options;
                        var actionData = zoomAndPan.actionData;
                        var isTouch = "touch" === e.pointerType;
                        var panIsEmpty = actionData && "pan" === actionData.action && !actionData.fallback && 0 === actionData.offset.x && 0 === actionData.offset.y;
                        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled() || panIsEmpty) {
                            return
                        }(!isTouch || !zoomAndPan.actionData.isNative) && preventDefaults(e);
                        if ("zoom" === actionData.action) {
                            var zoomAxes = function(axes, criteria, coordField, startCoords, curCoords, onlyAxisToNotify) {
                                axes = sortAxes(axes, onlyAxisToNotify);
                                var curCoord = curCoords[coordField];
                                var startCoord = startCoords[coordField];
                                var zoomStarted = false;
                                if (criteria && _abs(curCoord - startCoord) > MIN_DRAG_DELTA) {
                                    axes.some(function(axis) {
                                        var tr = axis.getTranslator();
                                        if (tr.getBusinessRange().isEmpty()) {
                                            return
                                        }
                                        var silent = onlyAxisToNotify && axis !== onlyAxisToNotify;
                                        var range = [tr.from(startCoord), tr.from(curCoord)];
                                        var isMinZoom = axis.isZoomingLowerLimitOvercome(actionData.action, tr.getMinScale(true), range);
                                        var result = axis.handleZooming(isMinZoom ? null : range, {
                                            start: !!silent,
                                            end: !!silent
                                        }, e, actionData.action);
                                        isMinZoom ? axis.handleZoomEnd() : zoomStarted = true;
                                        return onlyAxisToNotify && result.isPrevented
                                    })
                                }
                                return zoomStarted
                            };
                            var curCoords = getPointerCoord(actionData.curAxisRect, e);
                            var argumentAxesZoomed = zoomAxes(chart._argumentAxes, options.argumentAxis.zoom, rotated ? "y" : "x", actionData.startCoords, curCoords, chart.getArgumentAxis());
                            var valueAxesZoomed = zoomAxes(actionData.valueAxes, options.valueAxis.zoom, rotated ? "x" : "y", actionData.startCoords, curCoords);
                            if (valueAxesZoomed || argumentAxesZoomed) {
                                chart._requestChange(["VISUAL_RANGE"])
                            }
                            actionData.rect.dispose()
                        } else {
                            if ("pan" === actionData.action) {
                                finishAxesViewportChanging(zoomAndPan, "pan", e, calcOffsetForDrag)
                            }
                        }
                        zoomAndPan.actionData = null
                    },
                    pinchStartHandler: function(e) {
                        var actionData = prepareActionData(calcCenterForPinch(e), "zoom");
                        actionData.isNative = !zoomAndPan.panningVisualRangeEnabled();
                        if (actionData.cancel) {
                            cancelEvent(e);
                            return
                        }
                        zoomAndPan.actionData = actionData;
                        startAxesViewportChanging(zoomAndPan, "zoom", e)
                    },
                    pinchHandler: function(e) {
                        if (!zoomAndPan.actionData) {
                            return
                        }
                        var viewportChanged = axesViewportChanging(zoomAndPan, "zoom", e, function(e, actionData, coordField, scale) {
                            return calcCenterForPinch(e)[coordField] - actionData.center[coordField] + (actionData.center[coordField] - actionData.center[coordField] * scale)
                        }, calcCenterForPinch);
                        zoomAndPan.defineTouchBehavior(!viewportChanged, e);
                        !viewportChanged && (zoomAndPan.actionData = null)
                    },
                    pinchEndHandler: function(e) {
                        if (!zoomAndPan.actionData) {
                            return
                        }
                        finishAxesViewportChanging(zoomAndPan, "zoom", e, function(e, actionData, coordField, scale) {
                            return actionData.center[coordField] - actionData.startCenter[coordField] + (actionData.startCenter[coordField] - actionData.startCenter[coordField] * scale)
                        });
                        zoomAndPan.actionData = null
                    },
                    cleanup: function() {
                        renderer.root.off(EVENTS_NS);
                        zoomAndPan.actionData && zoomAndPan.actionData.rect && zoomAndPan.actionData.rect.dispose();
                        zoomAndPan.actionData = null;
                        renderer.root.css({
                            "touch-action": "",
                            "-ms-touch-action": ""
                        })
                    },
                    setup: function(options) {
                        zoomAndPan.cleanup();
                        if (!options.argumentAxis.pan) {
                            renderer.root.on(SCROLL_BAR_START_EVENT_NAME, cancelEvent)
                        }
                        if (options.argumentAxis.none && options.valueAxis.none) {
                            return
                        }
                        zoomAndPan.options = options;
                        var rotated = chart.option("rotated");
                        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowMouseWheel) {
                            renderer.root.on(_wheel.name + EVENTS_NS, function(e) {
                                function zoomAxes(axes, coord, delta, onlyAxisToNotify) {
                                    axes = sortAxes(axes, onlyAxisToNotify);
                                    var zoomStarted = false;
                                    axes.some(function(axis) {
                                        var translator = axis.getTranslator();
                                        if (translator.getBusinessRange().isEmpty()) {
                                            return
                                        }
                                        var silent = onlyAxisToNotify && axis !== onlyAxisToNotify;
                                        var scale = translator.getMinScale(delta > 0);
                                        var zoom = translator.zoom(-(coord - coord * scale), scale, axis.getZoomBounds());
                                        var range = {
                                            startValue: zoom.min,
                                            endValue: zoom.max
                                        };
                                        var isMinZoom = axis.isZoomingLowerLimitOvercome("zoom", scale, range);
                                        var result = axis.handleZooming(isMinZoom ? null : range, {
                                            start: !!silent,
                                            end: !!silent
                                        }, e, "zoom");
                                        isMinZoom ? axis.handleZoomEnd() : zoomStarted = true;
                                        return onlyAxisToNotify && result.isPrevented
                                    });
                                    return !!zoomStarted
                                }
                                var coords = calcCenterForDrag(e);
                                var axesZoomed = false;
                                var targetAxes;
                                if (options.valueAxis.zoom) {
                                    targetAxes = chart._valueAxes.filter(function(axis) {
                                        return checkCoords(canvasToRect(axis.getCanvas()), coords)
                                    });
                                    if (0 === targetAxes.length) {
                                        var targetCanvas = chart._valueAxes.reduce(function(r, axis) {
                                            if (!r && axis.coordsIn(coords.x, coords.y)) {
                                                r = axis.getCanvas()
                                            }
                                            return r
                                        }, null);
                                        if (targetCanvas) {
                                            targetAxes = chart._valueAxes.filter(function(axis) {
                                                return checkCoords(canvasToRect(axis.getCanvas()), {
                                                    x: targetCanvas.left,
                                                    y: targetCanvas.top
                                                })
                                            })
                                        }
                                    }
                                    axesZoomed |= zoomAxes(targetAxes, rotated ? coords.x : coords.y, e.delta)
                                }
                                if (options.argumentAxis.zoom) {
                                    var canZoom = chart._argumentAxes.some(function(axis) {
                                        if (checkCoords(canvasToRect(axis.getCanvas()), coords) || axis.coordsIn(coords.x, coords.y)) {
                                            return true
                                        }
                                        return false
                                    });
                                    axesZoomed |= canZoom && zoomAxes(chart._argumentAxes, rotated ? coords.y : coords.x, e.delta, chart.getArgumentAxis())
                                }
                                if (axesZoomed) {
                                    chart._requestChange(["VISUAL_RANGE"]);
                                    zoomAndPan.panningVisualRangeEnabled(targetAxes) && preventDefaults(e)
                                }
                            })
                        }
                        if (options.allowTouchGestures) {
                            if (options.argumentAxis.zoom || options.valueAxis.zoom) {
                                renderer.root.on(PINCH_START_EVENT_NAME, {
                                    passive: false
                                }, zoomAndPan.pinchStartHandler).on(PINCH_EVENT_NAME, {
                                    passive: false
                                }, zoomAndPan.pinchHandler).on(PINCH_END_EVENT_NAME, zoomAndPan.pinchEndHandler)
                            }
                        }
                        renderer.root.on(DRAG_START_EVENT_NAME, {
                            immediate: true,
                            passive: false
                        }, zoomAndPan.dragStartHandler).on(DRAG_EVENT_NAME, {
                            immediate: true,
                            passive: false
                        }, zoomAndPan.dragHandler).on(DRAG_END_EVENT_NAME, zoomAndPan.dragEndHandler);
                        if (options.argumentAxis.pan) {
                            renderer.root.on(SCROLL_BAR_START_EVENT_NAME, function(e) {
                                zoomAndPan.actionData = {
                                    valueAxes: [],
                                    offset: {
                                        x: 0,
                                        y: 0
                                    },
                                    center: {
                                        x: 0,
                                        y: 0
                                    }
                                };
                                preventDefaults(e);
                                startAxesViewportChanging(zoomAndPan, "pan", e)
                            }).on(SCROLL_BAR_MOVE_EVENT_NAME, function(e) {
                                preventDefaults(e);
                                axesViewportChanging(zoomAndPan, "pan", e, calcOffsetForDrag, function(e) {
                                    return e.offset
                                })
                            }).on(SCROLL_BAR_END_EVENT_NAME, function(e) {
                                preventDefaults(e);
                                finishAxesViewportChanging(zoomAndPan, "pan", e, calcOffsetForDrag);
                                zoomAndPan.actionData = null
                            })
                        }
                    },
                    defineTouchBehavior: function(isDefault, e) {
                        zoomAndPan.actionData && (zoomAndPan.actionData.isNative = isDefault);
                        if (!isDefault) {
                            preventDefaults(e)
                        }
                    },
                    panningVisualRangeEnabled: function(targetAxes) {
                        if (null === targetAxes || void 0 === targetAxes ? void 0 : targetAxes.length) {
                            return targetAxes.some(function(axis) {
                                return !axis.isExtremePosition(false) || !axis.isExtremePosition(true)
                            })
                        }
                        var enablePanByValueAxis = chart._valueAxes.some(function(axis) {
                            return !axis.isExtremePosition(false) || !axis.isExtremePosition(true)
                        });
                        var enablePanByArgumentAxis = chart._argumentAxes.some(function(axis) {
                            return !axis.isExtremePosition(false) || !axis.isExtremePosition(true)
                        });
                        return enablePanByValueAxis || enablePanByArgumentAxis
                    }
                };
                this._zoomAndPan = zoomAndPan
            },
            members: {
                _setupZoomAndPan: function() {
                    this._zoomAndPan.setup(this._themeManager.getOptions("zoomAndPan"))
                }
            },
            dispose: function() {
                this._zoomAndPan.cleanup()
            },
            customize: function(constructor) {
                constructor.addChange({
                    code: "ZOOM_AND_PAN",
                    handler: function() {
                        this._setupZoomAndPan()
                    },
                    isThemeDependent: true,
                    isOptionChange: true,
                    option: "zoomAndPan"
                })
            }
        }
    },
    /*!***********************************************!*\
      !*** ./artifacts/transpiled/viz/pie_chart.js ***!
      \***********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _consts = __webpack_require__( /*! ./components/consts */ 125);
        var _utils = __webpack_require__( /*! ./core/utils */ 13);
        var _extend2 = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);
        var _iterator = __webpack_require__( /*! ../core/utils/iterator */ 4);
        var _range = __webpack_require__( /*! ./translators/range */ 112);
        var _range2 = _interopRequireDefault(_range);
        var _component_registrator = __webpack_require__( /*! ../core/component_registrator */ 9);
        var _component_registrator2 = _interopRequireDefault(_component_registrator);
        var _base_chart = __webpack_require__( /*! ./chart_components/base_chart */ 256);
        var _common = __webpack_require__( /*! ../core/utils/common */ 3);
        var _translator1d = __webpack_require__( /*! ./translators/translator1d */ 430);
        var _translator1d2 = _interopRequireDefault(_translator1d);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var OPTIONS_FOR_REFRESH_SERIES = ["startAngle", "innerRadius", "segmentsDirection", "type"];
        var NORMAL_STATE = _consts.states.normalMark;
        var HOVER_STATE = _consts.states.hoverMark;
        var SELECTED_STATE = _consts.states.selectedMark;
        var MAX_RESOLVE_ITERATION_COUNT = 5;
        var LEGEND_ACTIONS = [_consts.states.resetItem, _consts.states.applyHover, _consts.states.applySelected, _consts.states.applySelected];

        function getLegendItemAction(points) {
            var state = NORMAL_STATE;
            points.forEach(function(point) {
                var _point$series;
                var seriesOptions = null === (_point$series = point.series) || void 0 === _point$series ? void 0 : _point$series.getOptions();
                var pointState = point.fullState;
                if ("none" === (null === seriesOptions || void 0 === seriesOptions ? void 0 : seriesOptions.hoverMode)) {
                    pointState &= ~HOVER_STATE
                }
                if ("none" === (null === seriesOptions || void 0 === seriesOptions ? void 0 : seriesOptions.selectionMode)) {
                    pointState &= ~SELECTED_STATE
                }
                state |= pointState
            });
            return LEGEND_ACTIONS[state]
        }

        function correctPercentValue(value) {
            if ((0, _type.isNumeric)(value)) {
                if (value > 1) {
                    value = 1
                } else {
                    if (value < 0) {
                        value = 0
                    }
                }
            } else {
                value = void 0
            }
            return value
        }
        var pieSizeEqualizer = function() {
            function equalize(group, allPies) {
                var pies = allPies.filter(function(p) {
                    return p._isVisible() && p.getSizeGroup() === group
                });
                var minRadius = Math.min.apply(null, pies.map(function(p) {
                    return p.getSizeGroupLayout().radius
                }));
                var minPie = pies.filter(function(p) {
                    return p.getSizeGroupLayout().radius === minRadius
                });
                pies.forEach(function(p) {
                    return p.render({
                        force: true,
                        sizeGroupLayout: minPie.length ? minPie[0].getSizeGroupLayout() : {}
                    })
                })
            }

            function removeFromList(list, item) {
                return list.filter(function(li) {
                    return li !== item
                })
            }

            function addToList(list, item) {
                return removeFromList(list, item).concat(item)
            }
            var pies = [];
            var timers = {};
            return {
                queue: function(pie) {
                    var group = pie.getSizeGroup();
                    pies = addToList(pies, pie);
                    clearTimeout(timers[group]);
                    timers[group] = setTimeout(function() {
                        equalize(group, pies)
                    })
                },
                remove: function(pie) {
                    pies = removeFromList(pies, pie);
                    if (!pies.length) {
                        timers = {}
                    }
                }
            }
        }();
        var dxPieChart = _base_chart.BaseChart.inherit({
            _themeSection: "pie",
            _layoutManagerOptions: function() {
                return (0, _extend2.extend)(true, {}, this.callBase(), {
                    piePercentage: correctPercentValue(this._themeManager.getOptions("diameter")),
                    minPiePercentage: correctPercentValue(this._themeManager.getOptions("minDiameter"))
                })
            },
            _optionChangesMap: {
                diameter: "REINIT",
                minDiameter: "REINIT",
                sizeGroup: "REINIT"
            },
            _disposeCore: function() {
                pieSizeEqualizer.remove(this);
                this.callBase()
            },
            _groupSeries: function() {
                var series = this.series;
                this._groupsData = {
                    groups: [{
                        series: series,
                        valueOptions: {
                            valueType: "numeric"
                        }
                    }],
                    argumentOptions: series[0] && series[0].getOptions()
                }
            },
            getArgumentAxis: function() {
                return null
            },
            _getValueAxis: function() {
                var translator = (new _translator1d2.default.Translator1D).setCodomain(360, 0);
                return {
                    getTranslator: function() {
                        return translator
                    },
                    setBusinessRange: function(range) {
                        translator.setDomain(range.min, range.max)
                    }
                }
            },
            _populateBusinessRange: function() {
                this.series.map(function(series) {
                    var range = new _range2.default.Range;
                    range.addRange(series.getRangeData().val);
                    series.getValueAxis().setBusinessRange(range);
                    return range
                })
            },
            _specialProcessSeries: function() {
                (0, _iterator.each)(this.series, function(_, singleSeries) {
                    singleSeries.arrangePoints()
                })
            },
            _checkPaneName: function() {
                return true
            },
            _processSingleSeries: function(singleSeries) {
                this.callBase(singleSeries);
                singleSeries.arrangePoints()
            },
            _handleSeriesDataUpdated: function() {
                var maxPointCount = 0;
                this.series.forEach(function(s) {
                    maxPointCount = Math.max(s.getPointsCount(), maxPointCount)
                });
                this.series.forEach(function(s) {
                    s.setMaxPointsCount(maxPointCount)
                });
                this.callBase()
            },
            _getLegendOptions: function(item) {
                var legendItem = this.callBase(item);
                var legendData = legendItem.legendData;
                legendData.argument = item.argument;
                legendData.argumentIndex = item.argumentIndex;
                legendData.points = [item];
                return legendItem
            },
            _getLegendTargets: function() {
                var that = this;
                var itemsByArgument = {};
                (that.series || []).forEach(function(series) {
                    series.getPoints().forEach(function(point) {
                        var argument = point.argument.valueOf();
                        var index = series.getPointsByArg(argument).indexOf(point);
                        var key = argument.valueOf().toString() + index;
                        itemsByArgument[key] = itemsByArgument[key] || [];
                        var argumentCount = itemsByArgument[key].push(point);
                        point.index = itemsByArgument[key][argumentCount - 2] ? itemsByArgument[key][argumentCount - 2].index : Object.keys(itemsByArgument).length - 1;
                        point.argumentIndex = index
                    })
                });
                var items = [];
                (0, _iterator.each)(itemsByArgument, function(_, points) {
                    points.forEach(function(point, index) {
                        if (0 === index) {
                            items.push(that._getLegendOptions(point));
                            return
                        }
                        var item = items[items.length - 1];
                        item.legendData.points.push(point);
                        if (!item.visible) {
                            item.visible = point.isVisible()
                        }
                    })
                });
                return items
            },
            _getLayoutTargets: function() {
                return [{
                    canvas: this._canvas
                }]
            },
            _getLayoutSeries: function(series, drawOptions) {
                var that = this;
                var layout;
                var canvas = that._canvas;
                var drawnLabels = false;
                layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, true);
                series.forEach(function(singleSeries) {
                    singleSeries.correctPosition(layout, canvas);
                    drawnLabels = singleSeries.drawLabelsWOPoints() || drawnLabels
                });
                if (drawnLabels) {
                    layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, drawOptions.hideLayoutLabels)
                }
                series.forEach(function(singleSeries) {
                    singleSeries.hideLabels()
                });
                that._sizeGroupLayout = {
                    x: layout.centerX,
                    y: layout.centerY,
                    radius: layout.radiusOuter,
                    drawOptions: drawOptions
                };
                return layout
            },
            _getLayoutSeriesForEqualPies: function(series, sizeGroupLayout) {
                var canvas = this._canvas;
                var layout = this.layoutManager.applyEqualPieChartLayout(series, sizeGroupLayout);
                series.forEach(function(s) {
                    s.correctPosition(layout, canvas);
                    s.drawLabelsWOPoints()
                });
                this.layoutManager.correctPieLabelRadius(series, layout, canvas);
                return layout
            },
            _updateSeriesDimensions: function(drawOptions) {
                var that = this;
                var visibleSeries = that._getVisibleSeries();
                var lengthVisibleSeries = visibleSeries.length;
                var innerRad;
                var delta;
                var layout;
                var sizeGroupLayout = drawOptions.sizeGroupLayout;
                if (lengthVisibleSeries) {
                    layout = sizeGroupLayout ? that._getLayoutSeriesForEqualPies(visibleSeries, sizeGroupLayout) : that._getLayoutSeries(visibleSeries, drawOptions);
                    delta = (layout.radiusOuter - layout.radiusInner - _consts.pieSeriesSpacing * (lengthVisibleSeries - 1)) / lengthVisibleSeries;
                    innerRad = layout.radiusInner;
                    that._setGeometry(layout);
                    visibleSeries.forEach(function(singleSeries) {
                        singleSeries.correctRadius({
                            radiusInner: innerRad,
                            radiusOuter: innerRad + delta
                        });
                        innerRad += delta + _consts.pieSeriesSpacing
                    })
                }
            },
            _renderSeries: function(drawOptions, isRotated, isLegendInside) {
                this._calculateSeriesLayout(drawOptions, isRotated);
                if (!drawOptions.sizeGroupLayout && this.getSizeGroup()) {
                    pieSizeEqualizer.queue(this);
                    this._clearCanvas();
                    return
                }
                this._renderSeriesElements(drawOptions, isLegendInside)
            },
            _renderExtraElements: function() {
                var template = this.option("centerTemplate");
                if (this._centerTemplateGroup) {
                    this._centerTemplateGroup.clear()
                }
                if (!template) {
                    return
                }
                if (!this._centerTemplateGroup) {
                    this._centerTemplateGroup = this._renderer.g().attr({
                        "class": "dxc-hole-template"
                    }).css((0, _utils.patchFontOptions)(this._themeManager._font))
                }
                this._centerTemplateGroup.append(this._renderer.root);
                template = this._getTemplate(template);
                template.render({
                    model: this,
                    container: this._centerTemplateGroup.element
                });
                var bBox = this._centerTemplateGroup.getBBox();
                this._centerTemplateGroup.move(this._center.x - (bBox.x + bBox.width / 2), this._center.y - (bBox.y + bBox.height / 2))
            },
            getInnerRadius: function() {
                return this._innerRadius
            },
            _getLegendCallBack: function() {
                var that = this;
                var legend = this._legend;
                var items = this._getLegendTargets().map(function(i) {
                    return i.legendData
                });
                return function(target) {
                    items.forEach(function(data) {
                        var points = [];
                        var callback = legend.getActionCallback({
                            index: data.id
                        });
                        that.series.forEach(function(series) {
                            var seriesPoints = series.getPointsByKeys(data.argument, data.argumentIndex);
                            points.push.apply(points, seriesPoints)
                        });
                        if (target && target.argument === data.argument && target.argumentIndex === data.argumentIndex) {
                            points.push(target)
                        }
                        callback(getLegendItemAction(points))
                    })
                }
            },
            _locateLabels: function(resolveLabelOverlapping) {
                var iterationCount = 0;
                var labelsWereOverlapped;
                var wordWrapApplied;
                do {
                    wordWrapApplied = this._adjustSeriesLabels("shift" === resolveLabelOverlapping);
                    labelsWereOverlapped = this._resolveLabelOverlapping(resolveLabelOverlapping)
                } while ((labelsWereOverlapped || wordWrapApplied) && ++iterationCount < MAX_RESOLVE_ITERATION_COUNT)
            },
            _adjustSeriesLabels: function(moveLabelsFromCenter) {
                return this.series.reduce(function(r, s) {
                    return s.adjustLabels(moveLabelsFromCenter) || r
                }, false)
            },
            _applyExtraSettings: _common.noop,
            _resolveLabelOverlappingShift: function() {
                var that = this;
                var inverseDirection = "anticlockwise" === that.option("segmentsDirection");
                var seriesByPosition = that.series.reduce(function(r, s) {
                    (r[s.getOptions().label.position] || r.outside).push(s);
                    return r
                }, {
                    inside: [],
                    columns: [],
                    outside: []
                });
                var labelsOverlapped = false;
                if (seriesByPosition.inside.length > 0) {
                    labelsOverlapped = resolve(seriesByPosition.inside.reduce(function(r, singleSeries) {
                        return singleSeries.getVisiblePoints().reduce(function(r, point) {
                            r.left.push(point);
                            return r
                        }, r)
                    }, {
                        left: [],
                        right: []
                    }), shiftInColumnFunction) || labelsOverlapped
                }
                labelsOverlapped = seriesByPosition.columns.reduce(function(r, singleSeries) {
                    return resolve(dividePoints(singleSeries), shiftInColumnFunction) || r
                }, labelsOverlapped);
                if (seriesByPosition.outside.length > 0) {
                    labelsOverlapped = resolve(seriesByPosition.outside.reduce(function(r, singleSeries) {
                        return dividePoints(singleSeries, r)
                    }, null), shiftFunction) || labelsOverlapped
                }
                return labelsOverlapped;

                function dividePoints(series, points) {
                    return series.getVisiblePoints().reduce(function(r, point) {
                        var angle = (0, _utils.normalizeAngle)(point.middleAngle);
                        (angle <= 90 || angle >= 270 ? r.right : r.left).push(point);
                        return r
                    }, points || {
                        left: [],
                        right: []
                    })
                }

                function resolve(points, shiftCallback) {
                    var overlapped = false;
                    if (inverseDirection) {
                        points.left.reverse();
                        points.right.reverse()
                    }
                    overlapped = _base_chart.overlapping.resolveLabelOverlappingInOneDirection(points.left, that._canvas, false, shiftCallback);
                    return _base_chart.overlapping.resolveLabelOverlappingInOneDirection(points.right, that._canvas, false, shiftCallback) || overlapped
                }

                function shiftFunction(box, length) {
                    return (0, _utils.getVerticallyShiftedAngularCoords)(box, -length, that._center)
                }

                function shiftInColumnFunction(box, length) {
                    return {
                        x: box.x,
                        y: box.y - length
                    }
                }
            },
            _setGeometry: function(_ref) {
                var x = _ref.centerX,
                    y = _ref.centerY,
                    radiusInner = _ref.radiusInner;
                this._center = {
                    x: x,
                    y: y
                };
                this._innerRadius = radiusInner
            },
            _disposeSeries: function(seriesIndex) {
                this.callBase.apply(this, arguments);
                this._abstractSeries = null
            },
            _legendDataField: "point",
            _legendItemTextField: "argument",
            _applyPointMarkersAutoHiding: _common.noop,
            _renderTrackers: _common.noop,
            _trackerType: "PieTracker",
            _createScrollBar: _common.noop,
            _updateAxesLayout: _common.noop,
            _applyClipRects: _common.noop,
            _appendAdditionalSeriesGroups: _common.noop,
            _prepareToRender: _common.noop,
            _isLegendInside: _common.noop,
            _renderAxes: _common.noop,
            _shrinkAxes: _common.noop,
            _isRotated: _common.noop,
            _seriesPopulatedHandlerCore: _common.noop,
            _reinitAxes: _common.noop,
            _correctAxes: _common.noop,
            _getExtraOptions: function() {
                var that = this;
                return {
                    startAngle: that.option("startAngle"),
                    innerRadius: that.option("innerRadius"),
                    segmentsDirection: that.option("segmentsDirection"),
                    type: that.option("type")
                }
            },
            getSizeGroup: function() {
                return this._themeManager.getOptions("sizeGroup")
            },
            getSizeGroupLayout: function() {
                return this._sizeGroupLayout || {}
            }
        });
        (0, _iterator.each)(OPTIONS_FOR_REFRESH_SERIES, function(_, name) {
            dxPieChart.prototype._optionChangesMap[name] = "REFRESH_SERIES_DATA_INIT"
        });
        (0, _component_registrator2.default)("dxPieChart", dxPieChart);
        module.exports = dxPieChart
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/viz/polar_chart.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _common = __webpack_require__( /*! ../core/utils/common */ 3);
        var _component_registrator = __webpack_require__( /*! ../core/component_registrator */ 9);
        var _component_registrator2 = _interopRequireDefault(_component_registrator);
        var _extend = __webpack_require__( /*! ../core/utils/extend */ 0);
        var _utils = __webpack_require__( /*! ./core/utils */ 13);
        var _utils2 = _interopRequireDefault(_utils);
        var _advanced_chart = __webpack_require__( /*! ./chart_components/advanced_chart */ 423);
        var _type = __webpack_require__( /*! ../core/utils/type */ 1);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var DEFAULT_PANE_NAME = "default";
        var DOUBLE_PI_ANGLE = 360;
        var dxPolarChart = _advanced_chart.AdvancedChart.inherit({
            _themeSection: "polar",
            _createPanes: function() {
                this.callBase();
                return [{
                    name: DEFAULT_PANE_NAME
                }]
            },
            _checkPaneName: function() {
                return true
            },
            _getAxisRenderingOptions: function(typeSelector) {
                var isArgumentAxis = "argumentAxis" === typeSelector;
                var type = isArgumentAxis ? "circular" : "linear";
                var useSpiderWeb = this.option("useSpiderWeb");
                if (useSpiderWeb) {
                    type += "Spider"
                }
                return {
                    axisType: "polarAxes",
                    drawingType: type
                }
            },
            _prepareAxisOptions: function(typeSelector, axisOptions) {
                var isArgumentAxis = "argumentAxis" === typeSelector;
                var themeManager = this._themeManager;
                var axisUserOptions = this.option("argumentAxis");
                var argumentAxisOptions = themeManager.getOptions("argumentAxis", axisUserOptions) || {};
                var startAngle = isFinite(argumentAxisOptions.startAngle) ? _utils2.default.normalizeAngle(argumentAxisOptions.startAngle) : 0;
                return {
                    type: this.option("useSpiderWeb") && isArgumentAxis ? "discrete" : axisOptions.type,
                    isHorizontal: true,
                    showCustomBoundaryTicks: isArgumentAxis,
                    startAngle: startAngle,
                    endAngle: startAngle + 360
                }
            },
            _optionChangesMap: {
                useSpiderWeb: "AXES_AND_PANES"
            },
            _getExtraOptions: function() {
                return {
                    spiderWidget: this.option("useSpiderWeb")
                }
            },
            _prepareToRender: function() {
                this._appendAxesGroups();
                return {}
            },
            _calcCanvas: function() {
                var canvas = (0, _extend.extend)({}, this._canvas);
                var argumentAxis = this.getArgumentAxis();
                var margins = argumentAxis.getMargins();
                Object.keys(margins).forEach(function(margin) {
                    return canvas[margin] = canvas["original".concat(margin[0].toUpperCase()).concat(margin.slice(1))] + margins[margin]
                });
                return canvas
            },
            _renderAxes: function(drawOptions) {
                var that = this;
                var valueAxis = that._getValueAxis();
                var argumentAxis = that.getArgumentAxis();
                argumentAxis.draw(that._canvas);
                valueAxis.setSpiderTicks(argumentAxis.getSpiderTicks());
                var canvas = that._calcCanvas();
                argumentAxis.updateSize(canvas);
                valueAxis.draw(canvas);
                return canvas
            },
            _getValueAxis: function() {
                return this._valueAxes[0]
            },
            _shrinkAxes: function(sizeStorage) {
                var valueAxis = this._getValueAxis();
                var argumentAxis = this.getArgumentAxis();
                if (sizeStorage && (sizeStorage.width || sizeStorage.height)) {
                    argumentAxis.hideOuterElements();
                    var canvas = this._calcCanvas();
                    argumentAxis.updateSize(canvas);
                    valueAxis.updateSize(canvas)
                }
            },
            checkForMoreSpaceForPanesCanvas: function() {
                return this.layoutManager.needMoreSpaceForPanesCanvas([{
                    canvas: this.getArgumentAxis().getCanvas()
                }], this._isRotated())
            },
            _getLayoutTargets: function() {
                return [{
                    canvas: this._canvas
                }]
            },
            _getSeriesForPane: function() {
                return this.series
            },
            _applyClipRects: function() {
                var canvasClipRectID = this._getCanvasClipRectID();
                this._createClipPathForPane();
                this.getArgumentAxis().applyClipRects(this._getElementsClipRectID(), canvasClipRectID);
                this._getValueAxis().applyClipRects(this._getElementsClipRectID(), canvasClipRectID)
            },
            _createClipPathForPane: function() {
                var that = this;
                var valueAxis = that._getValueAxis();
                var center = valueAxis.getCenter();
                var radius = valueAxis.getRadius();
                var panesClipRects = that._panesClipRects;
                center = {
                    x: Math.round(center.x),
                    y: Math.round(center.y)
                };
                that._createClipCircle(panesClipRects.fixed, center.x, center.y, radius);
                that._createClipCircle(panesClipRects.base, center.x, center.y, radius);
                if (that.series.some(function(s) {
                        return s.areErrorBarsVisible()
                    })) {
                    that._createClipCircle(panesClipRects.wide, center.x, center.y, radius)
                } else {
                    panesClipRects.wide[0] = null
                }
            },
            _createClipCircle: function(clipArray, left, top, radius) {
                var that = this;
                var clipCircle = clipArray[0];
                if (!clipCircle) {
                    clipCircle = that._renderer.clipCircle(left, top, radius);
                    clipArray[0] = clipCircle
                } else {
                    clipCircle.attr({
                        cx: left,
                        cy: top,
                        r: radius
                    })
                }
            },
            _applyExtraSettings: function(series) {
                var wideClipRect = this._panesClipRects.wide[0];
                series.setClippingParams(this._panesClipRects.base[0].id, wideClipRect && wideClipRect.id, false, false)
            },
            getActualAngle: function(angle) {
                return this.getArgumentAxis().getOptions().inverted ? DOUBLE_PI_ANGLE - angle : angle
            },
            getXYFromPolar: function(angle, radius, argument, value) {
                var layoutInfo = {
                    angle: void 0,
                    radius: void 0,
                    x: void 0,
                    y: void 0
                };
                if (!(0, _type.isDefined)(angle) && !(0, _type.isDefined)(radius) && !(0, _type.isDefined)(argument) && !(0, _type.isDefined)(value)) {
                    return layoutInfo
                }
                var argAxis = this.getArgumentAxis();
                var startAngle = argAxis.getAngles()[0];
                var argAngle;
                var translatedRadius;
                if ((0, _type.isDefined)(argument)) {
                    argAngle = argAxis.getTranslator().translate(argument)
                } else {
                    if (isFinite(angle)) {
                        argAngle = this.getActualAngle(angle)
                    } else {
                        if (!(0, _type.isDefined)(angle)) {
                            argAngle = 0
                        }
                    }
                }
                if ((0, _type.isDefined)(value)) {
                    translatedRadius = this.getValueAxis().getTranslator().translate(value)
                } else {
                    if (isFinite(radius)) {
                        translatedRadius = radius
                    } else {
                        if (!(0, _type.isDefined)(radius)) {
                            translatedRadius = argAxis.getRadius()
                        }
                    }
                }
                if ((0, _type.isDefined)(argAngle) && (0, _type.isDefined)(translatedRadius)) {
                    var coords = _utils2.default.convertPolarToXY(argAxis.getCenter(), startAngle, argAngle, translatedRadius);
                    (0, _extend.extend)(layoutInfo, coords, {
                        angle: argAxis.getTranslatedAngle(argAngle),
                        radius: translatedRadius
                    })
                }
                return layoutInfo
            },
            _applyPointMarkersAutoHiding: _common.noop,
            _createScrollBar: _common.noop,
            _isRotated: _common.noop,
            _getCrosshairOptions: _common.noop,
            _isLegendInside: _common.noop
        });
        dxPolarChart.addPlugin(__webpack_require__( /*! ./core/annotations */ 212).plugins.core);
        dxPolarChart.addPlugin(__webpack_require__( /*! ./core/annotations */ 212).plugins.polarChart);
        (0, _component_registrator2.default)("dxPolarChart", dxPolarChart);
        module.exports = dxPolarChart
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/viz/linear_gauge.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./gauges/linear_gauge */ 843)
    },
    /*!*********************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/linear_gauge.js ***!
      \*********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var _max = Math.max;
        var _min = Math.min;
        var _round = Math.round;
        var registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 9);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var objectUtils = __webpack_require__( /*! ../../core/utils/object */ 47);
        var dxBaseGauge = __webpack_require__( /*! ./base_gauge */ 153).dxBaseGauge;
        var dxGauge = __webpack_require__( /*! ./common */ 213).dxGauge;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var linearIndicatorsModule = __webpack_require__( /*! ./linear_indicators */ 846);
        var createIndicatorCreator = __webpack_require__( /*! ./common */ 213).createIndicatorCreator;
        var LinearRangeContainer = __webpack_require__( /*! ./linear_range_container */ 847);
        var dxLinearGauge = dxGauge.inherit({
            _rootClass: "dxg-linear-gauge",
            _factoryMethods: {
                rangeContainer: "createLinearRangeContainer",
                indicator: "createLinearIndicator"
            },
            _gridSpacingFactor: 25,
            _scaleTypes: {
                type: "xyAxes",
                drawingType: "linear"
            },
            _getTicksOrientation: function(scaleOptions) {
                return scaleOptions.isHorizontal ? scaleOptions.verticalOrientation : scaleOptions.horizontalOrientation
            },
            _getThemeManagerOptions: function() {
                var options = this.callBase.apply(this, arguments);
                options.subTheme = "_linear";
                return options
            },
            _updateScaleTickIndent: function(scaleOptions) {
                var indentFromTick = scaleOptions.label.indentFromTick;
                var length = scaleOptions.tick.length;
                var textParams = this._scale.measureLabels(extend({}, this._canvas));
                var verticalTextCorrection = scaleOptions.isHorizontal ? textParams.height + textParams.y : 0;
                var isIndentPositive = indentFromTick > 0;
                var orientation;
                var textCorrection;
                var tickCorrection;
                if (scaleOptions.isHorizontal) {
                    orientation = isIndentPositive ? {
                        center: .5,
                        top: 0,
                        bottom: 1
                    } : {
                        center: .5,
                        top: 1,
                        bottom: 0
                    };
                    tickCorrection = length * orientation[scaleOptions.verticalOrientation];
                    textCorrection = textParams.y
                } else {
                    orientation = isIndentPositive ? {
                        center: .5,
                        left: 0,
                        right: 1
                    } : {
                        center: .5,
                        left: 1,
                        right: 0
                    };
                    tickCorrection = length * orientation[scaleOptions.horizontalOrientation];
                    textCorrection = -textParams.width
                }
                scaleOptions.label.indentFromAxis = -indentFromTick + (isIndentPositive ? -tickCorrection + textCorrection : tickCorrection - verticalTextCorrection);
                this._scale.updateOptions(scaleOptions)
            },
            _shiftScale: function(layout, scaleOptions) {
                var that = this;
                var canvas = extend({}, that._canvas);
                var isHorizontal = scaleOptions.isHorizontal;
                var scale = that._scale;
                canvas[isHorizontal ? "left" : "top"] = that._area[isHorizontal ? "startCoord" : "endCoord"];
                canvas[isHorizontal ? "right" : "bottom"] = canvas[isHorizontal ? "width" : "height"] - that._area[isHorizontal ? "endCoord" : "startCoord"];
                scale.draw(canvas);
                scale.shift({
                    left: -layout.x,
                    top: -layout.y
                })
            },
            _setupCodomain: function() {
                var that = this;
                var geometry = that.option("geometry") || {};
                var vertical = "vertical" === _normalizeEnum(geometry.orientation);
                var initialStartCoord = -100;
                var initialEndCoord = 100;
                that._area = {
                    vertical: vertical,
                    x: 0,
                    y: 0,
                    startCoord: initialStartCoord,
                    endCoord: initialEndCoord
                };
                that._rangeContainer.vertical = vertical;
                that._translator.setCodomain(initialStartCoord, initialEndCoord)
            },
            _getScaleLayoutValue: function() {
                return this._area[this._area.vertical ? "x" : "y"]
            },
            _getTicksCoefficients: function(options) {
                var coefs = {
                    inner: 0,
                    outer: 1
                };
                if (this._area.vertical) {
                    if ("left" === options.horizontalOrientation) {
                        coefs.inner = 1;
                        coefs.outer = 0
                    } else {
                        if ("center" === options.horizontalOrientation) {
                            coefs.inner = coefs.outer = .5
                        }
                    }
                } else {
                    if ("top" === options.verticalOrientation) {
                        coefs.inner = 1;
                        coefs.outer = 0
                    } else {
                        if ("center" === options.verticalOrientation) {
                            coefs.inner = coefs.outer = .5
                        }
                    }
                }
                return coefs
            },
            _correctScaleIndents: function(result, indentFromTick, textParams) {
                var vertical = this._area.vertical;
                if (indentFromTick >= 0) {
                    result.max += indentFromTick + textParams[vertical ? "width" : "height"]
                } else {
                    result.min -= -indentFromTick + textParams[vertical ? "width" : "height"]
                }
                result.indent = textParams[vertical ? "height" : "width"] / 2
            },
            _measureMainElements: function(elements, scaleMeasurement) {
                var that = this;
                var x = that._area.x;
                var y = that._area.y;
                var minBound = 1e3;
                var maxBound = 0;
                var indent = 0;
                var scale = that._scale;
                _each(elements.concat(scale), function(_, element) {
                    var bounds = element.measure ? element.measure({
                        x: x + element.getOffset(),
                        y: y + element.getOffset()
                    }) : scaleMeasurement;
                    void 0 !== bounds.max && (maxBound = _max(maxBound, bounds.max));
                    void 0 !== bounds.min && (minBound = _min(minBound, bounds.min));
                    bounds.indent > 0 && (indent = _max(indent, bounds.indent))
                });
                return {
                    minBound: minBound,
                    maxBound: maxBound,
                    indent: indent
                }
            },
            _applyMainLayout: function(elements, scaleMeasurement) {
                var that = this;
                var measurements = that._measureMainElements(elements, scaleMeasurement);
                var area = that._area;
                var rect;
                var offset;
                if (area.vertical) {
                    rect = selectRectBySizes(that._innerRect, {
                        width: measurements.maxBound - measurements.minBound
                    });
                    offset = (rect.left + rect.right) / 2 - (measurements.minBound + measurements.maxBound) / 2;
                    area.startCoord = rect.bottom - measurements.indent;
                    area.endCoord = rect.top + measurements.indent;
                    area.x = _round(area.x + offset)
                } else {
                    rect = selectRectBySizes(that._innerRect, {
                        height: measurements.maxBound - measurements.minBound
                    });
                    offset = (rect.top + rect.bottom) / 2 - (measurements.minBound + measurements.maxBound) / 2;
                    area.startCoord = rect.left + measurements.indent;
                    area.endCoord = rect.right - measurements.indent;
                    area.y = _round(area.y + offset)
                }
                that._translator.setCodomain(area.startCoord, area.endCoord);
                that._innerRect = rect
            },
            _getElementLayout: function(offset) {
                return {
                    x: _round(this._area.x + offset),
                    y: _round(this._area.y + offset)
                }
            },
            _getApproximateScreenRange: function() {
                var that = this;
                var area = that._area;
                var s = area.vertical ? that._canvas.height : that._canvas.width;
                s > area.totalSize && (s = area.totalSize);
                s = .8 * s;
                return s
            },
            _getDefaultSize: function() {
                var geometry = this.option("geometry") || {};
                if ("vertical" === geometry.orientation) {
                    return {
                        width: 100,
                        height: 300
                    }
                } else {
                    return {
                        width: 300,
                        height: 100
                    }
                }
            },
            _factory: objectUtils.clone(dxBaseGauge.prototype._factory)
        });

        function selectRectBySizes(srcRect, sizes, margins) {
            var rect = extend({}, srcRect);
            var step;
            margins = margins || {};
            if (sizes) {
                rect.left += margins.left || 0;
                rect.right -= margins.right || 0;
                rect.top += margins.top || 0;
                rect.bottom -= margins.bottom || 0;
                if (sizes.width > 0) {
                    step = (rect.right - rect.left - sizes.width) / 2;
                    if (step > 0) {
                        rect.left += step;
                        rect.right -= step
                    }
                }
                if (sizes.height > 0) {
                    step = (rect.bottom - rect.top - sizes.height) / 2;
                    if (step > 0) {
                        rect.top += step;
                        rect.bottom -= step
                    }
                }
            }
            return rect
        }
        dxLinearGauge._TESTS_selectRectBySizes = selectRectBySizes;
        var indicators = dxLinearGauge.prototype._factory.indicators = {};
        dxLinearGauge.prototype._factory.createIndicator = createIndicatorCreator(indicators);
        indicators._default = linearIndicatorsModule._default;
        indicators.rectangle = linearIndicatorsModule.rectangle;
        indicators.rhombus = linearIndicatorsModule.rhombus;
        indicators.circle = linearIndicatorsModule.circle;
        indicators.trianglemarker = linearIndicatorsModule.trianglemarker;
        indicators.textcloud = linearIndicatorsModule.textcloud;
        indicators.rangebar = linearIndicatorsModule.rangebar;
        dxLinearGauge.prototype._factory.RangeContainer = LinearRangeContainer;
        registerComponent("dxLinearGauge", dxLinearGauge);
        module.exports = dxLinearGauge
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/theme_manager.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var _extend = extend;
        var BaseThemeManager = __webpack_require__( /*! ../core/base_theme_manager */ 257).BaseThemeManager;
        var ThemeManager = BaseThemeManager.inherit({
            ctor: function(options) {
                this.callBase.apply(this, arguments);
                this._subTheme = options.subTheme
            },
            _initializeTheme: function() {
                var that = this;
                var subTheme;
                if (that._subTheme) {
                    subTheme = _extend(true, {}, that._theme[that._subTheme], that._theme);
                    _extend(true, that._theme, subTheme)
                }
                that.callBase.apply(that, arguments)
            }
        });
        module.exports = {
            ThemeManager: ThemeManager
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/tracker.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var eventsEngine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var Class = __webpack_require__( /*! ../../core/class */ 16);
        var domAdapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var wheelEvent = __webpack_require__( /*! ../../events/core/wheel */ 133);
        var ready = __webpack_require__( /*! ../../core/utils/ready_callbacks */ 51).add;
        var addNamespace = __webpack_require__( /*! ../../events/utils */ 8).addNamespace;
        var pointerEvents = __webpack_require__( /*! ../../events/pointer */ 23);
        var EVENT_NS = "gauge-tooltip";
        var TOOLTIP_HIDE_DELAY = 100;
        var Tracker = Class.inherit({
            ctor: function(parameters) {
                var debug = __webpack_require__( /*! ../../core/utils/console */ 65).debug;
                debug.assertParam(parameters, "parameters");
                debug.assertParam(parameters.renderer, "parameters.renderer");
                debug.assertParam(parameters.container, "parameters.container");
                var that = this;
                that._element = parameters.renderer.g().attr({
                    "class": "dxg-tracker",
                    stroke: "none",
                    "stroke-width": 0,
                    fill: "#000000",
                    opacity: 1e-4
                }).linkOn(parameters.container, {
                    name: "tracker",
                    after: "peripheral"
                });
                that._showTooltipCallback = function() {
                    var target = that._tooltipEvent.target;
                    var data_target = target["gauge-data-target"];
                    var data_info = target["gauge-data-info"];
                    that._targetEvent = null;
                    if (that._tooltipTarget !== target && that._callbacks["tooltip-show"](data_target, data_info)) {
                        that._tooltipTarget = target
                    }
                };
                that._hideTooltipCallback = function() {
                    that._hideTooltipTimeout = null;
                    that._targetEvent = null;
                    if (that._tooltipTarget) {
                        that._callbacks["tooltip-hide"]();
                        that._tooltipTarget = null
                    }
                };
                that._dispose = function() {
                    clearTimeout(that._hideTooltipTimeout);
                    that._showTooltipCallback = that._hideTooltipCallback = that._dispose = null
                };
                that._DEBUG_hideTooltipTimeoutSet = that._DEBUG_hideTooltipTimeoutCleared = 0;
                that.TOOLTIP_HIDE_DELAY = TOOLTIP_HIDE_DELAY
            },
            dispose: function() {
                var that = this;
                that._dispose();
                that.deactivate();
                that._element.off("." + EVENT_NS);
                that._element.linkOff();
                that._element = that._context = that._callbacks = null;
                return that
            },
            activate: function() {
                this._element.linkAppend();
                return this
            },
            deactivate: function() {
                this._element.linkRemove().clear();
                return this
            },
            attach: function(element, target, info) {
                element.data({
                    "gauge-data-target": target,
                    "gauge-data-info": info
                }).append(this._element);
                return this
            },
            detach: function(element) {
                element.remove();
                return this
            },
            setTooltipState: function(state) {
                var that = this;
                that._element.off("." + EVENT_NS);
                if (state) {
                    var data = {
                        tracker: that
                    };
                    that._element.on(addNamespace([pointerEvents.move], EVENT_NS), data, handleTooltipMouseOver).on(addNamespace([pointerEvents.out], EVENT_NS), data, handleTooltipMouseOut).on(addNamespace([pointerEvents.down], EVENT_NS), data, handleTooltipTouchStart).on(addNamespace([pointerEvents.up], EVENT_NS), data, handleTooltipTouchEnd).on(addNamespace([wheelEvent.name], EVENT_NS), data, handleTooltipMouseWheel)
                }
                return that
            },
            setCallbacks: function(callbacks) {
                this._callbacks = callbacks;
                return this
            },
            _showTooltip: function(event) {
                var that = this;
                that._hideTooltipTimeout && ++that._DEBUG_hideTooltipTimeoutCleared;
                clearTimeout(that._hideTooltipTimeout);
                that._hideTooltipTimeout = null;
                if (that._tooltipTarget === event.target) {
                    return
                }
                that._tooltipEvent = event;
                that._showTooltipCallback()
            },
            _hideTooltip: function(delay) {
                var that = this;
                clearTimeout(that._hideTooltipTimeout);
                if (delay) {
                    ++that._DEBUG_hideTooltipTimeoutSet;
                    that._hideTooltipTimeout = setTimeout(that._hideTooltipCallback, delay)
                } else {
                    that._hideTooltipCallback()
                }
            }
        });
        var active_touch_tooltip_tracker = null;
        Tracker._DEBUG_reset = function() {
            active_touch_tooltip_tracker = null
        };

        function handleTooltipMouseOver(event) {
            var tracker = event.data.tracker;
            tracker._x = event.pageX;
            tracker._y = event.pageY;
            tracker._showTooltip(event)
        }

        function handleTooltipMouseOut(event) {
            event.data.tracker._hideTooltip(TOOLTIP_HIDE_DELAY)
        }

        function handleTooltipMouseWheel(event) {
            event.data.tracker._hideTooltip()
        }

        function handleTooltipTouchStart(event) {
            var tracker = active_touch_tooltip_tracker = event.data.tracker;
            tracker._touch = true;
            handleTooltipMouseOver(event)
        }

        function handleTooltipTouchEnd() {
            active_touch_tooltip_tracker._touch = false
        }

        function handleDocumentTooltipTouchStart(event) {
            var tracker = active_touch_tooltip_tracker;
            if (tracker && !tracker._touch) {
                tracker._hideTooltip(TOOLTIP_HIDE_DELAY);
                active_touch_tooltip_tracker = null
            }
        }
        ready(function() {
            eventsEngine.subscribeGlobal(domAdapter.getDocument(), addNamespace([pointerEvents.down], EVENT_NS), handleDocumentTooltipTouchStart)
        });
        module.exports = Tracker
    },
    /*!**************************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/linear_indicators.js ***!
      \**************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var baseIndicatorsModule = __webpack_require__( /*! ./base_indicators */ 265);
        var BaseIndicator = baseIndicatorsModule.BaseIndicator;
        var BaseTextCloudMarker = baseIndicatorsModule.BaseTextCloudMarker;
        var BaseRangeBar = baseIndicatorsModule.BaseRangeBar;
        var _Number = Number;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var SimpleIndicator = BaseIndicator.inherit({
            _move: function() {
                var that = this;
                var delta = that._actualPosition - that._zeroPosition;
                that._rootElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);
                that._trackerElement && that._trackerElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0)
            },
            _isEnabled: function() {
                this.vertical = this._options.vertical;
                return this._options.length > 0 && this._options.width > 0
            },
            _isVisible: function() {
                return true
            },
            _getTrackerSettings: function() {
                var options = this._options;
                var x1;
                var x2;
                var y1;
                var y2;
                var width = options.width / 2;
                var length = options.length / 2;
                var p = this._zeroPosition;
                width > 10 || (width = 10);
                length > 10 || (length = 10);
                if (this.vertical) {
                    x1 = options.x - length;
                    x2 = options.x + length;
                    y1 = p + width;
                    y2 = p - width
                } else {
                    x1 = p - width;
                    x2 = p + width;
                    y1 = options.y + length;
                    y2 = options.y - length
                }
                return {
                    points: [x1, y1, x1, y2, x2, y2, x2, y1]
                }
            },
            _render: function() {
                var that = this;
                that._zeroPosition = that._translator.getCodomainStart()
            },
            _clear: function() {
                delete this._element
            },
            measure: function(layout) {
                var p = this.vertical ? layout.x : layout.y;
                return {
                    min: p - this._options.length / 2,
                    max: p + this._options.length / 2
                }
            },
            getTooltipParameters: function() {
                var that = this;
                var options = that._options;
                var p = that._actualPosition;
                var parameters = {
                    x: p,
                    y: p,
                    value: that._currentValue,
                    color: options.color,
                    offset: options.width / 2
                };
                that.vertical ? parameters.x = options.x : parameters.y = options.y;
                return parameters
            }
        });
        var rectangle = SimpleIndicator.inherit({
            _render: function() {
                var that = this;
                var options = that._options;
                var x1;
                var x2;
                var y1;
                var y2;
                that.callBase();
                var p = that._zeroPosition;
                if (that.vertical) {
                    x1 = options.x - options.length / 2;
                    x2 = options.x + options.length / 2;
                    y1 = p + options.width / 2;
                    y2 = p - options.width / 2
                } else {
                    x1 = p - options.width / 2;
                    x2 = p + options.width / 2;
                    y1 = options.y + options.length / 2;
                    y2 = options.y - options.length / 2
                }
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr({
                    points: [x1, y1, x1, y2, x2, y2, x2, y1]
                })
            }
        });
        var rhombus = SimpleIndicator.inherit({
            _render: function() {
                var that = this;
                var options = that._options;
                var x;
                var y;
                var dx;
                var dy;
                that.callBase();
                if (that.vertical) {
                    x = options.x;
                    y = that._zeroPosition;
                    dx = options.length / 2 || 0;
                    dy = options.width / 2 || 0
                } else {
                    x = that._zeroPosition;
                    y = options.y;
                    dx = options.width / 2 || 0;
                    dy = options.length / 2 || 0
                }
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr({
                    points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy]
                })
            }
        });
        var circle = SimpleIndicator.inherit({
            _render: function() {
                var that = this;
                var options = that._options;
                var x;
                var y;
                that.callBase();
                if (that.vertical) {
                    x = options.x;
                    y = that._zeroPosition
                } else {
                    x = that._zeroPosition;
                    y = options.y
                }
                var r = options.length / 2 || 0;
                that._element = that._element || that._renderer.circle().append(that._rootElement);
                that._element.attr({
                    cx: x,
                    cy: y,
                    r: r
                })
            }
        });
        var triangleMarker = SimpleIndicator.inherit({
            _isEnabled: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inverted = that.vertical ? "right" === _normalizeEnum(that._options.horizontalOrientation) : "bottom" === _normalizeEnum(that._options.verticalOrientation);
                return that._options.length > 0 && that._options.width > 0
            },
            _isVisible: function() {
                return true
            },
            _render: function() {
                var that = this;
                var options = that._options;
                var x1;
                var x2;
                var y1;
                var y2;
                var settings = {
                    stroke: "none",
                    "stroke-width": 0,
                    "stroke-linecap": "square"
                };
                that.callBase();
                if (that.vertical) {
                    x1 = options.x;
                    y1 = that._zeroPosition;
                    x2 = x1 + _Number(that._inverted ? options.length : -options.length);
                    settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2]
                } else {
                    y1 = options.y;
                    x1 = that._zeroPosition;
                    y2 = y1 + _Number(that._inverted ? options.length : -options.length);
                    settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2]
                }
                if (options.space > 0) {
                    settings["stroke-width"] = Math.min(options.space, options.width / 4) || 0;
                    settings.stroke = settings["stroke-width"] > 0 ? options.containerBackgroundColor || "none" : "none"
                }
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr(settings).sharp()
            },
            _getTrackerSettings: function() {
                var that = this;
                var options = that._options;
                var width = options.width / 2;
                var length = _Number(options.length);
                var x1;
                var x2;
                var y1;
                var y2;
                var result;
                width > 10 || (width = 10);
                length > 20 || (length = 20);
                if (that.vertical) {
                    x1 = x2 = options.x;
                    x2 = x1 + (that._inverted ? length : -length);
                    y1 = that._zeroPosition + width;
                    y2 = that._zeroPosition - width;
                    result = [x1, y1, x2, y1, x2, y2, x1, y2]
                } else {
                    y1 = options.y;
                    y2 = y1 + (that._inverted ? length : -length);
                    x1 = that._zeroPosition - width;
                    x2 = that._zeroPosition + width;
                    result = [x1, y1, x1, y2, x2, y2, x2, y1]
                }
                return {
                    points: result
                }
            },
            measure: function(layout) {
                var that = this;
                var length = _Number(that._options.length);
                var minBound;
                var maxBound;
                if (that.vertical) {
                    minBound = maxBound = layout.x;
                    if (that._inverted) {
                        maxBound = minBound + length
                    } else {
                        minBound = maxBound - length
                    }
                } else {
                    minBound = maxBound = layout.y;
                    if (that._inverted) {
                        maxBound = minBound + length
                    } else {
                        minBound = maxBound - length
                    }
                }
                return {
                    min: minBound,
                    max: maxBound,
                    indent: that._options.width / 2
                }
            },
            getTooltipParameters: function() {
                var that = this;
                var options = that._options;
                var s = (that._inverted ? options.length : -options.length) / 2;
                var parameters = that.callBase();
                that.vertical ? parameters.x += s : parameters.y += s;
                parameters.offset = options.length / 2;
                return parameters
            }
        });
        var textCloud = BaseTextCloudMarker.inherit({
            _isEnabled: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inverted = that.vertical ? "right" === _normalizeEnum(that._options.horizontalOrientation) : "bottom" === _normalizeEnum(that._options.verticalOrientation);
                return true
            },
            _isVisible: function() {
                return true
            },
            _getTextCloudOptions: function() {
                var that = this;
                var x = that._actualPosition;
                var y = that._actualPosition;
                var type;
                if (that.vertical) {
                    x = that._options.x;
                    type = that._inverted ? "top-left" : "top-right"
                } else {
                    y = that._options.y;
                    type = that._inverted ? "right-top" : "right-bottom"
                }
                return {
                    x: x,
                    y: y,
                    type: type
                }
            },
            measure: function(layout) {
                var that = this;
                var minBound;
                var maxBound;
                var arrowLength = _Number(that._options.arrowLength) || 0;
                var indent;
                that._measureText();
                if (that.vertical) {
                    indent = that._textFullHeight;
                    if (that._inverted) {
                        minBound = layout.x;
                        maxBound = layout.x + arrowLength + that._textFullWidth
                    } else {
                        minBound = layout.x - arrowLength - that._textFullWidth;
                        maxBound = layout.x
                    }
                } else {
                    indent = that._textFullWidth;
                    if (that._inverted) {
                        minBound = layout.y;
                        maxBound = layout.y + arrowLength + that._textFullHeight
                    } else {
                        minBound = layout.y - arrowLength - that._textFullHeight;
                        maxBound = layout.y
                    }
                }
                return {
                    min: minBound,
                    max: maxBound,
                    indent: indent
                }
            }
        });
        var rangeBar = BaseRangeBar.inherit({
            _isEnabled: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inverted = that.vertical ? "right" === _normalizeEnum(that._options.horizontalOrientation) : "bottom" === _normalizeEnum(that._options.verticalOrientation);
                return that._options.size > 0
            },
            _isVisible: function() {
                return true
            },
            _createBarItem: function() {
                return this._renderer.path([], "area").append(this._rootElement)
            },
            _createTracker: function() {
                return this._renderer.path([], "area")
            },
            _setBarSides: function() {
                var that = this;
                var options = that._options;
                var size = _Number(options.size);
                var minSide;
                var maxSide;
                if (that.vertical) {
                    if (that._inverted) {
                        minSide = options.x;
                        maxSide = options.x + size
                    } else {
                        minSide = options.x - size;
                        maxSide = options.x
                    }
                } else {
                    if (that._inverted) {
                        minSide = options.y;
                        maxSide = options.y + size
                    } else {
                        minSide = options.y - size;
                        maxSide = options.y
                    }
                }
                that._minSide = minSide;
                that._maxSide = maxSide;
                that._minBound = minSide;
                that._maxBound = maxSide
            },
            _getSpace: function() {
                var options = this._options;
                return options.space > 0 ? _Number(options.space) : 0
            },
            _isTextVisible: function() {
                var textOptions = this._options.text || {};
                return textOptions.indent > 0 || textOptions.indent < 0
            },
            _getTextAlign: function() {
                return this.vertical ? this._options.text.indent > 0 ? "left" : "right" : "center"
            },
            _setTextItemsSides: function() {
                var that = this;
                var indent = _Number(that._options.text.indent);
                if (indent > 0) {
                    that._lineStart = that._maxSide;
                    that._lineEnd = that._maxSide + indent;
                    that._textPosition = that._lineEnd + (that.vertical ? 2 : that._textHeight / 2);
                    that._maxBound = that._textPosition + (that.vertical ? that._textWidth : that._textHeight / 2)
                } else {
                    if (indent < 0) {
                        that._lineStart = that._minSide;
                        that._lineEnd = that._minSide + indent;
                        that._textPosition = that._lineEnd - (that.vertical ? 2 : that._textHeight / 2);
                        that._minBound = that._textPosition - (that.vertical ? that._textWidth : that._textHeight / 2)
                    }
                }
            },
            _getPositions: function() {
                var that = this;
                var startPosition = that._startPosition;
                var endPosition = that._endPosition;
                var space = that._space;
                var basePosition = that._basePosition;
                var actualPosition = that._actualPosition;
                var mainPosition1;
                var mainPosition2;
                var backPosition1;
                var backPosition2;
                if (startPosition < endPosition) {
                    if (basePosition < actualPosition) {
                        mainPosition1 = basePosition;
                        mainPosition2 = actualPosition
                    } else {
                        mainPosition1 = actualPosition;
                        mainPosition2 = basePosition
                    }
                    backPosition1 = mainPosition1 - space;
                    backPosition2 = mainPosition2 + space
                } else {
                    if (basePosition > actualPosition) {
                        mainPosition1 = basePosition;
                        mainPosition2 = actualPosition
                    } else {
                        mainPosition1 = actualPosition;
                        mainPosition2 = basePosition
                    }
                    backPosition1 = mainPosition1 + space;
                    backPosition2 = mainPosition2 - space
                }
                return {
                    start: startPosition,
                    end: endPosition,
                    main1: mainPosition1,
                    main2: mainPosition2,
                    back1: backPosition1,
                    back2: backPosition2
                }
            },
            _buildItemSettings: function(from, to) {
                var that = this;
                var side1 = that._minSide;
                var side2 = that._maxSide;
                var points = that.vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];
                return {
                    points: points
                }
            },
            _updateTextPosition: function() {
                var that = this;
                that._text.attr(that.vertical ? {
                    x: that._textPosition,
                    y: that._actualPosition + that._textVerticalOffset
                } : {
                    x: that._actualPosition,
                    y: that._textPosition + that._textVerticalOffset
                })
            },
            _updateLinePosition: function() {
                var that = this;
                var actualPosition = that._actualPosition;
                var side1;
                var side2;
                var points;
                if (that.vertical) {
                    if (that._basePosition >= actualPosition) {
                        side1 = actualPosition;
                        side2 = actualPosition + 2
                    } else {
                        side1 = actualPosition - 2;
                        side2 = actualPosition
                    }
                    points = [that._lineStart, side1, that._lineStart, side2, that._lineEnd, side2, that._lineEnd, side1]
                } else {
                    if (that._basePosition <= actualPosition) {
                        side1 = actualPosition - 2;
                        side2 = actualPosition
                    } else {
                        side1 = actualPosition;
                        side2 = actualPosition + 2
                    }
                    points = [side1, that._lineStart, side1, that._lineEnd, side2, that._lineEnd, side2, that._lineStart]
                }
                that._line.attr({
                    points: points
                }).sharp()
            },
            _getTooltipPosition: function() {
                var that = this;
                var crossCenter = (that._minSide + that._maxSide) / 2;
                var alongCenter = (that._basePosition + that._actualPosition) / 2;
                return that.vertical ? {
                    x: crossCenter,
                    y: alongCenter
                } : {
                    x: alongCenter,
                    y: crossCenter
                }
            },
            measure: function(layout) {
                var that = this;
                var size = _Number(that._options.size);
                var textIndent = _Number(that._options.text.indent);
                var minBound;
                var maxBound;
                var indent;
                that._measureText();
                if (that.vertical) {
                    minBound = maxBound = layout.x;
                    if (that._inverted) {
                        maxBound += size
                    } else {
                        minBound -= size
                    }
                    if (that._hasText) {
                        indent = that._textHeight / 2;
                        if (textIndent > 0) {
                            maxBound += textIndent + that._textWidth
                        }
                        if (textIndent < 0) {
                            minBound += textIndent - that._textWidth
                        }
                    }
                } else {
                    minBound = maxBound = layout.y;
                    if (that._inverted) {
                        maxBound += size
                    } else {
                        minBound -= size
                    }
                    if (that._hasText) {
                        indent = that._textWidth / 2;
                        if (textIndent > 0) {
                            maxBound += textIndent + that._textHeight
                        }
                        if (textIndent < 0) {
                            minBound += textIndent - that._textHeight
                        }
                    }
                }
                return {
                    min: minBound,
                    max: maxBound,
                    indent: indent
                }
            }
        });
        exports._default = rangeBar;
        exports.rectangle = rectangle;
        exports.rhombus = rhombus;
        exports.circle = circle;
        exports.trianglemarker = triangleMarker;
        exports.textcloud = textCloud;
        exports.rangebar = rangeBar
    },
    /*!*******************************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/linear_range_container.js ***!
      \*******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var BaseRangeContainer = __webpack_require__( /*! ./base_range_container */ 431);
        var _Number = Number;
        var _max = Math.max;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var LinearRangeContainer = BaseRangeContainer.inherit({
            _processOptions: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inner = that._outer = 0;
                if (that.vertical) {
                    switch (_normalizeEnum(that._options.horizontalOrientation)) {
                        case "left":
                            that._inner = 1;
                            break;
                        case "center":
                            that._inner = that._outer = .5;
                            break;
                        default:
                            that._outer = 1
                    }
                } else {
                    switch (_normalizeEnum(that._options.verticalOrientation)) {
                        case "top":
                            that._inner = 1;
                            break;
                        case "center":
                            that._inner = that._outer = .5;
                            break;
                        default:
                            that._outer = 1
                    }
                }
            },
            _isVisible: function() {
                return true
            },
            _createRange: function(range, layout) {
                var that = this;
                var inner = that._inner;
                var outer = that._outer;
                var startPosition = that._translator.translate(range.start);
                var endPosition = that._translator.translate(range.end);
                var points;
                var x = layout.x;
                var y = layout.y;
                var startWidth = range.startWidth;
                var endWidth = range.endWidth;
                if (that.vertical) {
                    points = [x - startWidth * inner, startPosition, x - endWidth * inner, endPosition, x + endWidth * outer, endPosition, x + startWidth * outer, startPosition]
                } else {
                    points = [startPosition, y + startWidth * outer, startPosition, y - startWidth * inner, endPosition, y - endWidth * inner, endPosition, y + endWidth * outer]
                }
                return that._renderer.path(points, "area")
            },
            measure: function(layout) {
                var result = {};
                var width;
                result.min = result.max = layout[this.vertical ? "x" : "y"];
                width = this._options.width;
                width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                result.min -= this._inner * width;
                result.max += this._outer * width;
                return result
            }
        });
        module.exports = LinearRangeContainer
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/circular_gauge.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./gauges/circular_gauge */ 432)
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/circular_indicators.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var baseIndicatorsModule = __webpack_require__( /*! ./base_indicators */ 265);
        var BaseIndicator = baseIndicatorsModule.BaseIndicator;
        var BaseTextCloudMarker = baseIndicatorsModule.BaseTextCloudMarker;
        var BaseRangeBar = baseIndicatorsModule.BaseRangeBar;
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var _Number = Number;
        var _getCosAndSin = vizUtils.getCosAndSin;
        var _convertAngleToRendererSpace = vizUtils.convertAngleToRendererSpace;
        var SimpleIndicator = BaseIndicator.inherit({
            _move: function() {
                var that = this;
                var options = that._options;
                var angle = _convertAngleToRendererSpace(that._actualPosition);
                that._rootElement.rotate(angle, options.x, options.y);
                that._trackerElement && that._trackerElement.rotate(angle, options.x, options.y)
            },
            _isEnabled: function() {
                return this._options.width > 0
            },
            _isVisible: function(layout) {
                return layout.radius - _Number(this._options.indentFromCenter) > 0
            },
            _getTrackerSettings: function() {
                var options = this._options;
                var radius = this._getRadius();
                var indentFromCenter = this._getIndentFromCenter();
                var x = options.x;
                var y = options.y - (radius + indentFromCenter) / 2;
                var width = options.width / 2;
                var length = (radius - indentFromCenter) / 2;
                width > 10 || (width = 10);
                length > 10 || (length = 10);
                return {
                    points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
                }
            },
            _render: function() {
                var that = this;
                that._renderPointer()
            },
            _clearPointer: function() {
                delete this._element
            },
            _clear: function() {
                this._clearPointer()
            },
            _getIndentFromCenter: function(radius) {
                return Number(this._options.indentFromCenter) || 0
            },
            _getRadius: function() {
                return 0
            },
            measure: function(layout) {
                var result = {
                    max: layout.radius
                };
                if (this._options.indentFromCenter < 0) {
                    result.inverseHorizontalOffset = result.inverseVerticalOffset = -_Number(this._options.indentFromCenter)
                }
                return result
            },
            getTooltipParameters: function() {
                var options = this._options;
                var cosSin = _getCosAndSin(this._actualPosition);
                var r = (this._getRadius() + this._getIndentFromCenter()) / 2;
                return {
                    x: options.x + cosSin.cos * r,
                    y: options.y - cosSin.sin * r,
                    value: this._currentValue,
                    color: options.color,
                    offset: options.width / 2
                }
            }
        });
        var NeedleIndicator = SimpleIndicator.inherit({
            _isVisible: function(layout) {
                var indentFromCenter = this._adjustOffset(Number(this._options.indentFromCenter), layout.radius);
                var offset = this._adjustOffset(Number(this._options.offset), layout.radius);
                return layout.radius - indentFromCenter - offset > 0
            },
            getOffset: function() {
                return 0
            },
            _adjustOffset: function(value, radius) {
                var minRadius = Number(this._options.beginAdaptingAtRadius);
                var diff = radius / minRadius;
                if (diff < 1) {
                    value = Math.floor(value * diff)
                }
                return value || 0
            },
            _getIndentFromCenter: function(radius) {
                return this._adjustOffset(Number(this._options.indentFromCenter), this._options.radius)
            },
            _getRadius: function() {
                var options = this._options;
                return options.radius - this._adjustOffset(Number(options.offset), options.radius)
            },
            _renderSpindle: function() {
                var that = this;
                var options = that._options;
                var radius = options.radius;
                var spindleSize = 2 * this._adjustOffset(_Number(options.spindleSize) / 2, radius);
                var gapSize = 2 * this._adjustOffset(_Number(options.spindleGapSize) / 2, radius) || 0;
                if (gapSize > 0) {
                    gapSize = gapSize <= spindleSize ? gapSize : spindleSize
                }
                if (spindleSize > 0) {
                    that._spindleOuter = that._spindleOuter || that._renderer.circle().append(that._rootElement);
                    that._spindleInner = that._spindleInner || that._renderer.circle().append(that._rootElement);
                    that._spindleOuter.attr({
                        "class": "dxg-spindle-border",
                        cx: options.x,
                        cy: options.y,
                        r: spindleSize / 2
                    });
                    that._spindleInner.attr({
                        "class": "dxg-spindle-hole",
                        cx: options.x,
                        cy: options.y,
                        r: gapSize / 2,
                        fill: options.containerBackgroundColor
                    })
                }
            },
            _render: function() {
                var that = this;
                that.callBase();
                that._renderSpindle()
            },
            _clear: function() {
                this.callBase();
                delete this._spindleOuter;
                delete this._spindleInner
            }
        });
        var rectangleNeedle = NeedleIndicator.inherit({
            _renderPointer: function() {
                var that = this;
                var options = that._options;
                var y2 = options.y - this._getRadius();
                var y1 = options.y - this._getIndentFromCenter();
                var x1 = options.x - options.width / 2;
                var x2 = x1 + _Number(options.width);
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr({
                    points: [x1, y1, x1, y2, x2, y2, x2, y1]
                })
            }
        });
        var triangleNeedle = NeedleIndicator.inherit({
            _renderPointer: function() {
                var that = this;
                var options = that._options;
                var y2 = options.y - this._getRadius();
                var y1 = options.y - this._getIndentFromCenter();
                var x1 = options.x - options.width / 2;
                var x2 = options.x + options.width / 2;
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr({
                    points: [x1, y1, options.x, y2, x2, y1]
                })
            }
        });
        var twoColorNeedle = NeedleIndicator.inherit({
            _renderPointer: function() {
                var that = this;
                var options = that._options;
                var x1 = options.x - options.width / 2;
                var x2 = options.x + options.width / 2;
                var y4 = options.y - this._getRadius();
                var y1 = options.y - this._getIndentFromCenter();
                var fraction = _Number(options.secondFraction) || 0;
                var y2;
                var y3;
                if (fraction >= 1) {
                    y2 = y3 = y1
                } else {
                    if (fraction <= 0) {
                        y2 = y3 = y4
                    } else {
                        y3 = y4 + (y1 - y4) * fraction;
                        y2 = y3 + _Number(options.space)
                    }
                }
                that._firstElement = that._firstElement || that._renderer.path([], "area").append(that._rootElement);
                that._spaceElement = that._spaceElement || that._renderer.path([], "area").append(that._rootElement);
                that._secondElement = that._secondElement || that._renderer.path([], "area").append(that._rootElement);
                that._firstElement.attr({
                    points: [x1, y1, x1, y2, x2, y2, x2, y1]
                });
                that._spaceElement.attr({
                    points: [x1, y2, x1, y3, x2, y3, x2, y2],
                    "class": "dxg-hole",
                    fill: options.containerBackgroundColor
                });
                that._secondElement.attr({
                    points: [x1, y3, x1, y4, x2, y4, x2, y3],
                    "class": "dxg-part",
                    fill: options.secondColor
                })
            },
            _clearPointer: function() {
                delete this._firstElement;
                delete this._secondElement;
                delete this._spaceElement
            }
        });
        var triangleMarker = SimpleIndicator.inherit({
            _isEnabled: function() {
                return this._options.length > 0 && this._options.width > 0
            },
            _isVisible: function(layout) {
                return layout.radius > 0
            },
            _render: function() {
                var that = this;
                var options = that._options;
                var x = options.x;
                var y1 = options.y - options.radius;
                var dx = options.width / 2 || 0;
                var y2 = y1 - _Number(options.length);
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                var settings = {
                    points: [x, y1, x - dx, y2, x + dx, y2],
                    stroke: "none",
                    "stroke-width": 0,
                    "stroke-linecap": "square"
                };
                if (options.space > 0) {
                    settings["stroke-width"] = Math.min(options.space, options.width / 4) || 0;
                    settings.stroke = settings["stroke-width"] > 0 ? options.containerBackgroundColor || "none" : "none"
                }
                that._element.attr(settings).sharp()
            },
            _clear: function() {
                delete this._element
            },
            _getTrackerSettings: function() {
                var options = this._options;
                var x = options.x;
                var y = options.y - options.radius - options.length / 2;
                var width = options.width / 2;
                var length = options.length / 2;
                width > 10 || (width = 10);
                length > 10 || (length = 10);
                return {
                    points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
                }
            },
            measure: function(layout) {
                return {
                    min: layout.radius,
                    max: layout.radius + _Number(this._options.length)
                }
            },
            getTooltipParameters: function() {
                var options = this._options;
                var cosSin = _getCosAndSin(this._actualPosition);
                var r = options.radius + options.length / 2;
                var parameters = this.callBase();
                parameters.x = options.x + cosSin.cos * r;
                parameters.y = options.y - cosSin.sin * r;
                parameters.offset = options.length / 2;
                return parameters
            }
        });
        var textCloud = BaseTextCloudMarker.inherit({
            _isEnabled: function() {
                return true
            },
            _isVisible: function(layout) {
                return layout.radius > 0
            },
            _getTextCloudOptions: function() {
                var that = this;
                var cosSin = _getCosAndSin(that._actualPosition);
                var nAngle = vizUtils.normalizeAngle(that._actualPosition);
                return {
                    x: that._options.x + cosSin.cos * that._options.radius,
                    y: that._options.y - cosSin.sin * that._options.radius,
                    type: nAngle > 270 ? "left-top" : nAngle > 180 ? "top-right" : nAngle > 90 ? "right-bottom" : "bottom-left"
                }
            },
            measure: function(layout) {
                var that = this;
                var arrowLength = _Number(that._options.arrowLength) || 0;
                that._measureText();
                var verticalOffset = that._textFullHeight + arrowLength;
                var horizontalOffset = that._textFullWidth + arrowLength;
                return {
                    min: layout.radius,
                    max: layout.radius,
                    horizontalOffset: horizontalOffset,
                    verticalOffset: verticalOffset,
                    inverseHorizontalOffset: horizontalOffset,
                    inverseVerticalOffset: verticalOffset
                }
            }
        });
        var rangeBar = BaseRangeBar.inherit({
            _isEnabled: function() {
                return this._options.size > 0
            },
            _isVisible: function(layout) {
                return layout.radius - _Number(this._options.size) > 0
            },
            _createBarItem: function() {
                return this._renderer.arc().attr({
                    "stroke-linejoin": "round"
                }).append(this._rootElement)
            },
            _createTracker: function() {
                return this._renderer.arc().attr({
                    "stroke-linejoin": "round"
                })
            },
            _setBarSides: function() {
                var that = this;
                that._maxSide = that._options.radius;
                that._minSide = that._maxSide - _Number(that._options.size)
            },
            _getSpace: function() {
                var options = this._options;
                return options.space > 0 ? 180 * options.space / options.radius / Math.PI : 0
            },
            _isTextVisible: function() {
                var options = this._options.text || {};
                return options.indent > 0
            },
            _setTextItemsSides: function() {
                var that = this;
                var options = that._options;
                var indent = _Number(options.text.indent);
                that._lineFrom = options.y - options.radius;
                that._lineTo = that._lineFrom - indent;
                that._textRadius = options.radius + indent
            },
            _getPositions: function() {
                var that = this;
                var basePosition = that._basePosition;
                var actualPosition = that._actualPosition;
                var mainPosition1;
                var mainPosition2;
                if (basePosition >= actualPosition) {
                    mainPosition1 = basePosition;
                    mainPosition2 = actualPosition
                } else {
                    mainPosition1 = actualPosition;
                    mainPosition2 = basePosition
                }
                return {
                    start: that._startPosition,
                    end: that._endPosition,
                    main1: mainPosition1,
                    main2: mainPosition2,
                    back1: Math.min(mainPosition1 + that._space, that._startPosition),
                    back2: Math.max(mainPosition2 - that._space, that._endPosition)
                }
            },
            _buildItemSettings: function(from, to) {
                var that = this;
                return {
                    x: that._options.x,
                    y: that._options.y,
                    innerRadius: that._minSide,
                    outerRadius: that._maxSide,
                    startAngle: to,
                    endAngle: from
                }
            },
            _updateTextPosition: function() {
                var that = this;
                var cosSin = _getCosAndSin(that._actualPosition);
                var x = that._options.x + that._textRadius * cosSin.cos;
                var y = that._options.y - that._textRadius * cosSin.sin;
                x += cosSin.cos * that._textWidth * .6;
                y -= cosSin.sin * that._textHeight * .6;
                that._text.attr({
                    x: x,
                    y: y + that._textVerticalOffset
                })
            },
            _updateLinePosition: function() {
                var that = this;
                var x = that._options.x;
                var x1;
                var x2;
                if (that._basePosition > that._actualPosition) {
                    x1 = x - 2;
                    x2 = x
                } else {
                    if (that._basePosition < that._actualPosition) {
                        x1 = x;
                        x2 = x + 2
                    } else {
                        x1 = x - 1;
                        x2 = x + 1
                    }
                }
                that._line.attr({
                    points: [x1, that._lineFrom, x1, that._lineTo, x2, that._lineTo, x2, that._lineFrom]
                }).rotate(_convertAngleToRendererSpace(that._actualPosition), x, that._options.y).sharp()
            },
            _getTooltipPosition: function() {
                var that = this;
                var cosSin = _getCosAndSin((that._basePosition + that._actualPosition) / 2);
                var r = (that._minSide + that._maxSide) / 2;
                return {
                    x: that._options.x + cosSin.cos * r,
                    y: that._options.y - cosSin.sin * r
                }
            },
            measure: function(layout) {
                var that = this;
                var result = {
                    min: layout.radius - _Number(that._options.size),
                    max: layout.radius
                };
                that._measureText();
                if (that._hasText) {
                    result.max += _Number(that._options.text.indent);
                    result.horizontalOffset = that._textWidth;
                    result.verticalOffset = that._textHeight
                }
                return result
            }
        });
        exports._default = rectangleNeedle;
        exports.rectangleneedle = rectangleNeedle;
        exports.triangleneedle = triangleNeedle;
        exports.twocolorneedle = twoColorNeedle;
        exports.trianglemarker = triangleMarker;
        exports.textcloud = textCloud;
        exports.rangebar = rangeBar
    },
    /*!*********************************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/circular_range_container.js ***!
      \*********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var BaseRangeContainer = __webpack_require__( /*! ./base_range_container */ 431);
        var _Number = Number;
        var _max = Math.max;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var CircularRangeContainer = BaseRangeContainer.inherit({
            _processOptions: function() {
                var that = this;
                that._inner = that._outer = 0;
                switch (_normalizeEnum(that._options.orientation)) {
                    case "inside":
                        that._inner = 1;
                        break;
                    case "center":
                        that._inner = that._outer = .5;
                        break;
                    default:
                        that._outer = 1
                }
            },
            _isVisible: function(layout) {
                var width = this._options.width;
                width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                return layout.radius - this._inner * width > 0
            },
            _createRange: function(range, layout) {
                var that = this;
                var width = (range.startWidth + range.endWidth) / 2;
                return that._renderer.arc(layout.x, layout.y, layout.radius - that._inner * width, layout.radius + that._outer * width, that._translator.translate(range.end), that._translator.translate(range.start)).attr({
                    "stroke-linejoin": "round"
                })
            },
            measure: function(layout) {
                var width = this._options.width;
                width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                return {
                    min: layout.radius - this._inner * width,
                    max: layout.radius + this._outer * width
                }
            }
        });
        module.exports = CircularRangeContainer
    },
    /*!***********************************************!*\
      !*** ./artifacts/transpiled/viz/bar_gauge.js ***!
      \***********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./gauges/bar_gauge */ 852).dxBarGauge
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/gauges/bar_gauge.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var PI_DIV_180 = Math.PI / 180;
        var _abs = Math.abs;
        var _round = Math.round;
        var _floor = Math.floor;
        var _min = Math.min;
        var _max = Math.max;
        var registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 9);
        var objectUtils = __webpack_require__( /*! ../../core/utils/object */ 47);
        var commonUtils = __webpack_require__( /*! ../../core/utils/common */ 3);
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var baseGaugeModule = __webpack_require__( /*! ./base_gauge */ 153);
        var dxBaseGauge = baseGaugeModule.dxBaseGauge;
        var _getSampleText = baseGaugeModule.getSampleText;
        var _formatValue = baseGaugeModule.formatValue;
        var _compareArrays = baseGaugeModule.compareArrays;
        var dxCircularGauge = __webpack_require__( /*! ./circular_gauge */ 432);
        var _isArray = Array.isArray;
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var _convertAngleToRendererSpace = vizUtils.convertAngleToRendererSpace;
        var _getCosAndSin = vizUtils.getCosAndSin;
        var _patchFontOptions = vizUtils.patchFontOptions;
        var _Number = Number;
        var _isFinite = isFinite;
        var _noop = commonUtils.noop;
        var _extend = extend;
        var OPTION_VALUES = "values";
        var BarWrapper;
        var dxBarGauge = dxBaseGauge.inherit({
            _rootClass: "dxbg-bar-gauge",
            _themeSection: "barGauge",
            _fontFields: ["label.font", "legend.font", "legend.title.font", "legend.title.subtitle.font"],
            _initCore: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                that._barsGroup = that._renderer.g().attr({
                    "class": "dxbg-bars"
                }).linkOn(that._renderer.root, "bars");
                that._values = [];
                that._context = {
                    renderer: that._renderer,
                    translator: that._translator,
                    tracker: that._tracker,
                    group: that._barsGroup
                };
                that._animateStep = function(pos) {
                    var bars = that._bars;
                    var i;
                    var ii;
                    for (i = 0, ii = bars.length; i < ii; ++i) {
                        bars[i].animate(pos)
                    }
                };
                that._animateComplete = function() {
                    that._bars.forEach(function(bar) {
                        return bar.endAnimation()
                    });
                    that._checkOverlap()
                }
            },
            _disposeCore: function() {
                var that = this;
                that._barsGroup.linkOff();
                that._barsGroup = that._values = that._context = that._animateStep = that._animateComplete = null;
                that.callBase.apply(that, arguments)
            },
            _setupDomainCore: function() {
                var that = this;
                var startValue = that.option("startValue");
                var endValue = that.option("endValue");
                _isFinite(startValue) || (startValue = 0);
                _isFinite(endValue) || (endValue = 100);
                that._translator.setDomain(startValue, endValue);
                that._baseValue = that._translator.adjust(that.option("baseValue"));
                _isFinite(that._baseValue) || (that._baseValue = startValue < endValue ? startValue : endValue)
            },
            _getDefaultSize: function() {
                return {
                    width: 300,
                    height: 300
                }
            },
            _setupCodomain: dxCircularGauge.prototype._setupCodomain,
            _getApproximateScreenRange: function() {
                var that = this;
                var sides = that._area.sides;
                var width = that._canvas.width / (sides.right - sides.left);
                var height = that._canvas.height / (sides.down - sides.up);
                var r = width < height ? width : height;
                return -that._translator.getCodomainRange() * r * PI_DIV_180
            },
            _setupAnimationSettings: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                if (that._animationSettings) {
                    that._animationSettings.step = that._animateStep;
                    that._animationSettings.complete = that._animateComplete
                }
            },
            _cleanContent: function() {
                var that = this;
                that._barsGroup.linkRemove();
                that._animationSettings && that._barsGroup.stopAnimation();
                that._barsGroup.clear()
            },
            _renderContent: function() {
                var that = this;
                var labelOptions = that.option("label");
                var text;
                var bBox;
                var context = that._context;
                that._barsGroup.linkAppend();
                context.textEnabled = void 0 === labelOptions || labelOptions && (!("visible" in labelOptions) || labelOptions.visible);
                if (context.textEnabled) {
                    context.textColor = labelOptions && labelOptions.font && labelOptions.font.color || null;
                    labelOptions = _extend(true, {}, that._themeManager.theme().label, labelOptions);
                    context.formatOptions = {
                        format: void 0 !== labelOptions.format ? labelOptions.format : that._defaultFormatOptions,
                        customizeText: labelOptions.customizeText
                    };
                    context.textOptions = {
                        align: "center"
                    };
                    context.fontStyles = _patchFontOptions(_extend({}, that._themeManager.theme().label.font, labelOptions.font, {
                        color: null
                    }));
                    that._textIndent = labelOptions.indent > 0 ? _Number(labelOptions.indent) : 0;
                    context.lineWidth = labelOptions.connectorWidth > 0 ? _Number(labelOptions.connectorWidth) : 0;
                    context.lineColor = labelOptions.connectorColor || null;
                    text = that._renderer.text(_getSampleText(that._translator, context.formatOptions), 0, 0).attr(context.textOptions).css(context.fontStyles).append(that._barsGroup);
                    bBox = text.getBBox();
                    text.remove();
                    context.textY = bBox.y;
                    context.textWidth = bBox.width;
                    context.textHeight = bBox.height
                }
                dxCircularGauge.prototype._applyMainLayout.call(that);
                that._renderBars()
            },
            _measureMainElements: function() {
                var result = {
                    maxRadius: this._area.radius
                };
                if (this._context.textEnabled) {
                    result.horizontalMargin = this._context.textWidth;
                    result.verticalMargin = this._context.textHeight;
                    result.inverseHorizontalMargin = this._context.textWidth / 2;
                    result.inverseVerticalMargin = this._context.textHeight / 2
                }
                return result
            },
            _renderBars: function() {
                var that = this;
                var options = _extend({}, that._themeManager.theme(), that.option());
                var radius;
                var area = that._area;
                var relativeInnerRadius = options.relativeInnerRadius > 0 && options.relativeInnerRadius < 1 ? _Number(options.relativeInnerRadius) : .1;
                radius = area.radius;
                if (that._context.textEnabled) {
                    that._textIndent = _round(_min(that._textIndent, radius / 2));
                    radius -= that._textIndent
                }
                that._outerRadius = _floor(radius);
                that._innerRadius = _floor(radius * relativeInnerRadius);
                that._barSpacing = options.barSpacing > 0 ? _Number(options.barSpacing) : 0;
                _extend(that._context, {
                    backgroundColor: options.backgroundColor,
                    x: area.x,
                    y: area.y,
                    startAngle: area.startCoord,
                    endAngle: area.endCoord,
                    baseAngle: that._translator.translate(that._baseValue)
                });
                that._arrangeBars()
            },
            _arrangeBars: function() {
                var that = this;
                var radius = that._outerRadius - that._innerRadius;
                var context = that._context;
                var i;
                var count = that._bars.length;
                that._beginValueChanging();
                context.barSize = count > 0 ? _max((radius - (count - 1) * that._barSpacing) / count, 1) : 0;
                var spacing = count > 1 ? _max(_min((radius - count * context.barSize) / (count - 1), that._barSpacing), 0) : 0;
                var _count = _min(_floor((radius + spacing) / context.barSize), count);
                that._setBarsCount(count);
                radius = that._outerRadius;
                context.textRadius = radius;
                context.textIndent = that._textIndent;
                that._palette.reset();
                var unitOffset = context.barSize + spacing;
                var colors = that._palette.generateColors(_count);
                for (i = 0; i < _count; ++i, radius -= unitOffset) {
                    that._bars[i].arrange({
                        radius: radius,
                        color: colors[i]
                    })
                }
                for (var _i = _count; _i < count; _i++) {
                    that._bars[_i].hide()
                }
                if (that._animationSettings && !that._noAnimation) {
                    that._animateBars()
                } else {
                    that._updateBars()
                }
                that._endValueChanging()
            },
            _setBarsCount: function() {
                var that = this;
                if (that._bars.length > 0) {
                    if (that._dummyBackground) {
                        that._dummyBackground.dispose();
                        that._dummyBackground = null
                    }
                } else {
                    if (!that._dummyBackground) {
                        that._dummyBackground = that._renderer.arc().attr({
                            "stroke-linejoin": "round"
                        })
                    }
                    that._dummyBackground.attr({
                        x: that._context.x,
                        y: that._context.y,
                        outerRadius: that._outerRadius,
                        innerRadius: that._innerRadius,
                        startAngle: that._context.endAngle,
                        endAngle: that._context.startAngle,
                        fill: that._context.backgroundColor
                    }).append(that._barsGroup)
                }
            },
            _updateBars: function() {
                this._bars.forEach(function(bar) {
                    return bar.applyValue()
                });
                this._checkOverlap()
            },
            _checkOverlap: function() {
                var that = this;
                var bars = that._bars;
                var overlapStrategy = _normalizeEnum(that._getOption("resolveLabelOverlapping", true));
                if ("none" === overlapStrategy) {
                    return
                }
                var sortedBars = bars.concat().sort(function(a, b) {
                    return a.getValue() - b.getValue()
                });
                var currentIndex = 0;
                var nextIndex = 1;
                while (currentIndex < sortedBars.length && nextIndex < sortedBars.length) {
                    var current = sortedBars[currentIndex];
                    var next = sortedBars[nextIndex];
                    if (current.checkIntersect(next)) {
                        next.hideLabel();
                        nextIndex++
                    } else {
                        currentIndex = nextIndex;
                        nextIndex = currentIndex + 1
                    }
                }
            },
            _animateBars: function() {
                var that = this;
                var i;
                var ii = that._bars.length;
                if (ii > 0) {
                    for (i = 0; i < ii; ++i) {
                        that._bars[i].beginAnimation()
                    }
                    that._barsGroup.animate({
                        _: 0
                    }, that._animationSettings)
                }
            },
            _buildNodes: function() {
                var that = this;
                var options = that._options.silent();
                that._palette = that._themeManager.createPalette(options.palette, {
                    useHighlight: true,
                    extensionMode: options.paletteExtensionMode
                });
                that._palette.reset();
                that._bars = that._bars || [];
                that._animationSettings && that._barsGroup.stopAnimation();
                var barValues = that._values.filter(_isFinite);
                var count = barValues.length;
                if (that._bars.length > count) {
                    var ii = that._bars.length;
                    for (var i = count; i < ii; ++i) {
                        that._bars[i].dispose()
                    }
                    that._bars.splice(count, ii - count)
                } else {
                    if (that._bars.length < count) {
                        for (var _i2 = that._bars.length; _i2 < count; ++_i2) {
                            that._bars.push(new BarWrapper(_i2, that._context))
                        }
                    }
                }
                that._bars.forEach(function(bar, index) {
                    bar.update({
                        color: that._palette.getNextColor(count),
                        value: barValues[index]
                    })
                })
            },
            _updateValues: function(values) {
                var that = this;
                var list = _isArray(values) && values || _isFinite(values) && [values] || [];
                var i;
                var ii = list.length;
                var value;
                that._values.length = ii;
                for (i = 0; i < ii; ++i) {
                    value = list[i];
                    that._values[i] = value = _Number(_isFinite(value) ? value : that._values[i])
                }
                if (!that._resizing) {
                    if (!_compareArrays(that._values, that.option(OPTION_VALUES))) {
                        that.option(OPTION_VALUES, that._values.slice())
                    }
                }
                this._change(["NODES"])
            },
            values: function(arg) {
                if (void 0 !== arg) {
                    this._updateValues(arg);
                    return this
                } else {
                    return this._values.slice(0)
                }
            },
            _optionChangesMap: {
                backgroundColor: "MOSTLY_TOTAL",
                relativeInnerRadius: "MOSTLY_TOTAL",
                barSpacing: "MOSTLY_TOTAL",
                label: "MOSTLY_TOTAL",
                resolveLabelOverlapping: "MOSTLY_TOTAL",
                palette: "MOSTLY_TOTAL",
                paletteExtensionMode: "MOSTLY_TOTAL",
                values: "VALUES"
            },
            _change_VALUES: function() {
                this._updateValues(this.option(OPTION_VALUES))
            },
            _factory: objectUtils.clone(dxBaseGauge.prototype._factory),
            _optionChangesOrder: ["VALUES", "NODES"],
            _initialChanges: ["VALUES"],
            _change_NODES: function() {
                this._buildNodes()
            },
            _change_MOSTLY_TOTAL: function() {
                this._change(["NODES"]);
                this.callBase()
            },
            _proxyData: [],
            _getLegendData: function() {
                var that = this;
                var formatOptions = {};
                var options = that._options.silent();
                var labelFormatOptions = (options.label || {}).format;
                var legendFormatOptions = (options.legend || {}).itemTextFormat;
                if (legendFormatOptions) {
                    formatOptions.format = legendFormatOptions
                } else {
                    formatOptions.format = labelFormatOptions || that._defaultFormatOptions
                }
                return (this._bars || []).map(function(b) {
                    return {
                        id: b.index,
                        item: {
                            value: b.getValue(),
                            color: b.getColor(),
                            index: b.index
                        },
                        text: _formatValue(b.getValue(), formatOptions),
                        visible: true,
                        states: {
                            normal: {
                                fill: b.getColor()
                            }
                        }
                    }
                })
            }
        });
        BarWrapper = function(index, context) {
            var that = this;
            that._context = context;
            that._tracker = context.renderer.arc().attr({
                "stroke-linejoin": "round"
            });
            that.index = index
        };
        _extend(BarWrapper.prototype, {
            dispose: function() {
                var that = this;
                that._background.dispose();
                that._bar.dispose();
                if (that._context.textEnabled) {
                    that._line.dispose();
                    that._text.dispose()
                }
                that._context.tracker.detach(that._tracker);
                that._context = that._settings = that._background = that._bar = that._line = that._text = that._tracker = null;
                return that
            },
            arrange: function(options) {
                var that = this;
                var context = that._context;
                this._visible = true;
                context.tracker.attach(that._tracker, that, {
                    index: that.index
                });
                that._background = context.renderer.arc().attr({
                    "stroke-linejoin": "round",
                    fill: context.backgroundColor
                }).append(context.group);
                that._settings = that._settings || {
                    x: context.x,
                    y: context.y,
                    startAngle: context.baseAngle,
                    endAngle: context.baseAngle
                };
                that._bar = context.renderer.arc().attr(_extend({
                    "stroke-linejoin": "round"
                }, that._settings)).append(context.group);
                if (context.textEnabled) {
                    that._line = context.renderer.path([], "line").attr({
                        "stroke-width": context.lineWidth
                    }).append(context.group);
                    that._text = context.renderer.text().css(context.fontStyles).attr(context.textOptions).append(context.group)
                }
                that._angle = isFinite(that._angle) ? that._angle : context.baseAngle;
                that._settings.outerRadius = options.radius;
                that._settings.innerRadius = options.radius - context.barSize;
                that._settings.x = context.x;
                that._settings.y = context.y;
                that._background.attr(_extend({}, that._settings, {
                    startAngle: context.endAngle,
                    endAngle: context.startAngle,
                    fill: that._context.backgroundColor
                }));
                that._bar.attr({
                    x: context.x,
                    y: context.y,
                    outerRadius: that._settings.outerRadius,
                    innerRadius: that._settings.innerRadius,
                    fill: that._color
                });
                that._tracker.attr(that._settings);
                if (context.textEnabled) {
                    that._line.attr({
                        points: [context.x, context.y - that._settings.innerRadius, context.x, context.y - context.textRadius - context.textIndent],
                        stroke: context.lineColor || that._color
                    }).sharp();
                    that._text.css({
                        fill: context.textColor || that._color
                    })
                }
                return that
            },
            getTooltipParameters: function() {
                var that = this;
                var cosSin = _getCosAndSin((that._angle + that._context.baseAngle) / 2);
                return {
                    x: _round(that._context.x + (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.cos),
                    y: _round(that._context.y - (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.sin),
                    offset: 0,
                    color: that._color,
                    value: that._value
                }
            },
            setAngle: function(angle) {
                var that = this;
                var context = that._context;
                var settings = that._settings;
                var cosSin;
                that._angle = angle;
                setAngles(settings, context.baseAngle, angle);
                that._bar.attr(settings);
                that._tracker.attr(settings);
                if (context.textEnabled) {
                    cosSin = _getCosAndSin(angle);
                    var indent = context.textIndent;
                    var radius = context.textRadius + indent;
                    var x = context.x + radius * cosSin.cos;
                    var y = context.y - radius * cosSin.sin;
                    var halfWidth = .5 * context.textWidth;
                    var textHeight = context.textHeight;
                    var textY = context.textY;
                    if (_abs(x - context.x) > indent) {
                        x += x < context.x ? -halfWidth : halfWidth
                    }
                    if (_abs(y - context.y) <= indent) {
                        y -= textY + .5 * textHeight
                    } else {
                        y -= y < context.y ? textY + textHeight : textY
                    }
                    var text = _formatValue(that._value, context.formatOptions, {
                        index: that.index
                    });
                    var visibility = "" === text ? "hidden" : null;
                    that._text.attr({
                        text: text,
                        x: x,
                        y: y,
                        visibility: visibility
                    });
                    that._line.attr({
                        visibility: visibility
                    });
                    that._line.rotate(_convertAngleToRendererSpace(angle), context.x, context.y)
                }
                return that
            },
            hideLabel: function() {
                this._text.attr({
                    visibility: "hidden"
                });
                this._line.attr({
                    visibility: "hidden"
                })
            },
            checkIntersect: function(anotherBar) {
                var coords = this.calculateLabelCoords();
                var anotherCoords = anotherBar.calculateLabelCoords();
                if (!coords || !anotherCoords) {
                    return false
                }
                var width = Math.max(0, Math.min(coords.bottomRight.x, anotherCoords.bottomRight.x) - Math.max(coords.topLeft.x, anotherCoords.topLeft.x));
                var height = Math.max(0, Math.min(coords.bottomRight.y, anotherCoords.bottomRight.y) - Math.max(coords.topLeft.y, anotherCoords.topLeft.y));
                return width * height !== 0
            },
            calculateLabelCoords: function() {
                if (!this._text) {
                    return
                }
                var box = this._text.getBBox();
                return {
                    topLeft: {
                        x: box.x,
                        y: box.y
                    },
                    bottomRight: {
                        x: box.x + box.width,
                        y: box.y + box.height
                    }
                }
            },
            _processValue: function(value) {
                return this._context.translator.translate(this._context.translator.adjust(value))
            },
            applyValue: function() {
                if (!this._visible) {
                    return this
                }
                return this.setAngle(this._processValue(this.getValue()))
            },
            update: function(_ref) {
                var color = _ref.color,
                    value = _ref.value;
                this._color = color;
                this._value = value
            },
            hide: function() {
                this._visible = false
            },
            getColor: function() {
                return this._color
            },
            getValue: function() {
                return this._value
            },
            beginAnimation: function() {
                if (!this._visible) {
                    return this
                }
                var that = this;
                var angle = this._processValue(this.getValue());
                if (!compareFloats(that._angle, angle)) {
                    that._start = that._angle;
                    that._delta = angle - that._angle;
                    that._tracker.attr({
                        visibility: "hidden"
                    });
                    if (that._context.textEnabled) {
                        that._line.attr({
                            visibility: "hidden"
                        });
                        that._text.attr({
                            visibility: "hidden"
                        })
                    }
                } else {
                    that.animate = _noop;
                    that.setAngle(that._angle)
                }
            },
            animate: function(pos) {
                if (!this._visible) {
                    return this
                }
                var that = this;
                that._angle = that._start + that._delta * pos;
                setAngles(that._settings, that._context.baseAngle, that._angle);
                that._bar.attr(that._settings)
            },
            endAnimation: function() {
                var that = this;
                if (void 0 !== that._delta) {
                    if (compareFloats(that._angle, that._start + that._delta)) {
                        that._tracker.attr({
                            visibility: null
                        });
                        that.setAngle(that._angle)
                    }
                } else {
                    delete that.animate
                }
                delete that._start;
                delete that._delta
            }
        });

        function setAngles(target, angle1, angle2) {
            target.startAngle = angle1 < angle2 ? angle1 : angle2;
            target.endAngle = angle1 < angle2 ? angle2 : angle1
        }

        function compareFloats(value1, value2) {
            return _abs(value1 - value2) < 1e-4
        }
        registerComponent("dxBarGauge", dxBarGauge);
        exports.dxBarGauge = dxBarGauge;
        dxBarGauge.addPlugin(__webpack_require__( /*! ../components/legend */ 207).plugin);
        var __BarWrapper = BarWrapper;
        exports.BarWrapper = __BarWrapper;
        exports.stubBarWrapper = function(barWrapperType) {
            BarWrapper = barWrapperType
        };
        exports.restoreBarWrapper = function() {
            BarWrapper = __BarWrapper
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./range_selector/range_selector */ 854)
    },
    /*!*******************************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector/range_selector.js ***!
      \*******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _component_registrator = __webpack_require__( /*! ../../core/component_registrator */ 9);
        var _component_registrator2 = _interopRequireDefault(_component_registrator);
        var _type2 = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _date = __webpack_require__( /*! ../../core/utils/date */ 24);
        var _math = __webpack_require__( /*! ../../core/utils/math */ 31);
        var _range = __webpack_require__( /*! ../translators/range */ 112);
        var _range2 = _interopRequireDefault(_range);
        var _base_axis = __webpack_require__( /*! ../axes/base_axis */ 211);
        var _base_axis2 = _interopRequireDefault(_base_axis);
        var _parse_utils = __webpack_require__( /*! ../components/parse_utils */ 260);
        var _parse_utils2 = _interopRequireDefault(_parse_utils);
        var _format_helper = __webpack_require__( /*! ../../format_helper */ 63);
        var _format_helper2 = _interopRequireDefault(_format_helper);
        var _common = __webpack_require__( /*! ./common */ 214);
        var _common2 = _interopRequireDefault(_common);
        var _sliders_controller = __webpack_require__( /*! ./sliders_controller */ 855);
        var _sliders_controller2 = _interopRequireDefault(_sliders_controller);
        var _tracker = __webpack_require__( /*! ./tracker */ 858);
        var _range_view = __webpack_require__( /*! ./range_view */ 859);
        var _range_view2 = _interopRequireDefault(_range_view);
        var _series_data_source = __webpack_require__( /*! ./series_data_source */ 860);
        var _series_data_source2 = _interopRequireDefault(_series_data_source);
        var _tick_generator = __webpack_require__( /*! ../axes/tick_generator */ 425);
        var _tick_generator2 = _interopRequireDefault(_tick_generator);
        var _base_widget = __webpack_require__( /*! ../core/base_widget */ 102);
        var _base_widget2 = _interopRequireDefault(_base_widget);
        var _export = __webpack_require__( /*! ../core/export */ 99);
        var _title = __webpack_require__( /*! ../core/title */ 109);
        var _loading_indicator = __webpack_require__( /*! ../core/loading_indicator */ 127);
        var _data_source = __webpack_require__( /*! ../core/data_source */ 152);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _max = Math.max;
        var _ceil = Math.ceil;
        var _floor = Math.floor;
        var START_VALUE = "startValue";
        var END_VALUE = "endValue";
        var DATETIME = "datetime";
        var VALUE = "value";
        var DISCRETE = "discrete";
        var SEMIDISCRETE = "semidiscrete";
        var STRING = "string";
        var VALUE_CHANGED = VALUE + "Changed";
        var CONTAINER_BACKGROUND_COLOR = "containerBackgroundColor";
        var SLIDER_MARKER = "sliderMarker";
        var OPTION_BACKGROUND = "background";
        var LOGARITHMIC = "logarithmic";
        var KEEP = "keep";
        var SHIFT = "shift";
        var RESET = "reset";
        var INVISIBLE_POS = -1e3;
        var SEMIDISCRETE_GRID_SPACING_FACTOR = 50;
        var DEFAULT_AXIS_DIVISION_FACTOR = 30;
        var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;
        var logarithmBase = 10;

        function calculateMarkerHeight(renderer, value, sliderMarkerOptions) {
            var formattedText = void 0 === value ? _common2.default.consts.emptySliderMarkerText : _common2.default.formatValue(value, sliderMarkerOptions);
            var textBBox = getTextBBox(renderer, formattedText, sliderMarkerOptions.font);
            return _ceil(textBBox.height) + 2 * sliderMarkerOptions.paddingTopBottom + _common2.default.consts.pointerSize
        }

        function calculateScaleLabelHalfWidth(renderer, value, scaleOptions, tickIntervalsInfo) {
            var formattedText = _common2.default.formatValue(value, scaleOptions.label, tickIntervalsInfo, scaleOptions.valueType, scaleOptions.type, scaleOptions.logarithmBase);
            var textBBox = getTextBBox(renderer, formattedText, scaleOptions.label.font);
            return _ceil(textBBox.width / 2)
        }

        function calculateIndents(renderer, scale, sliderMarkerOptions, indentOptions, tickIntervalsInfo) {
            var leftMarkerHeight;
            var leftScaleLabelWidth = 0;
            var rightScaleLabelWidth = 0;
            var rightMarkerHeight;
            var placeholderWidthLeft;
            var placeholderWidthRight;
            var placeholderHeight;
            var ticks = "semidiscrete" === scale.type ? scale.customTicks : tickIntervalsInfo.ticks;
            var startTickValue;
            var endTickValue;
            indentOptions = indentOptions || {};
            placeholderWidthLeft = indentOptions.left;
            placeholderWidthRight = indentOptions.right;
            placeholderHeight = sliderMarkerOptions.placeholderHeight;
            if (sliderMarkerOptions.visible) {
                leftMarkerHeight = calculateMarkerHeight(renderer, scale.startValue, sliderMarkerOptions);
                rightMarkerHeight = calculateMarkerHeight(renderer, scale.endValue, sliderMarkerOptions);
                if (void 0 === placeholderHeight) {
                    placeholderHeight = _max(leftMarkerHeight, rightMarkerHeight)
                }
            }
            if (scale.label.visible) {
                startTickValue = (0, _type2.isDefined)(scale.startValue) ? ticks[0] : void 0;
                endTickValue = (0, _type2.isDefined)(scale.endValue) ? ticks[ticks.length - 1] : void 0;
                leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, startTickValue, scale, tickIntervalsInfo);
                rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, endTickValue, scale, tickIntervalsInfo)
            }
            placeholderWidthLeft = void 0 !== placeholderWidthLeft ? placeholderWidthLeft : leftScaleLabelWidth;
            placeholderWidthRight = (void 0 !== placeholderWidthRight ? placeholderWidthRight : rightScaleLabelWidth) || 1;
            return {
                left: placeholderWidthLeft,
                right: placeholderWidthRight,
                top: placeholderHeight || 0,
                bottom: 0
            }
        }

        function calculateValueType(firstValue, secondValue) {
            var typeFirstValue = (0, _type2.type)(firstValue);
            var typeSecondValue = (0, _type2.type)(secondValue);
            var validType = function(type) {
                return typeFirstValue === type || typeSecondValue === type
            };
            return validType("date") ? DATETIME : validType("number") ? "numeric" : validType(STRING) ? STRING : ""
        }

        function showScaleMarkers(scaleOptions) {
            return scaleOptions.valueType === DATETIME && scaleOptions.marker.visible
        }

        function updateTranslatorRangeInterval(translatorRange, scaleOptions) {
            var intervalX = scaleOptions.minorTickInterval || scaleOptions.tickInterval;
            if ("datetime" === scaleOptions.valueType) {
                intervalX = (0, _date.dateToMilliseconds)(intervalX)
            }
            translatorRange.addRange({
                interval: intervalX
            })
        }

        function checkLogarithmicOptions(options, defaultLogarithmBase, incidentOccurred) {
            if (!options) {
                return
            }
            var logarithmBase = options.logarithmBase;
            if (options.type === LOGARITHMIC && logarithmBase <= 0 || logarithmBase && !(0, _type2.isNumeric)(logarithmBase)) {
                options.logarithmBase = defaultLogarithmBase;
                incidentOccurred("E2104")
            } else {
                if (options.type !== LOGARITHMIC) {
                    options.logarithmBase = void 0
                }
            }
        }

        function calculateScaleAreaHeight(renderer, scaleOptions, visibleMarkers, tickIntervalsInfo) {
            var labelScaleOptions = scaleOptions.label;
            var markerScaleOptions = scaleOptions.marker;
            var placeholderHeight = scaleOptions.placeholderHeight;
            var ticks = "semidiscrete" === scaleOptions.type ? scaleOptions.customTicks : tickIntervalsInfo.ticks;
            var text = _common2.default.formatValue(ticks[0], labelScaleOptions);
            if (placeholderHeight) {
                return placeholderHeight
            } else {
                return (labelScaleOptions.visible ? labelScaleOptions.topIndent + getTextBBox(renderer, text, labelScaleOptions.font).height : 0) + (visibleMarkers ? markerScaleOptions.topIndent + markerScaleOptions.separatorHeight : 0)
            }
        }

        function getMinorTickIntervalUnit(tickInterval, minorTickInterval, withCorrection) {
            var interval = (0, _date.getDateUnitInterval)(minorTickInterval);
            var majorUnit = (0, _date.getDateUnitInterval)(tickInterval);
            var idx = _date.dateUnitIntervals.indexOf(interval);
            if (withCorrection && interval === majorUnit && idx > 0) {
                interval = _date.dateUnitIntervals[idx - 1]
            }
            return interval
        }

        function getNextTickInterval(tickInterval, minorTickInterval, isDateType) {
            if (!tickInterval) {
                tickInterval = minorTickInterval
            } else {
                if (isDateType) {
                    tickInterval = (0, _date.getNextDateUnit)(tickInterval)
                } else {
                    tickInterval += minorTickInterval
                }
            }
            return tickInterval
        }

        function calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta) {
            var minorTickInterval = scaleOptions.minorTickInterval;
            var tickInterval = scaleOptions.tickInterval;
            var interval;
            var isDateType = "datetime" === scaleOptions.valueType;
            var gridSpacingFactor = scaleOptions.axisDivisionFactor || {};
            var tickCountByInterval;
            var tickCountByScreen;
            if (!tickInterval) {
                do {
                    interval = getNextTickInterval(tickInterval, minorTickInterval, isDateType);
                    if (tickInterval !== interval) {
                        tickInterval = interval
                    } else {
                        break
                    }
                    if (isDateType) {
                        interval = (0, _date.dateToMilliseconds)(tickInterval)
                    }
                    tickCountByInterval = _ceil((max - min) / interval);
                    tickCountByScreen = _floor(screenDelta / (gridSpacingFactor[tickInterval] || SEMIDISCRETE_GRID_SPACING_FACTOR)) || 1
                } while (interval && tickCountByInterval > tickCountByScreen)
            }
            return {
                tickInterval: tickInterval,
                minorTickInterval: minorTickInterval,
                bounds: {
                    minVisible: min,
                    maxVisible: max
                },
                ticks: []
            }
        }

        function updateTickIntervals(scaleOptions, screenDelta, incidentOccurred, range) {
            var result;
            var min = (0, _type2.isDefined)(range.minVisible) ? range.minVisible : range.min;
            var max = (0, _type2.isDefined)(range.maxVisible) ? range.maxVisible : range.max;
            var categoriesInfo = scaleOptions._categoriesInfo;
            var ticksInfo;
            var length;
            var bounds = {};
            if (scaleOptions.type === SEMIDISCRETE) {
                result = calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta)
            } else {
                ticksInfo = _tick_generator2.default.tickGenerator({
                    axisType: scaleOptions.type,
                    dataType: scaleOptions.valueType,
                    logBase: scaleOptions.logarithmBase,
                    allowNegatives: true,
                    linearThreshold: Math.abs(scaleOptions.linearThreshold || 0),
                    axisDivisionFactor: scaleOptions.axisDivisionFactor,
                    minorAxisDivisionFactor: scaleOptions.minorAxisDivisionFactor,
                    calculateMinors: true,
                    allowDecimals: scaleOptions.allowDecimals,
                    endOnTick: scaleOptions.endOnTick,
                    incidentOccurred: incidentOccurred,
                    rangeIsEmpty: range.isEmpty()
                })({
                    min: min,
                    max: max,
                    categories: (0, _type2.isDefined)(categoriesInfo) ? categoriesInfo.categories : []
                }, screenDelta, scaleOptions.tickInterval, scaleOptions.forceUserTickInterval, void 0, scaleOptions.minorTickInterval, scaleOptions.minorTickCount);
                length = ticksInfo.ticks.length;
                bounds.minVisible = ticksInfo.ticks[0] < min ? ticksInfo.ticks[0] : min;
                bounds.maxVisible = ticksInfo.ticks[length - 1] > max ? ticksInfo.ticks[length - 1] : max;
                result = {
                    tickInterval: ticksInfo.tickInterval,
                    minorTickInterval: 0 === scaleOptions.minorTickInterval ? 0 : ticksInfo.minorTickInterval,
                    bounds: bounds,
                    ticks: ticksInfo.ticks
                }
            }
            return result
        }

        function getFirstDayOfWeek(options) {
            var _options$workWeek;
            return null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0]
        }

        function calculateTranslatorRange(seriesDataSource, scaleOptions) {
            var minValue;
            var maxValue;
            var inverted = false;
            var startValue = scaleOptions.startValue;
            var endValue = scaleOptions.endValue;
            var categories;
            var categoriesInfo;
            var translatorRange = seriesDataSource ? seriesDataSource.getBoundRange().arg : new _range2.default.Range;
            var rangeForCategories;
            var isDate = "datetime" === scaleOptions.valueType;
            var firstDayOfWeek = getFirstDayOfWeek(scaleOptions);
            var minRange = scaleOptions.minRange;
            if (scaleOptions.type === DISCRETE) {
                rangeForCategories = new _range2.default.Range({
                    minVisible: startValue,
                    maxVisible: endValue
                });
                rangeForCategories.addRange(translatorRange);
                translatorRange = rangeForCategories;
                categories = seriesDataSource ? seriesDataSource.argCategories : scaleOptions.categories || !seriesDataSource && startValue && endValue && [startValue, endValue];
                categories = categories || [];
                scaleOptions._categoriesInfo = categoriesInfo = (0, _utils.getCategoriesInfo)(categories, startValue, endValue)
            }
            if (scaleOptions.type === SEMIDISCRETE) {
                startValue = scaleOptions.startValue = correctValueByInterval(scaleOptions.startValue, isDate, minRange, firstDayOfWeek);
                endValue = scaleOptions.endValue = correctValueByInterval(scaleOptions.endValue, isDate, minRange, firstDayOfWeek);
                translatorRange.minVisible = correctValueByInterval(translatorRange.minVisible, isDate, minRange, firstDayOfWeek);
                translatorRange.maxVisible = correctValueByInterval(translatorRange.maxVisible, isDate, minRange, firstDayOfWeek);
                translatorRange.min = correctValueByInterval(translatorRange.min, isDate, minRange, firstDayOfWeek);
                translatorRange.max = correctValueByInterval(translatorRange.max, isDate, minRange, firstDayOfWeek)
            }
            if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {
                inverted = categoriesInfo ? categoriesInfo.inverted : startValue > endValue;
                minValue = categoriesInfo ? categoriesInfo.start : inverted ? endValue : startValue;
                maxValue = categoriesInfo ? categoriesInfo.end : inverted ? startValue : endValue
            } else {
                if ((0, _type2.isDefined)(startValue) || (0, _type2.isDefined)(endValue)) {
                    minValue = startValue;
                    maxValue = endValue
                } else {
                    if (categoriesInfo) {
                        minValue = categoriesInfo.start;
                        maxValue = categoriesInfo.end
                    }
                }
            }
            translatorRange.addRange({
                invert: inverted,
                min: minValue,
                max: maxValue,
                minVisible: minValue,
                maxVisible: maxValue,
                dataType: scaleOptions.valueType
            });
            translatorRange.addRange({
                categories: !seriesDataSource ? categories : void 0,
                base: scaleOptions.logarithmBase,
                axisType: scaleOptions.type,
                dataType: scaleOptions.valueType
            });
            seriesDataSource && translatorRange.sortCategories(categories);
            return translatorRange
        }

        function startEndNotDefined(start, end) {
            return !(0, _type2.isDefined)(start) || !(0, _type2.isDefined)(end)
        }

        function getTextBBox(renderer, text, fontOptions) {
            var textElement = renderer.text(text, INVISIBLE_POS, INVISIBLE_POS).css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);
            var textBBox = textElement.getBBox();
            textElement.remove();
            return textBBox
        }

        function getDateMarkerVisibilityChecker(screenDelta) {
            return function(isDateScale, isMarkerVisible, min, max, tickInterval) {
                if (isMarkerVisible && isDateScale) {
                    if (!(0, _type2.isDefined)(tickInterval) || tickInterval.years || tickInterval.months >= 6 || screenDelta / SEMIDISCRETE_GRID_SPACING_FACTOR < _ceil((max - min) / (0, _date.dateToMilliseconds)("year")) + 1) {
                        isMarkerVisible = false
                    }
                }
                return isMarkerVisible
            }
        }

        function updateScaleOptions(scaleOptions, seriesDataSource, translatorRange, tickIntervalsInfo, checkDateMarkerVisibility) {
            var bounds;
            var isEmptyInterval;
            var categoriesInfo = scaleOptions._categoriesInfo;
            var intervals;
            var isDateTime = scaleOptions.valueType === DATETIME;
            if (seriesDataSource && !seriesDataSource.isEmpty() && !translatorRange.isEmpty()) {
                bounds = tickIntervalsInfo.bounds;
                translatorRange.addRange(bounds);
                scaleOptions.startValue = translatorRange.invert ? bounds.maxVisible : bounds.minVisible;
                scaleOptions.endValue = translatorRange.invert ? bounds.minVisible : bounds.maxVisible
            }
            scaleOptions.marker.visible = checkDateMarkerVisibility(isDateTime && scaleOptions.type.indexOf(DISCRETE) === -1, scaleOptions.marker.visible, scaleOptions.startValue, scaleOptions.endValue, tickIntervalsInfo.tickInterval);
            if (categoriesInfo) {
                scaleOptions.startValue = categoriesInfo.start;
                scaleOptions.endValue = categoriesInfo.end
            }
            if (scaleOptions.type.indexOf(DISCRETE) === -1) {
                isEmptyInterval = (0, _type2.isDate)(scaleOptions.startValue) && (0, _type2.isDate)(scaleOptions.endValue) && scaleOptions.startValue.getTime() === scaleOptions.endValue.getTime() || scaleOptions.startValue === scaleOptions.endValue
            }
            scaleOptions.isEmpty = startEndNotDefined(scaleOptions.startValue, scaleOptions.endValue) || isEmptyInterval;
            if (scaleOptions.isEmpty) {
                scaleOptions.startValue = scaleOptions.endValue = void 0
            } else {
                scaleOptions.minorTickInterval = tickIntervalsInfo.minorTickInterval;
                scaleOptions.tickInterval = tickIntervalsInfo.tickInterval;
                if (isDateTime && (!(0, _type2.isDefined)(scaleOptions.label.format) || scaleOptions.type === SEMIDISCRETE && scaleOptions.minorTickInterval !== scaleOptions.tickInterval)) {
                    if (scaleOptions.type === DISCRETE) {
                        scaleOptions.label.format = _format_helper2.default.getDateFormatByTicks(tickIntervalsInfo.ticks)
                    } else {
                        if (!scaleOptions.marker.visible) {
                            scaleOptions.label.format = _format_helper2.default.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.tickInterval)
                        } else {
                            scaleOptions.label.format = (0, _date.getDateFormatByTickInterval)(scaleOptions.tickInterval)
                        }
                    }
                }
            }
            if (scaleOptions.type === SEMIDISCRETE) {
                intervals = getIntervalCustomTicks(scaleOptions);
                scaleOptions.customMinorTicks = intervals.altIntervals;
                scaleOptions.customTicks = intervals.intervals;
                scaleOptions.customBoundTicks = [scaleOptions.customTicks[0]]
            }
        }

        function prepareScaleOptions(scaleOption, calculatedValueType, incidentOccurred, containerColor) {
            var parsedValue = 0;
            var valueType = _parse_utils2.default.correctValueType((0, _utils.normalizeEnum)(scaleOption.valueType));
            var validateStartEndValues = function(field, parser) {
                var messageToIncidentOccurred = field === START_VALUE ? "start" : "end";
                if ((0, _type2.isDefined)(scaleOption[field])) {
                    parsedValue = parser(scaleOption[field]);
                    if ((0, _type2.isDefined)(parsedValue)) {
                        scaleOption[field] = parsedValue
                    } else {
                        scaleOption[field] = void 0;
                        incidentOccurred("E2202", [messageToIncidentOccurred])
                    }
                }
            };
            valueType = calculatedValueType || valueType;
            if (!valueType) {
                valueType = calculateValueType(scaleOption.startValue, scaleOption.endValue) || "numeric"
            }
            if (valueType === STRING || scaleOption.categories) {
                scaleOption.type = DISCRETE;
                valueType = STRING
            }
            scaleOption.containerColor = containerColor;
            scaleOption.valueType = valueType;
            scaleOption.dataType = valueType;
            var parser = _parse_utils2.default.getParser(valueType);
            validateStartEndValues(START_VALUE, parser);
            validateStartEndValues(END_VALUE, parser);
            checkLogarithmicOptions(scaleOption, logarithmBase, incidentOccurred);
            if (!scaleOption.type) {
                scaleOption.type = "continuous"
            }
            scaleOption.parser = parser;
            if (scaleOption.type === SEMIDISCRETE) {
                scaleOption.minorTick.visible = false;
                scaleOption.minorTickInterval = scaleOption.minRange;
                scaleOption.marker.visible = false;
                scaleOption.maxRange = void 0
            }
            scaleOption.forceUserTickInterval |= (0, _type2.isDefined)(scaleOption.tickInterval) && !(0, _type2.isDefined)(scaleOption.axisDivisionFactor);
            scaleOption.axisDivisionFactor = (0, _type2.isDefined)(scaleOption.axisDivisionFactor) ? scaleOption.axisDivisionFactor : DEFAULT_AXIS_DIVISION_FACTOR;
            scaleOption.minorAxisDivisionFactor = (0, _type2.isDefined)(scaleOption.minorAxisDivisionFactor) ? scaleOption.minorAxisDivisionFactor : DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
            return scaleOption
        }

        function correctValueByInterval(value, isDate, interval, firstDayOfWeek) {
            if ((0, _type2.isDefined)(value)) {
                value = isDate ? (0, _date.correctDateWithUnitBeginning)(new Date(value), interval, null, firstDayOfWeek) : (0, _math.adjust)(_floor((0, _math.adjust)(value / interval)) * interval)
            }
            return value
        }

        function getIntervalCustomTicks(options) {
            var min = options.startValue;
            var max = options.endValue;
            var isDate = "datetime" === options.valueType;
            var firstDayOfWeek = getFirstDayOfWeek(options);
            var tickInterval = options.tickInterval;
            var res = {
                intervals: []
            };
            if (!(0, _type2.isDefined)(min) || !(0, _type2.isDefined)(max)) {
                return res
            }
            res.intervals = (0, _date.getSequenceByInterval)(min, max, options.minorTickInterval);
            if (tickInterval !== options.minorTickInterval) {
                res.altIntervals = res.intervals;
                min = correctValueByInterval(min, isDate, tickInterval, firstDayOfWeek);
                max = correctValueByInterval(max, isDate, tickInterval, firstDayOfWeek);
                res.intervals = (0, _date.getSequenceByInterval)(min, max, tickInterval);
                res.intervals[0] = res.altIntervals[0]
            }
            return res
        }

        function getPrecisionForSlider(startValue, endValue, screenDelta) {
            var d = Math.abs(endValue - startValue) / screenDelta;
            var tail = d - _floor(d);
            return tail > 0 ? _ceil(Math.abs((0, _math.adjust)((0, _utils.getLog)(tail, 10)))) : 0
        }
        var dxRangeSelector = _base_widget2.default.inherit({
            _toggleParentsScrollSubscription: function() {},
            _eventsMap: {
                onValueChanged: {
                    name: VALUE_CHANGED
                }
            },
            _setDeprecatedOptions: function() {
                this.callBase.apply(this, arguments);
                (0, _extend.extend)(this._deprecatedOptions, {
                    "chart.barWidth": {
                        since: "18.1",
                        message: "Use the 'chart.commonSeriesSettings.barPadding' or 'chart.series.barPadding' option instead"
                    },
                    "chart.equalBarWidth": {
                        since: "18.1",
                        message: "Use the 'chart.commonSeriesSettings.ignoreEmptyPoints' or 'chart.series.ignoreEmptyPoints' option instead"
                    },
                    "chart.useAggregation": {
                        since: "18.1",
                        message: "Use the 'chart.commonSeriesSettings.aggregation.enabled' or 'chart.series.aggregation.enabled' option instead"
                    }
                })
            },
            _rootClassPrefix: "dxrs",
            _rootClass: "dxrs-range-selector",
            _dataIsReady: function() {
                return this._dataIsLoaded()
            },
            _initialChanges: ["DATA_SOURCE", "VALUE"],
            _themeDependentChanges: ["MOSTLY_TOTAL"],
            _themeSection: "rangeSelector",
            _fontFields: ["scale.label.font", "sliderMarker.font"],
            _initCore: function() {
                var that = this;
                var renderer = that._renderer;
                var root = renderer.root;
                root.css({
                    "touch-action": "pan-y"
                });
                that._clipRect = renderer.clipRect();
                var rangeViewGroup = renderer.g().attr({
                    "class": "dxrs-view"
                }).append(root);
                var slidersGroup = renderer.g().attr({
                    "class": "dxrs-slidersContainer",
                    "clip-path": that._clipRect.id
                }).append(root);
                var scaleGroup = renderer.g().attr({
                    "class": "dxrs-scale",
                    "clip-path": that._clipRect.id
                }).append(root);
                var scaleBreaksGroup = renderer.g().attr({
                    "class": "dxrs-scale-breaks"
                }).append(root);
                var trackersGroup = renderer.g().attr({
                    "class": "dxrs-trackers"
                }).append(root);
                that._axis = new AxisWrapper({
                    renderer: renderer,
                    root: scaleGroup,
                    scaleBreaksGroup: scaleBreaksGroup,
                    updateSelectedRange: function(range, e) {
                        that.setValue((0, _utils.convertVisualRangeObject)(range), e)
                    },
                    incidentOccurred: that._incidentOccurred
                });
                that._rangeView = new _range_view2.default.RangeView({
                    renderer: renderer,
                    root: rangeViewGroup,
                    translator: that._axis.getTranslator()
                });
                that._slidersController = new _sliders_controller2.default.SlidersController({
                    renderer: renderer,
                    root: slidersGroup,
                    trackersGroup: trackersGroup,
                    updateSelectedRange: function(range, lastSelectedRange, e) {
                        if (!that._rangeOption) {
                            that.option(VALUE, (0, _utils.convertVisualRangeObject)(range, (0, _type2.isPlainObject)(that._options.silent(VALUE))))
                        }
                        that._eventTrigger(VALUE_CHANGED, {
                            value: (0, _utils.convertVisualRangeObject)(range),
                            previousValue: (0, _utils.convertVisualRangeObject)(lastSelectedRange),
                            event: e
                        })
                    },
                    axis: that._axis,
                    translator: that._axis.getTranslator()
                });
                that._tracker = new _tracker.Tracker({
                    renderer: renderer,
                    controller: that._slidersController
                })
            },
            _getDefaultSize: function() {
                return {
                    width: 400,
                    height: 160
                }
            },
            _disposeCore: function() {
                this._axis.dispose();
                this._slidersController.dispose();
                this._tracker.dispose()
            },
            _applySize: function(rect) {
                this._clientRect = rect.slice();
                this._change(["MOSTLY_TOTAL"])
            },
            _optionChangesMap: {
                scale: "SCALE",
                value: "VALUE",
                dataSource: "DATA_SOURCE"
            },
            _optionChangesOrder: ["SCALE", "DATA_SOURCE"],
            _change_SCALE: function() {
                this._change(["MOSTLY_TOTAL"])
            },
            _setValueByDataSource: function() {
                var that = this;
                var options = that._options.silent();
                var axis = that._axis;
                if (options.dataSource) {
                    var selectedRangeUpdateMode = that.option("selectedRangeUpdateMode");
                    var value = that.getValue();
                    var valueIsReady = (0, _type2.isDefined)(value[0]) && (0, _type2.isDefined)(value[1]);
                    if ((0, _type2.isDefined)(selectedRangeUpdateMode)) {
                        selectedRangeUpdateMode = (0, _utils.normalizeEnum)(selectedRangeUpdateMode);
                        that.__skipAnimation = true
                    } else {
                        if (valueIsReady) {
                            selectedRangeUpdateMode = RESET
                        }
                    }
                    if ("auto" === selectedRangeUpdateMode && valueIsReady) {
                        var rangesInfo = axis.allScaleSelected(value);
                        if (rangesInfo.startValue && rangesInfo.endValue) {
                            selectedRangeUpdateMode = RESET
                        } else {
                            if (rangesInfo.endValue) {
                                selectedRangeUpdateMode = SHIFT
                            } else {
                                selectedRangeUpdateMode = KEEP
                            }
                        }
                    }
                    if (selectedRangeUpdateMode === RESET) {
                        options[VALUE] = null
                    } else {
                        if (selectedRangeUpdateMode === SHIFT && valueIsReady) {
                            var _value = that.getValue();
                            that.__skipAnimation = true;
                            options[VALUE] = {
                                length: axis.getVisualRangeLength({
                                    minVisible: _value[0],
                                    maxVisible: _value[1]
                                })
                            }
                        } else {
                            if (selectedRangeUpdateMode === KEEP) {
                                that.__skipAnimation = true
                            }
                        }
                    }
                }
            },
            _change_DATA_SOURCE: function() {
                if (this._options.silent("dataSource")) {
                    this._updateDataSource()
                }
            },
            _customChangesOrder: ["MOSTLY_TOTAL", "VALUE", "SLIDER_SELECTION"],
            _change_MOSTLY_TOTAL: function() {
                this._applyMostlyTotalChange()
            },
            _change_SLIDER_SELECTION: function() {
                var that = this;
                var value = that._options.silent(VALUE);
                that._slidersController.setSelectedRange(value && (0, _utils.getVizRangeObject)(value))
            },
            _change_VALUE: function() {
                var that = this;
                var option = that._rangeOption;
                if (option) {
                    that._options.silent(VALUE, option);
                    that.setValue(option)
                }
            },
            _validateRange: function(start, end) {
                var that = this;
                var translator = that._axis.getTranslator();
                if ((0, _type2.isDefined)(start) && !translator.isValid(start) || (0, _type2.isDefined)(end) && !translator.isValid(end)) {
                    that._incidentOccurred("E2203")
                }
            },
            _applyChanges: function() {
                var that = this;
                var value = that._options.silent(VALUE);
                if (that._changes.has("VALUE") && value) {
                    that._rangeOption = value
                }
                that.callBase.apply(that, arguments);
                that._rangeOption = null;
                that.__isResizing = that.__skipAnimation = false
            },
            _applyMostlyTotalChange: function() {
                var that = this;
                var renderer = that._renderer;
                var rect = that._clientRect;
                var currentAnimationEnabled;
                var canvas = {
                    left: rect[0],
                    top: rect[1],
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1]
                };
                if (that.__isResizing || that.__skipAnimation) {
                    currentAnimationEnabled = renderer.animationEnabled();
                    renderer.updateAnimationOptions({
                        enabled: false
                    })
                }
                that._clipRect.attr({
                    x: rect[0],
                    y: rect[1],
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1]
                });
                that._axis.getTranslator().update(new _range2.default.Range, canvas, {
                    isHorizontal: true
                });
                that._updateContent({
                    left: rect[0],
                    top: rect[1],
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1]
                });
                if (that.__isResizing || that.__skipAnimation) {
                    renderer.updateAnimationOptions({
                        enabled: currentAnimationEnabled
                    })
                }
                that._drawn()
            },
            _dataSourceChangedHandler: function() {
                this._setValueByDataSource();
                this._requestChange(["MOSTLY_TOTAL"])
            },
            _completeSeriesDataSourceCreation: function(scaleOptions, seriesDataSource) {
                var rect = this._clientRect;
                var canvas = {
                    left: rect[0],
                    top: rect[1],
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1]
                };
                this._axis.updateOptions((0, _extend.extend)({}, scaleOptions, {
                    isHorizontal: true,
                    label: {}
                }));
                seriesDataSource.isShowChart() && this._axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));
                this._axis.updateCanvas(canvas);
                seriesDataSource.createPoints()
            },
            _updateContent: function(canvas) {
                var that = this;
                var chartOptions = that.option("chart");
                var seriesDataSource = that._createSeriesDataSource(chartOptions);
                var isCompactMode = !(seriesDataSource && seriesDataSource.isShowChart() || that.option("background.image.url"));
                var scaleOptions = prepareScaleOptions(that._getOption("scale"), seriesDataSource && seriesDataSource.getCalculatedValueType(), that._incidentOccurred, this._getOption("containerBackgroundColor", true));
                seriesDataSource && that._completeSeriesDataSourceCreation(scaleOptions, seriesDataSource);
                var argTranslatorRange = calculateTranslatorRange(seriesDataSource, scaleOptions);
                var tickIntervalsInfo = updateTickIntervals(scaleOptions, canvas.width, that._incidentOccurred, argTranslatorRange);
                var chartThemeManager = seriesDataSource && seriesDataSource.isShowChart() && seriesDataSource.getThemeManager();
                if (chartThemeManager) {
                    checkLogarithmicOptions(chartOptions && chartOptions.valueAxis, chartThemeManager.getOptions("valueAxis").logarithmBase, that._incidentOccurred)
                }
                updateScaleOptions(scaleOptions, seriesDataSource, argTranslatorRange, tickIntervalsInfo, getDateMarkerVisibilityChecker(canvas.width));
                updateTranslatorRangeInterval(argTranslatorRange, scaleOptions);
                var sliderMarkerOptions = that._prepareSliderMarkersOptions(scaleOptions, canvas.width, tickIntervalsInfo, argTranslatorRange);
                var indents = calculateIndents(that._renderer, scaleOptions, sliderMarkerOptions, that.option("indent"), tickIntervalsInfo);
                var rangeContainerCanvas = {
                    left: canvas.left + indents.left,
                    top: canvas.top + indents.top,
                    width: canvas.left + indents.left + _max(canvas.width - indents.left - indents.right, 1),
                    height: _max(!isCompactMode ? canvas.height - indents.top - indents.bottom - calculateScaleAreaHeight(that._renderer, scaleOptions, showScaleMarkers(scaleOptions), tickIntervalsInfo) : _common2.default.HEIGHT_COMPACT_MODE, 0),
                    right: 0,
                    bottom: 0
                };
                that._axis.update(scaleOptions, isCompactMode, rangeContainerCanvas, argTranslatorRange, seriesDataSource);
                scaleOptions.minorTickInterval = scaleOptions.isEmpty ? 0 : scaleOptions.minorTickInterval;
                that._updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, rangeContainerCanvas, seriesDataSource);
                if (chartThemeManager) {
                    chartThemeManager.dispose()
                }
            },
            _updateElements: function(scaleOptions, sliderMarkerOptions, isCompactMode, canvas, seriesDataSource) {
                var that = this;
                var behavior = that._getOption("behavior");
                var shutterOptions = that._getOption("shutter");
                var isNotSemiDiscrete = scaleOptions.type !== SEMIDISCRETE;
                shutterOptions.color = shutterOptions.color || that._getOption(CONTAINER_BACKGROUND_COLOR, true);
                that._rangeView.update(that.option("background"), that._themeManager.theme("background"), canvas, isCompactMode, behavior.animationEnabled && that._renderer.animationEnabled(), seriesDataSource);
                that._isUpdating = true;
                that._slidersController.update([canvas.top, canvas.top + canvas.height], behavior, isCompactMode, that._getOption("sliderHandle"), sliderMarkerOptions, shutterOptions, {
                    minRange: isNotSemiDiscrete ? that.option("scale.minRange") : void 0,
                    maxRange: isNotSemiDiscrete ? that.option("scale.maxRange") : void 0
                }, that._axis.getFullTicks(), that._getOption("selectedRangeColor", true));
                that._requestChange(["SLIDER_SELECTION"]);
                that._isUpdating = false;
                that._tracker.update(!that._axis.getTranslator().getBusinessRange().isEmpty(), behavior)
            },
            _createSeriesDataSource: function(chartOptions) {
                var that = this;
                var seriesDataSource;
                var dataSource = that._dataSourceItems();
                var scaleOptions = that._getOption("scale");
                var valueType = scaleOptions.valueType || calculateValueType(scaleOptions.startValue, scaleOptions.endValue);
                var valueAxis = new _base_axis2.default.Axis({
                    renderer: that._renderer,
                    axisType: "xyAxes",
                    drawingType: "linear"
                });
                valueAxis.updateOptions({
                    isHorizontal: false,
                    label: {},
                    categoriesSortingMethod: that._getOption("chart").valueAxis.categoriesSortingMethod
                });
                if (dataSource || chartOptions && chartOptions.series) {
                    chartOptions = (0, _extend.extend)({}, chartOptions, {
                        theme: that.option("theme")
                    });
                    seriesDataSource = new _series_data_source2.default.SeriesDataSource({
                        renderer: that._renderer,
                        dataSource: dataSource,
                        valueType: (0, _utils.normalizeEnum)(valueType),
                        axisType: scaleOptions.type,
                        chart: chartOptions,
                        dataSourceField: that.option("dataSourceField"),
                        incidentOccurred: that._incidentOccurred,
                        categories: scaleOptions.categories,
                        argumentAxis: that._axis,
                        valueAxis: valueAxis
                    })
                }
                return seriesDataSource
            },
            _prepareSliderMarkersOptions: function(scaleOptions, screenDelta, tickIntervalsInfo, argRange) {
                var that = this;
                var minorTickInterval = tickIntervalsInfo.minorTickInterval;
                var tickInterval = tickIntervalsInfo.tickInterval;
                var interval = tickInterval;
                var endValue = scaleOptions.endValue;
                var startValue = scaleOptions.startValue;
                var sliderMarkerOptions = that._getOption(SLIDER_MARKER);
                var doNotSnap = !that._getOption("behavior").snapToTicks;
                var isTypeDiscrete = scaleOptions.type === DISCRETE;
                var isValueTypeDatetime = scaleOptions.valueType === DATETIME;
                sliderMarkerOptions.borderColor = that._getOption(CONTAINER_BACKGROUND_COLOR, true);
                if (!sliderMarkerOptions.format && !argRange.isEmpty()) {
                    if (doNotSnap && (0, _type2.isNumeric)(scaleOptions.startValue)) {
                        sliderMarkerOptions.format = {
                            type: "fixedPoint",
                            precision: getPrecisionForSlider(startValue, endValue, screenDelta)
                        }
                    }
                    if (isValueTypeDatetime && !isTypeDiscrete) {
                        if ((0, _type2.isDefined)(minorTickInterval) && 0 !== minorTickInterval) {
                            interval = getMinorTickIntervalUnit(tickInterval, minorTickInterval, doNotSnap)
                        }
                        if (!scaleOptions.marker.visible) {
                            if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {
                                sliderMarkerOptions.format = _format_helper2.default.getDateFormatByTickInterval(startValue, endValue, interval)
                            }
                        } else {
                            sliderMarkerOptions.format = (0, _date.getDateFormatByTickInterval)(interval)
                        }
                    }
                    if (isValueTypeDatetime && isTypeDiscrete && tickIntervalsInfo.ticks.length) {
                        sliderMarkerOptions.format = _format_helper2.default.getDateFormatByTicks(tickIntervalsInfo.ticks)
                    }
                }
                return sliderMarkerOptions
            },
            getValue: function() {
                return (0, _utils.convertVisualRangeObject)(this._slidersController.getSelectedRange())
            },
            setValue: function(value, e) {
                var visualRange = (0, _utils.getVizRangeObject)(value);
                if (!this._isUpdating && value) {
                    this._validateRange(visualRange.startValue, visualRange.endValue);
                    !(0, _utils.rangesAreEqual)(visualRange, this._slidersController.getSelectedRange()) && this._slidersController.setSelectedRange(visualRange, e)
                }
            },
            _setContentSize: function() {
                this.__isResizing = 2 === this._changes.count();
                this.callBase.apply(this, arguments)
            }
        });
        (0, _iterator.each)(["selectedRangeColor", "containerBackgroundColor", "sliderMarker", "sliderHandle", "shutter", OPTION_BACKGROUND, "behavior", "chart", "indent"], function(_, name) {
            dxRangeSelector.prototype._optionChangesMap[name] = "MOSTLY_TOTAL"
        });

        function prepareAxisOptions(scaleOptions, isCompactMode, height, axisPosition) {
            scaleOptions.marker.label.font = scaleOptions.label.font;
            scaleOptions.color = scaleOptions.marker.color = scaleOptions.tick.color;
            scaleOptions.opacity = scaleOptions.marker.opacity = scaleOptions.tick.opacity;
            scaleOptions.width = scaleOptions.marker.width = scaleOptions.tick.width;
            scaleOptions.placeholderSize = (scaleOptions.placeholderHeight || 0) + axisPosition;
            scaleOptions.argumentType = scaleOptions.valueType;
            scaleOptions.visible = isCompactMode;
            scaleOptions.isHorizontal = true;
            scaleOptions.calculateMinors = true;
            scaleOptions.semiDiscreteInterval = scaleOptions.minRange;
            if (!isCompactMode) {
                scaleOptions.minorTick.length = scaleOptions.tick.length = height
            }
            scaleOptions.label.indentFromAxis = scaleOptions.label.topIndent + axisPosition;
            return scaleOptions
        }

        function createDateMarkersEvent(scaleOptions, markerTrackers, setSelectedRange) {
            (0, _iterator.each)(markerTrackers, function(_, value) {
                value.on("dxpointerdown", onPointerDown)
            });

            function onPointerDown(e) {
                var range = e.target.range;
                var minRange = scaleOptions.minRange ? (0, _date.addInterval)(range.startValue, scaleOptions.minRange) : void 0;
                var maxRange = scaleOptions.maxRange ? (0, _date.addInterval)(range.startValue, scaleOptions.maxRange) : void 0;
                if (!(minRange && minRange > range.endValue || maxRange && maxRange < range.endValue)) {
                    setSelectedRange(range, e)
                }
            }
        }

        function getShiftDirection() {
            return 1
        }

        function getTickStartPositionShift(length) {
            return length % 2 === 1 ? -_floor(length / 2) : -length / 2
        }

        function AxisWrapper(params) {
            var that = this;
            that._axis = new _base_axis2.default.Axis({
                renderer: params.renderer,
                axesContainerGroup: params.root,
                scaleBreaksGroup: params.scaleBreaksGroup,
                incidentOccurred: params.incidentOccurred,
                axisType: "xyAxes",
                drawingType: "linear",
                widgetClass: "dxrs",
                axisClass: "range-selector",
                isArgumentAxis: true
            });
            that._updateSelectedRangeCallback = params.updateSelectedRange;
            that._axis.getAxisSharpDirection = that._axis.getSharpDirectionByCoords = getShiftDirection;
            that._axis.getTickStartPositionShift = getTickStartPositionShift
        }
        AxisWrapper.prototype = {
            constructor: AxisWrapper,
            dispose: function() {
                this._axis.dispose()
            },
            calculateInterval: function(value, prevValue) {
                return this._axis.calculateInterval(value, prevValue)
            },
            update: function(options, isCompactMode, canvas, businessRange, seriesDataSource) {
                var axis = this._axis;
                axis.updateOptions(prepareAxisOptions(options, isCompactMode, canvas.height, canvas.height / 2 - _ceil(options.width / 2)));
                axis.validate();
                axis.setBusinessRange(businessRange, true);
                if (void 0 !== seriesDataSource && seriesDataSource.isShowChart()) {
                    axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas))
                }
                axis.draw(canvas);
                axis.shift({
                    left: 0,
                    bottom: -canvas.height / 2 + canvas.top
                });
                if (axis.getMarkerTrackers()) {
                    createDateMarkersEvent(options, axis.getMarkerTrackers(), this._updateSelectedRangeCallback)
                }
                axis.drawScaleBreaks({
                    start: canvas.top,
                    end: canvas.top + canvas.height
                })
            },
            visualRange: function() {},
            getViewport: function() {
                return {}
            },
            allScaleSelected: function(value) {
                var _this$_axis$visualRan = this._axis.visualRange(),
                    startValue = _this$_axis$visualRan.startValue,
                    endValue = _this$_axis$visualRan.endValue;
                return {
                    startValue: value[0].valueOf() === startValue.valueOf(),
                    endValue: value[1].valueOf() === endValue.valueOf()
                }
            },
            getOptions: function() {
                return this._axis.getOptions() || {}
            }
        };
        ["setMarginOptions", "getFullTicks", "updateCanvas", "updateOptions", "getAggregationInfo", "getTranslator", "getVisualRangeLength", "getVisibleArea", "getMarginOptions"].forEach(function(methodName) {
            AxisWrapper.prototype[methodName] = function() {
                var axis = this._axis;
                return axis[methodName].apply(axis, arguments)
            }
        });
        (0, _component_registrator2.default)("dxRangeSelector", dxRangeSelector);
        module.exports = dxRangeSelector;
        dxRangeSelector.addPlugin(_export.plugin);
        dxRangeSelector.addPlugin(_title.plugin);
        dxRangeSelector.addPlugin(_loading_indicator.plugin);
        dxRangeSelector.addPlugin(_data_source.plugin)
    },
    /*!***********************************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector/sliders_controller.js ***!
      \***********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _common2 = __webpack_require__( /*! ./common */ 214);
        var _common3 = _interopRequireDefault(_common2);
        var _slider = __webpack_require__( /*! ./slider */ 856);
        var _slider2 = _interopRequireDefault(_slider);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _math = __webpack_require__( /*! ../../core/utils/math */ 31);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var animationSettings = _common3.default.utils.animationSettings;
        var emptySliderMarkerText = _common3.default.consts.emptySliderMarkerText;

        function buildRectPoints(left, top, right, bottom) {
            return [left, top, right, top, right, bottom, left, bottom]
        }

        function isLess(a, b) {
            return a < b
        }

        function isGreater(a, b) {
            return a > b
        }

        function selectClosestValue(target, values) {
            var start = 0;
            var end = values ? values.length - 1 : 0;
            var middle;
            var val = target;
            while (end - start > 1) {
                middle = start + end >> 1;
                val = values[middle];
                if (val === target) {
                    return target
                } else {
                    if (target < val) {
                        end = middle
                    } else {
                        start = middle
                    }
                }
            }
            if (values) {
                val = values[target - values[start] <= values[end] - target ? start : end]
            }
            return val
        }

        function dummyProcessSelectionChanged() {
            this._lastSelectedRange = this.getSelectedRange();
            delete this._processSelectionChanged
        }

        function suppressSetSelectedRange(controller) {
            controller.setSelectedRange = _common.noop;
            if (controller._processSelectionChanged === dummyProcessSelectionChanged) {
                controller._processSelectionChanged()
            }
        }

        function restoreSetSelectedRange(controller) {
            delete controller.setSelectedRange
        }

        function SlidersController(params) {
            var that = this;
            var sliderParams = {
                renderer: params.renderer,
                root: params.root,
                trackersGroup: params.trackersGroup,
                translator: params.translator
            };
            that._params = params;
            that._areaTracker = params.renderer.path(null, "area").attr({
                "class": "area-tracker",
                fill: "#000000",
                opacity: 1e-4
            }).append(params.trackersGroup);
            that._selectedAreaTracker = params.renderer.path(null, "area").attr({
                "class": "selected-area-tracker",
                fill: "#000000",
                opacity: 1e-4
            }).append(params.trackersGroup);
            that._shutter = params.renderer.path(null, "area").append(params.root);
            that._sliders = [new _slider2.default(sliderParams, 0), new _slider2.default(sliderParams, 1)];
            that._processSelectionChanged = dummyProcessSelectionChanged
        }
        SlidersController.prototype = {
            constructor: SlidersController,
            dispose: function() {
                this._sliders[0].dispose();
                this._sliders[1].dispose()
            },
            getTrackerTargets: function() {
                return {
                    area: this._areaTracker,
                    selectedArea: this._selectedAreaTracker,
                    sliders: this._sliders
                }
            },
            _processSelectionChanged: function(e) {
                var that = this;
                var selectedRange = that.getSelectedRange();
                if (!(0, _utils.rangesAreEqual)(selectedRange, that._lastSelectedRange)) {
                    that._params.updateSelectedRange(selectedRange, that._lastSelectedRange, e);
                    that._lastSelectedRange = selectedRange
                }
            },
            update: function(verticalRange, behavior, isCompactMode, sliderHandleOptions, sliderMarkerOptions, shutterOptions, rangeBounds, fullTicks, selectedRangeColor) {
                var that = this;
                var screenRange = that._params.translator.getScreenRange();
                that._verticalRange = verticalRange;
                that._minRange = rangeBounds.minRange;
                that._maxRange = rangeBounds.maxRange;
                that._animationEnabled = behavior.animationEnabled && that._params.renderer.animationEnabled();
                that._allowSlidersSwap = behavior.allowSlidersSwap;
                that._sliders[0].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);
                that._sliders[1].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);
                that._sliders[0]._position = that._sliders[1]._position = screenRange[0];
                that._values = !that._params.translator.isValueProlonged && behavior.snapToTicks ? fullTicks : null;
                that._areaTracker.attr({
                    points: buildRectPoints(screenRange[0], verticalRange[0], screenRange[1], verticalRange[1])
                });
                that._isCompactMode = isCompactMode;
                that._shutterOffset = sliderHandleOptions.width / 2;
                that._updateSelectedView(shutterOptions, selectedRangeColor);
                that._isOnMoving = "onmoving" === (0, _utils.normalizeEnum)(behavior.callValueChanged);
                that._updateSelectedRange();
                that._applyTotalPosition(false)
            },
            _updateSelectedView: function(shutterOptions, selectedRangeColor) {
                var settings = {
                    fill: null,
                    "fill-opacity": null,
                    stroke: null,
                    "stroke-width": null
                };
                if (this._isCompactMode) {
                    settings.stroke = selectedRangeColor;
                    settings["stroke-width"] = 3;
                    settings.sharp = "v"
                } else {
                    settings.fill = shutterOptions.color;
                    settings["fill-opacity"] = shutterOptions.opacity
                }
                this._shutter.attr(settings)
            },
            _updateSelectedRange: function() {
                var that = this;
                var sliders = that._sliders;
                sliders[0].cancelAnimation();
                sliders[1].cancelAnimation();
                that._shutter.stopAnimation();
                if (that._params.translator.getBusinessRange().isEmpty()) {
                    sliders[0]._setText(emptySliderMarkerText);
                    sliders[1]._setText(emptySliderMarkerText);
                    sliders[0]._value = sliders[1]._value = void 0;
                    sliders[0]._position = that._params.translator.getScreenRange()[0];
                    sliders[1]._position = that._params.translator.getScreenRange()[1];
                    that._applyTotalPosition(false);
                    suppressSetSelectedRange(that)
                } else {
                    restoreSetSelectedRange(that)
                }
            },
            _applyTotalPosition: function(isAnimated) {
                var sliders = this._sliders;
                isAnimated = this._animationEnabled && isAnimated;
                sliders[0].applyPosition(isAnimated);
                sliders[1].applyPosition(isAnimated);
                var areOverlapped = sliders[0].getCloudBorder() > sliders[1].getCloudBorder();
                sliders[0].setOverlapped(areOverlapped);
                sliders[1].setOverlapped(areOverlapped);
                this._applyAreaTrackersPosition();
                this._applySelectedRangePosition(isAnimated)
            },
            _applyAreaTrackersPosition: function() {
                var that = this;
                var position1 = that._sliders[0].getPosition();
                var position2 = that._sliders[1].getPosition();
                that._selectedAreaTracker.attr({
                    points: buildRectPoints(position1, that._verticalRange[0], position2, that._verticalRange[1])
                }).css({
                    cursor: Math.abs(that._params.translator.getScreenRange()[1] - that._params.translator.getScreenRange()[0] - position2 + position1) < .001 ? "default" : "pointer"
                })
            },
            _applySelectedRangePosition: function(isAnimated) {
                var that = this;
                var verticalRange = that._verticalRange;
                var pos1 = that._sliders[0].getPosition();
                var pos2 = that._sliders[1].getPosition();
                var screenRange;
                var points;
                if (that._isCompactMode) {
                    points = [pos1 + Math.ceil(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2, pos2 - Math.floor(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2]
                } else {
                    screenRange = that._params.axis.getVisibleArea();
                    points = [buildRectPoints(screenRange[0], verticalRange[0], Math.max(pos1 - Math.floor(that._shutterOffset), screenRange[0]), verticalRange[1]), buildRectPoints(screenRange[1], verticalRange[0], Math.min(pos2 + Math.ceil(that._shutterOffset), screenRange[1]), verticalRange[1])]
                }
                if (isAnimated) {
                    that._shutter.animate({
                        points: points
                    }, animationSettings)
                } else {
                    that._shutter.attr({
                        points: points
                    })
                }
            },
            getSelectedRange: function() {
                return {
                    startValue: this._sliders[0].getValue(),
                    endValue: this._sliders[1].getValue()
                }
            },
            setSelectedRange: function(visualRange, e) {
                visualRange = visualRange || {};
                var that = this;
                var translator = that._params.translator;
                var businessRange = translator.getBusinessRange();
                var compare = "discrete" === businessRange.axisType ? function(a, b) {
                    return a < b
                } : function(a, b) {
                    return a <= b
                };
                var _adjustVisualRange = (0, _utils.adjustVisualRange)({
                        dataType: businessRange.dataType,
                        axisType: businessRange.axisType,
                        base: businessRange.base
                    }, {
                        startValue: translator.isValid(visualRange.startValue) ? translator.getCorrectValue(visualRange.startValue, 1) : void 0,
                        endValue: translator.isValid(visualRange.endValue) ? translator.getCorrectValue(visualRange.endValue, -1) : void 0,
                        length: visualRange.length
                    }, {
                        min: businessRange.minVisible,
                        max: businessRange.maxVisible,
                        categories: businessRange.categories
                    }),
                    startValue = _adjustVisualRange.startValue,
                    endValue = _adjustVisualRange.endValue;
                startValue = (0, _type.isNumeric)(startValue) ? (0, _math.adjust)(startValue) : startValue;
                endValue = (0, _type.isNumeric)(endValue) ? (0, _math.adjust)(endValue) : endValue;
                var values = compare(translator.to(startValue, -1), translator.to(endValue, 1)) ? [startValue, endValue] : [endValue, startValue];
                that._sliders[0].setDisplayValue(values[0]);
                that._sliders[1].setDisplayValue(values[1]);
                that._sliders[0]._position = translator.to(values[0], -1);
                that._sliders[1]._position = translator.to(values[1], 1);
                that._applyTotalPosition(true);
                that._processSelectionChanged(e)
            },
            beginSelectedAreaMoving: function(initialPosition) {
                var that = this;
                var sliders = that._sliders;
                var offset = (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - initialPosition;
                var currentPosition = initialPosition;
                move.complete = function(e) {
                    that._dockSelectedArea(e)
                };
                return move;

                function move(position, e) {
                    if (position !== currentPosition && position > currentPosition === position > (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - offset) {
                        that._moveSelectedArea(position + offset, false, e)
                    }
                    currentPosition = position
                }
            },
            _dockSelectedArea: function(e) {
                var translator = this._params.translator;
                var sliders = this._sliders;
                sliders[0]._position = translator.to(sliders[0].getValue(), -1);
                sliders[1]._position = translator.to(sliders[1].getValue(), 1);
                this._applyTotalPosition(true);
                this._processSelectionChanged(e)
            },
            moveSelectedArea: function(screenPosition, e) {
                this._moveSelectedArea(screenPosition, true, e);
                this._dockSelectedArea(e)
            },
            _moveSelectedArea: function(screenPosition, isAnimated, e) {
                var that = this;
                var translator = that._params.translator;
                var sliders = that._sliders;
                var interval = sliders[1].getPosition() - sliders[0].getPosition();
                var startPosition = screenPosition - interval / 2;
                var endPosition = screenPosition + interval / 2;
                if (startPosition < translator.getScreenRange()[0]) {
                    startPosition = translator.getScreenRange()[0];
                    endPosition = startPosition + interval
                }
                if (endPosition > translator.getScreenRange()[1]) {
                    endPosition = translator.getScreenRange()[1];
                    startPosition = endPosition - interval
                }
                var startValue = selectClosestValue(translator.from(startPosition, -1), that._values);
                sliders[0].setDisplayValue(startValue);
                sliders[1].setDisplayValue(selectClosestValue(translator.from(translator.to(startValue, -1) + interval, 1), that._values));
                sliders[0]._position = startPosition;
                sliders[1]._position = endPosition;
                that._applyTotalPosition(isAnimated);
                if (that._isOnMoving) {
                    that._processSelectionChanged(e)
                }
            },
            placeSliderAndBeginMoving: function(firstPosition, secondPosition, e) {
                var that = this;
                var translator = that._params.translator;
                var sliders = that._sliders;
                var index = firstPosition < secondPosition ? 0 : 1;
                var dir = index > 0 ? 1 : -1;
                var compare = index > 0 ? isGreater : isLess;
                var antiCompare = index > 0 ? isLess : isGreater;
                var thresholdPosition;
                var positions = [];
                var values = [];
                values[index] = translator.from(firstPosition, dir);
                values[1 - index] = translator.from(secondPosition, -dir);
                positions[1 - index] = secondPosition;
                if (translator.isValueProlonged) {
                    if (compare(firstPosition, translator.to(values[index], dir))) {
                        values[index] = translator.from(firstPosition, -dir)
                    }
                    if (compare(secondPosition, translator.to(values[index], -dir))) {
                        values[1 - index] = values[index]
                    }
                }
                if (that._minRange) {
                    thresholdPosition = translator.to(translator.add(selectClosestValue(values[index], that._values), that._minRange, -dir), -dir);
                    if (compare(secondPosition, thresholdPosition)) {
                        values[1 - index] = translator.add(values[index], that._minRange, -dir)
                    }
                    thresholdPosition = translator.to(translator.add(translator.getRange()[1 - index], that._minRange, dir), -dir);
                    if (antiCompare(firstPosition, thresholdPosition)) {
                        values[1 - index] = translator.getRange()[1 - index];
                        values[index] = translator.add(values[1 - index], that._minRange, dir);
                        positions[1 - index] = firstPosition
                    }
                }
                values[0] = selectClosestValue(values[0], that._values);
                values[1] = selectClosestValue(values[1], that._values);
                positions[index] = translator.to(values[index], dir);
                sliders[0].setDisplayValue(values[0]);
                sliders[1].setDisplayValue(values[1]);
                sliders[0]._position = positions[0];
                sliders[1]._position = positions[1];
                that._applyTotalPosition(true);
                if (that._isOnMoving) {
                    that._processSelectionChanged(e)
                }
                var handler = that.beginSliderMoving(1 - index, secondPosition);
                sliders[1 - index]._sliderGroup.stopAnimation();
                that._shutter.stopAnimation();
                handler(secondPosition);
                return handler
            },
            beginSliderMoving: function(initialIndex, initialPosition) {
                var that = this;
                var translator = that._params.translator;
                var sliders = that._sliders;
                var minPosition = translator.getScreenRange()[0];
                var maxPosition = translator.getScreenRange()[1];
                var index = initialIndex;
                var staticPosition = sliders[1 - index].getPosition();
                var currentPosition = initialPosition;
                var dir = index > 0 ? 1 : -1;
                var compareMin = index > 0 ? isLess : isGreater;
                var compareMax = index > 0 ? isGreater : isLess;
                var moveOffset = sliders[index].getPosition() - initialPosition;
                var swapOffset = compareMin(sliders[index].getPosition(), initialPosition) ? -moveOffset : moveOffset;
                move.complete = function(e) {
                    sliders[index]._setValid(true);
                    that._dockSelectedArea(e)
                };
                return move;

                function move(position, e) {
                    var isValid;
                    var temp;
                    var pos;
                    var slider;
                    var value;
                    if (position !== currentPosition) {
                        if (compareMin(position + swapOffset, staticPosition)) {
                            isValid = that._allowSlidersSwap;
                            if (isValid && !translator.isValueProlonged && that._minRange) {
                                isValid = translator.isValid(translator.add(sliders[1 - index].getValue(), that._minRange, -dir))
                            }
                            if (isValid) {
                                that._changeMovingSlider(index);
                                index = 1 - index;
                                dir = -dir;
                                temp = compareMin;
                                compareMin = compareMax;
                                compareMax = temp;
                                moveOffset = -dir * Math.abs(moveOffset);
                                swapOffset = -moveOffset
                            }
                        }
                        if (compareMax(position + moveOffset, staticPosition)) {
                            isValid = true;
                            slider = sliders[index];
                            value = sliders[1 - index].getValue();
                            pos = Math.max(Math.min(position + moveOffset, maxPosition), minPosition);
                            if (isValid && translator.isValueProlonged) {
                                isValid = !compareMin(pos, translator.to(value, dir))
                            }
                            if (isValid && that._minRange) {
                                isValid = !compareMin(pos, translator.to(translator.add(value, that._minRange, dir), dir))
                            }
                            if (isValid && that._maxRange) {
                                isValid = !compareMax(pos, translator.to(translator.add(value, that._maxRange, dir), dir))
                            }
                            slider._setValid(isValid);
                            slider.setDisplayValue(isValid ? selectClosestValue(translator.from(pos, dir), that._values) : slider.getValue());
                            slider._position = pos;
                            that._applyTotalPosition(false);
                            slider.toForeground();
                            if (that._isOnMoving) {
                                that._processSelectionChanged(e)
                            }
                        }
                    }
                    currentPosition = position
                }
            },
            _changeMovingSlider: function(index) {
                var that = this;
                var translator = that._params.translator;
                var sliders = that._sliders;
                var position = sliders[1 - index].getPosition();
                var dir = index > 0 ? 1 : -1;
                var newValue;
                sliders[index].setDisplayValue(selectClosestValue(translator.from(position, dir), that._values));
                newValue = translator.from(position, -dir);
                if (translator.isValueProlonged) {
                    newValue = translator.from(position, dir)
                } else {
                    if (that._minRange) {
                        newValue = translator.add(newValue, that._minRange, -dir)
                    }
                }
                sliders[1 - index].setDisplayValue(selectClosestValue(newValue, that._values));
                sliders[index]._setValid(true);
                sliders[index]._marker._update();
                sliders[0]._position = sliders[1]._position = position
            },
            foregroundSlider: function(index) {
                this._sliders[index].toForeground()
            }
        };
        exports.SlidersController = SlidersController
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector/slider.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var commonModule = __webpack_require__( /*! ./common */ 214);
        var animationSettings = commonModule.utils.animationSettings;
        var formatValue = commonModule.formatValue;
        var SliderMarker = __webpack_require__( /*! ./slider_marker */ 857);
        var support = __webpack_require__( /*! ../../core/utils/support */ 46);
        var SPLITTER_WIDTH = 8;
        var TOUCH_SPLITTER_WIDTH = 20;

        function getSliderTrackerWidth(sliderHandleWidth) {
            return support.touchEvents || support.pointer ? TOUCH_SPLITTER_WIDTH : SPLITTER_WIDTH < sliderHandleWidth ? sliderHandleWidth : SPLITTER_WIDTH
        }

        function Slider(params, index) {
            var that = this;
            that._translator = params.translator;
            that._sliderGroup = params.renderer.g().attr({
                "class": "slider"
            }).append(params.root);
            that._line = params.renderer.path(null, "line").append(that._sliderGroup);
            that._marker = new SliderMarker(params.renderer, that._sliderGroup, 1 === index);
            that._tracker = params.renderer.rect().attr({
                "class": "slider-tracker",
                fill: "#000000",
                opacity: 1e-4
            }).css({
                cursor: "w-resize"
            }).append(params.trackersGroup)
        }
        Slider.prototype = {
            constructor: Slider,
            cancelAnimation: function() {
                this._sliderGroup.stopAnimation();
                this._tracker.stopAnimation()
            },
            applyPosition: function(isAnimated) {
                var that = this;
                var slider = that._sliderGroup;
                var tracker = that._tracker;
                var attrs = {
                    translateX: that._position
                };
                that._marker.setPosition(that._position);
                if (isAnimated) {
                    slider.animate(attrs, animationSettings);
                    tracker.animate(attrs, animationSettings)
                } else {
                    slider.attr(attrs);
                    tracker.attr(attrs)
                }
            },
            _setValid: function(isValid) {
                this._marker.setValid(isValid);
                this._line.attr({
                    stroke: this._colors[Number(isValid)]
                })
            },
            _setText: function(text) {
                this._marker.setText(text)
            },
            update: function(verticalRange, sliderHandleOptions, sliderMarkerOptions) {
                var that = this;
                that._formatOptions = {
                    format: sliderMarkerOptions.format,
                    customizeText: sliderMarkerOptions.customizeText
                };
                that._marker.applyOptions(sliderMarkerOptions, that._translator.getScreenRange());
                that._colors = [sliderMarkerOptions.invalidRangeColor, sliderHandleOptions.color];
                that._sliderGroup.attr({
                    translateY: verticalRange[0]
                });
                that._line.attr({
                    "stroke-width": sliderHandleOptions.width,
                    stroke: sliderHandleOptions.color,
                    "stroke-opacity": sliderHandleOptions.opacity,
                    sharp: "h",
                    points: [0, 0, 0, verticalRange[1] - verticalRange[0]]
                });
                var trackerWidth = getSliderTrackerWidth(sliderHandleOptions.width);
                that._tracker.attr({
                    x: -trackerWidth / 2,
                    y: 0,
                    width: trackerWidth,
                    height: verticalRange[1] - verticalRange[0],
                    translateY: verticalRange[0]
                })
            },
            toForeground: function() {
                this._sliderGroup.toForeground()
            },
            getSliderTracker: function() {
                return this._tracker
            },
            getPosition: function() {
                return this._position
            },
            setDisplayValue: function(value) {
                this._value = value;
                this._setText(formatValue(value, this._formatOptions))
            },
            setOverlapped: function(isOverlapped) {
                this._marker.setOverlapped(isOverlapped)
            },
            getValue: function() {
                return this._value
            },
            on: function(event, handler) {
                this._tracker.on(event, handler);
                this._marker.getTracker().on(event, handler)
            },
            getCloudBorder: function() {
                return this._marker.getBorderPosition()
            },
            dispose: function() {
                this._marker.dispose()
            }
        };
        module.exports = Slider
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector/slider_marker.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _common = __webpack_require__( /*! ./common */ 214);
        var POINTER_SIZE = _common.consts.pointerSize;
        var SLIDER_MARKER_UPDATE_DELAY = 75;

        function SliderMarker(renderer, root, isLeftPointer) {
            var that = this;
            that._isLeftPointer = isLeftPointer;
            that._isOverlapped = false;
            that._group = renderer.g().attr({
                "class": "slider-marker"
            }).append(root);
            that._area = renderer.path(null, "area").append(that._group);
            that._label = renderer.text().attr({
                align: "left"
            }).append(that._group);
            that._tracker = renderer.rect().attr({
                "class": "slider-marker-tracker",
                fill: "#000000",
                opacity: 1e-4
            }).css({
                cursor: "pointer"
            }).append(that._group);
            that._border = renderer.rect(0, 0, 1, 0)
        }
        SliderMarker.prototype = {
            constructor: SliderMarker,
            _getRectSize: function(textSize) {
                return {
                    width: Math.round(2 * this._paddingLeftRight + textSize.width),
                    height: Math.round(2 * this._paddingTopBottom + textSize.height)
                }
            },
            _getTextSize: function() {
                var textSize = this._label.getBBox();
                if (!this._textHeight && isFinite(textSize.height)) {
                    this._textHeight = textSize.height
                }
                return {
                    width: textSize.width,
                    height: this._textHeight,
                    y: textSize.y
                }
            },
            _getAreaPointsInfo: function(textSize) {
                var that = this;
                var rectSize = that._getRectSize(textSize);
                var rectWidth = rectSize.width;
                var rectHeight = rectSize.height;
                var rectLeftBorder = -rectWidth;
                var rectRightBorder = 0;
                var pointerRightPoint = POINTER_SIZE;
                var pointerCenterPoint = 0;
                var pointerLeftPoint = -POINTER_SIZE;
                var position = that._position;
                var isLeft = that._isLeftPointer;
                var correctCloudBorders = function() {
                    rectLeftBorder++;
                    rectRightBorder++;
                    pointerRightPoint++;
                    pointerCenterPoint++;
                    pointerLeftPoint++
                };
                var checkPointerBorders = function() {
                    if (pointerRightPoint > rectRightBorder) {
                        pointerRightPoint = rectRightBorder
                    } else {
                        if (pointerLeftPoint < rectLeftBorder) {
                            pointerLeftPoint = rectLeftBorder
                        }
                    }
                    isLeft && correctCloudBorders()
                };
                var borderPosition = position;
                if (isLeft) {
                    if (position > that._range[1] - rectWidth) {
                        rectRightBorder = -position + that._range[1];
                        rectLeftBorder = rectRightBorder - rectWidth;
                        checkPointerBorders();
                        borderPosition += rectLeftBorder
                    } else {
                        rectLeftBorder = pointerLeftPoint = 0;
                        rectRightBorder = rectWidth
                    }
                } else {
                    if (position - that._range[0] < rectWidth) {
                        rectLeftBorder = -(position - that._range[0]);
                        rectRightBorder = rectLeftBorder + rectWidth;
                        checkPointerBorders();
                        borderPosition += rectRightBorder
                    } else {
                        pointerRightPoint = 0;
                        correctCloudBorders()
                    }
                }
                that._borderPosition = borderPosition;
                return {
                    offset: rectLeftBorder,
                    isCut: (!isLeft || pointerCenterPoint !== pointerLeftPoint) && (isLeft || pointerCenterPoint !== pointerRightPoint),
                    points: [rectLeftBorder, 0, rectRightBorder, 0, rectRightBorder, rectHeight, pointerRightPoint, rectHeight, pointerCenterPoint, rectHeight + POINTER_SIZE, pointerLeftPoint, rectHeight, rectLeftBorder, rectHeight]
                }
            },
            _update: function() {
                var that = this;
                var textSize;
                clearTimeout(that._timeout);
                that._label.attr({
                    text: that._text || ""
                });
                var currentTextSize = that._getTextSize();
                var rectSize = that._getRectSize(currentTextSize);
                textSize = that._textSize || currentTextSize;
                textSize = that._textSize = currentTextSize.width > textSize.width || currentTextSize.height > textSize.height ? currentTextSize : textSize;
                that._timeout = setTimeout(function() {
                    updateSliderMarker(currentTextSize, rectSize);
                    that._textSize = currentTextSize
                }, SLIDER_MARKER_UPDATE_DELAY);

                function updateSliderMarker(size, rectSize) {
                    rectSize = rectSize || that._getRectSize(size);
                    that._group.attr({
                        translateY: -(rectSize.height + POINTER_SIZE)
                    });
                    var pointsData = that._getAreaPointsInfo(size);
                    var points = pointsData.points;
                    var offset = pointsData.offset;
                    that._area.attr({
                        points: points
                    });
                    that._border.attr({
                        x: that._isLeftPointer ? points[0] - 1 : points[2],
                        height: pointsData.isCut ? rectSize.height : rectSize.height + POINTER_SIZE
                    });
                    that._tracker.attr({
                        translateX: offset,
                        width: rectSize.width,
                        height: rectSize.height + POINTER_SIZE
                    });
                    that._label.attr({
                        translateX: that._paddingLeftRight + offset,
                        translateY: rectSize.height / 2 - (size.y + size.height / 2)
                    })
                }
                updateSliderMarker(textSize)
            },
            setText: function(value) {
                this._text = value
            },
            setPosition: function(position) {
                this._position = position;
                this._update()
            },
            applyOptions: function(options, screenRange) {
                var that = this;
                that._range = screenRange;
                that._paddingLeftRight = options.paddingLeftRight;
                that._paddingTopBottom = options.paddingTopBottom;
                that._textHeight = null;
                that._colors = [options.invalidRangeColor, options.color];
                that._area.attr({
                    fill: options.color
                });
                that._border.attr({
                    fill: options.borderColor
                });
                that._label.css((0, _utils.patchFontOptions)(options.font));
                that._update()
            },
            getTracker: function() {
                return this._tracker
            },
            setValid: function(isValid) {
                this._area.attr({
                    fill: this._colors[Number(isValid)]
                })
            },
            setColor: function(color) {
                this._area.attr({
                    fill: color
                })
            },
            dispose: function() {
                clearTimeout(this._timeout)
            },
            setOverlapped: function(isOverlapped) {
                var that = this;
                if (that._isOverlapped !== isOverlapped) {
                    if (isOverlapped) {
                        that._border.append(that._group)
                    } else {
                        that._isOverlapped && that._border.remove()
                    }
                    that._isOverlapped = isOverlapped
                }
            },
            getBorderPosition: function() {
                return this._borderPosition
            }
        };
        module.exports = SliderMarker
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector/tracker.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Tracker = Tracker;
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _pointer = __webpack_require__( /*! ../../events/pointer */ 23);
        var _pointer2 = _interopRequireDefault(_pointer);
        var _window = __webpack_require__( /*! ../../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _support = __webpack_require__( /*! ../../core/utils/support */ 46);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                })
            } else {
                obj[key] = value
            }
            return obj
        }
        var MIN_MANUAL_SELECTING_WIDTH = 10;
        var window = _window2.default.getWindow();

        function isLeftButtonPressed(event) {
            var e = event || window.event;
            var originalEvent = e.originalEvent;
            var touches = e.touches;
            var pointerType = originalEvent ? originalEvent.pointerType : false;
            var eventTouches = originalEvent ? originalEvent.touches : false;
            var isMSPointerLeftClick = originalEvent && void 0 !== pointerType && (pointerType === (originalEvent.MSPOINTER_TYPE_TOUCH || "touch") || pointerType === (originalEvent.MSPOINTER_TYPE_MOUSE || "mouse") && 1 === originalEvent.buttons);
            var isTouches = touches && touches.length > 0 || eventTouches && eventTouches.length > 0;
            return 1 === e.which || isMSPointerLeftClick || isTouches
        }

        function isMultiTouches(event) {
            var originalEvent = event.originalEvent;
            var touches = event.touches;
            var eventTouches = originalEvent && originalEvent.touches;
            return touches && touches.length > 1 || eventTouches && eventTouches.length > 1 || null
        }

        function preventDefault(e) {
            if (!isMultiTouches(e)) {
                e.preventDefault()
            }
        }

        function stopPropagationAndPreventDefault(e) {
            if (!isMultiTouches(e)) {
                e.stopPropagation();
                e.preventDefault()
            }
        }

        function isTouchEventArgs(e) {
            return e && e.type && 0 === e.type.indexOf("touch")
        }

        function getEventPageX(event) {
            var originalEvent = event.originalEvent;
            var result = 0;
            if (event.pageX) {
                result = event.pageX
            } else {
                if (originalEvent && originalEvent.pageX) {
                    result = originalEvent.pageX
                }
            }
            if (originalEvent && originalEvent.touches) {
                if (originalEvent.touches.length > 0) {
                    result = originalEvent.touches[0].pageX
                } else {
                    if (originalEvent.changedTouches.length > 0) {
                        result = originalEvent.changedTouches[0].pageX
                    }
                }
            }
            return result
        }

        function initializeAreaEvents(controller, area, state, getRootOffsetLeft) {
            var _docEvents;
            var isTouchEvent;
            var isActive = false;
            var initialPosition;
            var movingHandler = null;
            var docEvents = (_docEvents = {}, _defineProperty(_docEvents, _pointer2.default.move, function(e) {
                var position;
                var offset;
                if (isTouchEvent !== isTouchEventArgs(e)) {
                    return
                }
                if (!isLeftButtonPressed(e)) {
                    cancel(e)
                }
                if (isActive) {
                    position = getEventPageX(e);
                    offset = getRootOffsetLeft();
                    if (movingHandler) {
                        movingHandler(position - offset, e)
                    } else {
                        if (state.manualRangeSelectionEnabled && Math.abs(initialPosition - position) >= MIN_MANUAL_SELECTING_WIDTH) {
                            movingHandler = controller.placeSliderAndBeginMoving(initialPosition - offset, position - offset, e)
                        }
                    }
                }
            }), _defineProperty(_docEvents, _pointer2.default.up, function(e) {
                var position;
                if (isActive) {
                    position = getEventPageX(e);
                    if (!movingHandler && state.moveSelectedRangeByClick && Math.abs(initialPosition - position) < MIN_MANUAL_SELECTING_WIDTH) {
                        controller.moveSelectedArea(position - getRootOffsetLeft(), e)
                    }
                    cancel(e)
                }
            }), _docEvents);

            function cancel(e) {
                if (isActive) {
                    isActive = false;
                    if (movingHandler) {
                        movingHandler.complete(e);
                        movingHandler = null
                    }
                }
            }
            area.on(_pointer2.default.down, function(e) {
                if (!state.enabled || !isLeftButtonPressed(e) || isActive) {
                    return
                }
                isActive = true;
                isTouchEvent = isTouchEventArgs(e);
                initialPosition = getEventPageX(e)
            });
            return docEvents
        }

        function initializeSelectedAreaEvents(controller, area, state, getRootOffsetLeft) {
            var _docEvents2;
            var isTouchEvent;
            var isActive = false;
            var movingHandler = null;
            var docEvents = (_docEvents2 = {}, _defineProperty(_docEvents2, _pointer2.default.move, function(e) {
                if (isTouchEvent !== isTouchEventArgs(e)) {
                    return
                }
                if (!isLeftButtonPressed(e)) {
                    cancel(e)
                }
                if (isActive) {
                    preventDefault(e);
                    movingHandler(getEventPageX(e) - getRootOffsetLeft(), e)
                }
            }), _defineProperty(_docEvents2, _pointer2.default.up, cancel), _docEvents2);

            function cancel(e) {
                if (isActive) {
                    isActive = false;
                    movingHandler.complete(e);
                    movingHandler = null
                }
            }
            area.on(_pointer2.default.down, function(e) {
                if (!state.enabled || !isLeftButtonPressed(e) || isActive) {
                    return
                }
                isActive = true;
                isTouchEvent = isTouchEventArgs(e);
                movingHandler = controller.beginSelectedAreaMoving(getEventPageX(e) - getRootOffsetLeft());
                stopPropagationAndPreventDefault(e)
            });
            return docEvents
        }

        function initializeSliderEvents(controller, sliders, state, getRootOffsetLeft) {
            var _docEvents3;
            var isTouchEvent;
            var isActive = false;
            var movingHandler = null;
            var docEvents = (_docEvents3 = {}, _defineProperty(_docEvents3, _pointer2.default.move, function(e) {
                if (isTouchEvent !== isTouchEventArgs(e)) {
                    return
                }
                if (!isLeftButtonPressed(e)) {
                    cancel(e)
                }
                if (isActive) {
                    preventDefault(e);
                    movingHandler(getEventPageX(e) - getRootOffsetLeft(), e)
                }
            }), _defineProperty(_docEvents3, _pointer2.default.up, cancel), _docEvents3);
            (0, _iterator.each)(sliders, function(i, slider) {
                var _slider$on;
                slider.on((_slider$on = {}, _defineProperty(_slider$on, _pointer2.default.down, function(e) {
                    if (!state.enabled || !isLeftButtonPressed(e) || isActive) {
                        return
                    }
                    isActive = true;
                    isTouchEvent = isTouchEventArgs(e);
                    movingHandler = controller.beginSliderMoving(i, getEventPageX(e) - getRootOffsetLeft());
                    stopPropagationAndPreventDefault(e)
                }), _defineProperty(_slider$on, _pointer2.default.move, function() {
                    if (!movingHandler) {
                        controller.foregroundSlider(i)
                    }
                }), _slider$on))
            });

            function cancel(e) {
                if (isActive) {
                    isActive = false;
                    movingHandler.complete(e);
                    movingHandler = null
                }
            }
            return docEvents
        }

        function Tracker(params) {
            var state = this._state = {};
            var targets = params.controller.getTrackerTargets();
            if (_support.pointer) {
                params.renderer.root.css({
                    msTouchAction: "pinch-zoom"
                })
            }
            this._docEvents = [initializeSelectedAreaEvents(params.controller, targets.selectedArea, state, getRootOffsetLeft), initializeAreaEvents(params.controller, targets.area, state, getRootOffsetLeft), initializeSliderEvents(params.controller, targets.sliders, state, getRootOffsetLeft)];
            (0, _iterator.each)(this._docEvents, function(_, events) {
                _events_engine2.default.on(_dom_adapter2.default.getDocument(), events)
            });

            function getRootOffsetLeft() {
                return params.renderer.getRootOffset().left
            }
        }
        Tracker.prototype = {
            constructor: Tracker,
            dispose: function() {
                (0, _iterator.each)(this._docEvents, function(_, events) {
                    _events_engine2.default.off(_dom_adapter2.default.getDocument(), events)
                })
            },
            update: function(enabled, behavior) {
                var state = this._state;
                state.enabled = enabled;
                state.moveSelectedRangeByClick = behavior.moveSelectedRangeByClick;
                state.manualRangeSelectionEnabled = behavior.manualRangeSelectionEnabled
            }
        }
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector/range_view.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function drawSeriesView(root, seriesDataSource, canvas, isAnimationEnabled) {
            var seriesList = seriesDataSource.getSeries();
            if (!seriesList.length) {
                return
            }
            var valueAxis = seriesList[0].getValueAxis();
            valueAxis.updateCanvas({
                top: canvas.top,
                bottom: 0,
                height: canvas.height + canvas.top
            });
            seriesDataSource.adjustSeriesDimensions();
            var valueRange = seriesDataSource.getBoundRange().val;
            valueRange.sortCategories(valueAxis.getCategoriesSorter());
            valueAxis.setBusinessRange(valueRange);
            seriesList.forEach(function(series) {
                series._extGroups.seriesGroup = series._extGroups.labelsGroup = root;
                series.draw(isAnimationEnabled)
            })
        }

        function merge(a, b) {
            return void 0 !== a ? a : b
        }

        function RangeView(params) {
            this._params = params;
            this._clipRect = params.renderer.clipRect();
            params.root.attr({
                "clip-path": this._clipRect.id
            })
        }
        RangeView.prototype = {
            constructor: RangeView,
            update: function(backgroundOption, backgroundTheme, canvas, isCompactMode, isAnimationEnabled, seriesDataSource) {
                var renderer = this._params.renderer;
                var root = this._params.root;
                var canvasWidth = canvas.width - canvas.left;
                var seriesGroup;
                backgroundOption = backgroundOption || {};
                root.clear();
                this._clipRect.attr({
                    x: canvas.left,
                    y: canvas.top,
                    width: canvasWidth,
                    height: canvas.height
                });
                if (!isCompactMode) {
                    if (merge(backgroundOption.visible, backgroundTheme.visible)) {
                        if (backgroundOption.color) {
                            renderer.rect(canvas.left, canvas.top, canvasWidth + 1, canvas.height).attr({
                                fill: merge(backgroundOption.color, backgroundTheme.color),
                                "class": "dx-range-selector-background"
                            }).append(root)
                        }
                        if (backgroundOption.image && backgroundOption.image.url) {
                            renderer.image(canvas.left, canvas.top, canvasWidth + 1, canvas.height, backgroundOption.image.url, merge(backgroundOption.image.location, backgroundTheme.image.location)).append(root)
                        }
                    }
                    if (seriesDataSource && seriesDataSource.isShowChart()) {
                        seriesGroup = renderer.g().attr({
                            "class": "dxrs-series-group"
                        }).append(root);
                        drawSeriesView(seriesGroup, seriesDataSource, canvas, isAnimationEnabled)
                    }
                }
            }
        };
        exports.RangeView = RangeView
    },
    /*!***********************************************************************!*\
      !*** ./artifacts/transpiled/viz/range_selector/series_data_source.js ***!
      \***********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _base_series = __webpack_require__( /*! ../series/base_series */ 261);
        var _base_series2 = _interopRequireDefault(_base_series);
        var _series_family = __webpack_require__( /*! ../core/series_family */ 428);
        var _series_family2 = _interopRequireDefault(_series_family);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _array = __webpack_require__( /*! ../../core/utils/array */ 14);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _utils2 = _interopRequireDefault(_utils);
        var _range = __webpack_require__( /*! ../translators/range */ 112);
        var _range2 = _interopRequireDefault(_range);
        var _data_validator = __webpack_require__( /*! ../components/data_validator */ 259);
        var _data_validator2 = _interopRequireDefault(_data_validator);
        var _chart_theme_manager = __webpack_require__( /*! ../components/chart_theme_manager */ 420);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var createThemeManager = function(chartOptions) {
            return new _chart_theme_manager.ThemeManager({
                options: chartOptions,
                themeSection: "rangeSelector.chart",
                fontFields: ["commonSeriesSettings.label.font"]
            })
        };
        var processSeriesFamilies = function(series, equalBarWidth, minBubbleSize, maxBubbleSize, barOptions, negativesAsZeroes) {
            var families = [];
            var types = [];
            (0, _iterator.each)(series, function(i, item) {
                if ((0, _array.inArray)(item.type, types) === -1) {
                    types.push(item.type)
                }
            });
            (0, _iterator.each)(types, function(_, type) {
                var family = new _series_family2.default.SeriesFamily({
                    type: type,
                    equalBarWidth: equalBarWidth,
                    minBubbleSize: minBubbleSize,
                    maxBubbleSize: maxBubbleSize,
                    barWidth: barOptions.barWidth,
                    barGroupPadding: barOptions.barGroupPadding,
                    barGroupWidth: barOptions.barGroupWidth,
                    negativesAsZeroes: negativesAsZeroes
                });
                family.add(series);
                family.adjustSeriesValues();
                families.push(family)
            });
            return families
        };
        var SeriesDataSource = function(options) {
            var that = this;
            var themeManager = that._themeManager = createThemeManager(options.chart);
            themeManager.setTheme(options.chart.theme);
            var topIndent = themeManager.getOptions("topIndent");
            var bottomIndent = themeManager.getOptions("bottomIndent");
            that._indent = {
                top: topIndent >= 0 && topIndent < 1 ? topIndent : 0,
                bottom: bottomIndent >= 0 && bottomIndent < 1 ? bottomIndent : 0
            };
            that._valueAxis = themeManager.getOptions("valueAxisRangeSelector") || {};
            that._hideChart = false;
            that._series = that._calculateSeries(options);
            that._seriesFamilies = []
        };
        SeriesDataSource.prototype = {
            constructor: SeriesDataSource,
            _calculateSeries: function(options) {
                var that = this;
                var series = [];
                var particularSeriesOptions;
                var seriesTheme;
                var data = options.dataSource || [];
                var parsedData;
                var chartThemeManager = that._themeManager;
                var seriesTemplate = chartThemeManager.getOptions("seriesTemplate");
                var allSeriesOptions = seriesTemplate ? _utils2.default.processSeriesTemplate(seriesTemplate, data) : options.chart.series;
                var dataSourceField;
                var valueAxis = that._valueAxis;
                var i;
                var newSeries;
                var groupsData;
                if (options.dataSource && !allSeriesOptions) {
                    dataSourceField = options.dataSourceField || "arg";
                    allSeriesOptions = {
                        argumentField: dataSourceField,
                        valueField: dataSourceField
                    };
                    that._hideChart = true
                }
                allSeriesOptions = Array.isArray(allSeriesOptions) ? allSeriesOptions : allSeriesOptions ? [allSeriesOptions] : [];
                for (i = 0; i < allSeriesOptions.length; i++) {
                    particularSeriesOptions = (0, _extend.extend)(true, {}, allSeriesOptions[i]);
                    particularSeriesOptions.rotated = false;
                    seriesTheme = chartThemeManager.getOptions("series", particularSeriesOptions, allSeriesOptions.length);
                    seriesTheme.argumentField = seriesTheme.argumentField || options.dataSourceField;
                    if (!seriesTheme.name) {
                        seriesTheme.name = "Series " + (i + 1).toString()
                    }
                    if (data && data.length > 0) {
                        newSeries = new _base_series2.default.Series({
                            renderer: options.renderer,
                            argumentAxis: options.argumentAxis,
                            valueAxis: options.valueAxis,
                            incidentOccurred: options.incidentOccurred
                        }, seriesTheme);
                        series.push(newSeries)
                    }
                }
                if (series.length) {
                    groupsData = {
                        groups: [{
                            series: series,
                            valueAxis: options.valueAxis,
                            valueOptions: {
                                type: valueAxis.type,
                                valueType: dataSourceField ? options.valueType : valueAxis.valueType
                            }
                        }],
                        argumentOptions: {
                            categories: options.categories,
                            argumentType: options.valueType,
                            type: options.axisType
                        }
                    };
                    parsedData = _data_validator2.default.validateData(data, groupsData, options.incidentOccurred, chartThemeManager.getOptions("dataPrepareSettings"));
                    that.argCategories = groupsData.categories;
                    for (i = 0; i < series.length; i++) {
                        series[i].updateData(parsedData[series[i].getArgumentField()])
                    }
                }
                return series
            },
            createPoints: function() {
                if (0 === this._series.length) {
                    return
                }
                var series = this._series;
                var viewport = new _range2.default.Range;
                var axis = series[0].getArgumentAxis();
                var themeManager = this._themeManager;
                var negativesAsZeroes = themeManager.getOptions("negativesAsZeroes");
                var negativesAsZeros = themeManager.getOptions("negativesAsZeros");
                series.forEach(function(s) {
                    viewport.addRange(s.getArgumentRange())
                });
                axis.getTranslator().updateBusinessRange(viewport);
                series.forEach(function(s) {
                    s.createPoints()
                });
                this._seriesFamilies = processSeriesFamilies(series, themeManager.getOptions("equalBarWidth"), themeManager.getOptions("minBubbleSize"), themeManager.getOptions("maxBubbleSize"), {
                    barWidth: themeManager.getOptions("barWidth"),
                    barGroupPadding: themeManager.getOptions("barGroupPadding"),
                    barGroupWidth: themeManager.getOptions("barGroupWidth")
                }, (0, _type.isDefined)(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros)
            },
            adjustSeriesDimensions: function() {
                (0, _iterator.each)(this._seriesFamilies, function(_, family) {
                    family.adjustSeriesDimensions()
                })
            },
            getBoundRange: function() {
                var that = this;
                var rangeData;
                var valueAxis = that._valueAxis;
                var valRange = new _range2.default.Range({
                    min: valueAxis.min,
                    minVisible: valueAxis.min,
                    max: valueAxis.max,
                    maxVisible: valueAxis.max,
                    axisType: valueAxis.type,
                    base: valueAxis.logarithmBase
                });
                var argRange = new _range2.default.Range({});
                var rangeYSize;
                var rangeVisibleSizeY;
                var minIndent;
                var maxIndent;
                (0, _iterator.each)(that._series, function(_, series) {
                    rangeData = series.getRangeData();
                    valRange.addRange(rangeData.val);
                    argRange.addRange(rangeData.arg)
                });
                if (!valRange.isEmpty() && !argRange.isEmpty()) {
                    minIndent = valueAxis.inverted ? that._indent.top : that._indent.bottom;
                    maxIndent = valueAxis.inverted ? that._indent.bottom : that._indent.top;
                    rangeYSize = valRange.max - valRange.min;
                    rangeVisibleSizeY = ((0, _type.isNumeric)(valRange.maxVisible) ? valRange.maxVisible : valRange.max) - ((0, _type.isNumeric)(valRange.minVisible) ? valRange.minVisible : valRange.min);
                    if ((0, _type.isDate)(valRange.min)) {
                        valRange.min = new Date(valRange.min.valueOf() - rangeYSize * minIndent)
                    } else {
                        valRange.min -= rangeYSize * minIndent
                    }
                    if ((0, _type.isDate)(valRange.max)) {
                        valRange.max = new Date(valRange.max.valueOf() + rangeYSize * maxIndent)
                    } else {
                        valRange.max += rangeYSize * maxIndent
                    }
                    if ((0, _type.isNumeric)(rangeVisibleSizeY)) {
                        valRange.maxVisible = valRange.maxVisible ? valRange.maxVisible + rangeVisibleSizeY * maxIndent : void 0;
                        valRange.minVisible = valRange.minVisible ? valRange.minVisible - rangeVisibleSizeY * minIndent : void 0
                    }
                    valRange.invert = valueAxis.inverted
                }
                return {
                    arg: argRange,
                    val: valRange
                }
            },
            getMarginOptions: function(canvas) {
                var bubbleSize = Math.min(canvas.width, canvas.height) * this._themeManager.getOptions("maxBubbleSize");
                return this._series.reduce(function(marginOptions, series) {
                    var seriesOptions = series.getMarginOptions();
                    if (true === seriesOptions.processBubbleSize) {
                        seriesOptions.size = bubbleSize
                    }
                    return _utils2.default.mergeMarginOptions(marginOptions, seriesOptions)
                }, {})
            },
            getSeries: function() {
                return this._series
            },
            isEmpty: function() {
                return 0 === this.getSeries().length
            },
            isShowChart: function() {
                return !this._hideChart
            },
            getCalculatedValueType: function() {
                var series = this._series[0];
                return null === series || void 0 === series ? void 0 : series.argumentType
            },
            getThemeManager: function() {
                return this._themeManager
            }
        };
        exports.SeriesDataSource = SeriesDataSource
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./vector_map/vector_map */ 862)
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/vector_map.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _projection = __webpack_require__( /*! ./projection.main */ 433);
        var _control_bar = __webpack_require__( /*! ./control_bar */ 863);
        var _control_bar2 = _interopRequireDefault(_control_bar);
        var _gesture_handler = __webpack_require__( /*! ./gesture_handler */ 864);
        var _gesture_handler2 = _interopRequireDefault(_gesture_handler);
        var _tracker = __webpack_require__( /*! ./tracker */ 865);
        var _tracker2 = _interopRequireDefault(_tracker);
        var _data_exchanger = __webpack_require__( /*! ./data_exchanger */ 866);
        var _data_exchanger2 = _interopRequireDefault(_data_exchanger);
        var _legend = __webpack_require__( /*! ./legend */ 867);
        var _legend2 = _interopRequireDefault(_legend);
        var _layout = __webpack_require__( /*! ./layout */ 868);
        var _layout2 = _interopRequireDefault(_layout);
        var _map_layer = __webpack_require__( /*! ./map_layer */ 869);
        var _tooltip_viewer = __webpack_require__( /*! ./tooltip_viewer */ 870);
        var _tooltip_viewer2 = _interopRequireDefault(_tooltip_viewer);
        __webpack_require__( /*! ./projection */ 435);
        var _base_widget = __webpack_require__( /*! ../core/base_widget */ 102);
        var _base_widget2 = _interopRequireDefault(_base_widget);
        var _component_registrator = __webpack_require__( /*! ../../core/component_registrator */ 9);
        var _component_registrator2 = _interopRequireDefault(_component_registrator);
        var _export = __webpack_require__( /*! ../core/export */ 99);
        var _title = __webpack_require__( /*! ../core/title */ 109);
        var _tooltip = __webpack_require__( /*! ../core/tooltip */ 111);
        var _loading_indicator = __webpack_require__( /*! ../core/loading_indicator */ 127);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var DEFAULT_WIDTH = 800;
        var DEFAULT_HEIGHT = 400;
        var RE_STARTS_LAYERS = /^layers/;
        var RE_ENDS_DATA_SOURCE = /\.dataSource$/;
        var nextDataKey = 1;

        function generateDataKey() {
            return "vectormap-data-" + nextDataKey++
        }

        function mergeBounds(sumBounds, dataBounds) {
            return dataBounds ? [Math.min(dataBounds[0], dataBounds[2], sumBounds[0]), Math.min(dataBounds[1], dataBounds[3], sumBounds[3]), Math.max(dataBounds[0], dataBounds[2], sumBounds[2]), Math.max(dataBounds[1], dataBounds[3], sumBounds[1])] : sumBounds
        }
        var dxVectorMap = _base_widget2.default.inherit({
            _eventsMap: {
                onClick: {
                    name: "click"
                },
                onCenterChanged: {
                    name: "centerChanged"
                },
                onZoomFactorChanged: {
                    name: "zoomFactorChanged"
                },
                onHoverChanged: {
                    name: "hoverChanged"
                },
                onSelectionChanged: {
                    name: "selectionChanged"
                }
            },
            _rootClassPrefix: "dxm",
            _rootClass: "dxm-vector-map",
            _themeSection: "map",
            _fontFields: ["layer:area.label.font", "layer:marker:dot.label.font", "layer:marker:bubble.label.font", "layer:marker:pie.label.font", "layer:marker:image.label.font", "legend.font", "legend.title.font", "legend.title.subtitle.font"],
            _initLayerCollection: function(dataKey) {
                var that = this;
                that._layerCollection = new _map_layer.MapLayerCollection({
                    renderer: that._renderer,
                    projection: that._projection,
                    themeManager: that._themeManager,
                    tracker: that._tracker,
                    dataKey: dataKey,
                    eventTrigger: that._eventTrigger,
                    dataExchanger: that._dataExchanger,
                    tooltip: that._tooltip,
                    notifyDirty: that._notifyDirty,
                    notifyReady: that._notifyReady,
                    dataReady: function() {
                        var bounds;
                        if (that.option("getBoundsFromData") && !that.option("bounds")) {
                            that._preventProjectionEvents();
                            bounds = that._getBoundsFromData();
                            that._projection.setBounds(bounds);
                            that._allowProjectionEvents()
                        }
                        if (!that.option("projection")) {
                            bounds = bounds || that._getBoundsFromData();
                            if (Math.ceil(bounds[0]) < -180 || Math.ceil(bounds[3]) < -90 || Math.floor(bounds[2]) > 180 || Math.floor(bounds[1]) > 90) {
                                var longitudeLength = bounds[2] - bounds[0];
                                var latitudeLength = bounds[1] - bounds[3];
                                that._projection.setEngine({
                                    to: function(coordinates) {
                                        return [2 * (coordinates[0] - bounds[0]) / longitudeLength - 1, 2 * (coordinates[1] - bounds[3]) / latitudeLength - 1]
                                    },
                                    from: function(coordinates) {
                                        return [(coordinates[0] + 1) * longitudeLength / 2 + bounds[0], (coordinates[1] + 1) * latitudeLength / 2 + bounds[3]]
                                    }
                                })
                            }
                        }
                    }
                })
            },
            _getBoundsFromData: function() {
                var bounds = this._getBoundingBoxFromDataSource();
                if (!bounds) {
                    var boundsByData = (0, _map_layer.getMaxBound)(this.getLayers().map(function(l) {
                        return l.getBounds()
                    }));
                    if (boundsByData) {
                        bounds = boundsByData
                    }
                }
                bounds = bounds || [];
                bounds = [bounds[0], bounds[3], bounds[2], bounds[1]];
                return bounds
            },
            _initLegendsControl: function() {
                var that = this;
                that._legendsControl = new _legend2.default.LegendsControl({
                    renderer: that._renderer,
                    container: that._root,
                    widget: that,
                    layoutControl: that._layoutControl,
                    themeManager: that._themeManager,
                    dataExchanger: that._dataExchanger,
                    notifyDirty: that._notifyDirty,
                    notifyReady: that._notifyReady
                })
            },
            _initControlBar: function(dataKey) {
                var that = this;
                that._controlBar = new _control_bar2.default.ControlBar({
                    renderer: that._renderer,
                    container: that._root,
                    layoutControl: that._layoutControl,
                    projection: that._projection,
                    tracker: that._tracker,
                    dataKey: dataKey
                })
            },
            _initElements: function() {
                var that = this;
                var dataKey = generateDataKey();
                var notifyCounter = 0;
                var preventProjectionEvents;
                that._preventProjectionEvents = function() {
                    preventProjectionEvents = true
                };
                that._allowProjectionEvents = function() {
                    preventProjectionEvents = false
                };
                that._notifyDirty = function() {
                    that._resetIsReady();
                    ++notifyCounter
                };
                that._notifyReady = function() {
                    that._allowProjectionEvents();
                    if (0 === --notifyCounter) {
                        that._drawn()
                    }
                };
                that._preventProjectionEvents();
                that._dataExchanger = new _data_exchanger2.default.DataExchanger;
                that._projection = new _projection.Projection({
                    centerChanged: function(value) {
                        if (!preventProjectionEvents) {
                            that._eventTrigger("centerChanged", {
                                center: value
                            })
                        }
                    },
                    zoomChanged: function(value) {
                        if (!preventProjectionEvents) {
                            that._eventTrigger("zoomFactorChanged", {
                                zoomFactor: value
                            })
                        }
                    }
                });
                that._tracker = new _tracker2.default.Tracker({
                    root: that._root,
                    projection: that._projection,
                    dataKey: dataKey
                });
                that._gestureHandler = new _gesture_handler2.default.GestureHandler({
                    projection: that._projection,
                    renderer: that._renderer,
                    tracker: that._tracker
                });
                that._layoutControl = new _layout2.default.LayoutControl;
                that._layoutControl.suspend();
                that._initLayerCollection(dataKey);
                that._initControlBar(dataKey);
                that._initLegendsControl();
                that._tooltipViewer = new _tooltip_viewer2.default.TooltipViewer({
                    tracker: that._tracker,
                    tooltip: that._tooltip,
                    layerCollection: that._layerCollection
                })
            },
            _change_RESUME_LAYOUT: function() {
                this._layoutControl.resume()
            },
            _initialChanges: ["PROJECTION", "RESUME_LAYOUT", "LAYOUT_INIT", "BOUNDS", "MAX_ZOOM_FACTOR", "ZOOM_FACTOR", "CENTER"],
            _layoutChangesOrder: ["RESUME_LAYOUT", "LAYERS"],
            _initCore: function() {
                this._root = this._renderer.root.attr({
                    align: "center",
                    cursor: "default"
                });
                this._initElements()
            },
            _disposeCore: function() {
                var that = this;
                that._controlBar.dispose();
                that._gestureHandler.dispose();
                that._tracker.dispose();
                that._legendsControl.dispose();
                that._layerCollection.dispose();
                that._layoutControl.dispose();
                that._tooltipViewer.dispose();
                that._dataExchanger.dispose();
                that._projection.dispose();
                that._dataExchanger = that._gestureHandler = that._projection = that._tracker = that._layoutControl = that._root = that._layerCollection = that._controlBar = that._legendsControl = null
            },
            _setupInteraction: function() {
                var options = {
                    centeringEnabled: !!(0, _utils.parseScalar)(this._getOption("panningEnabled", true), true),
                    zoomingEnabled: !!(0, _utils.parseScalar)(this._getOption("zoomingEnabled", true), true)
                };
                this._gestureHandler.setInteraction(options);
                this._controlBar.setInteraction(options)
            },
            _getDefaultSize: function() {
                return {
                    width: DEFAULT_WIDTH,
                    height: DEFAULT_HEIGHT
                }
            },
            _applySize: function(rect) {
                var layout = {
                    left: rect[0],
                    top: rect[1],
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1],
                    right: 0,
                    bottom: 0
                };
                this._projection.setSize(layout);
                this._layoutControl.setSize(layout);
                this._layerCollection.setRect([layout.left, layout.top, layout.width, layout.height])
            },
            _optionChanging: function(name, currentValue, nextValue) {
                if (currentValue && nextValue) {
                    if (RE_STARTS_LAYERS.test(name)) {
                        if (currentValue.dataSource && nextValue.dataSource && currentValue !== nextValue) {
                            currentValue.dataSource = null
                        } else {
                            if (RE_ENDS_DATA_SOURCE.test(name)) {
                                this.option(name, null)
                            }
                        }
                    }
                }
            },
            _applyChanges: function() {
                this._notifyDirty();
                this.callBase.apply(this, arguments);
                this._notifyReady()
            },
            _optionChangesMap: {
                background: "BACKGROUND",
                layers: "LAYERS",
                controlBar: "CONTROL_BAR",
                legends: "LEGENDS",
                touchEnabled: "TRACKER",
                wheelEnabled: "TRACKER",
                panningEnabled: "INTERACTION",
                zoomingEnabled: "INTERACTION",
                projection: "PROJECTION",
                bounds: "BOUNDS",
                maxZoomFactor: "MAX_ZOOM_FACTOR",
                zoomFactor: "ZOOM_FACTOR",
                center: "CENTER"
            },
            _optionChangesOrder: ["PROJECTION", "BOUNDS", "MAX_ZOOM_FACTOR", "ZOOM_FACTOR", "CENTER", "BACKGROUND", "CONTROL_BAR", "LEGENDS", "TRACKER", "INTERACTION"],
            _change_PROJECTION: function() {
                this._setProjection()
            },
            _change_BOUNDS: function() {
                this._setBounds()
            },
            _change_MAX_ZOOM_FACTOR: function() {
                this._setMaxZoom()
            },
            _change_ZOOM_FACTOR: function() {
                this._setZoom()
            },
            _change_CENTER: function() {
                this._setCenter()
            },
            _change_BACKGROUND: function() {
                this._setBackgroundOptions()
            },
            _change_LAYERS: function() {
                this._setLayerCollectionOptions()
            },
            _change_CONTROL_BAR: function() {
                this._setControlBarOptions()
            },
            _change_LEGENDS: function() {
                this._setLegendsOptions()
            },
            _change_TRACKER: function() {
                this._setTrackerOptions()
            },
            _change_INTERACTION: function() {
                this._setupInteraction()
            },
            _themeDependentChanges: ["BACKGROUND", "LAYERS", "CONTROL_BAR", "LEGENDS", "TRACKER", "INTERACTION"],
            _setProjection: function() {
                this._projection.setEngine(this.option("projection"))
            },
            _setBounds: function() {
                this._projection.setBounds(this.option("bounds"))
            },
            _setMaxZoom: function() {
                this._projection.setMaxZoom(this.option("maxZoomFactor"))
            },
            _setZoom: function() {
                this._projection.setZoom(this.option("zoomFactor"))
            },
            _setCenter: function() {
                this._projection.setCenter(this.option("center"))
            },
            _setBackgroundOptions: function() {
                this._layerCollection.setBackgroundOptions(this._getOption("background"))
            },
            _setLayerCollectionOptions: function() {
                this._layerCollection.setOptions(this.option("layers"))
            },
            _getBoundingBoxFromDataSource: function() {
                var that = this;
                var layers = that._layerCollection.items();
                var infinityBounds = [1 / 0, -(1 / 0), -(1 / 0), 1 / 0];
                var resultBBox = layers && layers.length ? layers.reduce(function(sumBBox, l) {
                    var layerData = l.getData();
                    var itemCount = layerData.count();
                    if (itemCount > 0) {
                        var rootBBox = layerData.getBBox();
                        if (rootBBox) {
                            sumBBox = mergeBounds(sumBBox, rootBBox)
                        } else {
                            for (var i = 0; i < itemCount; i++) {
                                sumBBox = mergeBounds(sumBBox, layerData.getBBox(i))
                            }
                        }
                    }
                    return sumBBox
                }, infinityBounds) : void 0;
                return resultBBox === infinityBounds ? void 0 : resultBBox
            },
            _setControlBarOptions: function() {
                this._controlBar.setOptions(this._getOption("controlBar"))
            },
            _setLegendsOptions: function() {
                this._legendsControl.setOptions(this.option("legends"))
            },
            _setTrackerOptions: function() {
                this._tracker.setOptions({
                    touchEnabled: this._getOption("touchEnabled", true),
                    wheelEnabled: this._getOption("wheelEnabled", true)
                })
            },
            getLayers: function() {
                return this._layerCollection.items().map(function(l) {
                    return l.proxy
                })
            },
            getLayerByIndex: function(index) {
                var layer = this._layerCollection.byIndex(index);
                return layer ? layer.proxy : null
            },
            getLayerByName: function(name) {
                var layer = this._layerCollection.byName(name);
                return layer ? layer.proxy : null
            },
            clearSelection: function(_noEvent) {
                var layers = this._layerCollection.items();
                var i;
                var ii = layers.length;
                for (i = 0; i < ii; ++i) {
                    layers[i].clearSelection(_noEvent)
                }
                return this
            },
            center: function(value) {
                var that = this;
                if (void 0 === value) {
                    return that._projection.getCenter()
                } else {
                    that._projection.setCenter(value);
                    return that
                }
            },
            zoomFactor: function(value) {
                var that = this;
                if (void 0 === value) {
                    return that._projection.getZoom()
                } else {
                    that._projection.setZoom(value);
                    return that
                }
            },
            viewport: function(value) {
                var that = this;
                if (void 0 === value) {
                    return that._projection.getViewport()
                } else {
                    that._projection.setViewport(value);
                    return that
                }
            },
            convertCoordinates: function(coordinates) {
                coordinates = coordinates && coordinates.length ? coordinates : [arguments[0], arguments[1]];
                return this.convertToGeo(coordinates[0], coordinates[1])
            },
            convertToGeo: function(x, y) {
                return this._projection.fromScreenPoint([x, y])
            },
            convertToXY: function(longitude, latitude) {
                return this._projection.toScreenPoint([longitude, latitude])
            }
        });
        (0, _component_registrator2.default)("dxVectorMap", dxVectorMap);
        module.exports = dxVectorMap;
        module.exports._TESTS_resetDataKey = function() {
            nextDataKey = 1
        };
        dxVectorMap.addPlugin(_export.plugin);
        dxVectorMap.addPlugin(_title.plugin);
        dxVectorMap.addPlugin(_tooltip.plugin);
        dxVectorMap.addPlugin(_loading_indicator.plugin)
    },
    /*!************************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/control_bar.js ***!
      \************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _math = Math;
        var _min = _math.min;
        var _max = _math.max;
        var _round = _math.round;
        var _floor = _math.floor;
        var _sqrt = _math.sqrt;
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var _parseScalar = vizUtils.parseScalar;
        var parseHorizontalAlignment = vizUtils.enumParser(["left", "center", "right"]);
        var parseVerticalAlignment = vizUtils.enumParser(["top", "bottom"]);
        var COMMAND_RESET = "command-reset";
        var COMMAND_MOVE_UP = "command-move-up";
        var COMMAND_MOVE_RIGHT = "command-move-right";
        var COMMAND_MOVE_DOWN = "command-move-down";
        var COMMAND_MOVE_LEFT = "command-move-left";
        var COMMAND_ZOOM_IN = "command-zoom-in";
        var COMMAND_ZOOM_OUT = "command-zoom-out";
        var COMMAND_ZOOM_DRAG_LINE = "command-zoom-drag-line";
        var COMMAND_ZOOM_DRAG = "command-zoom-drag";
        var EVENT_TARGET_TYPE = "control-bar";
        var FLAG_CENTERING = 1;
        var FLAG_ZOOMING = 2;
        var SIZE_OPTIONS = {
            bigCircleSize: 58,
            smallCircleSize: 28,
            buttonSize: 10,
            arrowButtonOffset: 20,
            incDecButtonSize: 11,
            incButtonOffset: 66,
            decButtonOffset: 227,
            sliderLineStartOffset: 88.5,
            sliderLineEndOffset: 205.5,
            sliderLength: 20,
            sliderWidth: 8,
            trackerGap: 4
        };
        var OFFSET_X = 30.5;
        var OFFSET_Y = 30.5;
        var TOTAL_WIDTH = 61;
        var TOTAL_HEIGHT = 274;
        var COMMAND_TO_TYPE_MAP = {};
        COMMAND_TO_TYPE_MAP[COMMAND_RESET] = ResetCommand;
        COMMAND_TO_TYPE_MAP[COMMAND_MOVE_UP] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_RIGHT] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_DOWN] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_LEFT] = MoveCommand;
        COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_IN] = COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_OUT] = ZoomCommand;
        COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_DRAG] = ZoomDragCommand;

        function ControlBar(parameters) {
            var that = this;
            that._params = parameters;
            that._createElements(parameters.renderer, parameters.container, parameters.dataKey);
            parameters.layoutControl.addItem(that);
            that._subscribeToProjection(parameters.projection);
            that._subscribeToTracker(parameters.tracker);
            that._createCallbacks(parameters.projection)
        }
        ControlBar.prototype = {
            constructor: ControlBar,
            _flags: 0,
            dispose: function() {
                var that = this;
                that._params.layoutControl.removeItem(that);
                that._root.linkRemove().linkOff();
                that._offProjection();
                that._offTracker();
                that._params = that._root = that._offProjection = that._offTracker = that._callbacks = null
            },
            _subscribeToProjection: function(projection) {
                var that = this;
                that._offProjection = projection.on({
                    engine: function() {
                        that._update()
                    },
                    zoom: updateZoom,
                    "max-zoom": function() {
                        that._zoomPartition = projection.getZoomScalePartition();
                        that._sliderUnitLength = that._sliderLineLength / that._zoomPartition;
                        updateZoom()
                    }
                });

                function updateZoom() {
                    that._adjustZoom(projection.getScaledZoom())
                }
            },
            _subscribeToTracker: function(tracker) {
                var that = this;
                var isActive = false;
                that._offTracker = tracker.on({
                    start: function(arg) {
                        isActive = arg.data.name === EVENT_TARGET_TYPE;
                        if (isActive) {
                            that._processStart(arg.data.index, arg)
                        }
                    },
                    move: function(arg) {
                        if (isActive) {
                            that._processMove(arg.data.index, arg)
                        }
                    },
                    end: function() {
                        if (isActive) {
                            that._processEnd();
                            isActive = false
                        }
                    }
                })
            },
            _createCallbacks: function(projection) {
                var that = this;
                that._callbacks = {
                    reset: function(isCenter, isZoom) {
                        if (isCenter) {
                            projection.setCenter(null)
                        }
                        if (isZoom) {
                            projection.setZoom(null)
                        }
                    },
                    beginMove: function() {
                        projection.beginMoveCenter()
                    },
                    endMove: function() {
                        projection.endMoveCenter()
                    },
                    move: function(shift) {
                        projection.moveCenter(shift)
                    },
                    zoom: function(_zoom) {
                        projection.setScaledZoom(_zoom)
                    }
                }
            },
            _createElements: function(renderer, container, dataKey) {
                var that = this;
                that._root = renderer.g().attr({
                    "class": "dxm-control-bar"
                }).linkOn(container, "control-bar");
                var buttonsGroups = that._buttonsGroup = renderer.g().attr({
                    "class": "dxm-control-buttons"
                }).append(that._root);
                var trackersGroup = renderer.g().attr({
                    stroke: "none",
                    "stroke-width": 0,
                    fill: "#000000",
                    opacity: 1e-4
                }).css({
                    cursor: "pointer"
                }).append(that._root);
                that._createButtons(renderer, dataKey, buttonsGroups);
                that._createTrackers(renderer, dataKey, trackersGroup)
            },
            _createButtons: function(renderer, dataKey, group) {
                var that = this;
                var options = SIZE_OPTIONS;
                var size = options.buttonSize / 2;
                var offset1 = options.arrowButtonOffset - size;
                var offset2 = options.arrowButtonOffset;
                var incDecButtonSize = options.incDecButtonSize / 2;
                var directionOptions = {
                    "stroke-linecap": "square",
                    fill: "none"
                };
                var line = "line";
                renderer.circle(0, 0, options.bigCircleSize / 2).append(group);
                renderer.circle(0, 0, size).attr({
                    fill: "none"
                }).append(group);
                renderer.path([-size, -offset1, 0, -offset2, size, -offset1], line).attr(directionOptions).append(group);
                renderer.path([offset1, -size, offset2, 0, offset1, size], line).attr(directionOptions).append(group);
                renderer.path([size, offset1, 0, offset2, -size, offset1], line).attr(directionOptions).append(group);
                renderer.path([-offset1, size, -offset2, 0, -offset1, -size], line).attr(directionOptions).append(group);
                renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).append(group);
                renderer.path([
                    [-incDecButtonSize, options.incButtonOffset, incDecButtonSize, options.incButtonOffset],
                    [0, options.incButtonOffset - incDecButtonSize, 0, options.incButtonOffset + incDecButtonSize]
                ], "area").append(group);
                renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).append(group);
                renderer.path([-incDecButtonSize, options.decButtonOffset, incDecButtonSize, options.decButtonOffset], "area").append(group);
                that._zoomLine = renderer.path([], "line").append(group);
                that._zoomDrag = renderer.rect(_floor(-options.sliderLength / 2), _floor(options.sliderLineEndOffset - options.sliderWidth / 2), options.sliderLength, options.sliderWidth).append(group);
                that._sliderLineLength = options.sliderLineEndOffset - options.sliderLineStartOffset
            },
            _createTrackers: function(renderer, dataKey, group) {
                var options = SIZE_OPTIONS;
                var size = _round((options.arrowButtonOffset - options.trackerGap) / 2);
                var offset1 = options.arrowButtonOffset - size;
                var offset2 = _round(_sqrt(options.bigCircleSize * options.bigCircleSize / 4 - size * size));
                var size2 = offset2 - offset1;
                renderer.rect(-size, -size, 2 * size, 2 * size).data(dataKey, {
                    index: COMMAND_RESET,
                    name: EVENT_TARGET_TYPE
                }).append(group);
                renderer.rect(-size, -offset2, 2 * size, size2).data(dataKey, {
                    index: COMMAND_MOVE_UP,
                    name: EVENT_TARGET_TYPE
                }).append(group);
                renderer.rect(offset1, -size, size2, 2 * size).data(dataKey, {
                    index: COMMAND_MOVE_RIGHT,
                    name: EVENT_TARGET_TYPE
                }).append(group);
                renderer.rect(-size, offset1, 2 * size, size2).data(dataKey, {
                    index: COMMAND_MOVE_DOWN,
                    name: EVENT_TARGET_TYPE
                }).append(group);
                renderer.rect(-offset2, -size, size2, 2 * size).data(dataKey, {
                    index: COMMAND_MOVE_LEFT,
                    name: EVENT_TARGET_TYPE
                }).append(group);
                renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).data(dataKey, {
                    index: COMMAND_ZOOM_IN,
                    name: EVENT_TARGET_TYPE
                }).append(group);
                renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).data(dataKey, {
                    index: COMMAND_ZOOM_OUT,
                    name: EVENT_TARGET_TYPE
                }).append(group);
                renderer.rect(-2, options.sliderLineStartOffset - 2, 4, options.sliderLineEndOffset - options.sliderLineStartOffset + 4).css({
                    cursor: "default"
                }).data(dataKey, {
                    index: COMMAND_ZOOM_DRAG_LINE,
                    name: EVENT_TARGET_TYPE
                }).append(group);
                this._zoomDragTracker = renderer.rect(-options.sliderLength / 2, options.sliderLineEndOffset - options.sliderWidth / 2, options.sliderLength, options.sliderWidth).data(dataKey, {
                    index: COMMAND_ZOOM_DRAG,
                    name: EVENT_TARGET_TYPE
                }).append(group)
            },
            resize: function(size) {
                if (this._isActive) {
                    this._root.attr({
                        visibility: null !== size ? null : "hidden"
                    })
                }
            },
            getLayoutOptions: function() {
                return this._isActive ? this._layoutOptions : null
            },
            locate: function(x, y) {
                this._root.attr({
                    translateX: x + this._margin + OFFSET_X,
                    translateY: y + this._margin + OFFSET_Y
                })
            },
            _update: function() {
                var that = this;
                that._isActive = that._isEnabled && that._flags && that._params.projection.isInvertible();
                if (that._isActive) {
                    that._root.linkAppend()
                } else {
                    that._root.linkRemove()
                }
                that._processEnd();
                that.updateLayout()
            },
            setInteraction: function(interaction) {
                var that = this;
                if (_parseScalar(interaction.centeringEnabled, true)) {
                    that._flags |= FLAG_CENTERING
                } else {
                    that._flags &= ~FLAG_CENTERING
                }
                if (_parseScalar(interaction.zoomingEnabled, true)) {
                    that._flags |= FLAG_ZOOMING
                } else {
                    that._flags &= ~FLAG_ZOOMING
                }
                that._update()
            },
            setOptions: function(options) {
                var that = this;
                that._isEnabled = !!_parseScalar(options.enabled, true);
                that._margin = options.margin || 0;
                that._layoutOptions = {
                    width: 2 * that._margin + TOTAL_WIDTH,
                    height: 2 * that._margin + TOTAL_HEIGHT,
                    horizontalAlignment: parseHorizontalAlignment(options.horizontalAlignment, "left"),
                    verticalAlignment: parseVerticalAlignment(options.verticalAlignment, "top")
                };
                that._buttonsGroup.attr({
                    "stroke-width": options.borderWidth,
                    stroke: options.borderColor,
                    fill: options.color,
                    "fill-opacity": options.opacity
                });
                that._update()
            },
            _adjustZoom: function(zoom) {
                var that = this;
                var start = SIZE_OPTIONS.sliderLineStartOffset;
                var end = SIZE_OPTIONS.sliderLineEndOffset;
                var h = SIZE_OPTIONS.sliderWidth;
                that._zoomFactor = _max(_min(_round(zoom), that._zoomPartition), 0);
                var transform = {
                    translateY: -_round(that._zoomFactor * that._sliderUnitLength)
                };
                var y = end - h / 2 + transform.translateY;
                that._zoomLine.attr({
                    points: [
                        [0, start, 0, _max(start, y)],
                        [0, _min(end, y + h), 0, end]
                    ]
                });
                that._zoomDrag.attr(transform);
                that._zoomDragTracker.attr(transform)
            },
            _applyZoom: function() {
                this._callbacks.zoom(this._zoomFactor)
            },
            _processStart: function(command, arg) {
                var commandType;
                if (this._isActive) {
                    commandType = COMMAND_TO_TYPE_MAP[command];
                    this._command = commandType && commandType.flags & this._flags ? new commandType(this, command, arg) : null
                }
            },
            _processMove: function(command, arg) {
                this._command && this._command.update(command, arg)
            },
            _processEnd: function() {
                this._command && this._command.finish();
                this._command = null
            }
        };

        function disposeCommand(command) {
            delete command._owner;
            command.update = function() {};
            command.finish = function() {}
        }

        function ResetCommand(owner, command) {
            this._owner = owner;
            this._command = command
        }
        ResetCommand.flags = FLAG_CENTERING | FLAG_ZOOMING;
        ResetCommand.prototype.update = function(command) {
            command !== this._command && disposeCommand(this)
        };
        ResetCommand.prototype.finish = function() {
            var flags = this._owner._flags;
            this._owner._callbacks.reset(!!(flags & FLAG_CENTERING), !!(flags & FLAG_ZOOMING));
            disposeCommand(this)
        };

        function MoveCommand(owner, command, arg) {
            this._command = command;
            var timeout = null;
            var interval = 100;
            var dx = 0;
            var dy = 0;
            switch (this._command) {
                case COMMAND_MOVE_UP:
                    dy = -10;
                    break;
                case COMMAND_MOVE_RIGHT:
                    dx = 10;
                    break;
                case COMMAND_MOVE_DOWN:
                    dy = 10;
                    break;
                case COMMAND_MOVE_LEFT:
                    dx = -10
            }

            function callback() {
                owner._callbacks.move([dx, dy]);
                timeout = setTimeout(callback, interval)
            }
            this._stop = function() {
                clearTimeout(timeout);
                owner._callbacks.endMove();
                this._stop = owner = null;
                return this
            };
            arg = null;
            owner._callbacks.beginMove();
            callback()
        }
        MoveCommand.flags = FLAG_CENTERING;
        MoveCommand.prototype.update = function(command) {
            this._command !== command && this.finish()
        };
        MoveCommand.prototype.finish = function() {
            disposeCommand(this._stop())
        };

        function ZoomCommand(owner, command) {
            this._owner = owner;
            this._command = command;
            var timeout = null;
            var interval = 150;
            var dZoom = this._command === COMMAND_ZOOM_IN ? 1 : -1;

            function callback() {
                owner._adjustZoom(owner._zoomFactor + dZoom);
                timeout = setTimeout(callback, interval)
            }
            this._stop = function() {
                clearTimeout(timeout);
                this._stop = owner = null;
                return this
            };
            callback()
        }
        ZoomCommand.flags = FLAG_ZOOMING;
        ZoomCommand.prototype.update = function(command) {
            this._command !== command && this.finish()
        };
        ZoomCommand.prototype.finish = function() {
            this._owner._applyZoom();
            disposeCommand(this._stop())
        };

        function ZoomDragCommand(owner, command, arg) {
            this._owner = owner;
            this._zoomFactor = owner._zoomFactor;
            this._pos = arg.y
        }
        ZoomDragCommand.flags = FLAG_ZOOMING;
        ZoomDragCommand.prototype.update = function(command, arg) {
            var owner = this._owner;
            owner._adjustZoom(this._zoomFactor + owner._zoomPartition * (this._pos - arg.y) / owner._sliderLineLength)
        };
        ZoomDragCommand.prototype.finish = function() {
            this._owner._applyZoom();
            disposeCommand(this)
        };
        exports.ControlBar = ControlBar;
        var COMMAND_TO_TYPE_MAP__ORIGINAL = COMMAND_TO_TYPE_MAP;
        exports._TESTS_stubCommandToTypeMap = function(map) {
            COMMAND_TO_TYPE_MAP = map
        };
        exports._TESTS_restoreCommandToTypeMap = function() {
            COMMAND_TO_TYPE_MAP = COMMAND_TO_TYPE_MAP__ORIGINAL
        }
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/gesture_handler.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _ln = Math.log;
        var _LN2 = Math.LN2;

        function GestureHandler(params) {
            var that = this;
            that._projection = params.projection;
            that._renderer = params.renderer;
            that._x = that._y = 0;
            that._subscribeToTracker(params.tracker)
        }
        GestureHandler.prototype = {
            constructor: GestureHandler,
            dispose: function() {
                this._offTracker();
                this._offTracker = null
            },
            _subscribeToTracker: function(tracker) {
                var that = this;
                var isActive = false;
                that._offTracker = tracker.on({
                    start: function(arg) {
                        isActive = "control-bar" !== arg.data.name;
                        if (isActive) {
                            that._processStart(arg)
                        }
                    },
                    move: function(arg) {
                        if (isActive) {
                            that._processMove(arg)
                        }
                    },
                    end: function() {
                        if (isActive) {
                            that._processEnd()
                        }
                    },
                    zoom: function(arg) {
                        that._processZoom(arg)
                    }
                })
            },
            setInteraction: function(options) {
                this._processEnd();
                this._centeringEnabled = options.centeringEnabled;
                this._zoomingEnabled = options.zoomingEnabled
            },
            _processStart: function(arg) {
                if (this._centeringEnabled) {
                    this._x = arg.x;
                    this._y = arg.y;
                    this._projection.beginMoveCenter()
                }
            },
            _processMove: function(arg) {
                var that = this;
                if (that._centeringEnabled) {
                    that._renderer.root.attr({
                        cursor: "move"
                    });
                    that._projection.moveCenter([that._x - arg.x, that._y - arg.y]);
                    that._x = arg.x;
                    that._y = arg.y
                }
            },
            _processEnd: function() {
                if (this._centeringEnabled) {
                    this._renderer.root.attr({
                        cursor: "default"
                    });
                    this._projection.endMoveCenter()
                }
            },
            _processZoom: function(arg) {
                var that = this;
                var delta;
                var screenPosition;
                var coords;
                if (that._zoomingEnabled) {
                    if (arg.delta) {
                        delta = arg.delta
                    } else {
                        if (arg.ratio) {
                            delta = _ln(arg.ratio) / _LN2
                        }
                    }
                    if (that._centeringEnabled) {
                        screenPosition = that._renderer.getRootOffset();
                        screenPosition = [arg.x - screenPosition.left, arg.y - screenPosition.top];
                        coords = that._projection.fromScreenPoint(screenPosition)
                    }
                    that._projection.changeScaledZoom(delta);
                    if (that._centeringEnabled) {
                        that._projection.setCenterByPoint(coords, screenPosition)
                    }
                }
            }
        };
        exports.GestureHandler = GestureHandler
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/tracker.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
                _typeof = function(obj) {
                    return typeof obj
                }
            } else {
                _typeof = function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                }
            }
            return _typeof(obj)
        }
        var _events_engine = __webpack_require__( /*! ../../events/core/events_engine */ 5);
        var _events_engine2 = _interopRequireDefault(_events_engine);
        var _window = __webpack_require__( /*! ../../core/utils/window */ 7);
        var _window2 = _interopRequireDefault(_window);
        var _dom_adapter = __webpack_require__( /*! ../../core/dom_adapter */ 12);
        var _dom_adapter2 = _interopRequireDefault(_dom_adapter);
        var _event_emitter = __webpack_require__( /*! ./event_emitter */ 434);
        var _event_emitter2 = _interopRequireDefault(_event_emitter);
        var _utils = __webpack_require__( /*! ../../events/utils */ 8);
        var eventUtils = _interopRequireWildcard(_utils);
        var _wheel = __webpack_require__( /*! ../../events/core/wheel */ 133);
        var _utils2 = __webpack_require__( /*! ../core/utils */ 13);

        function _getRequireWildcardCache() {
            if ("function" !== typeof WeakMap) {
                return null
            }
            var cache = new WeakMap;
            _getRequireWildcardCache = function() {
                return cache
            };
            return cache
        }

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            }
            if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
                return {
                    "default": obj
                }
            }
            var cache = _getRequireWildcardCache();
            if (cache && cache.has(obj)) {
                return cache.get(obj)
            }
            var newObj = {};
            var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                        Object.defineProperty(newObj, key, desc)
                    } else {
                        newObj[key] = obj[key]
                    }
                }
            }
            newObj.default = obj;
            if (cache) {
                cache.set(obj, newObj)
            }
            return newObj
        }

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var navigator = _window2.default.getNavigator();
        var _math = Math;
        var _abs = _math.abs;
        var _sqrt = _math.sqrt;
        var _round = _math.round;
        var _addNamespace = eventUtils.addNamespace;
        var _now = Date.now;
        var _NAME = "dxVectorMap";
        var EVENT_START = "start";
        var EVENT_MOVE = "move";
        var EVENT_END = "end";
        var EVENT_ZOOM = "zoom";
        var EVENT_HOVER_ON = "hover-on";
        var EVENT_HOVER_OFF = "hover-off";
        var EVENT_CLICK = "click";
        var EVENT_FOCUS_ON = "focus-on";
        var EVENT_FOCUS_MOVE = "focus-move";
        var EVENT_FOCUS_OFF = "focus-off";
        var CLICK_TIME_THRESHOLD = 500;
        var CLICK_COORD_THRESHOLD_MOUSE = 5;
        var CLICK_COORD_THRESHOLD_TOUCH = 20;
        var DRAG_COORD_THRESHOLD_MOUSE = 5;
        var DRAG_COORD_THRESHOLD_TOUCH = 10;
        var FOCUS_OFF_DELAY = 100;
        var WHEEL_COOLDOWN = 50;
        var WHEEL_DIRECTION_COOLDOWN = 300;
        var EVENTS;
        var Focus;
        setupEvents();

        function Tracker(parameters) {
            var that = this;
            that._root = parameters.root;
            that._createEventHandlers(parameters.dataKey);
            that._createProjectionHandlers(parameters.projection);
            that._initEvents();
            that._focus = new Focus(function(name, arg) {
                that._fire(name, arg)
            });
            that._attachHandlers()
        }
        Tracker.prototype = {
            constructor: Tracker,
            dispose: function() {
                var that = this;
                that._detachHandlers();
                that._disposeEvents();
                that._focus.dispose();
                that._root = that._focus = that._docHandlers = that._rootHandlers = null
            },
            _eventNames: [EVENT_START, EVENT_MOVE, EVENT_END, EVENT_ZOOM, EVENT_CLICK, EVENT_HOVER_ON, EVENT_HOVER_OFF, EVENT_FOCUS_ON, EVENT_FOCUS_OFF, EVENT_FOCUS_MOVE],
            _startClick: function(event, data) {
                if (!data) {
                    return
                }
                var coords = getEventCoords(event);
                this._clickState = {
                    x: coords.x,
                    y: coords.y,
                    threshold: isTouchEvent(event) ? CLICK_COORD_THRESHOLD_TOUCH : CLICK_COORD_THRESHOLD_MOUSE,
                    time: _now()
                }
            },
            _endClick: function(event, data) {
                var state = this._clickState;
                var threshold;
                var coords;
                if (!state) {
                    return
                }
                if (data && _now() - state.time <= CLICK_TIME_THRESHOLD) {
                    threshold = state.threshold;
                    coords = getEventCoords(event);
                    if (_abs(coords.x - state.x) <= threshold && _abs(coords.y - state.y) <= threshold) {
                        this._fire(EVENT_CLICK, {
                            data: data,
                            x: coords.x,
                            y: coords.y,
                            $event: event
                        })
                    }
                }
                this._clickState = null
            },
            _startDrag: function(event, data) {
                if (!data) {
                    return
                }
                var coords = getEventCoords(event);
                var state = this._dragState = {
                    x: coords.x,
                    y: coords.y,
                    data: data
                };
                this._fire(EVENT_START, {
                    x: state.x,
                    y: state.y,
                    data: state.data
                })
            },
            _moveDrag: function(event, data) {
                var state = this._dragState;
                if (!state) {
                    return
                }
                var coords = getEventCoords(event);
                var threshold = isTouchEvent(event) ? DRAG_COORD_THRESHOLD_TOUCH : DRAG_COORD_THRESHOLD_MOUSE;
                if (state.active || _abs(coords.x - state.x) > threshold || _abs(coords.y - state.y) > threshold) {
                    state.x = coords.x;
                    state.y = coords.y;
                    state.active = true;
                    state.data = data || {};
                    this._fire(EVENT_MOVE, {
                        x: state.x,
                        y: state.y,
                        data: state.data
                    })
                }
            },
            _endDrag: function() {
                var state = this._dragState;
                if (!state) {
                    return
                }
                this._dragState = null;
                this._fire(EVENT_END, {
                    x: state.x,
                    y: state.y,
                    data: state.data
                })
            },
            _wheelZoom: function(event, data) {
                if (!data) {
                    return
                }
                var that = this;
                var lock = that._wheelLock;
                var time = _now();
                if (time - lock.time <= WHEEL_COOLDOWN) {
                    return
                }
                if (time - lock.dirTime > WHEEL_DIRECTION_COOLDOWN) {
                    lock.dir = 0
                }
                var delta = adjustWheelDelta(event.delta / 120 || 0, lock);
                if (0 === delta) {
                    return
                }
                var coords = getEventCoords(event);
                that._fire(EVENT_ZOOM, {
                    delta: delta,
                    x: coords.x,
                    y: coords.y
                });
                lock.time = lock.dirTime = time
            },
            _startZoom: function(event, data) {
                if (!isTouchEvent(event) || !data) {
                    return
                }
                var state = this._zoomState = this._zoomState || {};
                var coords;
                var pointer2;
                if (state.pointer1 && state.pointer2) {
                    return
                }
                if (void 0 === state.pointer1) {
                    state.pointer1 = getPointerId(event) || 0;
                    coords = getMultitouchEventCoords(event, state.pointer1);
                    state.x1 = state.x1_0 = coords.x;
                    state.y1 = state.y1_0 = coords.y
                }
                if (void 0 === state.pointer2) {
                    pointer2 = getPointerId(event) || 1;
                    if (pointer2 !== state.pointer1) {
                        coords = getMultitouchEventCoords(event, pointer2);
                        if (coords) {
                            state.x2 = state.x2_0 = coords.x;
                            state.y2 = state.y2_0 = coords.y;
                            state.pointer2 = pointer2;
                            state.ready = true;
                            this._endDrag()
                        }
                    }
                }
            },
            _moveZoom: function(event) {
                var state = this._zoomState;
                var coords;
                if (!state || !isTouchEvent(event)) {
                    return
                }
                if (void 0 !== state.pointer1) {
                    coords = getMultitouchEventCoords(event, state.pointer1);
                    if (coords) {
                        state.x1 = coords.x;
                        state.y1 = coords.y
                    }
                }
                if (void 0 !== state.pointer2) {
                    coords = getMultitouchEventCoords(event, state.pointer2);
                    if (coords) {
                        state.x2 = coords.x;
                        state.y2 = coords.y
                    }
                }
            },
            _endZoom: function(event) {
                var state = this._zoomState;
                var startDistance;
                var currentDistance;
                if (!state || !isTouchEvent(event)) {
                    return
                }
                if (state.ready) {
                    startDistance = getDistance(state.x1_0, state.y1_0, state.x2_0, state.y2_0);
                    currentDistance = getDistance(state.x1, state.y1, state.x2, state.y2);
                    this._fire(EVENT_ZOOM, {
                        ratio: currentDistance / startDistance,
                        x: (state.x1_0 + state.x2_0) / 2,
                        y: (state.y1_0 + state.y2_0) / 2
                    })
                }
                this._zoomState = null
            },
            _startHover: function(event, data) {
                this._doHover(event, data, true)
            },
            _moveHover: function(event, data) {
                this._doHover(event, data, false)
            },
            _doHover: function(event, data, isTouch) {
                var that = this;
                if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
                    that._cancelHover();
                    return
                }
                if (isTouchEvent(event) !== isTouch || that._hoverTarget === event.target || that._hoverState && that._hoverState.data === data) {
                    return
                }
                that._cancelHover();
                if (data) {
                    that._hoverState = {
                        data: data
                    };
                    that._fire(EVENT_HOVER_ON, {
                        data: data
                    })
                }
                that._hoverTarget = event.target
            },
            _cancelHover: function() {
                var state = this._hoverState;
                this._hoverState = this._hoverTarget = null;
                if (state) {
                    this._fire(EVENT_HOVER_OFF, {
                        data: state.data
                    })
                }
            },
            _startFocus: function(event, data) {
                this._doFocus(event, data, true)
            },
            _moveFocus: function(event, data) {
                this._doFocus(event, data, false)
            },
            _doFocus: function(event, data, isTouch) {
                var that = this;
                if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
                    that._cancelFocus();
                    return
                }
                if (isTouchEvent(event) !== isTouch) {
                    return
                }
                that._focus.turnOff();
                data && that._focus.turnOn(data, getEventCoords(event))
            },
            _cancelFocus: function() {
                this._focus.cancel()
            },
            _createEventHandlers: function(DATA_KEY) {
                var that = this;
                that._docHandlers = {};
                that._rootHandlers = {};
                that._rootHandlers[EVENTS.start] = that._docHandlers[EVENTS.start] = function(event) {
                    var isTouch = isTouchEvent(event);
                    var data = getData(event);
                    if (isTouch && !that._isTouchEnabled) {
                        return
                    }
                    if (data) {
                        event.preventDefault();
                        event.stopPropagation()
                    }
                    that._startClick(event, data);
                    that._startDrag(event, data);
                    that._startZoom(event, data);
                    that._startHover(event, data);
                    that._startFocus(event, data)
                };
                that._docHandlers[EVENTS.move] = function(event) {
                    var isTouch = isTouchEvent(event);
                    var data = getData(event);
                    if (isTouch && !that._isTouchEnabled) {
                        return
                    }
                    that._moveDrag(event, data);
                    that._moveZoom(event, data);
                    that._moveHover(event, data);
                    that._moveFocus(event, data)
                };
                that._docHandlers[EVENTS.end] = function(event) {
                    var isTouch = isTouchEvent(event);
                    var data = getData(event);
                    if (isTouch && !that._isTouchEnabled) {
                        return
                    }
                    that._endClick(event, data);
                    that._endDrag(event, data);
                    that._endZoom(event, data)
                };
                that._rootHandlers[EVENTS.wheel] = function(event) {
                    that._cancelFocus();
                    if (!that._isWheelEnabled) {
                        return
                    }
                    var data = getData(event);
                    if (data) {
                        event.preventDefault();
                        event.stopPropagation();
                        that._wheelZoom(event, data)
                    }
                };
                that._wheelLock = {
                    dir: 0
                };

                function getData(event) {
                    var target = event.target;
                    return ("tspan" === target.tagName ? target.parentNode : target)[DATA_KEY]
                }
            },
            _createProjectionHandlers: function(projection) {
                var that = this;
                projection.on({
                    center: handler,
                    zoom: handler
                });

                function handler() {
                    that._cancelFocus()
                }
            },
            reset: function() {
                var that = this;
                that._clickState = null;
                that._endDrag();
                that._cancelHover();
                that._cancelFocus()
            },
            setOptions: function(options) {
                var that = this;
                that.reset();
                that._detachHandlers();
                that._isTouchEnabled = !!(0, _utils2.parseScalar)(options.touchEnabled, true);
                that._isWheelEnabled = !!(0, _utils2.parseScalar)(options.wheelEnabled, true);
                that._attachHandlers()
            },
            _detachHandlers: function() {
                var that = this;
                if (that._isTouchEnabled) {
                    that._root.css({
                        "touch-action": "",
                        "-webkit-user-select": ""
                    }).off(_addNamespace("MSHoldVisual", _NAME)).off(_addNamespace("contextmenu", _NAME))
                }
                _events_engine2.default.off(_dom_adapter2.default.getDocument(), that._docHandlers);
                that._root.off(that._rootHandlers)
            },
            _attachHandlers: function() {
                var that = this;
                if (that._isTouchEnabled) {
                    that._root.css({
                        "touch-action": "none",
                        "-webkit-user-select": "none"
                    }).on(_addNamespace("MSHoldVisual", _NAME), function(event) {
                        event.preventDefault()
                    }).on(_addNamespace("contextmenu", _NAME), function(event) {
                        isTouchEvent(event) && event.preventDefault()
                    })
                }
                _events_engine2.default.on(_dom_adapter2.default.getDocument(), that._docHandlers);
                that._root.on(that._rootHandlers)
            }
        };
        Focus = function(fire) {
            var that = this;
            var _activeData = null;
            var _data = null;
            var _disabled = false;
            var _offTimer = null;
            var _x;
            var _y;
            that.dispose = function() {
                clearTimeout(_offTimer);
                that.turnOn = that.turnOff = that.cancel = that.dispose = that = fire = _activeData = _data = _offTimer = null
            };
            that.turnOn = function(data, coords) {
                if (data === _data && _disabled) {
                    return
                }
                _disabled = false;
                _data = data;
                if (_activeData) {
                    _x = coords.x;
                    _y = coords.y;
                    if (_data === _activeData) {
                        fire(EVENT_FOCUS_MOVE, {
                            data: _data,
                            x: _x,
                            y: _y
                        });
                        onCheck(true)
                    } else {
                        fire(EVENT_FOCUS_ON, {
                            data: _data,
                            x: _x,
                            y: _y,
                            done: onCheck
                        })
                    }
                } else {
                    _x = coords.x;
                    _y = coords.y;
                    fire(EVENT_FOCUS_ON, {
                        data: _data,
                        x: _x,
                        y: _y,
                        done: onCheck
                    })
                }

                function onCheck(result) {
                    _disabled = !result;
                    if (result) {
                        _activeData = _data;
                        clearTimeout(_offTimer);
                        _offTimer = null
                    }
                }
            };
            that.turnOff = function() {
                _data = null;
                if (_activeData && !_disabled) {
                    _offTimer = _offTimer || setTimeout(function() {
                        _offTimer = null;
                        fire(EVENT_FOCUS_OFF, {
                            data: _activeData
                        });
                        _activeData = null
                    }, FOCUS_OFF_DELAY)
                }
            };
            that.cancel = function() {
                clearTimeout(_offTimer);
                if (_activeData) {
                    fire(EVENT_FOCUS_OFF, {
                        data: _activeData
                    })
                }
                _activeData = _data = _offTimer = null
            }
        };
        _event_emitter2.default.makeEventEmitter(Tracker);
        exports.Tracker = Tracker;
        var originFocus = Focus;
        exports._DEBUG_forceEventMode = function(mode) {
            setupEvents(mode)
        };
        exports.Focus = Focus;
        exports._DEBUG_stubFocusType = function(focusType) {
            Focus = focusType
        };
        exports._DEBUG_restoreFocusType = function() {
            Focus = originFocus
        };

        function getDistance(x1, y1, x2, y2) {
            return _sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
        }

        function isTouchEvent(event) {
            var type = event.originalEvent.type;
            var pointerType = event.originalEvent.pointerType;
            return /^touch/.test(type) || /^MSPointer/.test(type) && 4 !== pointerType || /^pointer/.test(type) && "mouse" !== pointerType
        }

        function selectItem(flags, items) {
            var i = 0;
            var ii = flags.length;
            var item;
            for (; i < ii; ++i) {
                if (flags[i]) {
                    item = items[i];
                    break
                }
            }
            return _addNamespace(item || items[i], _NAME)
        }

        function setupEvents() {
            var flags = [navigator.pointerEnabled, navigator.msPointerEnabled, _window2.default.hasProperty("ontouchstart")];
            if (arguments.length) {
                flags = ["pointer" === arguments[0], "MSPointer" === arguments[0], "touch" === arguments[0]]
            }
            EVENTS = {
                start: selectItem(flags, ["pointerdown", "MSPointerDown", "touchstart mousedown", "mousedown"]),
                move: selectItem(flags, ["pointermove", "MSPointerMove", "touchmove mousemove", "mousemove"]),
                end: selectItem(flags, ["pointerup", "MSPointerUp", "touchend mouseup", "mouseup"]),
                wheel: _addNamespace(_wheel.name, _NAME)
            }
        }

        function getEventCoords(event) {
            var originalEvent = event.originalEvent;
            var touch = originalEvent.touches && originalEvent.touches[0] || {};
            return {
                x: touch.pageX || originalEvent.pageX || event.pageX,
                y: touch.pageY || originalEvent.pageY || event.pageY
            }
        }

        function getPointerId(event) {
            return event.originalEvent.pointerId
        }

        function getMultitouchEventCoords(event, pointerId) {
            var originalEvent = event.originalEvent;
            if (void 0 !== originalEvent.pointerId) {
                originalEvent = originalEvent.pointerId === pointerId ? originalEvent : null
            } else {
                originalEvent = originalEvent.touches[pointerId]
            }
            return originalEvent ? {
                x: originalEvent.pageX || event.pageX,
                y: originalEvent.pageY || event.pageY
            } : null
        }

        function adjustWheelDelta(delta, lock) {
            if (0 === delta) {
                return 0
            }
            var _delta = _abs(delta);
            var sign = _round(delta / _delta);
            if (lock.dir && sign !== lock.dir) {
                return 0
            }
            lock.dir = sign;
            if (_delta < .1) {
                _delta = 0
            } else {
                if (_delta < 1) {
                    _delta = 1
                } else {
                    if (_delta > 4) {
                        _delta = 4
                    } else {
                        _delta = _round(_delta)
                    }
                }
            }
            return sign * _delta
        }
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/data_exchanger.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var Callbacks = __webpack_require__( /*! ../../core/utils/callbacks */ 27);

        function DataExchanger() {
            this._store = {}
        }
        DataExchanger.prototype = {
            constructor: DataExchanger,
            dispose: function() {
                this._store = null;
                return this
            },
            _get: function(category, name) {
                var store = this._store[category] || (this._store[category] = {});
                return store[name] || (store[name] = {
                    callbacks: Callbacks()
                })
            },
            set: function(category, name, data) {
                var item = this._get(category, name);
                item.data = data;
                item.callbacks.fire(data);
                return this
            },
            bind: function(category, name, callback) {
                var item = this._get(category, name);
                item.callbacks.add(callback);
                item.data && callback(item.data);
                return this
            },
            unbind: function(category, name, callback) {
                var item = this._get(category, name);
                item.callbacks.remove(callback);
                return this
            }
        };
        exports.DataExchanger = DataExchanger
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/legend.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var _extend = extend;
        var _each = each;
        var legendModule = __webpack_require__( /*! ../components/legend */ 207);
        var _BaseLegend = legendModule.Legend;
        var unknownSource = {
            category: "UNKNOWN",
            name: "UNKNOWN"
        };

        function buildData(partition, values, field) {
            var i;
            var ii = values.length;
            var list = [];
            var item;
            for (i = 0; i < ii; ++i) {
                list[i] = item = {
                    start: partition[i],
                    end: partition[i + 1],
                    index: i
                };
                item[field] = values[i];
                item.states = {
                    normal: {
                        fill: item.color
                    }
                };
                item.visible = true
            }
            return list
        }
        var Legend = function(parameters) {
            var that = this;
            that._params = parameters;
            that._root = parameters.renderer.g().attr({
                "class": "dxm-legend"
            }).linkOn(parameters.container, {
                name: "legend",
                after: "legend-base"
            }).enableLinks().linkAppend();
            parameters.layoutControl.addItem(that);
            _BaseLegend.call(that, {
                renderer: parameters.renderer,
                widget: parameters.widget,
                group: that._root,
                backgroundClass: null,
                itemsGroupClass: null,
                textField: "text",
                getFormatObject: function(data) {
                    return data
                }
            });
            that._onDataChanged = function(data) {
                that._updateData(data)
            }
        };
        Legend.prototype = _extend(__webpack_require__( /*! ../../core/utils/object */ 47).clone(_BaseLegend.prototype), {
            constructor: Legend,
            dispose: function() {
                var that = this;
                that._params.layoutControl.removeItem(that);
                that._unbindData();
                that._root.linkRemove().linkOff();
                that._params = that._root = that._onDataChanged = null;
                return _BaseLegend.prototype.dispose.apply(that, arguments)
            },
            resize: function(size) {
                this._params.notifyDirty();
                if (null === size) {
                    this.erase()
                } else {
                    this.draw(size.width, size.height)
                }
                this._params.notifyReady()
            },
            locate: _BaseLegend.prototype.shift,
            _updateData: function(data) {
                this._options.defaultColor = data && data.defaultColor;
                this.update(data ? buildData(data.partition, data.values, this._dataName) : [], this._options, this._params.themeManager.theme("legend").title);
                this.updateLayout()
            },
            _unbindData: function() {
                if (this._dataCategory) {
                    this._params.dataExchanger.unbind(this._dataCategory, this._dataName, this._onDataChanged)
                }
            },
            _bindData: function(arg) {
                this._params.dataExchanger.bind(this._dataCategory = arg.category, this._dataName = arg.name, this._onDataChanged)
            },
            setOptions: function(options) {
                var that = this;
                that.update(that._data, options, this._params.themeManager.theme("legend").title);
                that._unbindData();
                var source = options.source;
                that._bindData(source ? {
                    category: source.layer,
                    name: source.grouping
                } : unknownSource);
                that.updateLayout();
                return that
            }
        });

        function LegendsControl(parameters) {
            this._params = parameters;
            this._items = [];
            parameters.container.virtualLink("legend-base")
        }
        LegendsControl.prototype = {
            constructor: LegendsControl,
            dispose: function() {
                _each(this._items, function(_, item) {
                    item.dispose()
                });
                this._params = this._items = null
            },
            setOptions: function(options) {
                var optionList = options && options.length ? options : [];
                var items = this._items;
                var i;
                var ii = optionList.length;
                var params = this._params;
                var theme = params.themeManager.theme("legend");
                for (i = items.length; i < ii; ++i) {
                    items[i] = new Legend(params)
                }
                for (i = items.length - 1; i >= ii; --i) {
                    items[i].dispose();
                    items.splice(i, 1)
                }
                params.layoutControl.suspend();
                for (i = 0; i < ii; ++i) {
                    items[i].setOptions(_extend(true, {}, theme, optionList[i]))
                }
                params.layoutControl.resume()
            }
        };
        exports.LegendsControl = LegendsControl;
        var originalLegend = Legend;
        exports._TESTS_Legend = Legend;
        exports._TESTS_stubLegendType = function(stub) {
            Legend = stub
        };
        exports._TESTS_restoreLegendType = function() {
            Legend = originalLegend
        }
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/layout.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var inArray = __webpack_require__( /*! ../../core/utils/array */ 14).inArray;
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var _round = Math.round;
        var _min = Math.min;
        var _max = Math.max;
        var _each = each;
        var _inArray = inArray;
        var horizontalAlignmentMap = {
            left: 0,
            center: 1,
            right: 2
        };
        var verticalAlignmentMap = {
            top: 0,
            bottom: 1
        };

        function getCellIndex(options) {
            return 3 * verticalAlignmentMap[options.verticalAlignment] + horizontalAlignmentMap[options.horizontalAlignment]
        }

        function createCells(canvas, items) {
            var hStep = (canvas.right - canvas.left) / 3;
            var vStep = (canvas.bottom - canvas.top) / 2;
            var h1 = canvas.left;
            var h2 = _round(h1 + hStep);
            var h3 = _round(h1 + hStep + hStep);
            var h4 = canvas.right;
            var v1 = canvas.top;
            var v2 = _round(v1 + vStep);
            var v3 = canvas.bottom;
            var cells = [{
                rect: [h1, v1, h2, v2]
            }, {
                rect: [h2, v1, h3, v2],
                center: true
            }, {
                rect: [h3, v1, h4, v2],
                horInversion: true
            }, {
                rect: [h1, v2, h2, v3],
                verInversion: true
            }, {
                rect: [h2, v2, h3, v3],
                center: true,
                verInversion: true
            }, {
                rect: [h3, v2, h4, v3],
                horInversion: true,
                verInversion: true
            }];
            var itemsList = [
                [],
                [],
                [],
                [],
                [],
                []
            ];
            _each(items, function(_, item) {
                var options = item.getLayoutOptions();
                if (options) {
                    itemsList[getCellIndex(options)].push({
                        item: item,
                        width: options.width,
                        height: options.height
                    })
                }
            });
            _each(cells, function(i, cell) {
                if (itemsList[i].length) {
                    cell.items = itemsList[i]
                } else {
                    if (cell.center) {
                        cell.rect[0] = cell.rect[2] = (cell.rect[0] + cell.rect[2]) / 2
                    } else {
                        cell.rect[cell.horInversion ? 0 : 2] = cell.rect[cell.horInversion ? 2 : 0]
                    }
                    cell.rect[cell.verInversion ? 1 : 3] = cell.rect[cell.verInversion ? 3 : 1]
                }
            });
            return cells
        }

        function adjustCellSizes(cells) {
            _each([0, 1, 2, 3, 4, 5], function(_, index) {
                var cell = cells[index];
                var otherCell = cells[(index + 3) % 6];
                if (cell.items) {
                    if (!otherCell.items) {
                        cell.rect[1] = _min(cell.rect[1], otherCell.rect[3]);
                        cell.rect[3] = _max(cell.rect[3], otherCell.rect[1])
                    }
                }
            });
            _each([1, 4], function(_, index) {
                var cell = cells[index];
                var otherCell1 = cells[index - 1];
                var otherCell2 = cells[index + 1];
                var size1;
                var size2;
                if (cell.items) {
                    if (!otherCell1.items && !otherCell2.items) {
                        size1 = cell.rect[0] - otherCell1.rect[2];
                        size2 = otherCell2.rect[0] - cell.rect[2];
                        if (size1 > size2) {
                            if (size1 / size2 >= 2) {
                                cell.rect[0] -= size1;
                                cell.right = true
                            } else {
                                cell.rect[0] -= size2;
                                cell.rect[2] += size2
                            }
                        } else {
                            if (size2 / size1 >= 2) {
                                cell.rect[2] += size2;
                                cell.center = null
                            } else {
                                cell.rect[0] -= size1;
                                cell.rect[2] += size1
                            }
                        }
                    }
                } else {
                    if (otherCell1.items) {
                        otherCell1.rect[2] = (cell.rect[0] + cell.rect[2]) / 2
                    }
                    if (otherCell2.items) {
                        otherCell2.rect[0] = (cell.rect[0] + cell.rect[2]) / 2
                    }
                }
            })
        }

        function adjustCellsAndApplyLayout(cells, forceMode) {
            var hasHiddenItems = false;
            adjustCellSizes(cells);
            _each(cells, function(_, cell) {
                if (cell.items) {
                    hasHiddenItems = applyCellLayout(cell, forceMode) || hasHiddenItems
                }
            });
            return hasHiddenItems
        }

        function applyCellLayout(cell, forceMode) {
            var cellRect = cell.rect;
            var cellWidth = cellRect[2] - cellRect[0];
            var cellHeight = cellRect[3] - cellRect[1];
            var xOffset = 0;
            var yOffset = 0;
            var currentHeight = 0;
            var totalL = cellRect[2];
            var totalT = cellRect[3];
            var totalR = cellRect[0];
            var totalB = cellRect[1];
            var moves = [];
            var hasHiddenItems = false;
            _each(cell.items, function(_, item) {
                if (item.width > cellWidth || item.height > cellHeight) {
                    moves.push(null);
                    hasHiddenItems = true;
                    return forceMode || false
                }
                if (xOffset + item.width > cellWidth) {
                    yOffset += currentHeight;
                    xOffset = currentHeight = 0
                }
                if (yOffset + item.height > cellHeight) {
                    moves.push(null);
                    hasHiddenItems = true;
                    return forceMode || false
                }
                currentHeight = _max(currentHeight, item.height);
                var dx = cell.horInversion ? cellRect[2] - item.width - xOffset : cellRect[0] + xOffset;
                var dy = cell.verInversion ? cellRect[3] - item.height - yOffset : cellRect[1] + yOffset;
                xOffset += item.width;
                totalL = _min(totalL, dx);
                totalT = _min(totalT, dy);
                totalR = _max(totalR, dx + item.width);
                totalB = _max(totalB, dy + item.height);
                moves.push([dx, dy])
            });
            if (forceMode || !hasHiddenItems) {
                xOffset = 0;
                if (cell.right) {
                    xOffset = cellRect[2] - cellRect[0] - totalR + totalL
                } else {
                    if (cell.center) {
                        xOffset = _round((cellRect[2] - cellRect[0] - totalR + totalL) / 2)
                    }
                }
                _each(cell.items, function(i, item) {
                    var move = moves[i];
                    if (move) {
                        item.item.locate(move[0] + xOffset, move[1])
                    } else {
                        item.item.resize(null)
                    }
                });
                cell.rect = [totalL, totalT, totalR, totalB];
                cell.items = null
            }
            return hasHiddenItems
        }

        function applyLayout(canvas, items) {
            var cells = createCells(canvas, items);
            if (adjustCellsAndApplyLayout(cells)) {
                adjustCellsAndApplyLayout(cells, true)
            }
        }

        function LayoutControl() {
            var that = this;
            that._items = [];
            that._suspended = 0;
            that._updateLayout = function() {
                that._update()
            }
        }
        LayoutControl.prototype = {
            constructor: LayoutControl,
            dispose: function() {
                this._items = this._updateLayout = null
            },
            setSize: function(canvas) {
                this._canvas = canvas;
                this._update()
            },
            suspend: function() {
                ++this._suspended
            },
            resume: function() {
                if (0 === --this._suspended) {
                    this._update()
                }
            },
            addItem: function(item) {
                this._items.push(item);
                item.updateLayout = this._updateLayout
            },
            removeItem: function(item) {
                this._items.splice(_inArray(item, this._items), 1);
                item.updateLayout = null
            },
            _update: function() {
                var canvas;
                if (0 === this._suspended) {
                    canvas = this._canvas;
                    _each(this._items, function(_, item) {
                        item.resize(canvas)
                    });
                    applyLayout({
                        left: canvas.left,
                        top: canvas.top,
                        right: canvas.width + canvas.left,
                        bottom: canvas.height + canvas.top
                    }, this._items)
                }
            }
        };
        exports.LayoutControl = LayoutControl
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/map_layer.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports._TESTS_findGroupingIndex = exports._TESTS_groupBySize = exports._TESTS_stub_groupBySize = exports._TESTS_groupByColor = exports._TESTS_stub_groupByColor = exports._TESTS_performGrouping = exports._TESTS_stub_performGrouping = exports._TESTS_createProxy = exports._TESTS_stub_MapLayerElement = exports._TESTS_MapLayerElement = exports._TESTS_stub_selectStrategy = exports._TESTS_selectStrategy = exports._TESTS_stub_MapLayer = exports._TESTS_MapLayer = void 0;
        exports.getMaxBound = getMaxBound;
        exports.MapLayerCollection = MapLayerCollection;
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);
        var _extend2 = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _iterator = __webpack_require__( /*! ../../core/utils/iterator */ 4);
        var _data_helper = __webpack_require__( /*! ../../data_helper */ 82);
        var _data_helper2 = _interopRequireDefault(_data_helper);
        var _type = __webpack_require__( /*! ../../core/utils/type */ 1);
        var _deferred = __webpack_require__( /*! ../../core/utils/deferred */ 6);
        var _deferred2 = _interopRequireDefault(_deferred);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }
        var _noop = _common.noop;
        var _extend = _extend2.extend;
        var _each = _iterator.each;
        var _concat = Array.prototype.concat;
        var TYPE_AREA = "area";
        var TYPE_LINE = "line";
        var TYPE_MARKER = "marker";
        var STATE_DEFAULT = 0;
        var STATE_HOVERED = 1;
        var STATE_SELECTED = 2;
        var STATE_TO_INDEX = [0, 1, 2, 2];
        var TOLERANCE = 1;
        var SELECTIONS = {
            none: null,
            single: -1,
            multiple: NaN
        };
        var _isArray = Array.isArray;
        var _Number = Number;
        var _String = String;
        var _abs = Math.abs;
        var _round = Math.round;
        var _min = Math.min;
        var _max = Math.max;
        var _sqrt = Math.sqrt;

        function getMaxBound(arr) {
            return arr.reduce(function(a, c) {
                return c ? [_min(a[0], c[0]), _min(a[1], c[1]), _max(a[2], c[2]), _max(a[3], c[3])] : a
            }, arr[0])
        }

        function getSelection(selectionMode) {
            var selection = (0, _utils.normalizeEnum)(selectionMode);
            selection = selection in SELECTIONS ? SELECTIONS[selection] : SELECTIONS.single;
            if (null !== selection) {
                selection = {
                    state: {},
                    single: selection
                }
            }
            return selection
        }

        function getName(opt, index) {
            return (opt[index] || {}).name
        }

        function EmptySource() {}
        EmptySource.prototype.count = function() {
            return 0
        };

        function ArraySource(raw) {
            this.raw = raw
        }
        ArraySource.prototype = {
            constructor: ArraySource,
            count: function() {
                return this.raw.length
            },
            item: function(index) {
                return this.raw[index]
            },
            geometry: function(item) {
                return {
                    coordinates: item.coordinates
                }
            },
            attributes: function(item) {
                return item.attributes
            },
            getBBox: function(index) {
                return 0 === arguments.length ? void 0 : this.raw[index].bbox
            }
        };

        function GeoJsonSource(raw) {
            this.raw = raw
        }
        GeoJsonSource.prototype = {
            constructor: GeoJsonSource,
            count: function() {
                return this.raw.features.length
            },
            item: function(index) {
                return this.raw.features[index]
            },
            geometry: function(item) {
                return item.geometry
            },
            attributes: function(item) {
                return item.properties
            },
            getBBox: function(index) {
                return 0 === arguments.length ? this.raw.bbox : this.raw.features[index].bbox
            }
        };

        function isGeoJsonObject(obj) {
            return _isArray(obj.features)
        }

        function unwrapFromDataSource(source) {
            var sourceType;
            if (source) {
                if (isGeoJsonObject(source)) {
                    sourceType = GeoJsonSource
                } else {
                    if (1 === source.length && source[0] && isGeoJsonObject(source[0])) {
                        sourceType = GeoJsonSource;
                        source = source[0]
                    } else {
                        if (_isArray(source)) {
                            sourceType = ArraySource
                        }
                    }
                }
            }
            sourceType = sourceType || EmptySource;
            return new sourceType(source)
        }

        function wrapToDataSource(option) {
            return option ? isGeoJsonObject(option) ? [option] : option : []
        }

        function customizeHandles(proxies, callback, widget) {
            callback.call(widget, proxies)
        }

        function setAreaLabelVisibility(label) {
            label.text.attr({
                visibility: label.size[0] / label.spaceSize[0] < TOLERANCE && label.size[1] / label.spaceSize[1] < TOLERANCE ? null : "hidden"
            })
        }

        function setLineLabelVisibility(label) {
            label.text.attr({
                visibility: label.size[0] / label.spaceSize[0] < TOLERANCE || label.size[1] / label.spaceSize[1] < TOLERANCE ? null : "hidden"
            })
        }

        function getDataValue(proxy, dataField) {
            return proxy.attribute(dataField)
        }
        var TYPE_TO_TYPE_MAP = {
            Point: TYPE_MARKER,
            MultiPoint: TYPE_LINE,
            LineString: TYPE_LINE,
            MultiLineString: TYPE_LINE,
            Polygon: TYPE_AREA,
            MultiPolygon: TYPE_AREA
        };

        function pick(a, b) {
            return void 0 !== a ? a : b
        }

        function guessTypeByData(sample) {
            var type = TYPE_TO_TYPE_MAP[sample.type];
            var coordinates = sample.coordinates;
            if (!type) {
                if ("number" === typeof coordinates[0]) {
                    type = TYPE_MARKER
                } else {
                    if ("number" === typeof coordinates[0][0]) {
                        type = TYPE_LINE
                    } else {
                        type = TYPE_AREA
                    }
                }
            }
            return type
        }
        var emptyStrategy = {
            setup: _noop,
            reset: _noop,
            arrange: _noop,
            updateGrouping: _noop,
            getDefaultColor: _noop
        };
        var strategiesByType = {};
        var strategiesByGeometry = {};
        var strategiesByElementType = {};
        var groupByColor;
        var groupBySize;
        var selectStrategy = function(options, data) {
            var type = (0, _utils.normalizeEnum)(options.type);
            var elementType = (0, _utils.normalizeEnum)(options.elementType);
            var sample;
            var strategy = _extend({}, emptyStrategy);
            if (data.count() > 0) {
                sample = data.geometry(data.item(0));
                type = strategiesByType[type] ? type : guessTypeByData(sample);
                _extend(strategy, strategiesByType[type]);
                strategy.fullType = strategy.type = type;
                if (strategiesByGeometry[type]) {
                    _extend(strategy, strategiesByGeometry[type](sample))
                }
                if (strategiesByElementType[type]) {
                    elementType = strategiesByElementType[type][elementType] ? elementType : strategiesByElementType[type]._default;
                    _extend(strategy, strategiesByElementType[type][elementType]);
                    strategy.elementType = elementType;
                    strategy.fullType += ":" + elementType
                }
            }
            return strategy
        };

        function applyElementState(figure, styles, state, field) {
            figure[field].attr(styles[field][state])
        }
        strategiesByType[TYPE_AREA] = {
            projectLabel: projectAreaLabel,
            transform: transformPointList,
            transformLabel: transformAreaLabel,
            draw: function(context, figure, data) {
                figure.root = context.renderer.path([], "area").data(context.dataKey, data)
            },
            refresh: _noop,
            getLabelOffset: function(label) {
                setAreaLabelVisibility(label);
                return [0, 0]
            },
            getStyles: function(settings) {
                var color = settings.color || null;
                var borderColor = settings.borderColor || null;
                var borderWidth = pick(settings.borderWidth, null);
                var opacity = pick(settings.opacity, null);
                return {
                    root: [{
                        "class": "dxm-area",
                        stroke: borderColor,
                        "stroke-width": borderWidth,
                        fill: color,
                        opacity: opacity
                    }, {
                        "class": "dxm-area dxm-area-hovered",
                        stroke: settings.hoveredBorderColor || borderColor,
                        "stroke-width": pick(settings.hoveredBorderWidth, borderWidth),
                        fill: settings.hoveredColor || color,
                        opacity: pick(settings.hoveredOpacity, opacity)
                    }, {
                        "class": "dxm-area dxm-area-selected",
                        stroke: settings.selectedBorderColor || borderColor,
                        "stroke-width": pick(settings.selectedBorderWidth, borderWidth),
                        fill: settings.selectedColor || color,
                        opacity: pick(settings.selectedOpacity, opacity)
                    }]
                }
            },
            setState: function(figure, styles, state) {
                applyElementState(figure, styles, state, "root")
            },
            hasLabelsGroup: true,
            updateGrouping: function(context) {
                groupByColor(context)
            },
            getDefaultColor: _noop
        };
        strategiesByType[TYPE_LINE] = {
            projectLabel: projectLineLabel,
            transform: transformPointList,
            transformLabel: transformLineLabel,
            draw: function(context, figure, data) {
                figure.root = context.renderer.path([], "line").data(context.dataKey, data)
            },
            refresh: _noop,
            getLabelOffset: function(label) {
                setLineLabelVisibility(label);
                return [0, 0]
            },
            getStyles: function(settings) {
                var color = settings.color || settings.borderColor || null;
                var width = pick(settings.borderWidth, null);
                var opacity = pick(settings.opacity, null);
                return {
                    root: [{
                        "class": "dxm-line",
                        stroke: color,
                        "stroke-width": width,
                        opacity: opacity
                    }, {
                        "class": "dxm-line dxm-line-hovered",
                        stroke: settings.hoveredColor || settings.hoveredBorderColor || color,
                        "stroke-width": pick(settings.hoveredBorderWidth, width),
                        opacity: pick(settings.hoveredOpacity, opacity)
                    }, {
                        "class": "dxm-line dxm-line-selected",
                        stroke: settings.selectedColor || settings.selectedBorderColor || color,
                        "stroke-width": pick(settings.selectedBorderWidth, width),
                        opacity: pick(settings.selectedOpacity, opacity)
                    }]
                }
            },
            setState: function(figure, styles, state) {
                applyElementState(figure, styles, state, "root")
            },
            hasLabelsGroup: true,
            updateGrouping: function(context) {
                groupByColor(context)
            },
            getDefaultColor: _noop
        };
        strategiesByType[TYPE_MARKER] = {
            project: projectPoint,
            transform: transformPoint,
            draw: function(context, figure, data) {
                figure.root = context.renderer.g();
                this._draw(context, figure, data)
            },
            refresh: _noop,
            hasLabelsGroup: false,
            getLabelOffset: function(label, settings) {
                return [_round((label.size[0] + _max(settings.size || 0, 0)) / 2) + 2, 0]
            },
            getStyles: function(settings) {
                var styles = {
                    root: [{
                        "class": "dxm-marker"
                    }, {
                        "class": "dxm-marker dxm-marker-hovered"
                    }, {
                        "class": "dxm-marker dxm-marker-selected"
                    }]
                };
                this._getStyles(styles, settings);
                return styles
            },
            setState: function(figure, styles, state) {
                applyElementState(figure, styles, state, "root");
                this._setState(figure, styles, state)
            },
            updateGrouping: function(context) {
                groupByColor(context);
                groupBySize(context)
            },
            getDefaultColor: function(ctx, palette) {
                return ctx.params.themeManager.getAccentColor(palette)
            }
        };
        strategiesByGeometry[TYPE_AREA] = function(sample) {
            return {
                project: function(projection, coordinates) {
                    return coordinates[0] && coordinates[0][0] && coordinates[0][0][0] && "number" === typeof coordinates[0][0][0][0] ? projectMultiPolygon(projection, coordinates) : projectPolygon(projection, coordinates)
                }
            }
        };
        strategiesByGeometry[TYPE_LINE] = function(sample) {
            var coordinates = sample.coordinates;
            return {
                project: coordinates[0] && coordinates[0][0] && "number" === typeof coordinates[0][0][0] ? projectPolygon : projectLineString
            }
        };
        strategiesByElementType[TYPE_MARKER] = {
            _default: "dot",
            dot: {
                setup: function(context) {
                    context.filter = context.renderer.shadowFilter("-40%", "-40%", "180%", "200%", 0, 1, 1, "#000000", .2)
                },
                reset: function(context) {
                    context.filter.dispose();
                    context.filter = null
                },
                _draw: function(ctx, figure, data) {
                    figure.back = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
                    figure.dot = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root)
                },
                refresh: function(ctx, figure, data, proxy, settings) {
                    figure.dot.attr({
                        filter: settings.shadow ? ctx.filter.id : null
                    })
                },
                _getStyles: function(styles, style) {
                    var size = style.size > 0 ? _Number(style.size) : 0;
                    var hoveredSize = size;
                    var selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
                    var hoveredBackSize = hoveredSize + (style.backStep > 0 ? _Number(style.backStep) : 0);
                    var selectedBackSize = selectedSize + (style.backStep > 0 ? _Number(style.backStep) : 0);
                    var color = style.color || null;
                    var borderColor = style.borderColor || null;
                    var borderWidth = pick(style.borderWidth, null);
                    var opacity = pick(style.opacity, null);
                    var backColor = style.backColor || null;
                    var backOpacity = pick(style.backOpacity, null);
                    styles.dot = [{
                        r: size / 2,
                        stroke: borderColor,
                        "stroke-width": borderWidth,
                        fill: color,
                        opacity: opacity
                    }, {
                        r: hoveredSize / 2,
                        stroke: style.hoveredBorderColor || borderColor,
                        "stroke-width": pick(style.hoveredBorderWidth, borderWidth),
                        fill: style.hoveredColor || color,
                        opacity: pick(style.hoveredOpacity, opacity)
                    }, {
                        r: selectedSize / 2,
                        stroke: style.selectedBorderColor || borderColor,
                        "stroke-width": pick(style.selectedBorderWidth, borderWidth),
                        fill: style.selectedColor || color,
                        opacity: pick(style.selectedOpacity, opacity)
                    }];
                    styles.back = [{
                        r: size / 2,
                        stroke: "none",
                        "stroke-width": 0,
                        fill: backColor,
                        opacity: backOpacity
                    }, {
                        r: hoveredBackSize / 2,
                        stroke: "none",
                        "stroke-width": 0,
                        fill: backColor,
                        opacity: backOpacity
                    }, {
                        r: selectedBackSize / 2,
                        stroke: "none",
                        "stroke-width": 0,
                        fill: backColor,
                        opacity: backOpacity
                    }]
                },
                _setState: function(figure, styles, state) {
                    applyElementState(figure, styles, state, "dot");
                    applyElementState(figure, styles, state, "back")
                }
            },
            bubble: {
                _draw: function(ctx, figure, data) {
                    figure.bubble = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root)
                },
                refresh: function(ctx, figure, data, proxy, settings) {
                    figure.bubble.attr({
                        r: settings.size / 2
                    })
                },
                _getStyles: function(styles, style) {
                    var color = style.color || null;
                    var borderColor = style.borderColor || null;
                    var borderWidth = pick(style.borderWidth, null);
                    var opacity = pick(style.opacity, null);
                    styles.bubble = [{
                        stroke: borderColor,
                        "stroke-width": borderWidth,
                        fill: color,
                        opacity: opacity
                    }, {
                        stroke: style.hoveredBorderColor || borderColor,
                        "stroke-width": pick(style.hoveredBorderWidth, borderWidth),
                        fill: style.hoveredColor || style.color,
                        opacity: pick(style.hoveredOpacity, opacity)
                    }, {
                        stroke: style.selectedBorderColor || borderColor,
                        "stroke-width": pick(style.selectedBorderWidth, borderWidth),
                        fill: style.selectedColor || style.color,
                        opacity: pick(style.selectedOpacity, opacity)
                    }]
                },
                _setState: function(figure, styles, state) {
                    applyElementState(figure, styles, state, "bubble")
                },
                arrange: function(context, handles) {
                    var values = [];
                    var i;
                    var ii = values.length = handles.length;
                    var settings = context.settings;
                    var dataField = settings.dataField;
                    var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;
                    var maxSize = settings.maxSize > minSize ? _Number(settings.maxSize) : minSize;
                    if (settings.sizeGroups) {
                        return
                    }
                    for (i = 0; i < ii; ++i) {
                        values[i] = _max(getDataValue(handles[i].proxy, dataField) || 0, 0)
                    }
                    var minValue = _min.apply(null, values);
                    var maxValue = _max.apply(null, values);
                    var deltaValue = maxValue - minValue || 1;
                    var deltaSize = maxSize - minSize;
                    for (i = 0; i < ii; ++i) {
                        handles[i]._settings.size = minSize + deltaSize * (values[i] - minValue) / deltaValue
                    }
                },
                updateGrouping: function(context) {
                    var dataField = context.settings.dataField;
                    strategiesByType[TYPE_MARKER].updateGrouping(context);
                    groupBySize(context, function(proxy) {
                        return getDataValue(proxy, dataField)
                    })
                }
            },
            pie: {
                _draw: function(ctx, figure, data) {
                    figure.pie = ctx.renderer.g().append(figure.root);
                    figure.border = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root)
                },
                refresh: function(ctx, figure, data, proxy, settings) {
                    var values = getDataValue(proxy, ctx.settings.dataField) || [];
                    var colors = settings._colors;
                    var sum = 0;
                    var pie = figure.pie;
                    var renderer = ctx.renderer;
                    var dataKey = ctx.dataKey;
                    var r = (settings.size > 0 ? _Number(settings.size) : 0) / 2;
                    var start = 90;
                    var end = start;
                    var zeroSum = false;
                    sum = values.reduce(function(total, item) {
                        return total + (item || 0)
                    }, 0);
                    if (0 === sum) {
                        zeroSum = true;
                        sum = 360 / values.length
                    }
                    values.forEach(function(item, i) {
                        start = end;
                        end += zeroSum ? sum : (item || 0) / sum * 360;
                        renderer.arc(0, 0, 0, r, start, end).attr({
                            "stroke-linejoin": "round",
                            fill: colors[i]
                        }).data(dataKey, data).append(pie)
                    });
                    figure.border.attr({
                        r: r
                    })
                },
                _getStyles: function(styles, style) {
                    var opacity = pick(style.opacity, null);
                    var borderColor = style.borderColor || null;
                    var borderWidth = pick(style.borderWidth, null);
                    styles.pie = [{
                        opacity: opacity
                    }, {
                        opacity: pick(style.hoveredOpacity, opacity)
                    }, {
                        opacity: pick(style.selectedOpacity, opacity)
                    }];
                    styles.border = [{
                        stroke: borderColor,
                        "stroke-width": borderWidth
                    }, {
                        stroke: style.hoveredBorderColor || borderColor,
                        "stroke-width": pick(style.hoveredBorderWidth, borderWidth)
                    }, {
                        stroke: style.selectedBorderColor || borderColor,
                        "stroke-width": pick(style.selectedBorderWidth, borderWidth)
                    }]
                },
                _setState: function(figure, styles, state) {
                    applyElementState(figure, styles, state, "pie");
                    applyElementState(figure, styles, state, "border")
                },
                arrange: function(context, handles) {
                    var i;
                    var ii = handles.length;
                    var dataField = context.settings.dataField;
                    var values;
                    var count = 0;
                    var palette;
                    for (i = 0; i < ii; ++i) {
                        values = getDataValue(handles[i].proxy, dataField);
                        if (values && values.length > count) {
                            count = values.length
                        }
                    }
                    if (count > 0) {
                        palette = context.params.themeManager.createPalette(context.settings.palette, {
                            useHighlight: true,
                            extensionMode: "alternate"
                        });
                        values = palette.generateColors(count);
                        context.settings._colors = values;
                        context.grouping.color = {
                            callback: _noop,
                            field: "",
                            partition: [],
                            values: []
                        };
                        context.params.dataExchanger.set(context.name, "color", {
                            partition: [],
                            values: values
                        })
                    }
                }
            },
            image: {
                _draw: function(ctx, figure, data) {
                    figure.image = ctx.renderer.image(null, null, null, null, null, "center").attr({
                        "pointer-events": "visible"
                    }).data(ctx.dataKey, data).append(figure.root)
                },
                refresh: function(ctx, figure, data, proxy) {
                    figure.image.attr({
                        href: getDataValue(proxy, ctx.settings.dataField)
                    })
                },
                _getStyles: function(styles, style) {
                    var size = style.size > 0 ? _Number(style.size) : 0;
                    var hoveredSize = size + (style.hoveredStep > 0 ? _Number(style.hoveredStep) : 0);
                    var selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
                    var opacity = pick(style.opacity, null);
                    styles.image = [{
                        x: -size / 2,
                        y: -size / 2,
                        width: size,
                        height: size,
                        opacity: opacity
                    }, {
                        x: -hoveredSize / 2,
                        y: -hoveredSize / 2,
                        width: hoveredSize,
                        height: hoveredSize,
                        opacity: pick(style.hoveredOpacity, opacity)
                    }, {
                        x: -selectedSize / 2,
                        y: -selectedSize / 2,
                        width: selectedSize,
                        height: selectedSize,
                        opacity: pick(style.selectedOpacity, opacity)
                    }]
                },
                _setState: function(figure, styles, state) {
                    applyElementState(figure, styles, state, "image")
                }
            }
        };

        function projectPoint(projection, coordinates) {
            return projection.project(coordinates)
        }

        function projectPointList(projection, coordinates) {
            var output = [];
            var i;
            var ii = output.length = coordinates.length;
            for (i = 0; i < ii; ++i) {
                output[i] = projection.project(coordinates[i])
            }
            return output
        }

        function projectLineString(projection, coordinates) {
            return [projectPointList(projection, coordinates)]
        }

        function projectPolygon(projection, coordinates) {
            var output = [];
            var i;
            var ii = output.length = coordinates.length;
            for (i = 0; i < ii; ++i) {
                output[i] = projectPointList(projection, coordinates[i])
            }
            return output
        }

        function projectMultiPolygon(projection, coordinates) {
            var output = [];
            var i;
            var ii = output.length = coordinates.length;
            for (i = 0; i < ii; ++i) {
                output[i] = projectPolygon(projection, coordinates[i])
            }
            return _concat.apply([], output)
        }

        function transformPoint(content, projection, coordinates) {
            var data = projection.transform(coordinates);
            content.root.attr({
                translateX: data[0],
                translateY: data[1]
            })
        }

        function transformList(projection, coordinates) {
            var output = [];
            var i;
            var ii = coordinates.length;
            var item;
            var k = 0;
            output.length = 2 * ii;
            for (i = 0; i < ii; ++i) {
                item = projection.transform(coordinates[i]);
                output[k++] = item[0];
                output[k++] = item[1]
            }
            return output
        }

        function transformPointList(content, projection, coordinates) {
            var output = [];
            var i;
            var ii = output.length = coordinates.length;
            for (i = 0; i < ii; ++i) {
                output[i] = transformList(projection, coordinates[i])
            }
            content.root.attr({
                points: output
            })
        }

        function transformAreaLabel(label, projection, coordinates) {
            var data = projection.transform(coordinates[0]);
            label.spaceSize = projection.getSquareSize(coordinates[1]);
            label.text.attr({
                translateX: data[0],
                translateY: data[1]
            });
            setAreaLabelVisibility(label)
        }

        function transformLineLabel(label, projection, coordinates) {
            var data = projection.transform(coordinates[0]);
            label.spaceSize = projection.getSquareSize(coordinates[1]);
            label.text.attr({
                translateX: data[0],
                translateY: data[1]
            });
            setLineLabelVisibility(label)
        }

        function getItemSettings(context, proxy, settings) {
            var result = combineSettings(context.settings, settings);
            applyGrouping(context.grouping, proxy, result);
            if (void 0 === settings.color && settings.paletteIndex >= 0) {
                result.color = result._colors[settings.paletteIndex]
            }
            return result
        }

        function applyGrouping(grouping, proxy, settings) {
            _each(grouping, function(name, data) {
                var index = findGroupingIndex(data.callback(proxy, data.field), data.partition);
                if (index >= 0) {
                    settings[name] = data.values[index]
                }
            })
        }

        function findGroupingIndex(value, partition) {
            var start = 0;
            var end = partition.length - 1;
            var index = -1;
            var middle;
            if (partition[start] <= value && value <= partition[end]) {
                if (value === partition[end]) {
                    index = end - 1
                } else {
                    while (end - start > 1) {
                        middle = start + end >> 1;
                        if (value < partition[middle]) {
                            end = middle
                        } else {
                            start = middle
                        }
                    }
                    index = start
                }
            }
            return index
        }

        function raiseChanged(context, handle, state, name) {
            context.params.eventTrigger(name, {
                target: handle.proxy,
                state: state
            })
        }

        function combineSettings(common, partial) {
            var obj = _extend({}, common, partial);
            obj.label = _extend({}, common.label, obj.label);
            obj.label.font = _extend({}, common.label.font, obj.label.font);
            return obj
        }

        function processCommonSettings(context, options) {
            var themeManager = context.params.themeManager;
            var strategy = context.str;
            var settings = combineSettings(_extend({
                label: {},
                color: strategy.getDefaultColor(context, options.palette)
            }, themeManager.theme("layer:" + strategy.fullType)), options);
            var colors;
            var i;
            var palette;
            if (settings.paletteSize > 0) {
                palette = themeManager.createDiscretePalette(settings.palette, settings.paletteSize);
                for (i = 0, colors = []; i < settings.paletteSize; ++i) {
                    colors.push(palette.getColor(i))
                }
                settings._colors = colors
            }
            return settings
        }

        function valueCallback(proxy, dataField) {
            return proxy.attribute(dataField)
        }
        var performGrouping = function(context, partition, settingField, dataField, valuesCallback) {
            var values;
            if (dataField && partition && partition.length > 1) {
                values = valuesCallback(partition.length - 1);
                context.grouping[settingField] = {
                    callback: (0, _type.isFunction)(dataField) ? dataField : valueCallback,
                    field: dataField,
                    partition: partition,
                    values: values
                };
                context.params.dataExchanger.set(context.name, settingField, {
                    partition: partition,
                    values: values,
                    defaultColor: context.settings.color
                })
            }
        };

        function dropGrouping(context) {
            var name = context.name;
            var dataExchanger = context.params.dataExchanger;
            _each(context.grouping, function(field) {
                dataExchanger.set(name, field, null)
            });
            context.grouping = {}
        }
        groupByColor = function(context) {
            performGrouping(context, context.settings.colorGroups, "color", context.settings.colorGroupingField, function(count) {
                var _palette = context.params.themeManager.createDiscretePalette(context.settings.palette, count);
                var i;
                var list = [];
                for (i = 0; i < count; ++i) {
                    list.push(_palette.getColor(i))
                }
                return list
            })
        };
        groupBySize = function(context, valueCallback) {
            var settings = context.settings;
            performGrouping(context, settings.sizeGroups, "size", valueCallback || settings.sizeGroupingField, function(count) {
                var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;
                var maxSize = settings.maxSize >= minSize ? _Number(settings.maxSize) : 0;
                var i = 0;
                var sizes = [];
                if (count > 1) {
                    for (i = 0; i < count; ++i) {
                        sizes.push((minSize * (count - i - 1) + maxSize * i) / (count - 1))
                    }
                } else {
                    if (1 === count) {
                        sizes.push((minSize + maxSize) / 2)
                    }
                }
                return sizes
            })
        };

        function setFlag(flags, flag, state) {
            if (state) {
                flags |= flag
            } else {
                flags &= ~flag
            }
            return flags
        }

        function hasFlag(flags, flag) {
            return !!(flags & flag)
        }

        function createLayerProxy(layer, name, index) {
            var proxy = {
                index: index,
                name: name,
                getElements: function() {
                    return layer.getProxies()
                },
                clearSelection: function(_noEvent) {
                    layer.clearSelection(_noEvent);
                    return proxy
                },
                getDataSource: function() {
                    return layer.getDataSource()
                },
                getBounds: function() {
                    return layer.getBounds()
                }
            };
            return proxy
        }
        var MapLayerElement;
        var MapLayer = function(params, container, name, index) {
            var that = this;
            that._params = params;
            that._onProjection();
            that.proxy = createLayerProxy(that, name, index);
            that._context = {
                name: name,
                layer: that.proxy,
                renderer: params.renderer,
                projection: params.projection,
                params: params,
                dataKey: params.dataKey,
                str: emptyStrategy,
                hover: false,
                selection: null,
                grouping: {},
                root: params.renderer.g().attr({
                    "class": "dxm-layer"
                }).linkOn(container, name).linkAppend()
            };
            that._container = container;
            that._options = {};
            that._handles = [];
            that._data = new EmptySource;
            that._dataSourceLoaded = null
        };
        MapLayer.prototype = _extend({
            constructor: MapLayer,
            getDataReadyCallback: function() {
                return this._dataSourceLoaded
            },
            _onProjection: function() {
                var that = this;
                that._removeHandlers = that._params.projection.on({
                    engine: function() {
                        that._project()
                    },
                    screen: function() {
                        that._transform()
                    },
                    center: function() {
                        that._transformCore()
                    },
                    zoom: function() {
                        that._transform()
                    }
                })
            },
            getData: function() {
                return this._data
            },
            _dataSourceLoadErrorHandler: function() {
                this._dataSourceChangedHandler()
            },
            _dataSourceChangedHandler: function() {
                var that = this;
                that._data = unwrapFromDataSource(that._dataSource && that._dataSource.items());
                that._update(true)
            },
            _dataSourceOptions: function() {
                return {
                    paginate: false
                }
            },
            _getSpecificDataSourceOption: function() {
                return this._specificDataSourceOption
            },
            _normalizeDataSource: function(dataSource) {
                var store = dataSource.store();
                if ("raw" === store._loadMode) {
                    store._loadMode = void 0
                }
                return dataSource
            },
            _offProjection: function() {
                this._removeHandlers();
                this._removeHandlers = null
            },
            dispose: function() {
                var that = this;
                that._disposeDataSource();
                that._destroyHandles();
                dropGrouping(that._context);
                that._context.root.linkRemove().linkOff();
                that._context.labelRoot && that._context.labelRoot.linkRemove().linkOff();
                that._context.str.reset(that._context);
                that._offProjection();
                that._params = that._container = that._context = that.proxy = null;
                return that
            },
            TESTS_getContext: function() {
                return this._context
            },
            setOptions: function(options) {
                var that = this;
                options = that._options = options || {};
                that._dataSourceLoaded = new _deferred2.default.Deferred;
                if ("dataSource" in options && options.dataSource !== that._options_dataSource) {
                    that._options_dataSource = options.dataSource;
                    that._params.notifyDirty();
                    that._specificDataSourceOption = wrapToDataSource(options.dataSource);
                    that._refreshDataSource()
                } else {
                    if (that._data.count() > 0) {
                        that._params.notifyDirty();
                        that._update(void 0 !== options.type && options.type !== that._context.str.type || void 0 !== options.elementType && options.elementType !== that._context.str.elementType)
                    }
                }
                that._transformCore()
            },
            _update: function(isContextChanged) {
                var that = this;
                var context = that._context;
                if (isContextChanged) {
                    context.str.reset(context);
                    context.root.clear();
                    context.labelRoot && context.labelRoot.clear();
                    that._params.tracker.reset();
                    that._destroyHandles();
                    context.str = selectStrategy(that._options, that._data);
                    context.str.setup(context);
                    that.proxy.type = context.str.type;
                    that.proxy.elementType = context.str.elementType
                }
                context.settings = processCommonSettings(context, that._options);
                context.hasSeparateLabel = !!(context.settings.label.enabled && context.str.hasLabelsGroup);
                context.hover = !!(0, _utils.parseScalar)(context.settings.hoverEnabled, true);
                if (context.selection) {
                    _each(context.selection.state, function(_, handle) {
                        handle && handle.resetSelected()
                    })
                }
                context.selection = getSelection(context.settings.selectionMode);
                if (context.hasSeparateLabel) {
                    if (!context.labelRoot) {
                        context.labelRoot = context.renderer.g().attr({
                            "class": "dxm-layer-labels"
                        }).linkOn(that._container, {
                            name: context.name + "-labels",
                            after: context.name
                        }).linkAppend();
                        that._transformCore()
                    }
                } else {
                    if (context.labelRoot) {
                        context.labelRoot.linkRemove().linkOff();
                        context.labelRoot = null
                    }
                }
                if (isContextChanged) {
                    that._createHandles()
                }
                dropGrouping(context);
                context.str.arrange(context, that._handles);
                context.str.updateGrouping(context);
                that._updateHandles();
                that._params.notifyReady();
                that._dataSourceLoaded.resolve();
                that._dataSourceLoaded = null
            },
            getBounds: function() {
                return getMaxBound(this._handles.map(function(_ref) {
                    var proxy = _ref.proxy;
                    return proxy.coordinates().map(function(coords) {
                        if (!_isArray(coords)) {
                            return
                        }
                        var initValue = coords[0];
                        return coords.reduce(function(min, c) {
                            return [_min(min[0], c[0]), _min(min[1], c[1]), _max(min[2], c[0]), _max(min[3], c[1])]
                        }, [initValue[0], initValue[1], initValue[0], initValue[1]])
                    })
                }).map(getMaxBound))
            },
            _destroyHandles: function() {
                this._handles.forEach(function(h) {
                    return h.dispose()
                });
                if (this._context.selection) {
                    this._context.selection.state = {}
                }
                this._handles = []
            },
            _createHandles: function() {
                var that = this;
                var handles = that._handles = [];
                var data = that._data;
                var i;
                var ii = handles.length = data.count();
                var context = that._context;
                var geometry = data.geometry;
                var attributes = data.attributes;
                var handle;
                var dataItem;
                for (i = 0; i < ii; ++i) {
                    dataItem = data.item(i);
                    handles[i] = new MapLayerElement(context, i, geometry(dataItem), attributes(dataItem))
                }(0, _type.isFunction)(that._options.customize) && customizeHandles(that.getProxies(), that._options.customize, that._params.widget);
                for (i = 0; i < ii; ++i) {
                    handle = handles[i];
                    handle.project();
                    handle.draw();
                    handle.transform()
                }
                if (context.selection) {
                    _each(context.selection.state, function(_, handle) {
                        handle && handle.restoreSelected()
                    })
                }
            },
            _updateHandles: function() {
                var handles = this._handles;
                var i;
                var ii = handles.length;
                for (i = 0; i < ii; ++i) {
                    handles[i].refresh()
                }
                if (this._context.settings.label.enabled) {
                    for (i = 0; i < ii; ++i) {
                        handles[i].measureLabel()
                    }
                    for (i = 0; i < ii; ++i) {
                        handles[i].adjustLabel()
                    }
                }
            },
            _transformCore: function() {
                var transform = this._params.projection.getTransform();
                this._context.root.attr(transform);
                this._context.labelRoot && this._context.labelRoot.attr(transform)
            },
            _project: function() {
                var handles = this._handles;
                var i;
                var ii = handles.length;
                for (i = 0; i < ii; ++i) {
                    handles[i].project()
                }
            },
            _transform: function() {
                var handles = this._handles;
                var i;
                var ii = handles.length;
                this._transformCore();
                for (i = 0; i < ii; ++i) {
                    handles[i].transform()
                }
            },
            getProxies: function() {
                return this._handles.map(function(p) {
                    return p.proxy
                })
            },
            getProxy: function(index) {
                return this._handles[index].proxy
            },
            raiseClick: function(i, dxEvent) {
                this._params.eventTrigger("click", {
                    target: this._handles[i].proxy,
                    event: dxEvent
                })
            },
            hoverItem: function(i, state) {
                this._handles[i].setHovered(state)
            },
            selectItem: function(i, state, _noEvent) {
                this._handles[i].setSelected(state, _noEvent)
            },
            clearSelection: function() {
                var selection = this._context.selection;
                if (selection) {
                    _each(selection.state, function(_, handle) {
                        handle && handle.setSelected(false)
                    });
                    selection.state = {}
                }
            }
        }, _data_helper2.default);

        function createProxy(handle, coords, attrs) {
            var proxy = {
                coordinates: function() {
                    return coords
                },
                attribute: function(name, value) {
                    if (arguments.length > 1) {
                        attrs[name] = value;
                        return proxy
                    } else {
                        return arguments.length > 0 ? attrs[name] : attrs
                    }
                },
                selected: function(state, _noEvent) {
                    if (arguments.length > 0) {
                        handle.setSelected(state, _noEvent);
                        return proxy
                    } else {
                        return handle.isSelected()
                    }
                },
                applySettings: function(settings) {
                    handle.update(settings);
                    return proxy
                }
            };
            return proxy
        }
        MapLayerElement = function(context, index, geometry, attributes) {
            var that = this;
            var proxy = that.proxy = createProxy(that, geometry.coordinates, _extend({}, attributes));
            that._ctx = context;
            that._index = index;
            that._fig = that._label = null;
            that._state = STATE_DEFAULT;
            that._coordinates = geometry.coordinates;
            that._settings = {
                label: {}
            };
            proxy.index = index;
            proxy.layer = context.layer;
            that._data = {
                name: context.name,
                index: index
            }
        };
        MapLayerElement.prototype = {
            constructor: MapLayerElement,
            dispose: function() {
                var that = this;
                that._ctx = that.proxy = that._settings = that._fig = that._label = that.data = null;
                return that
            },
            project: function() {
                var context = this._ctx;
                this._projection = context.str.project(context.projection, this._coordinates);
                if (context.hasSeparateLabel && this._label) {
                    this._projectLabel()
                }
            },
            _projectLabel: function() {
                this._labelProjection = this._ctx.str.projectLabel(this._projection)
            },
            draw: function() {
                var that = this;
                var context = this._ctx;
                context.str.draw(context, that._fig = {}, that._data);
                that._fig.root.append(context.root)
            },
            transform: function() {
                var that = this;
                var context = that._ctx;
                context.str.transform(that._fig, context.projection, that._projection);
                if (context.hasSeparateLabel && that._label) {
                    that._transformLabel()
                }
            },
            _transformLabel: function() {
                this._ctx.str.transformLabel(this._label, this._ctx.projection, this._labelProjection)
            },
            refresh: function() {
                var that = this;
                var strategy = that._ctx.str;
                var settings = getItemSettings(that._ctx, that.proxy, that._settings);
                that._styles = strategy.getStyles(settings);
                strategy.refresh(that._ctx, that._fig, that._data, that.proxy, settings);
                that._refreshLabel(settings);
                that._setState()
            },
            _refreshLabel: function(settings) {
                var that = this;
                var context = that._ctx;
                var labelSettings = settings.label;
                var label = that._label;
                if (context.settings.label.enabled) {
                    if (!label) {
                        label = that._label = {
                            root: context.labelRoot || that._fig.root,
                            text: context.renderer.text().attr({
                                "class": "dxm-label"
                            }),
                            size: [0, 0]
                        };
                        if (context.hasSeparateLabel) {
                            that._projectLabel();
                            that._transformLabel()
                        }
                    }
                    label.value = _String(that.proxy.text || that.proxy.attribute(labelSettings.dataField) || "");
                    if (label.value) {
                        label.text.attr({
                            text: label.value,
                            x: 0,
                            y: 0
                        }).css((0, _utils.patchFontOptions)(labelSettings.font)).attr({
                            align: "center",
                            stroke: labelSettings.stroke,
                            "stroke-width": labelSettings["stroke-width"],
                            "stroke-opacity": labelSettings["stroke-opacity"]
                        }).data(context.dataKey, that._data).append(label.root);
                        label.settings = settings
                    }
                } else {
                    if (label) {
                        label.text.remove();
                        that._label = null
                    }
                }
            },
            measureLabel: function() {
                var label = this._label;
                var bBox;
                if (label.value) {
                    bBox = label.text.getBBox();
                    label.size = [bBox.width, bBox.height, -bBox.y - bBox.height / 2]
                }
            },
            adjustLabel: function() {
                var label = this._label;
                var offset;
                if (label.value) {
                    offset = this._ctx.str.getLabelOffset(label, label.settings);
                    label.settings = null;
                    label.text.attr({
                        x: offset[0],
                        y: offset[1] + label.size[2]
                    })
                }
            },
            update: function(settings) {
                var that = this;
                that._settings = combineSettings(that._settings, settings);
                if (that._fig) {
                    that.refresh();
                    if (that._label && that._label.value) {
                        that.measureLabel();
                        that.adjustLabel()
                    }
                }
            },
            _setState: function() {
                this._ctx.str.setState(this._fig, this._styles, STATE_TO_INDEX[this._state])
            },
            _setForeground: function() {
                var root = this._fig.root;
                this._state ? root.toForeground() : root.toBackground()
            },
            setHovered: function(state) {
                var that = this;
                var currentState = hasFlag(that._state, STATE_HOVERED);
                var newState = !!state;
                if (that._ctx.hover && currentState !== newState) {
                    that._state = setFlag(that._state, STATE_HOVERED, newState);
                    that._setState();
                    that._setForeground();
                    raiseChanged(that._ctx, that, newState, "hoverChanged")
                }
                return that
            },
            setSelected: function(state, _noEvent) {
                var that = this;
                var currentState = hasFlag(that._state, STATE_SELECTED);
                var newState = !!state;
                var selection = that._ctx.selection;
                var tmp;
                if (selection && currentState !== newState) {
                    that._state = setFlag(that._state, STATE_SELECTED, newState);
                    tmp = selection.state[selection.single];
                    selection.state[selection.single] = null;
                    if (tmp) {
                        tmp.setSelected(false)
                    }
                    selection.state[selection.single || that._index] = state ? that : null;
                    if (that._fig) {
                        that._setState();
                        that._setForeground();
                        if (!_noEvent) {
                            raiseChanged(that._ctx, that, newState, "selectionChanged")
                        }
                    }
                }
            },
            isSelected: function() {
                return hasFlag(this._state, STATE_SELECTED)
            },
            resetSelected: function() {
                this._state = setFlag(this._state, STATE_SELECTED, false)
            },
            restoreSelected: function() {
                this._fig.root.toForeground()
            }
        };

        function calculatePolygonCentroid(coordinates) {
            var i;
            var length = coordinates.length;
            var v1;
            var v2 = coordinates[length - 1];
            var cross;
            var cx = 0;
            var cy = 0;
            var area = 0;
            var minX = 1 / 0;
            var maxX = -(1 / 0);
            var minY = 1 / 0;
            var maxY = -(1 / 0);
            for (i = 0; i < length; ++i) {
                v1 = v2;
                v2 = coordinates[i];
                cross = v1[0] * v2[1] - v2[0] * v1[1];
                area += cross;
                cx += (v1[0] + v2[0]) * cross;
                cy += (v1[1] + v2[1]) * cross;
                minX = _min(minX, v2[0]);
                maxX = _max(maxX, v2[0]);
                minY = _min(minY, v2[1]);
                maxY = _max(maxY, v2[1])
            }
            return {
                area: _abs(area) / 2,
                center: [2 * cx / 3 / area - (minX + maxX) / 2, 2 * cy / 3 / area - (minY + maxY) / 2]
            }
        }

        function calculateLineStringData(coordinates) {
            var i;
            var ii = coordinates.length;
            var v1;
            var v2 = coordinates[0] || [];
            var totalLength = 0;
            var items = [0];
            var min0 = v2[0];
            var max0 = v2[0];
            var min1 = v2[1];
            var max1 = v2[1];
            for (i = 1; i < ii; ++i) {
                v1 = v2;
                v2 = coordinates[i];
                totalLength += _sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
                items[i] = totalLength;
                min0 = _min(min0, v2[0]);
                max0 = _max(max0, v2[0]);
                min1 = _min(min1, v2[1]);
                max1 = _max(max1, v2[1])
            }
            i = findGroupingIndex(totalLength / 2, items);
            v1 = coordinates[i];
            v2 = coordinates[i + 1];
            var t = (totalLength / 2 - items[i]) / (items[i + 1] - items[i]);
            return ii ? [
                [v1[0] * (1 - t) + v2[0] * t, v1[1] * (1 - t) + v2[1] * t],
                [max0 - min0, max1 - min1], totalLength
            ] : []
        }

        function projectAreaLabel(coordinates) {
            var i;
            var ii = coordinates.length;
            var centroid;
            var resultCentroid;
            var maxArea = 0;
            for (i = 0; i < ii; ++i) {
                centroid = calculatePolygonCentroid(coordinates[i]);
                if (centroid.area > maxArea) {
                    maxArea = centroid.area;
                    resultCentroid = centroid
                }
            }
            return resultCentroid ? [resultCentroid.center, [_sqrt(resultCentroid.area), _sqrt(resultCentroid.area)]] : [
                [],
                []
            ]
        }

        function projectLineLabel(coordinates) {
            var i;
            var ii = coordinates.length;
            var maxLength = 0;
            var data;
            var resultData;
            for (i = 0; i < ii; ++i) {
                data = calculateLineStringData(coordinates[i]);
                if (data[2] > maxLength) {
                    maxLength = data[2];
                    resultData = data
                }
            }
            return resultData || [
                [],
                []
            ]
        }

        function MapLayerCollection(params) {
            var that = this;
            var renderer = params.renderer;
            that._params = params;
            that._layers = [];
            that._layerByName = {};
            that._rect = [0, 0, 0, 0];
            that._clip = renderer.clipRect();
            that._background = renderer.rect().attr({
                "class": "dxm-background"
            }).data(params.dataKey, {
                name: "background"
            }).append(renderer.root);
            that._container = renderer.g().attr({
                "class": "dxm-layers",
                "clip-path": that._clip.id
            }).append(renderer.root).enableLinks();
            that._subscribeToTracker(params.tracker, renderer, params.eventTrigger);
            that._dataReady = params.dataReady
        }
        MapLayerCollection.prototype = {
            constructor: MapLayerCollection,
            dispose: function() {
                var that = this;
                that._clip.dispose();
                that._layers.forEach(function(l) {
                    return l.dispose()
                });
                that._offTracker();
                that._params = that._offTracker = that._layers = that._layerByName = that._clip = that._background = that._container = null
            },
            _subscribeToTracker: function(tracker, renderer, eventTrigger) {
                var that = this;
                that._offTracker = tracker.on({
                    click: function(arg) {
                        var offset = renderer.getRootOffset();
                        var layer = that.byName(arg.data.name);
                        arg.$event.x = arg.x - offset.left;
                        arg.$event.y = arg.y - offset.top;
                        if (layer) {
                            layer.raiseClick(arg.data.index, arg.$event)
                        } else {
                            if ("background" === arg.data.name) {
                                eventTrigger("click", {
                                    event: arg.$event
                                })
                            }
                        }
                    },
                    "hover-on": function(arg) {
                        var layer = that.byName(arg.data.name);
                        if (layer) {
                            layer.hoverItem(arg.data.index, true)
                        }
                    },
                    "hover-off": function(arg) {
                        var layer = that.byName(arg.data.name);
                        if (layer) {
                            layer.hoverItem(arg.data.index, false)
                        }
                    }
                })
            },
            setOptions: function(options) {
                var that = this;
                var optionList = options ? _isArray(options) ? options : [options] : [];
                var layerByName = that._layerByName;
                var layers = that._layers;
                var readyCallbacks = [];
                var needToCreateLayers = optionList.length !== layers.length || layers.some(function(l, i) {
                    var name = getName(optionList, i);
                    return (0, _type.isDefined)(name) && name !== l.proxy.name
                });
                if (needToCreateLayers) {
                    that._params.tracker.reset();
                    that._layers.forEach(function(l) {
                        return l.dispose()
                    });
                    that._layerByName = layerByName = {};
                    that._layers = layers = [];
                    for (var i = 0, ii = optionList.length; i < ii; ++i) {
                        var name = getName(optionList, i) || "map-layer-" + i;
                        var layer = layers[i] = new MapLayer(that._params, that._container, name, i);
                        layerByName[name] = layer
                    }
                }
                layers.forEach(function(l, i) {
                    l.setOptions(optionList[i])
                });
                readyCallbacks = layers.map(function(l) {
                    return l.getDataReadyCallback()
                });
                readyCallbacks.length && _deferred2.default.when.apply(void 0, readyCallbacks).done(that._dataReady)
            },
            _updateClip: function() {
                var rect = this._rect;
                var bw = this._borderWidth;
                this._clip.attr({
                    x: rect[0] + bw,
                    y: rect[1] + bw,
                    width: _max(rect[2] - 2 * bw, 0),
                    height: _max(rect[3] - 2 * bw, 0)
                })
            },
            setBackgroundOptions: function(options) {
                this._background.attr({
                    stroke: options.borderColor,
                    "stroke-width": options.borderWidth,
                    fill: options.color
                });
                this._borderWidth = _max(options.borderWidth, 0);
                this._updateClip()
            },
            setRect: function(rect) {
                this._rect = rect;
                this._background.attr({
                    x: rect[0],
                    y: rect[1],
                    width: rect[2],
                    height: rect[3]
                });
                this._updateClip()
            },
            byIndex: function(index) {
                return this._layers[index]
            },
            byName: function(name) {
                return this._layerByName[name]
            },
            items: function() {
                return this._layers
            }
        };
        exports._TESTS_MapLayer = MapLayer;
        exports._TESTS_stub_MapLayer = function(stub) {
            MapLayer = stub
        };
        exports._TESTS_selectStrategy = selectStrategy;
        exports._TESTS_stub_selectStrategy = function(stub) {
            selectStrategy = stub
        };
        exports._TESTS_MapLayerElement = MapLayerElement;
        exports._TESTS_stub_MapLayerElement = function(stub) {
            MapLayerElement = stub
        };
        exports._TESTS_createProxy = createProxy;
        exports._TESTS_stub_performGrouping = function(stub) {
            performGrouping = stub
        };
        exports._TESTS_performGrouping = performGrouping;
        exports._TESTS_stub_groupByColor = function(stub) {
            groupByColor = stub
        };
        exports._TESTS_groupByColor = groupByColor;
        exports._TESTS_stub_groupBySize = function(stub) {
            groupBySize = stub
        };
        exports._TESTS_groupBySize = groupBySize;
        exports._TESTS_findGroupingIndex = findGroupingIndex
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/vector_map/tooltip_viewer.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var TOOLTIP_OFFSET = 12;

        function TooltipViewer(params) {
            this._subscribeToTracker(params.tracker, params.tooltip, params.layerCollection)
        }
        TooltipViewer.prototype = {
            constructor: TooltipViewer,
            dispose: function() {
                this._offTracker();
                this._offTracker = null
            },
            _subscribeToTracker: function(tracker, tooltip, layerCollection) {
                this._offTracker = tracker.on({
                    "focus-on": function(arg) {
                        var result = false;
                        var layer;
                        var proxy;
                        if (tooltip.isEnabled()) {
                            layer = layerCollection.byName(arg.data.name);
                            proxy = layer && layer.getProxy(arg.data.index);
                            if (proxy && tooltip.show(proxy, {
                                    x: 0,
                                    y: 0,
                                    offset: 0
                                }, {
                                    target: proxy
                                })) {
                                tooltip.move(arg.x, arg.y, TOOLTIP_OFFSET);
                                result = true
                            }
                        }
                        arg.done(result)
                    },
                    "focus-move": function(arg) {
                        tooltip.move(arg.x, arg.y, TOOLTIP_OFFSET)
                    },
                    "focus-off": function() {
                        tooltip.hide()
                    }
                })
            }
        };
        exports.TooltipViewer = TooltipViewer
    },
    /*!***********************************************!*\
      !*** ./artifacts/transpiled/viz/sparkline.js ***!
      \***********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./sparklines/sparkline */ 872)
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/sparklines/sparkline.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var BaseSparkline = __webpack_require__( /*! ./base_sparkline */ 436);
        var dataValidatorModule = __webpack_require__( /*! ../components/data_validator */ 259);
        var seriesModule = __webpack_require__( /*! ../series/base_series */ 261);
        var MIN_BAR_WIDTH = 1;
        var MAX_BAR_WIDTH = 50;
        var DEFAULT_BAR_INTERVAL = 4;
        var DEFAULT_CANVAS_WIDTH = 250;
        var DEFAULT_CANVAS_HEIGHT = 30;
        var DEFAULT_POINT_BORDER = 2;
        var ALLOWED_TYPES = {
            line: true,
            spline: true,
            stepline: true,
            area: true,
            steparea: true,
            splinearea: true,
            bar: true,
            winloss: true
        };
        var _math = Math;
        var _abs = _math.abs;
        var _round = _math.round;
        var _max = _math.max;
        var _min = _math.min;
        var _isFinite = isFinite;
        var vizUtils = __webpack_require__( /*! ../core/utils */ 13);
        var _map = vizUtils.map;
        var _normalizeEnum = vizUtils.normalizeEnum;
        var _isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var _Number = Number;
        var _String = String;

        function findMinMax(data, valField) {
            var firstItem = data[0] || {};
            var firstValue = firstItem[valField] || 0;
            var min = firstValue;
            var max = firstValue;
            var minIndexes = [0];
            var maxIndexes = [0];
            var dataLength = data.length;
            var value;
            var i;
            for (i = 1; i < dataLength; i++) {
                value = data[i][valField];
                if (value < min) {
                    min = value;
                    minIndexes = [i]
                } else {
                    if (value === min) {
                        minIndexes.push(i)
                    }
                }
                if (value > max) {
                    max = value;
                    maxIndexes = [i]
                } else {
                    if (value === max) {
                        maxIndexes.push(i)
                    }
                }
            }
            if (max === min) {
                minIndexes = maxIndexes = []
            }
            return {
                minIndexes: minIndexes,
                maxIndexes: maxIndexes
            }
        }

        function parseNumericDataSource(data, argField, valField, ignoreEmptyPoints) {
            return _map(data, function(dataItem, index) {
                var item = null;
                var isDataNumber;
                var value;
                if (void 0 !== dataItem) {
                    item = {};
                    isDataNumber = _isFinite(dataItem);
                    item[argField] = isDataNumber ? _String(index) : dataItem[argField];
                    value = isDataNumber ? dataItem : dataItem[valField];
                    item[valField] = null === value ? ignoreEmptyPoints ? void 0 : value : _Number(value);
                    item = void 0 !== item[argField] && void 0 !== item[valField] ? item : null
                }
                return item
            })
        }

        function parseWinlossDataSource(data, argField, valField, target) {
            var lowBarValue = -1;
            var zeroBarValue = 0;
            var highBarValue = 1;
            var delta = 1e-4;
            return _map(data, function(dataItem) {
                var item = {};
                item[argField] = dataItem[argField];
                if (_abs(dataItem[valField] - target) < delta) {
                    item[valField] = zeroBarValue
                } else {
                    if (dataItem[valField] > target) {
                        item[valField] = highBarValue
                    } else {
                        item[valField] = lowBarValue
                    }
                }
                return item
            })
        }

        function selectPointColor(color, options, index, pointIndexes) {
            if (index === pointIndexes.first || index === pointIndexes.last) {
                color = options.firstLastColor
            }
            if ((pointIndexes.min || []).indexOf(index) >= 0) {
                color = options.minColor
            }
            if ((pointIndexes.max || []).indexOf(index) >= 0) {
                color = options.maxColor
            }
            return color
        }

        function createLineCustomizeFunction(pointIndexes, options) {
            return function() {
                var color = selectPointColor(void 0, options, this.index, pointIndexes);
                return color ? {
                    visible: true,
                    border: {
                        color: color
                    }
                } : {}
            }
        }

        function createBarCustomizeFunction(pointIndexes, options, winlossData) {
            return function() {
                var index = this.index;
                var isWinloss = "winloss" === options.type;
                var target = isWinloss ? options.winlossThreshold : 0;
                var value = isWinloss ? winlossData[index][options.valueField] : this.value;
                var positiveColor = isWinloss ? options.winColor : options.barPositiveColor;
                var negativeColor = isWinloss ? options.lossColor : options.barNegativeColor;
                return {
                    color: selectPointColor(value >= target ? positiveColor : negativeColor, options, index, pointIndexes)
                }
            }
        }
        var dxSparkline = BaseSparkline.inherit({
            _rootClassPrefix: "dxsl",
            _rootClass: "dxsl-sparkline",
            _themeSection: "sparkline",
            _defaultSize: {
                width: DEFAULT_CANVAS_WIDTH,
                height: DEFAULT_CANVAS_HEIGHT
            },
            _initCore: function() {
                this.callBase();
                this._createSeries()
            },
            _initialChanges: ["DATA_SOURCE"],
            _dataSourceChangedHandler: function() {
                this._requestChange(["UPDATE"])
            },
            _updateWidgetElements: function() {
                this._updateSeries();
                this.callBase()
            },
            _disposeWidgetElements: function() {
                var that = this;
                that._series && that._series.dispose();
                that._series = that._seriesGroup = that._seriesLabelGroup = null
            },
            _cleanWidgetElements: function() {
                this._seriesGroup.remove();
                this._seriesLabelGroup.remove();
                this._seriesGroup.clear();
                this._seriesLabelGroup.clear()
            },
            _drawWidgetElements: function() {
                if (this._dataIsLoaded()) {
                    this._drawSeries();
                    this._drawn()
                }
            },
            _getCorrectCanvas: function() {
                var options = this._allOptions;
                var canvas = this._canvas;
                var halfPointSize = options.pointSize && Math.ceil(options.pointSize / 2) + DEFAULT_POINT_BORDER;
                var type = options.type;
                if ("bar" !== type && "winloss" !== type && (options.showFirstLast || options.showMinMax)) {
                    return {
                        width: canvas.width,
                        height: canvas.height,
                        left: canvas.left + halfPointSize,
                        right: canvas.right + halfPointSize,
                        top: canvas.top + halfPointSize,
                        bottom: canvas.bottom + halfPointSize
                    }
                }
                return canvas
            },
            _prepareOptions: function() {
                var that = this;
                that._allOptions = that.callBase();
                that._allOptions.type = _normalizeEnum(that._allOptions.type);
                if (!ALLOWED_TYPES[that._allOptions.type]) {
                    that._allOptions.type = "line"
                }
            },
            _createHtmlElements: function() {
                this._seriesGroup = this._renderer.g().attr({
                    "class": "dxsl-series"
                });
                this._seriesLabelGroup = this._renderer.g().attr({
                    "class": "dxsl-series-labels"
                })
            },
            _createSeries: function() {
                this._series = new seriesModule.Series({
                    renderer: this._renderer,
                    seriesGroup: this._seriesGroup,
                    labelsGroup: this._seriesLabelGroup,
                    argumentAxis: this._argumentAxis,
                    valueAxis: this._valueAxis
                }, {
                    widgetType: "chart",
                    type: "line"
                })
            },
            getSeriesOptions: function() {
                return this._series.getOptions()
            },
            _updateSeries: function() {
                var that = this;
                var singleSeries = that._series;
                that._prepareDataSource();
                var seriesOptions = that._prepareSeriesOptions();
                singleSeries.updateOptions(seriesOptions);
                var groupsData = {
                    groups: [{
                        series: [singleSeries]
                    }]
                };
                groupsData.argumentOptions = {
                    type: "bar" === seriesOptions.type ? "discrete" : void 0
                };
                that._simpleDataSource = dataValidatorModule.validateData(that._simpleDataSource, groupsData, that._incidentOccurred, {
                    checkTypeForAllData: false,
                    convertToAxisDataType: true,
                    sortingMethod: true
                })[singleSeries.getArgumentField()];
                seriesOptions.customizePoint = that._getCustomizeFunction();
                singleSeries.updateData(that._simpleDataSource);
                singleSeries.createPoints();
                that._groupsDataCategories = groupsData.categories
            },
            _optionChangesMap: {
                dataSource: "DATA_SOURCE"
            },
            _optionChangesOrder: ["DATA_SOURCE"],
            _change_DATA_SOURCE: function() {
                this._updateDataSource()
            },
            _prepareDataSource: function() {
                var that = this;
                var options = that._allOptions;
                var argField = options.argumentField;
                var valField = options.valueField;
                var dataSource = that._dataSourceItems() || [];
                var data = parseNumericDataSource(dataSource, argField, valField, that.option("ignoreEmptyPoints"));
                if ("winloss" === options.type) {
                    that._winlossDataSource = data;
                    that._simpleDataSource = parseWinlossDataSource(data, argField, valField, options.winlossThreshold)
                } else {
                    that._simpleDataSource = data
                }
            },
            _prepareSeriesOptions: function() {
                var that = this;
                var options = that._allOptions;
                var type = "winloss" === options.type ? "bar" : options.type;
                return {
                    visible: true,
                    argumentField: options.argumentField,
                    valueField: options.valueField,
                    color: options.lineColor,
                    width: options.lineWidth,
                    widgetType: "chart",
                    type: type,
                    opacity: type.indexOf("area") !== -1 ? that._allOptions.areaOpacity : void 0,
                    point: {
                        size: options.pointSize,
                        symbol: options.pointSymbol,
                        border: {
                            visible: true,
                            width: DEFAULT_POINT_BORDER
                        },
                        color: options.pointColor,
                        visible: false,
                        hoverStyle: {
                            border: {}
                        },
                        selectionStyle: {
                            border: {}
                        }
                    },
                    border: {
                        color: options.lineColor,
                        width: options.lineWidth,
                        visible: "bar" !== type
                    }
                }
            },
            _getCustomizeFunction: function() {
                var that = this;
                var options = that._allOptions;
                var dataSource = that._winlossDataSource || that._simpleDataSource;
                var drawnPointIndexes = that._getExtremumPointsIndexes(dataSource);
                var customizeFunction;
                if ("winloss" === options.type || "bar" === options.type) {
                    customizeFunction = createBarCustomizeFunction(drawnPointIndexes, options, that._winlossDataSource)
                } else {
                    customizeFunction = createLineCustomizeFunction(drawnPointIndexes, options)
                }
                return customizeFunction
            },
            _getExtremumPointsIndexes: function(data) {
                var that = this;
                var options = that._allOptions;
                var lastIndex = data.length - 1;
                var indexes = {};
                that._minMaxIndexes = findMinMax(data, options.valueField);
                if (options.showFirstLast) {
                    indexes.first = 0;
                    indexes.last = lastIndex
                }
                if (options.showMinMax) {
                    indexes.min = that._minMaxIndexes.minIndexes;
                    indexes.max = that._minMaxIndexes.maxIndexes
                }
                return indexes
            },
            _getStick: function() {
                return {
                    stick: "bar" !== this._series.type
                }
            },
            _updateRange: function() {
                var that = this;
                var series = that._series;
                var type = series.type;
                var isBarType = "bar" === type;
                var isWinlossType = "winloss" === type;
                var DEFAULT_VALUE_RANGE_MARGIN = .15;
                var DEFAULT_ARGUMENT_RANGE_MARGIN = .1;
                var WINLOSS_MAX_RANGE = 1;
                var WINLOSS_MIN_RANGE = -1;
                var rangeData = series.getRangeData();
                var minValue = that._allOptions.minValue;
                var hasMinY = _isDefined(minValue) && _isFinite(minValue);
                var maxValue = that._allOptions.maxValue;
                var hasMaxY = _isDefined(maxValue) && _isFinite(maxValue);
                var argCoef;
                var valCoef = (rangeData.val.max - rangeData.val.min) * DEFAULT_VALUE_RANGE_MARGIN;
                if (isBarType || isWinlossType || "area" === type) {
                    if (0 !== rangeData.val.min) {
                        rangeData.val.min -= valCoef
                    }
                    if (0 !== rangeData.val.max) {
                        rangeData.val.max += valCoef
                    }
                } else {
                    rangeData.val.min -= valCoef;
                    rangeData.val.max += valCoef
                }
                if (hasMinY || hasMaxY) {
                    if (hasMinY && hasMaxY) {
                        rangeData.val.minVisible = _min(minValue, maxValue);
                        rangeData.val.maxVisible = _max(minValue, maxValue)
                    } else {
                        rangeData.val.minVisible = hasMinY ? _Number(minValue) : void 0;
                        rangeData.val.maxVisible = hasMaxY ? _Number(maxValue) : void 0
                    }
                    if (isWinlossType) {
                        rangeData.val.minVisible = hasMinY ? _max(rangeData.val.minVisible, WINLOSS_MIN_RANGE) : void 0;
                        rangeData.val.maxVisible = hasMaxY ? _min(rangeData.val.maxVisible, WINLOSS_MAX_RANGE) : void 0
                    }
                }
                if (series.getPoints().length > 1) {
                    if (isBarType) {
                        argCoef = (rangeData.arg.max - rangeData.arg.min) * DEFAULT_ARGUMENT_RANGE_MARGIN;
                        rangeData.arg.min = rangeData.arg.min - argCoef;
                        rangeData.arg.max = rangeData.arg.max + argCoef
                    }
                }
                rangeData.arg.categories = that._groupsDataCategories;
                that._ranges = rangeData
            },
            _getBarWidth: function(pointsCount) {
                var that = this;
                var canvas = that._canvas;
                var intervalWidth = pointsCount * DEFAULT_BAR_INTERVAL;
                var rangeWidth = canvas.width - canvas.left - canvas.right - intervalWidth;
                var width = _round(rangeWidth / pointsCount);
                if (width < MIN_BAR_WIDTH) {
                    width = MIN_BAR_WIDTH
                }
                if (width > MAX_BAR_WIDTH) {
                    width = MAX_BAR_WIDTH
                }
                return width
            },
            _correctPoints: function() {
                var that = this;
                var seriesType = that._allOptions.type;
                var seriesPoints = that._series.getPoints();
                var pointsLength = seriesPoints.length;
                var barWidth;
                var i;
                if ("bar" === seriesType || "winloss" === seriesType) {
                    barWidth = that._getBarWidth(pointsLength);
                    for (i = 0; i < pointsLength; i++) {
                        seriesPoints[i].correctCoordinates({
                            width: barWidth,
                            offset: 0
                        })
                    }
                }
            },
            _drawSeries: function() {
                var that = this;
                if (that._simpleDataSource.length > 0) {
                    that._correctPoints();
                    that._series.draw();
                    that._seriesGroup.append(that._renderer.root)
                }
            },
            _isTooltipEnabled: function() {
                return !!this._simpleDataSource.length
            },
            _getTooltipData: function() {
                var that = this;
                var options = that._allOptions;
                var dataSource = that._winlossDataSource || that._simpleDataSource;
                var tooltip = that._tooltip;
                if (0 === dataSource.length) {
                    return {}
                }
                var minMax = that._minMaxIndexes;
                var valueField = options.valueField;
                var first = dataSource[0][valueField];
                var last = dataSource[dataSource.length - 1][valueField];
                var min = _isDefined(minMax.minIndexes[0]) ? dataSource[minMax.minIndexes[0]][valueField] : first;
                var max = _isDefined(minMax.maxIndexes[0]) ? dataSource[minMax.maxIndexes[0]][valueField] : first;
                var formattedFirst = tooltip.formatValue(first);
                var formattedLast = tooltip.formatValue(last);
                var formattedMin = tooltip.formatValue(min);
                var formattedMax = tooltip.formatValue(max);
                var customizeObject = {
                    firstValue: formattedFirst,
                    lastValue: formattedLast,
                    minValue: formattedMin,
                    maxValue: formattedMax,
                    originalFirstValue: first,
                    originalLastValue: last,
                    originalMinValue: min,
                    originalMaxValue: max,
                    valueText: ["Start:", formattedFirst, "End:", formattedLast, "Min:", formattedMin, "Max:", formattedMax]
                };
                if ("winloss" === options.type) {
                    customizeObject.originalThresholdValue = options.winlossThreshold;
                    customizeObject.thresholdValue = tooltip.formatValue(options.winlossThreshold)
                }
                return customizeObject
            }
        });
        _map(["lineColor", "lineWidth", "areaOpacity", "minColor", "maxColor", "barPositiveColor", "barNegativeColor", "winColor", "lessColor", "firstLastColor", "pointSymbol", "pointColor", "pointSize", "type", "argumentField", "valueField", "winlossThreshold", "showFirstLast", "showMinMax", "ignoreEmptyPoints", "minValue", "maxValue"], function(name) {
            dxSparkline.prototype._optionChangesMap[name] = "OPTIONS"
        });
        __webpack_require__( /*! ../../core/component_registrator */ 9)("dxSparkline", dxSparkline);
        module.exports = dxSparkline;
        dxSparkline.addPlugin(__webpack_require__( /*! ../core/data_source */ 152).plugin)
    },
    /*!********************************************!*\
      !*** ./artifacts/transpiled/viz/bullet.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./sparklines/bullet */ 874)
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/sparklines/bullet.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var each = __webpack_require__( /*! ../../core/utils/iterator */ 4).each;
        var BaseSparkline = __webpack_require__( /*! ./base_sparkline */ 436);
        var TARGET_MIN_Y = .02;
        var TARGET_MAX_Y = .98;
        var BAR_VALUE_MIN_Y = .1;
        var BAR_VALUE_MAX_Y = .9;
        var DEFAULT_CANVAS_WIDTH = 300;
        var DEFAULT_CANVAS_HEIGHT = 30;
        var DEFAULT_HORIZONTAL_MARGIN = 1;
        var DEFAULT_VERTICAL_MARGIN = 2;
        var _Number = Number;
        var _isFinite = isFinite;
        var dxBullet = BaseSparkline.inherit({
            _rootClassPrefix: "dxb",
            _rootClass: "dxb-bullet",
            _themeSection: "bullet",
            _defaultSize: {
                width: DEFAULT_CANVAS_WIDTH,
                height: DEFAULT_CANVAS_HEIGHT,
                left: DEFAULT_HORIZONTAL_MARGIN,
                right: DEFAULT_HORIZONTAL_MARGIN,
                top: DEFAULT_VERTICAL_MARGIN,
                bottom: DEFAULT_VERTICAL_MARGIN
            },
            _disposeWidgetElements: function() {
                delete this._zeroLevelPath;
                delete this._targetPath;
                delete this._barValuePath
            },
            _cleanWidgetElements: function() {
                this._zeroLevelPath.remove();
                this._targetPath.remove();
                this._barValuePath.remove()
            },
            _drawWidgetElements: function() {
                this._drawBullet();
                this._drawn()
            },
            _createHtmlElements: function() {
                var renderer = this._renderer;
                this._zeroLevelPath = renderer.path(void 0, "line").attr({
                    "class": "dxb-zero-level",
                    "stroke-linecap": "square"
                });
                this._targetPath = renderer.path(void 0, "line").attr({
                    "class": "dxb-target",
                    "stroke-linecap": "square"
                });
                this._barValuePath = renderer.path(void 0, "line").attr({
                    "class": "dxb-bar-value",
                    "stroke-linecap": "square"
                })
            },
            _prepareOptions: function() {
                var that = this;
                var options;
                var startScaleValue;
                var endScaleValue;
                var level;
                var value;
                var target;
                that._allOptions = options = that.callBase();
                var isValueUndefined = void 0 === that._allOptions.value;
                var isTargetUndefined = void 0 === that._allOptions.target;
                that._tooltipEnabled = !(isValueUndefined && isTargetUndefined);
                if (isValueUndefined) {
                    that._allOptions.value = 0
                }
                if (isTargetUndefined) {
                    that._allOptions.target = 0
                }
                options.value = value = _Number(options.value);
                options.target = target = _Number(options.target);
                if (void 0 === that._allOptions.startScaleValue) {
                    that._allOptions.startScaleValue = target < value ? target : value;
                    that._allOptions.startScaleValue = that._allOptions.startScaleValue < 0 ? that._allOptions.startScaleValue : 0
                }
                if (void 0 === that._allOptions.endScaleValue) {
                    that._allOptions.endScaleValue = target > value ? target : value
                }
                options.startScaleValue = startScaleValue = _Number(options.startScaleValue);
                options.endScaleValue = endScaleValue = _Number(options.endScaleValue);
                if (endScaleValue < startScaleValue) {
                    level = endScaleValue;
                    that._allOptions.endScaleValue = startScaleValue;
                    that._allOptions.startScaleValue = level;
                    that._allOptions.inverted = true
                }
            },
            _updateRange: function() {
                var that = this;
                var options = that._allOptions;
                that._ranges = {
                    arg: {
                        invert: options.rtlEnabled ? !options.inverted : options.inverted,
                        min: options.startScaleValue,
                        max: options.endScaleValue,
                        axisType: "continuous",
                        dataType: "numeric"
                    },
                    val: {
                        min: 0,
                        max: 1,
                        axisType: "continuous",
                        dataType: "numeric"
                    }
                }
            },
            _drawBullet: function() {
                var that = this;
                var options = that._allOptions;
                var isValidBounds = options.startScaleValue !== options.endScaleValue;
                var isValidMin = _isFinite(options.startScaleValue);
                var isValidMax = _isFinite(options.endScaleValue);
                var isValidValue = _isFinite(options.value);
                var isValidTarget = _isFinite(options.target);
                if (isValidBounds && isValidMax && isValidMin && isValidTarget && isValidValue) {
                    this._drawBarValue();
                    this._drawTarget();
                    this._drawZeroLevel()
                }
            },
            _getTargetParams: function() {
                var that = this;
                var options = that._allOptions;
                var translatorY = that._valueAxis.getTranslator();
                var x = that._argumentAxis.getTranslator().translate(options.target);
                return {
                    points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
                    stroke: options.targetColor,
                    "stroke-width": options.targetWidth
                }
            },
            _getBarValueParams: function() {
                var that = this;
                var options = that._allOptions;
                var translatorX = that._argumentAxis.getTranslator();
                var translatorY = that._valueAxis.getTranslator();
                var startLevel = options.startScaleValue;
                var endLevel = options.endScaleValue;
                var value = options.value;
                var y2 = translatorY.translate(BAR_VALUE_MIN_Y);
                var y1 = translatorY.translate(BAR_VALUE_MAX_Y);
                var x1;
                var x2;
                if (value > 0) {
                    x1 = startLevel <= 0 ? 0 : startLevel;
                    x2 = value >= endLevel ? endLevel : value < x1 ? x1 : value
                } else {
                    x1 = endLevel >= 0 ? 0 : endLevel;
                    x2 = value < startLevel ? startLevel : value > x1 ? x1 : value
                }
                x1 = translatorX.translate(x1);
                x2 = translatorX.translate(x2);
                return {
                    points: [x1, y1, x2, y1, x2, y2, x1, y2],
                    fill: options.color
                }
            },
            _getCorrectCanvas: function() {
                return this._canvas
            },
            _getZeroLevelParams: function() {
                var that = this;
                var translatorY = that._valueAxis.getTranslator();
                var x = that._argumentAxis.getTranslator().translate(0);
                return {
                    points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
                    stroke: that._allOptions.targetColor,
                    "stroke-width": 1
                }
            },
            _drawZeroLevel: function() {
                var that = this;
                var options = that._allOptions;
                if (0 > options.endScaleValue || 0 < options.startScaleValue || !options.showZeroLevel) {
                    return
                }
                that._zeroLevelPath.attr(that._getZeroLevelParams()).sharp().append(that._renderer.root)
            },
            _drawTarget: function() {
                var that = this;
                var options = that._allOptions;
                var target = options.target;
                if (target > options.endScaleValue || target < options.startScaleValue || !options.showTarget) {
                    return
                }
                that._targetPath.attr(that._getTargetParams()).sharp().append(that._renderer.root)
            },
            _drawBarValue: function() {
                this._barValuePath.attr(this._getBarValueParams()).append(this._renderer.root)
            },
            _getTooltipCoords: function() {
                var canvas = this._canvas;
                var rootOffset = this._renderer.getRootOffset();
                var bBox = this._barValuePath.getBBox();
                return {
                    x: bBox.x + bBox.width / 2 + rootOffset.left,
                    y: canvas.height / 2 + rootOffset.top
                }
            },
            _getTooltipData: function() {
                var that = this;
                var tooltip = that._tooltip;
                var options = that._allOptions;
                var value = options.value;
                var target = options.target;
                var valueText = tooltip.formatValue(value);
                var targetText = tooltip.formatValue(target);
                return {
                    originalValue: value,
                    originalTarget: target,
                    value: valueText,
                    target: targetText,
                    valueText: ["Actual Value:", valueText, "Target Value:", targetText]
                }
            },
            _isTooltipEnabled: function() {
                return this._tooltipEnabled
            }
        });
        each(["color", "targetColor", "targetWidth", "showTarget", "showZeroLevel", "value", "target", "startScaleValue", "endScaleValue"], function(_, name) {
            dxBullet.prototype._optionChangesMap[name] = "OPTIONS"
        });
        __webpack_require__( /*! ../../core/component_registrator */ 9)("dxBullet", dxBullet);
        module.exports = dxBullet
    },
    /*!**********************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map.js ***!
      \**********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! ./tree_map/tree_map */ 876)
    },
    /*!*******************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tree_map.js ***!
      \*******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dxTreeMap = module.exports = __webpack_require__( /*! ./tree_map.base */ 73);
        __webpack_require__( /*! ./tiling.squarified */ 437);
        __webpack_require__( /*! ./tiling.strip */ 877);
        __webpack_require__( /*! ./tiling.slice_and_dice */ 878);
        __webpack_require__( /*! ./tiling.rotated_slice_and_dice */ 879);
        __webpack_require__( /*! ./colorizing.discrete */ 439);
        __webpack_require__( /*! ./colorizing.gradient */ 880);
        __webpack_require__( /*! ./colorizing.range */ 881);
        __webpack_require__( /*! ./api */ 154);
        __webpack_require__( /*! ./hover */ 440);
        __webpack_require__( /*! ./selection */ 882);
        __webpack_require__( /*! ./tooltip */ 442);
        __webpack_require__( /*! ./tracker */ 883);
        __webpack_require__( /*! ./drilldown */ 884);
        __webpack_require__( /*! ./plain_data_source */ 885);
        dxTreeMap.addPlugin(__webpack_require__( /*! ../core/export */ 99).plugin);
        dxTreeMap.addPlugin(__webpack_require__( /*! ../core/title */ 109).plugin);
        dxTreeMap.addPlugin(__webpack_require__( /*! ../core/loading_indicator */ 127).plugin)
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tiling.strip.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _squarify = __webpack_require__( /*! ./tiling.squarified.base */ 438);

        function accumulate(total, current, count) {
            return ((count - 1) * total + current) / count
        }

        function strip(data) {
            return _squarify(data, accumulate, true)
        }
        __webpack_require__( /*! ./tiling */ 128).addAlgorithm("strip", strip);
        module.exports = strip
    },
    /*!********************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tiling.slice_and_dice.js ***!
      \********************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var tiling = __webpack_require__( /*! ./tiling */ 128);

        function sliceAndDice(data) {
            var items = data.items;
            var sidesData = tiling.buildSidesData(data.rect, data.directions, data.isRotated ? 1 : 0);
            tiling.calculateRectangles(items, 0, data.rect, sidesData, {
                sum: data.sum,
                count: items.length,
                side: sidesData.variedSide
            })
        }
        tiling.addAlgorithm("sliceanddice", sliceAndDice);
        module.exports = sliceAndDice
    },
    /*!****************************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tiling.rotated_slice_and_dice.js ***!
      \****************************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var tiling = __webpack_require__( /*! ./tiling */ 128);
        var sliceAndDiceAlgorithm = tiling.getAlgorithm("sliceanddice");

        function rotatedSliceAndDice(data) {
            data.isRotated = !data.isRotated;
            return sliceAndDiceAlgorithm.call(this, data)
        }
        tiling.addAlgorithm("rotatedsliceanddice", rotatedSliceAndDice)
    },
    /*!******************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/colorizing.gradient.js ***!
      \******************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _createColorCodeGetter = __webpack_require__( /*! ./colorizing */ 129).createColorCodeGetter;
        var _min = Math.min;
        var _max = Math.max;

        function createSimpleColorizer(getColor, range) {
            return function(node) {
                return getColor(node, range)
            }
        }

        function getRangeData(range) {
            return [Number(range[0]) || 0, range[1] - range[0] || 1]
        }

        function calculateRange(nodes, getValue) {
            var i;
            var ii = nodes.length;
            var codes = [];
            var code;
            for (i = 0; i < ii; ++i) {
                code = getValue(nodes[i]);
                if (isFinite(code)) {
                    codes.push(code)
                }
            }
            return getRangeData([_min.apply(null, codes), _max.apply(null, codes)])
        }

        function createGuessingColorizer(getColor, getValue) {
            var ranges = {};
            return function(node) {
                var parent = node.parent;
                return getColor(node, ranges[parent._id] || (ranges[parent._id] = calculateRange(parent.nodes, getValue)))
            }
        }

        function gradientColorizer(options, themeManager) {
            var palette = themeManager.createGradientPalette(options.palette);
            var getValue = _createColorCodeGetter(options);
            return "range" in options ? createSimpleColorizer(getColor, getRangeData(options.range || [])) : createGuessingColorizer(getColor, getValue);

            function getColor(node, arg) {
                return palette.getColor((getValue(node) - arg[0]) / arg[1])
            }
        }
        __webpack_require__( /*! ./colorizing */ 129).addColorizer("gradient", gradientColorizer);
        module.exports = gradientColorizer
    },
    /*!***************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/colorizing.range.js ***!
      \***************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _createColorCodeGetter = __webpack_require__( /*! ./colorizing */ 129).createColorCodeGetter;

        function getPaletteIndex(value, items) {
            var start = 0;
            var end = items.length - 1;
            var index = -1;
            var middle;
            if (items[start] <= value && value <= items[end]) {
                if (value === items[end]) {
                    index = end - 1
                } else {
                    while (end - start > 1) {
                        middle = start + end >> 1;
                        if (value < items[middle]) {
                            end = middle
                        } else {
                            start = middle
                        }
                    }
                    index = start
                }
            }
            return index
        }

        function rangeColorizer(options, themeManager) {
            var range = options.range || [];
            var palette = themeManager.createDiscretePalette(options.palette, range.length - 1);
            var getValue = _createColorCodeGetter(options);
            return function(node) {
                return palette.getColor(getPaletteIndex(getValue(node), range))
            }
        }
        __webpack_require__( /*! ./colorizing */ 129).addColorizer("range", rangeColorizer);
        module.exports = rangeColorizer
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/selection.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./tree_map.base */ 73).prototype;
        var nodeProto = __webpack_require__( /*! ./node */ 175).prototype;
        var expand = __webpack_require__( /*! ../core/helpers */ 150).expand;
        var common = __webpack_require__( /*! ./common */ 266);
        var _buildRectAppearance = common.buildRectAppearance;
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var _inArray = __webpack_require__( /*! ../../core/utils/array */ 14).inArray;
        var MODE_NONE = 0;
        var MODE_SINGLE = 1;
        var MODE_MULTIPLE = 2;
        var STATE_CODE = 2;
        __webpack_require__( /*! ./api */ 154);
        __webpack_require__( /*! ./states */ 441);
        proto._eventsMap.onSelectionChanged = {
            name: "selectionChanged"
        };
        expand(proto._handlers, "calculateAdditionalStates", function(states, options) {
            states[2] = options.selectionStyle ? _buildRectAppearance(options.selectionStyle) : {}
        });
        nodeProto.statesMap[2] = nodeProto.statesMap[3] = STATE_CODE;
        nodeProto.additionalStates.push(2);
        expand(proto, "_onNodesCreated", function() {
            this._selectionList.length = 0
        });
        expand(proto, "_extendProxyType", function(proto) {
            var that = this;
            proto.select = function(state) {
                that._selectNode(this._id, !!state)
            };
            proto.isSelected = function() {
                return _inArray(this._id, that._selectionList) >= 0
            };
            that._selectionList = []
        });
        __webpack_require__( /*! ./tree_map.base */ 73).addChange({
            code: "SELECTION_MODE",
            handler: function() {
                var that = this;
                var option = _normalizeEnum(that._getOption("selectionMode", true));
                var selectionList = that._selectionList;
                var tmp;
                var mode = "none" === option ? MODE_NONE : "multiple" === option ? MODE_MULTIPLE : MODE_SINGLE;
                if (mode === MODE_SINGLE && selectionList.length > 1) {
                    tmp = selectionList.pop();
                    that.clearSelection();
                    selectionList.push(tmp)
                } else {
                    if (mode === MODE_NONE) {
                        that.clearSelection()
                    }
                }
                that._selectionMode = mode
            },
            isThemeDependent: true,
            isOptionChange: true,
            option: "selectionMode"
        });
        expand(proto, "_applyTilesAppearance", function() {
            if (this._selectionList.length) {
                bringSelectedTilesToForeground(this._nodes, this._selectionList)
            }
        });
        var tileToFront = [leafToFront, groupToFront];

        function bringSelectedTilesToForeground(nodes, selectionList) {
            var i;
            var ii = selectionList.length;
            var node;
            for (i = 0; i < ii; ++i) {
                node = nodes[selectionList[i]];
                tileToFront[Number(node.isNode())](node.tile)
            }
        }

        function leafToFront(content) {
            content.toForeground()
        }

        function groupToFront(content) {
            content.outer.toForeground();
            content.inner.toForeground()
        }
        proto._applySelectionState = function(index, state) {
            var node = this._nodes[index];
            node.setState(STATE_CODE, state);
            this._eventTrigger("selectionChanged", {
                node: node.proxy
            })
        };
        proto._selectNode = function(index, state) {
            var that = this;
            var selectionList;
            var k;
            var tmp;
            if (that._selectionMode !== MODE_NONE) {
                that._context.suspend();
                selectionList = that._selectionList;
                k = _inArray(index, selectionList);
                if (state && k === -1) {
                    if (that._selectionMode === MODE_SINGLE) {
                        if (selectionList.length) {
                            tmp = selectionList.pop();
                            that._applySelectionState(tmp, false)
                        }
                    }
                    selectionList.push(index);
                    that._applySelectionState(index, true)
                } else {
                    if (!state && k >= 0) {
                        selectionList.splice(k, 1);
                        that._applySelectionState(index, false)
                    }
                }
                that._context.resume()
            }
        };
        proto.clearSelection = function() {
            var that = this;
            var selectionList = that._selectionList;
            var i;
            var ii = selectionList.length;
            if (that._selectionMode !== MODE_NONE) {
                that._context.suspend();
                for (i = 0; i < ii; ++i) {
                    that._applySelectionState(selectionList[i], false)
                }
                selectionList.length = 0;
                that._context.resume()
            }
        }
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/tracker.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./tree_map.base */ 73).prototype;
        var Tracker = __webpack_require__( /*! ../components/tracker */ 267).Tracker;
        var expand = __webpack_require__( /*! ../core/helpers */ 150).expand;
        var _parseScalar = __webpack_require__( /*! ../core/utils */ 13).parseScalar;
        var DATA_KEY_BASE = "__treemap_data_";
        var dataKeyModifier = 0;
        __webpack_require__( /*! ./api */ 154);
        __webpack_require__( /*! ./hover */ 440);
        __webpack_require__( /*! ./tooltip */ 442);
        proto._eventsMap.onClick = {
            name: "click"
        };
        expand(proto, "_initCore", function() {
            var that = this;
            var dataKey = DATA_KEY_BASE + dataKeyModifier++;
            var getProxy = function(index) {
                return that._nodes[index].proxy
            };
            that._tracker = new Tracker({
                widget: that,
                root: that._renderer.root,
                getNode: function(id) {
                    var proxy = getProxy(id);
                    var interactWithGroup = _parseScalar(that._getOption("interactWithGroup", true));
                    return interactWithGroup && proxy.isLeaf() && proxy.getParent().isActive() ? proxy.getParent() : proxy
                },
                getData: function(e) {
                    var target = e.target;
                    return ("tspan" === target.tagName ? target.parentNode : target)[dataKey]
                },
                getProxy: getProxy,
                click: function(e) {
                    that._eventTrigger("click", e)
                }
            });
            that._handlers.setTrackerData = function(node, element) {
                element.data(dataKey, node._id)
            };
            exports._TESTS_dataKey = dataKey
        });
        expand(proto, "_disposeCore", function() {
            this._tracker.dispose()
        })
    },
    /*!********************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/drilldown.js ***!
      \********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./tree_map.base */ 73).prototype;
        var _expand = __webpack_require__( /*! ../core/helpers */ 150).expand;
        __webpack_require__( /*! ./api */ 154);
        proto._eventsMap.onDrill = {
            name: "drill"
        };
        _expand(proto, "_extendProxyType", function(proto) {
            var that = this;
            proto.drillDown = function() {
                that._drillToNode(this._id)
            }
        });
        _expand(proto, "_onNodesCreated", function() {
            this._drilldownIndex = -1
        });
        proto._drillToNode = function(index) {
            var that = this;
            var node;
            if (that._drilldownIndex !== index) {
                node = that._nodes[index] || that._root;
                if (node.nodes) {
                    that._drilldownIndex = index;
                    that._topNode = node;
                    that._context.suspend();
                    that._context.change(["MAX_DEPTH", "NODES_RESET"]);
                    that._context.resume();
                    that._eventTrigger("drill", {
                        node: node.proxy
                    })
                }
            }
        };
        proto.resetDrillDown = function() {
            this._drillToNode(-1);
            return this
        };
        proto.drillUp = function() {
            this._drillToNode(this._topNode.parent._id || -1);
            return this
        };
        proto.getCurrentNode = function() {
            return this._topNode.proxy
        }
    },
    /*!****************************************************************!*\
      !*** ./artifacts/transpiled/viz/tree_map/plain_data_source.js ***!
      \****************************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./tree_map.base */ 73).prototype;
        proto._optionChangesMap.idField = proto._optionChangesMap.parentField = "NODES_CREATE";
        proto._processDataSourceItems = function(items) {
            var i;
            var struct = {};
            var currentItem;
            var idField = this._getOption("idField", true);
            var parentField = this._getOption("parentField", true);
            var parentId;
            var rootNodes = [];
            var tmpItems;
            var item;
            if (!idField || !parentField || 0 === items.length) {
                return {
                    items: items,
                    isPlain: true
                }
            }
            for (i = 0; i < items.length; i++) {
                currentItem = items[i];
                parentId = currentItem[parentField];
                if (parentId) {
                    struct[parentId] = struct[parentId] || {
                        items: []
                    };
                    tmpItems = struct[parentId].items
                } else {
                    tmpItems = rootNodes
                }
                tmpItems.push(currentItem)
            }
            treeFiller({
                struct: struct,
                idField: idField
            }, rootNodes);
            for (item in struct) {
                struct[item] && rootNodes.push(struct[item])
            }
            return {
                items: rootNodes,
                isPlain: true
            }
        };

        function treeFiller(context, items) {
            var currentItem;
            var i;
            var struct = context.struct;
            var id;
            for (i = 0; i < items.length; i++) {
                currentItem = items[i];
                id = currentItem[context.idField];
                if (struct[id]) {
                    currentItem.items = struct[id].items;
                    struct[id] = null;
                    treeFiller(context, currentItem.items)
                }
            }
        }
    },
    /*!********************************************!*\
      !*** ./artifacts/transpiled/viz/funnel.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dxFunnel = __webpack_require__( /*! ./funnel/funnel */ 443);
        dxFunnel.addPlugin(__webpack_require__( /*! ./funnel/label */ 891).plugin);
        dxFunnel.addPlugin(__webpack_require__( /*! ./core/export */ 99).plugin);
        dxFunnel.addPlugin(__webpack_require__( /*! ./core/title */ 109).plugin);
        dxFunnel.addPlugin(__webpack_require__( /*! ./components/legend */ 207).plugin);
        dxFunnel.addPlugin(__webpack_require__( /*! ./funnel/tracker */ 892).plugin);
        dxFunnel.addPlugin(__webpack_require__( /*! ./funnel/tooltip */ 893).plugin);
        dxFunnel.addPlugin(__webpack_require__( /*! ./core/loading_indicator */ 127).plugin);
        module.exports = dxFunnel
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/viz/funnel/tiling.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _normalizeEnum = __webpack_require__( /*! ../core/utils */ 13).normalizeEnum;
        var algorithms = {};
        var defaultAlgorithm;
        exports.getAlgorithm = function(name) {
            return algorithms[_normalizeEnum(name)] || defaultAlgorithm
        };
        exports.addAlgorithm = function(name, callback, setDefault) {
            algorithms[name] = callback;
            if (setDefault) {
                defaultAlgorithm = algorithms[name]
            }
        }
    },
    /*!**********************************************************!*\
      !*** ./artifacts/transpiled/viz/funnel/tiling.funnel.js ***!
      \**********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var CENTER = .5;
        module.exports = {
            getFigures: function(data) {
                var height = 1 / data.length;
                return data.map(function(value, index, array) {
                    var nextValue = array[index + 1] ? array[index + 1] : array[index];
                    return [CENTER - value / 2, height * index, CENTER + value / 2, height * index, CENTER + nextValue / 2, height * (index + 1), CENTER - nextValue / 2, height * (index + 1)]
                })
            },
            normalizeValues: function(items) {
                var max = items.reduce(function(max, item) {
                    return Math.max(item.value, max)
                }, items[0] && items[0].value || 0);
                return items.map(function(item) {
                    return item.value / max
                })
            }
        }
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/funnel/tiling.pyramid.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var CENTER = .5;
        var LEFTCORNER = 0;
        var RIGHTCORNER = 1;
        module.exports = {
            getFigures: function(data, neckWidth, neckHeight) {
                var height = 0;
                var y = 0;
                var x = 0;
                var offsetX = 0;
                var halfNeckWidth = neckWidth / 2;
                var offsetFromCorner = CENTER - halfNeckWidth;
                var funnelHeight = 1 - neckHeight;
                var neckLeftCorner = CENTER - halfNeckWidth;
                var neckRightCorner = CENTER + halfNeckWidth;
                return data.map(function(value) {
                    x = offsetX;
                    y = height;
                    height += value;
                    offsetX = offsetFromCorner * height / funnelHeight;
                    if (y <= funnelHeight && height <= funnelHeight) {
                        return [x, y, RIGHTCORNER - x, y, RIGHTCORNER - offsetX, height, LEFTCORNER + offsetX, height]
                    } else {
                        if (y <= funnelHeight && height > funnelHeight) {
                            return [x, y, RIGHTCORNER - x, y, neckRightCorner, funnelHeight, neckRightCorner, height, neckLeftCorner, height, neckLeftCorner, funnelHeight]
                        } else {
                            return [neckLeftCorner, y, neckRightCorner, y, neckRightCorner, height, neckLeftCorner, height]
                        }
                    }
                })
            },
            normalizeValues: function(items) {
                var sum = items.reduce(function(sum, item) {
                    return sum + item.value
                }, 0);
                return items.map(function(item) {
                    return item.value / sum
                })
            }
        }
    },
    /*!*************************************************!*\
      !*** ./artifacts/transpiled/viz/funnel/item.js ***!
      \*************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var states = ["normal", "hover", "selection", "selection"];
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;

        function parseStyles(color, style, baseStyle) {
            var border = style.border;
            var baseBorder = baseStyle.border;
            var borderVisible = isDefined(border.visible) ? border.visible : baseBorder.visible;
            var borderWidth = isDefined(border.width) ? border.width : baseBorder.width;
            return {
                fill: color,
                hatching: style.hatching,
                stroke: border.color || baseBorder.color,
                "stroke-width": borderVisible ? borderWidth : 0
            }
        }

        function Item(widget, options) {
            var that = this;
            var data = options.data;
            that.code = 0;
            that.widget = widget;
            that.figure = options.figure;
            that.argument = data.argument;
            that.value = data.value;
            that.data = data.dataItem;
            that.percent = options.percent;
            that.id = options.id;
            that.color = options.color;
            that.states = {
                normal: parseStyles(options.color, options.itemOptions, options.itemOptions),
                hover: parseStyles(options.color, options.itemOptions.hoverStyle, options.itemOptions),
                selection: parseStyles(options.color, options.itemOptions.selectionStyle, options.itemOptions)
            }
        }
        Item.prototype = {
            getState: function() {
                return states[this.code]
            },
            getNormalStyle: function() {
                return this.states.normal
            },
            setHover: function() {
                this.hover(true)
            },
            hover: function(state) {
                if (!this.widget._getOption("hoverEnabled", true) || state === this.isHovered()) {
                    return
                }
                this.widget._suspend();
                state && this.widget.clearHover();
                this.setState(1, state);
                this.widget._eventTrigger("hoverChanged", {
                    item: this
                });
                this.widget._resume()
            },
            setState: function(code, state) {
                if (state) {
                    this.code |= code
                } else {
                    this.code &= ~code
                }
                this.widget._applyTilesAppearance()
            },
            select: function(state) {
                var mode = this.widget._getOption("selectionMode", true);
                if ("none" === mode || state === this.isSelected()) {
                    return
                }
                this.widget._suspend();
                if (state && "multiple" !== mode) {
                    this.widget.clearSelection()
                }
                this.setState(2, state);
                this.widget._eventTrigger("selectionChanged", {
                    item: this
                });
                this.widget._resume()
            },
            showTooltip: function(coords) {
                this.widget._showTooltip(this.id, coords)
            },
            getColor: function() {
                return this.color
            },
            isHovered: function() {
                return !!(1 & this.code)
            },
            isSelected: function() {
                return !!(2 & this.code)
            }
        };
        module.exports = Item
    },
    /*!**************************************************!*\
      !*** ./artifacts/transpiled/viz/funnel/label.js ***!
      \**************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _label = __webpack_require__( /*! ../series/points/label */ 262);
        var _label2 = _interopRequireDefault(_label);
        var _utils = __webpack_require__( /*! ../core/utils */ 13);
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0);
        var _common = __webpack_require__( /*! ../../core/utils/common */ 3);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            }
        }

        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest()
        }

        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _iterableToArrayLimit(arr, i) {
            if ("undefined" === typeof Symbol || !(Symbol.iterator in Object(arr))) {
                return
            }
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) {
                        break
                    }
                }
            } catch (err) {
                _d = true;
                _e = err
            } finally {
                try {
                    if (!_n && null != _i.return) {
                        _i.return()
                    }
                } finally {
                    if (_d) {
                        throw _e
                    }
                }
            }
            return _arr
        }

        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) {
                return arr
            }
        }

        function _toConsumableArray(arr) {
            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
        }

        function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) {
                return
            }
            if ("string" === typeof o) {
                return _arrayLikeToArray(o, minLen)
            }
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if ("Object" === n && o.constructor) {
                n = o.constructor.name
            }
            if ("Map" === n || "Set" === n) {
                return Array.from(o)
            }
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return _arrayLikeToArray(o, minLen)
            }
        }

        function _iterableToArray(iter) {
            if ("undefined" !== typeof Symbol && Symbol.iterator in Object(iter)) {
                return Array.from(iter)
            }
        }

        function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
                return _arrayLikeToArray(arr)
            }
        }

        function _arrayLikeToArray(arr, len) {
            if (null == len || len > arr.length) {
                len = arr.length
            }
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
            }
            return arr2
        }
        var OUTSIDE_POSITION = "outside";
        var INSIDE_POSITION = "inside";
        var OUTSIDE_LABEL_INDENT = 5;
        var COLUMNS_LABEL_INDENT = 20;
        var CONNECTOR_INDENT = 4;
        var PREVENT_EMPTY_PIXEL_OFFSET = 1;

        function getLabelIndent(pos) {
            pos = (0, _utils.normalizeEnum)(pos);
            if (pos === OUTSIDE_POSITION) {
                return OUTSIDE_LABEL_INDENT
            } else {
                if (pos === INSIDE_POSITION) {
                    return 0
                }
            }
            return COLUMNS_LABEL_INDENT
        }

        function isOutsidePosition(pos) {
            pos = (0, _utils.normalizeEnum)(pos);
            return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION
        }

        function correctYForInverted(y, bBox, inverted) {
            return inverted ? y - bBox.height : y
        }

        function getOutsideRightLabelPosition(coords, bBox, options, inverted) {
            return {
                x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,
                y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
            }
        }

        function getOutsideLeftLabelPosition(coords, bBox, options, inverted) {
            return {
                x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,
                y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)
            }
        }

        function getInsideLabelPosition(coords, bBox, options) {
            var width = coords[2] - coords[0];
            var height = coords[7] - coords[1];
            return {
                x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,
                y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2
            }
        }

        function getColumnLabelRightPosition(labelRect, rect, textAlignment) {
            return function(coords, bBox, options, inverted) {
                return {
                    x: "left" === textAlignment ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,
                    y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
                }
            }
        }

        function getColumnLabelLeftPosition(labelRect, rect, textAlignment) {
            return function(coords, bBox, options, inverted) {
                return {
                    x: "left" === textAlignment ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,
                    y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
                }
            }
        }

        function getConnectorStrategy(options, inverted) {
            var isLeftPos = "left" === options.horizontalAlignment;
            var connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;
            var verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;

            function getFigureCenter(figure) {
                return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection]
            }
            return {
                isLabelInside: function() {
                    return !isOutsidePosition(options.position)
                },
                getFigureCenter: getFigureCenter,
                prepareLabelPoints: function(bBox) {
                    var x = bBox.x + connectorIndent;
                    var y = bBox.y;
                    var x1 = x + bBox.width;
                    return _toConsumableArray(Array(bBox.height + 1)).map(function(_, i) {
                        return [x, y + i]
                    }).concat(_toConsumableArray(Array(bBox.height + 1)).map(function(_, i) {
                        return [x1, y + i]
                    }))
                },
                isHorizontal: function() {
                    return true
                },
                findFigurePoint: function(figure) {
                    return getFigureCenter(figure)
                },
                adjustPoints: function(points) {
                    return points.map(Math.round)
                }
            }
        }

        function getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {
            var opt = labelOptions || {};
            var labelFont = (0, _extend.extend)({}, opt.font) || {};
            var labelBorder = opt.border || {};
            var labelConnector = opt.connector || {};
            var backgroundAttr = {
                fill: opt.backgroundColor || defaultColor,
                "stroke-width": labelBorder.visible ? labelBorder.width || 0 : 0,
                stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : "none",
                dashStyle: labelBorder.dashStyle
            };
            var connectorAttr = {
                stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : "none",
                "stroke-width": labelConnector.visible ? labelConnector.width || 0 : 0,
                opacity: labelConnector.opacity
            };
            labelFont.color = "none" === opt.backgroundColor && "#ffffff" === (0, _utils.normalizeEnum)(labelFont.color) && "inside" !== opt.position ? defaultColor : labelFont.color;
            return {
                format: opt.format,
                textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : "center"),
                customizeText: opt.customizeText,
                attributes: {
                    font: labelFont
                },
                visible: 0 !== labelFont.size ? opt.visible : false,
                showForZeroValues: opt.showForZeroValues,
                horizontalOffset: opt.horizontalOffset,
                verticalOffset: opt.verticalOffset,
                background: backgroundAttr,
                connector: connectorAttr,
                wordWrap: labelOptions.wordWrap,
                textOverflow: labelOptions.textOverflow
            }
        }

        function correctLabelPosition(pos, bBox, rect) {
            if (pos.x < rect[0]) {
                pos.x = rect[0]
            }
            if (pos.x + bBox.width > rect[2]) {
                pos.x = rect[2] - bBox.width
            }
            if (pos.y < rect[1]) {
                pos.y = rect[1]
            }
            if (pos.y + bBox.height > rect[3]) {
                pos.y = rect[3] - bBox.height
            }
            return pos
        }

        function removeEmptySpace(labels, requiredSpace, startPoint) {
            labels.reduce(function(requiredSpace, label, index, labels) {
                var prevLabel = labels[index + 1];
                if (requiredSpace > 0) {
                    var bBox = label.getBoundingRect();
                    var point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;
                    var emptySpace = bBox.y - point;
                    var shift = Math.min(emptySpace, requiredSpace);
                    labels.slice(0, index + 1).forEach(function(label) {
                        var bBox = label.getBoundingRect();
                        label.shift(bBox.x, bBox.y - shift)
                    });
                    requiredSpace -= shift
                }
                return requiredSpace
            }, requiredSpace)
        }
        exports.plugin = {
            name: "lables",
            init: _common.noop,
            dispose: _common.noop,
            extenders: {
                _initCore: function() {
                    this._labelsGroup = this._renderer.g().attr({
                        "class": this._rootClassPrefix + "-labels"
                    }).append(this._renderer.root);
                    this._labels = []
                },
                _applySize: function() {
                    var options = this._getOption("label");
                    var adaptiveLayout = this._getOption("adaptiveLayout");
                    var rect = this._rect;
                    var labelWidth = 0;
                    var width = rect[2] - rect[0];
                    this._labelRect = rect.slice();
                    if (!this._labels.length || !isOutsidePosition(options.position)) {
                        if ((0, _utils.normalizeEnum)("none" !== this._getOption("resolveLabelOverlapping", true))) {
                            this._labels.forEach(function(l) {
                                return !l.isVisible() && l.draw(true)
                            })
                        }
                        return
                    }
                    var groupWidth = this._labels.map(function(label) {
                        label.resetEllipsis();
                        return label.getBoundingRect().width
                    }).reduce(function(max, width) {
                        return Math.max(max, width)
                    }, 0);
                    labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);
                    if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {
                        this._labels.forEach(function(label) {
                            label.draw(false)
                        });
                        return
                    } else {
                        if (width - labelWidth < adaptiveLayout.width) {
                            labelWidth = width - adaptiveLayout.width;
                            labelWidth = labelWidth > 0 ? labelWidth : 0
                        }
                        this._labels.forEach(function(label) {
                            label.draw(true)
                        })
                    }
                    if ("left" === options.horizontalAlignment) {
                        rect[0] += labelWidth
                    } else {
                        rect[2] -= labelWidth
                    }
                },
                _buildNodes: function() {
                    this._createLabels()
                },
                _change_TILING: function() {
                    var that = this;
                    var options = that._getOption("label");
                    var getCoords = getInsideLabelPosition;
                    var inverted = that._getOption("inverted", true);
                    var textAlignment;
                    if (isOutsidePosition(options.position)) {
                        if ((0, _utils.normalizeEnum)(options.position) === OUTSIDE_POSITION) {
                            getCoords = "left" === options.horizontalAlignment ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition
                        } else {
                            textAlignment = this._defaultLabelTextAlignment();
                            getCoords = "left" === options.horizontalAlignment ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment)
                        }
                    }
                    that._labels.forEach(function(label, index) {
                        var item = that._items[index];
                        var borderWidth = item.getNormalStyle()["stroke-width"];
                        var halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;
                        var coords = halfBorderWidth ? item.coords.map(function(coord, index) {
                            if (1 === index || 3 === index) {
                                return coord - halfBorderWidth
                            } else {
                                if (2 === index) {
                                    return coord - borderWidth
                                } else {
                                    if (0 === index) {
                                        return coord + borderWidth
                                    }
                                }
                            }
                            return coord
                        }) : item.coords;
                        if (!options.showForZeroValues && 0 === item.value) {
                            label.draw(false);
                            return
                        }
                        if (isOutsidePosition(options.position)) {
                            that._correctLabelWidth(label, item.coords, options)
                        }
                        var bBox = label.getBoundingRect();
                        var pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);
                        label.setFigureToDrawConnector(coords);
                        label.shift(pos.x, pos.y)
                    });
                    that._resolveLabelOverlapping()
                }
            },
            members: {
                _resolveLabelOverlapping: function() {
                    var that = this;
                    var resolveLabelOverlapping = (0, _utils.normalizeEnum)(that._getOption("resolveLabelOverlapping", true));
                    var labels = this._getOption("inverted", true) ? that._labels.slice().reverse() : that._labels;
                    if ("hide" === resolveLabelOverlapping) {
                        labels.reduce(function(height, label) {
                            if (label.getBoundingRect().y < height) {
                                label.hide()
                            } else {
                                height = label.getBoundingRect().y + label.getBoundingRect().height
                            }
                            return height
                        }, 0)
                    } else {
                        if ("shift" === resolveLabelOverlapping) {
                            var maxHeight = this._labelRect[3];
                            labels.reduce(function(_ref, label, index, labels) {
                                var _ref2 = _slicedToArray(_ref, 2),
                                    height = _ref2[0],
                                    emptySpace = _ref2[1];
                                var bBox = label.getBoundingRect();
                                var y = bBox.y;
                                if (bBox.y < height) {
                                    label.shift(bBox.x, height);
                                    y = height
                                }
                                if (y - height > 0) {
                                    emptySpace += y - height
                                }
                                if (y + bBox.height > maxHeight) {
                                    if (emptySpace && emptySpace > y + bBox.height - maxHeight) {
                                        removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);
                                        emptySpace -= y + bBox.height - maxHeight;
                                        label.shift(bBox.x, y - (y + bBox.height - maxHeight));
                                        height = y - (y + bBox.height - maxHeight) + bBox.height
                                    } else {
                                        label.hide()
                                    }
                                } else {
                                    height = y + bBox.height
                                }
                                return [height, emptySpace]
                            }, [this._labelRect[1], 0])
                        }
                    }
                },
                _defaultLabelTextAlignment: function() {
                    return this._getOption("rtlEnabled", true) ? "right" : "left"
                },
                _correctLabelWidth: function(label, item, options) {
                    var isLeftPos = "left" === options.horizontalAlignment;
                    var minX = isLeftPos ? this._labelRect[0] : item[2];
                    var maxX = isLeftPos ? item[0] : this._labelRect[2];
                    var maxWidth = maxX - minX;
                    if (label.getBoundingRect().width > maxWidth) {
                        label.fit(maxWidth)
                    }
                },
                _createLabels: function() {
                    var that = this;
                    var labelOptions = that._getOption("label");
                    var connectorStrategy = getConnectorStrategy(labelOptions, that._getOption("inverted", true));
                    this._labelsGroup.clear();
                    if (!labelOptions.visible) {
                        return
                    }
                    this._labels = that._items.map(function(item) {
                        var label = new _label2.default.Label({
                            renderer: that._renderer,
                            labelsGroup: that._labelsGroup,
                            strategy: connectorStrategy
                        });
                        label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));
                        label.setData({
                            item: item,
                            value: item.value,
                            percent: item.percent
                        });
                        label.draw(true);
                        return label
                    });
                    if (this._labels.length && isOutsidePosition(labelOptions.position)) {
                        this._requestChange(["LAYOUT"])
                    }
                }
            },
            customize: function(constructor) {
                constructor.prototype._proxyData.push(function(x, y) {
                    var that = this;
                    var data;
                    that._labels.forEach(function(label, index) {
                        var rect = label.getBoundingRect();
                        if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
                            var pos = isOutsidePosition(that._getOption("label").position) ? "outside" : "inside";
                            data = {
                                id: index,
                                type: pos + "-label"
                            };
                            return true
                        }
                    });
                    return data
                });
                ["label", "resolveLabelOverlapping"].forEach(function(optionName) {
                    constructor.addChange({
                        code: optionName.toUpperCase(),
                        handler: function() {
                            this._createLabels();
                            this._requestChange(["LAYOUT"])
                        },
                        isThemeDependent: true,
                        isOptionChange: true,
                        option: optionName
                    })
                })
            },
            fontFields: ["label.font"]
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/funnel/tracker.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./funnel */ 443).prototype;
        var Tracker = __webpack_require__( /*! ../components/tracker */ 267).Tracker;
        var DATA_KEY_BASE = "__funnel_data_";
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;
        var dataKeyModifier = 0;
        proto._eventsMap.onItemClick = {
            name: "itemClick"
        };
        proto._eventsMap.onLegendClick = {
            name: "legendClick"
        };
        exports.plugin = {
            name: "tracker",
            init: function() {
                var that = this;
                var dataKey = DATA_KEY_BASE + dataKeyModifier++;
                var getProxyData = function(e) {
                    var rootOffset = that._renderer.getRootOffset();
                    var x = Math.floor(e.pageX - rootOffset.left);
                    var y = Math.floor(e.pageY - rootOffset.top);
                    return that._hitTestTargets(x, y)
                };
                that._tracker = new Tracker({
                    widget: that,
                    root: that._renderer.root,
                    getData: function(e, tooltipData) {
                        var target = e.target;
                        var data = target[dataKey];
                        if (isDefined(data)) {
                            return data
                        }
                        var proxyData = getProxyData(e);
                        if (tooltipData && proxyData && "inside-label" !== proxyData.type) {
                            return
                        }
                        return proxyData && proxyData.id
                    },
                    getNode: function(index) {
                        return that._items[index]
                    },
                    click: function(e) {
                        var proxyData = getProxyData(e.event);
                        var dataType = proxyData && proxyData.type;
                        var event = "legend" === dataType ? "legendClick" : "itemClick";
                        that._eventTrigger(event, {
                            item: e.node,
                            event: e.event
                        })
                    }
                });
                exports._TESTS_dataKey = dataKey;
                this._dataKey = dataKey
            },
            dispose: function() {
                this._tracker.dispose()
            },
            extenders: {
                _change_TILING: function() {
                    var dataKey = this._dataKey;
                    this._items.forEach(function(item, index) {
                        item.element.data(dataKey, index)
                    })
                }
            }
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/funnel/tooltip.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var noop = __webpack_require__( /*! ../../core/utils/common */ 3).noop;

        function getCoords(figureCoords, renderer) {
            var offset = renderer.getRootOffset();
            return [(figureCoords[0] + figureCoords[2]) / 2 + offset.left, (figureCoords[1] + figureCoords[5]) / 2 + offset.top]
        }
        exports.plugin = {
            name: "funnel-tooltip",
            init: noop,
            dispose: noop,
            extenders: {
                _buildNodes: function() {
                    this.hideTooltip()
                },
                _change_TILING: function() {
                    if (this._tooltipIndex >= 0) {
                        this._moveTooltip(this._items[this._tooltipIndex])
                    }
                }
            },
            members: {
                hideTooltip: function() {
                    if (this._tooltipIndex >= 0) {
                        this._tooltipIndex = -1;
                        this._tooltip.hide()
                    }
                },
                _moveTooltip: function(item, coords) {
                    var xy = coords || item.coords && getCoords(item.coords, this._renderer) || [-1e3, -1e3];
                    this._tooltip.move(xy[0], xy[1], 0)
                },
                _showTooltip: function(index, coords) {
                    var that = this;
                    var tooltip = that._tooltip;
                    var item = that._items[index];
                    var state = that._tooltipIndex === index || tooltip.show({
                        value: item.value,
                        valueText: tooltip.formatValue(item.value),
                        percentText: tooltip.formatValue(item.percent, "percent"),
                        percent: item.percent,
                        item: item
                    }, {
                        x: 0,
                        y: 0,
                        offset: 0
                    }, {
                        item: item
                    });
                    if (state) {
                        that._moveTooltip(item, coords)
                    } else {
                        tooltip.hide()
                    }
                    that._tooltipIndex = state ? index : -1
                }
            },
            customize: function(constructor) {
                constructor.addPlugin(__webpack_require__( /*! ../core/tooltip */ 111).plugin)
            }
        }
    },
    /*!********************************************!*\
      !*** ./artifacts/transpiled/viz/sankey.js ***!
      \********************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var dxSankey = __webpack_require__( /*! ./sankey/sankey */ 444);
        var setTooltipCustomOptions = __webpack_require__( /*! ./sankey/tooltip */ 899).setTooltipCustomOptions;
        dxSankey.addPlugin(__webpack_require__( /*! ./core/export */ 99).plugin);
        dxSankey.addPlugin(__webpack_require__( /*! ./core/title */ 109).plugin);
        dxSankey.addPlugin(__webpack_require__( /*! ./sankey/tracker */ 900).plugin);
        dxSankey.addPlugin(__webpack_require__( /*! ./core/loading_indicator */ 127).plugin);
        dxSankey.addPlugin(__webpack_require__( /*! ./core/tooltip */ 111).plugin);
        setTooltipCustomOptions(dxSankey);
        module.exports = dxSankey
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/node_item.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var states = ["normal", "hover"];
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;

        function _compileAttrs(color, itemOptions, itemBaseOptions) {
            var border = itemOptions.border;
            var baseBorder = itemBaseOptions.border;
            var borderVisible = isDefined(border.visible) ? border.visible : baseBorder.visible;
            var borderWidth = isDefined(border.width) ? border.width : baseBorder.width;
            var borderOpacity = isDefined(border.opacity) ? border.opacity : isDefined(baseBorder.opacity) ? baseBorder.opacity : 1;
            var opacity = isDefined(itemOptions.opacity) ? itemOptions.opacity : isDefined(itemBaseOptions.opacity) ? itemBaseOptions.opacity : 1;
            return {
                fill: itemOptions.color || color,
                "stroke-width": borderVisible ? borderWidth : 0,
                stroke: itemOptions.border.color || itemBaseOptions.border.color,
                "stroke-opacity": borderOpacity,
                opacity: opacity,
                hatching: itemOptions.hatching
            }
        }

        function compileLabelAttrs(labelOptions, filter, node) {
            var _patchFontOptions = __webpack_require__( /*! ../core/utils */ 13).patchFontOptions;
            if (labelOptions.useNodeColors) {
                labelOptions.font.color = node.color
            }
            var borderVisible = isDefined(labelOptions.border.visible) ? labelOptions.border.visible : false;
            var borderWidth = isDefined(labelOptions.border.width) ? labelOptions.border.width : 0;
            var borderColor = isDefined(labelOptions.border.color) ? labelOptions.border.color : labelOptions.font.color;
            var borderOpacity = isDefined(labelOptions.border.opacity) ? labelOptions.border.opacity : 1;
            var attr = {
                filter: filter
            };
            if (borderVisible && borderWidth) {
                attr.stroke = borderColor;
                attr["stroke-width"] = borderVisible ? borderWidth : 0;
                attr["stroke-opacity"] = borderOpacity
            }
            return {
                attr: attr,
                css: _patchFontOptions(labelOptions.font)
            }
        }

        function Node(widget, params) {
            var that = this;
            var widgetOffset = widget._renderer.getRootOffset();
            that.code = 0;
            that.widget = widget;
            that.color = params.color;
            that.options = params.options;
            that.rect = params.rect;
            that.label = that.title = params.rect._name;
            that.coords = {
                x: params.rect.x + params.rect.width / 2 + widgetOffset.left,
                y: params.rect.y + params.rect.height / 2 + widgetOffset.top
            };
            that.id = params.id;
            that.linksIn = params.linksIn;
            that.linksOut = params.linksOut;
            this.states = {
                normal: _compileAttrs(this.color, that.options, that.options),
                hover: _compileAttrs(this.color, that.options.hoverStyle, that.options)
            }
        }
        Node.prototype = {
            compileAttrs: function() {
                return _compileAttrs(this.color, this.options)
            },
            getState: function() {
                return states[this.code]
            },
            isHovered: function() {
                return !!(1 & this.code)
            },
            setState: function(code, state) {
                var _this = this;
                if (state) {
                    this.code |= code
                } else {
                    this.code &= ~code
                }
                if (state) {
                    this.linksIn.concat(this.linksOut).forEach(function(adjacentLink) {
                        _this.widget._links[adjacentLink.index].setAdjacentNodeHover(true)
                    })
                } else {
                    this.widget._links.forEach(function(link) {
                        link.isAdjacentNodeHovered() && link.adjacentNodeHover(false)
                    });
                    this.hideTooltip()
                }
                this.widget._applyNodesAppearance();
                this.widget._applyLinksAppearance()
            },
            hover: function(state) {
                if (!this.widget._getOption("hoverEnabled", true) || state === this.isHovered()) {
                    return
                }
                this.widget._suspend();
                state && this.widget.clearHover();
                this.setState(1, state);
                this.widget._eventTrigger("nodeHoverChanged", {
                    target: this
                });
                this.widget._resume()
            },
            setHover: function() {
                this.hover(true)
            },
            showTooltip: function(coords) {
                this.widget._getOption("hoverEnabled", true) && this.widget._tooltip && this.widget._tooltip.show({
                    type: "node",
                    info: {
                        label: this.label,
                        title: this.label,
                        weightIn: this.linksIn.reduce(function(previousValue, currentValue) {
                            return previousValue + currentValue.weight
                        }, 0),
                        weightOut: this.linksOut.reduce(function(previousValue, currentValue) {
                            return previousValue + currentValue.weight
                        }, 0)
                    }
                }, "undefined" !== typeof coords ? {
                    x: coords[0],
                    y: coords[1]
                } : this.coords)
            },
            hideTooltip: function() {
                this.widget._tooltip && this.widget._tooltip.hide()
            },
            getLabelAttributes: function(labelSettings, filter) {
                return compileLabelAttrs(labelSettings, filter, this)
            }
        };
        module.exports = Node
    },
    /*!******************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/link_item.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _constants = __webpack_require__( /*! ./constants */ 445);
        var states = ["normal", "adjacentNodeHover", "hover"];
        var isDefined = __webpack_require__( /*! ../../core/utils/type */ 1).isDefined;

        function compileAttrs(color, itemOptions, itemBaseOptions, gradient) {
            var border = itemOptions.border;
            var baseBorder = itemBaseOptions.border;
            var borderVisible = isDefined(border.visible) ? border.visible : baseBorder.visible;
            var borderWidth = isDefined(border.width) ? border.width : baseBorder.width;
            var borderOpacity = isDefined(border.opacity) ? border.opacity : isDefined(baseBorder.opacity) ? baseBorder.opacity : 1;
            var opacity = isDefined(itemOptions.opacity) ? itemOptions.opacity : isDefined(itemBaseOptions.opacity) ? itemBaseOptions.opacity : 1;
            var fill = itemOptions.color || color;
            if (itemBaseOptions.colorMode === _constants.COLOR_MODE_TARGET || itemBaseOptions.colorMode === _constants.COLOR_MODE_SOURCE) {
                fill = color
            } else {
                if (itemBaseOptions.colorMode === _constants.COLOR_MODE_GRADIENT && gradient && isDefined(gradient.id)) {
                    fill = gradient.id
                }
            }
            return {
                fill: fill,
                "stroke-width": borderVisible ? borderWidth : 0,
                stroke: itemOptions.border.color || itemBaseOptions.border.color,
                "stroke-opacity": borderOpacity,
                opacity: opacity,
                hatching: itemOptions.hatching
            }
        }

        function Link(widget, params) {
            var that = this;
            var widgetOffset = widget._renderer.getRootOffset();
            that.code = 0;
            that.widget = widget;
            that.color = params.color;
            that.connection = params.connection;
            that.d = params.d;
            that.options = params.options;
            that.boundingRect = params.boundingRect, that.coords = {
                x: params.boundingRect.x + params.boundingRect.width / 2 + widgetOffset.left,
                y: params.boundingRect.y + params.boundingRect.height / 2 + widgetOffset.top
            };
            that.states = {
                normal: compileAttrs(that.color, that.options, that.options, params.gradient),
                adjacentNodeHover: compileAttrs(that.color, {
                    opacity: 0,
                    border: {}
                }, that.options, params.gradient),
                hover: compileAttrs(that.color, {
                    opacity: 0,
                    border: {}
                }, that.options, params.gradient)
            };
            that.overlayStates = {
                normal: compileAttrs(that.color, {
                    opacity: 0,
                    border: {}
                }, that.options),
                adjacentNodeHover: compileAttrs(that.color, that.options.hoverStyle, that.options),
                hover: compileAttrs(that.color, that.options.hoverStyle, that.options)
            }
        }
        Link.prototype = {
            getState: function() {
                return states[this.code]
            },
            isHovered: function() {
                return 2 === this.code
            },
            isAdjacentNodeHovered: function() {
                return 1 === this.code
            },
            setState: function(code, state) {
                if (state) {
                    this.code = code
                } else {
                    this.code = 0;
                    this.hideTooltip()
                }
                this.widget._applyLinksAppearance()
            },
            setHover: function() {
                this.hover(true)
            },
            hover: function(state) {
                if (!this.widget._getOption("hoverEnabled", true) || state === this.isHovered()) {
                    return
                }
                this.widget._suspend();
                state && this.widget.clearHover();
                this.setState(2, state);
                this.widget._eventTrigger("linkHoverChanged", {
                    target: this
                });
                this.widget._resume()
            },
            adjacentNodeHover: function(state) {
                if (!this.widget._getOption("hoverEnabled", true) || state === this.isAdjacentNodeHovered()) {
                    return
                }
                this.widget._suspend();
                this.setState(1, state);
                this.widget._resume()
            },
            setAdjacentNodeHover: function() {
                this.adjacentNodeHover(true)
            },
            showTooltip: function(coords) {
                this.widget._getOption("hoverEnabled", true) && this.widget._tooltip && this.widget._tooltip.show({
                    type: "link",
                    info: {
                        source: this.connection.source,
                        target: this.connection.target,
                        weight: this.connection.weight
                    }
                }, "undefined" !== typeof coords ? {
                    x: coords[0],
                    y: coords[1]
                } : this.coords)
            },
            hideTooltip: function() {
                this.widget._tooltip && this.widget._tooltip.hide()
            }
        };
        module.exports = Link
    },
    /*!***************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/layout.js ***!
      \***************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var _SPLINE_TENSION = .3;
        var _ALIGNMENT_CENTER = "center";
        var _ALIGNMENT_BOTTOM = "bottom";
        var _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;
        var graphModule = __webpack_require__( /*! ./graph */ 446);
        var validatorModule = __webpack_require__( /*! ./data_validator */ 898);
        var layout = {
            _weightPerPixel: null,
            _getCascadeIdx: function(nodeTitle, cascadesConfig) {
                var nodeInfo = cascadesConfig.filter(function(c) {
                    return c.name === nodeTitle
                })[0];
                if (nodeInfo.outgoing.length > 0) {
                    return nodeInfo.lp
                } else {
                    return graphModule.routines.maxOfArray(cascadesConfig.map(function(c) {
                        return c.lp
                    }))
                }
            },
            _getInWeightForNode: function(nodeTitle, links) {
                var w = 0;
                links.forEach(function(link) {
                    if (link[1] === nodeTitle) {
                        w += link[2]
                    }
                });
                return w
            },
            _getOutWeightForNode: function(nodeTitle, links) {
                var w = 0;
                links.forEach(function(link) {
                    if (link[0] === nodeTitle) {
                        w += link[2]
                    }
                });
                return w
            },
            _computeCascades: function(links) {
                var _this = this;
                var cascadesConfig = graphModule.struct.computeLongestPaths(links);
                var maxCascade = graphModule.routines.maxOfArray(cascadesConfig.map(function(c) {
                    return c.lp
                }));
                var cascades = [];
                for (var i = 0; i < maxCascade + 1; i++) {
                    cascades.push({})
                }
                links.forEach(function(link) {
                    var cascade = cascades[_this._getCascadeIdx(link[0], cascadesConfig)];
                    if (!cascade[link[0]]) {
                        cascade[link[0]] = {
                            nodeTitle: link[0]
                        }
                    }
                    cascade = cascades[_this._getCascadeIdx(link[1], cascadesConfig)];
                    if (!cascade[link[1]]) {
                        cascade[link[1]] = {
                            nodeTitle: link[1]
                        }
                    }
                });
                cascades.forEach(function(cascade) {
                    Object.keys(cascade).forEach(function(nodeTitle) {
                        var node = cascade[nodeTitle];
                        node.inWeight = _this._getInWeightForNode(node.nodeTitle, links);
                        node.outWeight = _this._getOutWeightForNode(node.nodeTitle, links);
                        node.maxWeight = Math.max(node.inWeight, node.outWeight)
                    })
                });
                return cascades
            },
            _getWeightForCascade: function(cascades, cascadeIdx) {
                var wMax = 0;
                var cascade = cascades[cascadeIdx];
                Object.keys(cascade).forEach(function(nodeTitle) {
                    wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight)
                });
                return wMax
            },
            _getMaxWeightThroughCascades: function(cascades) {
                var max = [];
                cascades.forEach(function(cascade) {
                    var mW = 0;
                    Object.keys(cascade).forEach(function(nodeTitle) {
                        var node = cascade[nodeTitle];
                        mW += Math.max(node.inWeight, node.outWeight)
                    });
                    max.push(mW)
                });
                return graphModule.routines.maxOfArray(max)
            },
            _computeNodes: function(cascades, options) {
                var _this2 = this;
                var rects = [];
                var maxWeight = this._getMaxWeightThroughCascades(cascades);
                var maxNodeNum = graphModule.routines.maxOfArray(cascades.map(function(nodesInCascade) {
                    return Object.keys(nodesInCascade).length
                }));
                var nodePadding = options.nodePadding;
                var heightAvailable = options.height - nodePadding * (maxNodeNum - 1);
                if (heightAvailable < 0) {
                    nodePadding = 0;
                    heightAvailable = options.height - nodePadding * (maxNodeNum - 1)
                }
                this._weightPerPixel = maxWeight / heightAvailable;
                var cascadeIdx = 0;
                cascades.forEach(function(cascade) {
                    var cascadeRects = [];
                    var y = 0;
                    var nodesInCascade = Object.keys(cascade).length;
                    var cascadeHeight = _this2._getWeightForCascade(cascades, cascadeIdx) / _this2._weightPerPixel + nodePadding * (nodesInCascade - 1);
                    var cascadeAlign = _ALIGNMENT_DEFAULT;
                    if (Array.isArray(options.nodeAlign)) {
                        cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT
                    } else {
                        cascadeAlign = options.nodeAlign
                    }
                    if (cascadeAlign === _ALIGNMENT_BOTTOM) {
                        y = options.height - cascadeHeight
                    } else {
                        if (cascadeAlign === _ALIGNMENT_CENTER) {
                            y = .5 * (options.height - cascadeHeight)
                        }
                    }
                    y = Math.round(y);
                    Object.keys(cascade).forEach(function(nodeTitle) {
                        cascade[nodeTitle].sort = _this2._sort && Object.prototype.hasOwnProperty.call(_this2._sort, nodeTitle) ? _this2._sort[nodeTitle] : 1
                    });
                    Object.keys(cascade).sort(function(a, b) {
                        return cascade[a].sort - cascade[b].sort
                    }).forEach(function(nodeTitle) {
                        var node = cascade[nodeTitle];
                        var height = Math.floor(heightAvailable * node.maxWeight / maxWeight);
                        var x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (0 === cascadeIdx ? 0 : options.nodeWidth);
                        var rect = {};
                        rect._name = nodeTitle;
                        rect.width = options.nodeWidth;
                        rect.height = height;
                        rect.x = x + options.x;
                        rect.y = y + options.y;
                        y += height + nodePadding;
                        cascadeRects.push(rect)
                    });
                    cascadeIdx++;
                    rects.push(cascadeRects)
                });
                return rects
            },
            _findRectByName: function(rects, name) {
                for (var c = 0; c < rects.length; c++) {
                    for (var r = 0; r < rects[c].length; r++) {
                        if (name === rects[c][r]._name) {
                            return rects[c][r]
                        }
                    }
                }
                return null
            },
            _findIndexByName: function(rects, nodeTitle) {
                var index = 0;
                for (var c = 0; c < rects.length; c++) {
                    for (var r = 0; r < rects[c].length; r++) {
                        if (nodeTitle === rects[c][r]._name) {
                            return index
                        }
                        index++
                    }
                }
                return null
            },
            _computeLinks: function(links, rects, cascades) {
                var _this3 = this;
                var yOffsets = {};
                var paths = [];
                var result = [];
                cascades.forEach(function(cascade) {
                    Object.keys(cascade).forEach(function(nodeTitle) {
                        yOffsets[nodeTitle] = {
                            "in": 0,
                            out: 0
                        }
                    })
                });
                rects.forEach(function(rectsOfCascade) {
                    rectsOfCascade.forEach(function(nodeRect) {
                        var nodeTitle = nodeRect._name;
                        var rectFrom = _this3._findRectByName(rects, nodeTitle);
                        var linksFromNode = links.filter(function(link) {
                            return link[0] === nodeTitle
                        });
                        linksFromNode.forEach(function(link) {
                            link.sort = _this3._findIndexByName(rects, link[1])
                        });
                        linksFromNode.sort(function(a, b) {
                            return a.sort - b.sort
                        }).forEach(function(link) {
                            var rectTo = _this3._findRectByName(rects, link[1]);
                            var height = Math.round(link[2] / _this3._weightPerPixel);
                            var yOffsetFrom = yOffsets[link[0]].out;
                            var yOffsetTo = yOffsets[link[1]].in;
                            var heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;
                            var heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;
                            paths.push({
                                from: {
                                    x: rectFrom.x,
                                    y: rectFrom.y + yOffsetFrom,
                                    width: rectFrom.width,
                                    height: heightFrom,
                                    node: rectFrom,
                                    weight: link[2]
                                },
                                to: {
                                    x: rectTo.x,
                                    y: rectTo.y + yOffsetTo,
                                    width: rectTo.width,
                                    height: heightTo,
                                    node: rectTo
                                }
                            });
                            yOffsets[link[0]].out += height;
                            yOffsets[link[1]].in += height
                        })
                    })
                });
                paths.forEach(function(link) {
                    var path = {
                        d: _this3._spline(link.from, link.to),
                        _boundingRect: {
                            x: link.from.x + link.from.width,
                            y: Math.min(link.from.y, link.to.y),
                            width: link.to.x - (link.from.x + link.from.width),
                            height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)
                        },
                        _weight: link.from.weight,
                        _from: link.from.node,
                        _to: link.to.node
                    };
                    result.push(path)
                });
                this._fitAllNodesHeight(rects, paths);
                return result
            },
            _fitNodeHeight: function(nodeName, nodeRects, paths) {
                var targetRect = this._findRectByName(nodeRects, nodeName);
                var heightOfLinksSummaryIn = 0;
                var heightOfLinksSummaryOut = 0;
                paths.forEach(function(path) {
                    if (path.from.node._name === nodeName) {
                        heightOfLinksSummaryOut += path.from.height
                    }
                    if (path.to.node._name === nodeName) {
                        heightOfLinksSummaryIn += path.to.height
                    }
                });
                targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut)
            },
            _fitAllNodesHeight: function(nodeRects, paths) {
                for (var c = 0; c < nodeRects.length; c++) {
                    for (var r = 0; r < nodeRects[c].length; r++) {
                        this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths)
                    }
                }
            },
            _spline: function(rectLeft, rectRight) {
                var p_UpLeft = {
                    x: rectLeft.x + rectLeft.width,
                    y: rectLeft.y
                };
                var p_DownLeft = {
                    x: rectLeft.x + rectLeft.width,
                    y: rectLeft.y + rectLeft.height
                };
                var p_UpRight = {
                    x: rectRight.x,
                    y: rectRight.y
                };
                var p_DownRight = {
                    x: rectRight.x,
                    y: rectRight.y + rectRight.height
                };
                var curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);
                var result = "M ".concat(p_UpLeft.x, " ").concat(p_UpLeft.y, " C ").concat(p_UpLeft.x + curve_width, " ").concat(p_UpLeft.y, " ").concat(p_UpRight.x - curve_width, " ").concat(p_UpRight.y, " ").concat(p_UpRight.x, " ").concat(p_UpRight.y, " L ").concat(p_DownRight.x, " ").concat(p_DownRight.y, " C ").concat(p_DownRight.x - curve_width, " ").concat(p_DownRight.y, " ").concat(p_DownLeft.x + curve_width, " ").concat(p_DownLeft.y, " ").concat(p_DownLeft.x, " ").concat(p_DownLeft.y, " Z");
                return result
            },
            computeLayout: function(linksData, sortData, options, incidentOccurred) {
                this._sort = sortData;
                var result = {};
                var validateResult = validatorModule.validate(linksData, incidentOccurred);
                if (!validateResult) {
                    result.cascades = this._computeCascades(linksData);
                    result.nodes = this._computeNodes(result.cascades, {
                        width: options.availableRect.width,
                        height: options.availableRect.height,
                        x: options.availableRect.x,
                        y: options.availableRect.y,
                        nodePadding: options.nodePadding,
                        nodeWidth: options.nodeWidth,
                        nodeAlign: options.nodeAlign
                    });
                    result.links = this._computeLinks(linksData, result.nodes, result.cascades)
                } else {
                    result.error = validateResult
                }
                return result
            },
            overlap: function(box1, box2) {
                return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y)
            }
        };
        module.exports = layout
    },
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/data_validator.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var graphModule = __webpack_require__( /*! ./graph */ 446);
        var validator = {
            validate: function(data, incidentOccurred) {
                var result = null;
                if (this._hasCycle(data)) {
                    result = "E2006";
                    incidentOccurred("E2006")
                }
                return result
            },
            _hasCycle: function(data) {
                return graphModule.struct.hasCycle(data)
            }
        };
        module.exports = validator
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/tooltip.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.setTooltipCustomOptions = setTooltipCustomOptions;
        var _extend = __webpack_require__( /*! ../../core/utils/extend */ 0).extend;
        var isFunction = __webpack_require__( /*! ../../core/utils/type */ 1).isFunction;
        var defaultCustomizeLinkTooltip = function(info) {
            return {
                html: "<strong>".concat(info.source, " > ").concat(info.target, "</strong><br/>Weight: ").concat(info.weight)
            }
        };
        var defaultCustomizeNodeTooltip = function(info) {
            return {
                html: "<strong>".concat(info.label, "</strong><br/>Incoming weight: ").concat(info.weightIn, "<br/>Outgoing weight: ").concat(info.weightOut)
            }
        };
        var generateCustomCallback = function(customCallback, defaultCallback) {
            return function(objectInfo) {
                var res = isFunction(customCallback) ? customCallback.call(objectInfo, objectInfo) : {};
                var hasOwnProperty = Object.prototype.hasOwnProperty.bind(res);
                if (!hasOwnProperty("html") && !hasOwnProperty("text")) {
                    res = _extend(res, defaultCallback.call(objectInfo, objectInfo))
                }
                return res
            }
        };

        function setTooltipCustomOptions(sankey) {
            sankey.prototype._setTooltipOptions = function() {
                var tooltip = this._tooltip;
                var options = tooltip && this._getOption("tooltip");
                var linkTemplate;
                var nodeTemplate;
                if (options.linkTooltipTemplate) {
                    linkTemplate = this._getTemplate(options.linkTooltipTemplate)
                }
                if (options.nodeTooltipTemplate) {
                    nodeTemplate = this._getTemplate(options.nodeTooltipTemplate)
                }
                tooltip && tooltip.update(_extend({}, options, {
                    customizeTooltip: function(args) {
                        if (!(linkTemplate && "link" === args.type || nodeTemplate && "node" === args.type)) {
                            args.skipTemplate = true
                        }
                        if ("node" === args.type) {
                            return generateCustomCallback(options.customizeNodeTooltip, defaultCustomizeNodeTooltip)(args.info)
                        } else {
                            if ("link" === args.type) {
                                return generateCustomCallback(options.customizeLinkTooltip, defaultCustomizeLinkTooltip)(args.info)
                            }
                        }
                        return {}
                    },
                    contentTemplate: function(arg, div) {
                        var templateArgs = {
                            model: arg.info,
                            container: div
                        };
                        if (linkTemplate && "link" === arg.type) {
                            return linkTemplate.render(templateArgs)
                        }
                        if (nodeTemplate && "node" === arg.type) {
                            return nodeTemplate.render(templateArgs)
                        }
                    },
                    enabled: options.enabled
                }))
            };
            sankey.prototype.hideTooltip = function() {
                this._tooltip && this._tooltip.hide()
            }
        }
    },
    /*!****************************************************!*\
      !*** ./artifacts/transpiled/viz/sankey/tracker.js ***!
      \****************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var proto = __webpack_require__( /*! ./sankey */ 444).prototype;
        var Tracker = __webpack_require__( /*! ../components/tracker */ 267).Tracker;
        var DATA_KEY_BASE = "__sankey_data_";
        var dataKeyModifier = 0;
        proto._eventsMap.onNodeClick = {
            name: "nodeClick"
        };
        proto._eventsMap.onLinkClick = {
            name: "linkClick"
        };
        exports.plugin = {
            name: "tracker",
            init: function() {
                var that = this;
                var dataKey = DATA_KEY_BASE + dataKeyModifier++;
                that._tracker = new Tracker({
                    widget: that,
                    root: that._renderer.root,
                    getData: function(e) {
                        var target = e.target;
                        return target[dataKey]
                    },
                    getNode: function(index) {
                        if (index < that._nodes.length) {
                            return that._nodes[index]
                        } else {
                            return that._links[index - that._nodes.length]
                        }
                    },
                    click: function(e) {
                        var eventName = this.getData(e.event) < that._nodes.length ? "nodeClick" : "linkClick";
                        that._eventTrigger(eventName, {
                            target: e.node,
                            event: e.event
                        })
                    }
                });
                exports._TESTS_dataKey = dataKey;
                this._dataKey = dataKey
            },
            dispose: function() {
                this._tracker.dispose()
            },
            extenders: {
                _change_LINKS_DRAW: function() {
                    var dataKey = this._dataKey;
                    this._nodes.concat(this._links).forEach(function(item, index) {
                        item.element.data(dataKey, index)
                    })
                }
            }
        }
    }, , , , , ,
    /*!***********************************************************!*\
      !*** ./artifacts/transpiled/bundles/modules/parts/viz.js ***!
      \***********************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        var DevExpress = __webpack_require__( /*! ./core */ 219);
        __webpack_require__( /*! ./data */ 305);
        var viz = DevExpress.viz = __webpack_require__( /*! ../../../bundles/modules/viz */ 802);
        viz.currentTheme = __webpack_require__( /*! ../../../viz/themes */ 50).currentTheme;
        viz.registerTheme = __webpack_require__( /*! ../../../viz/themes */ 50).registerTheme;
        viz.exportFromMarkup = __webpack_require__( /*! ../../../viz/export */ 255).exportFromMarkup;
        viz.getMarkup = __webpack_require__( /*! ../../../viz/export */ 255).getMarkup;
        viz.exportWidgets = __webpack_require__( /*! ../../../viz/export */ 255).exportWidgets;
        viz.currentPalette = __webpack_require__( /*! ../../../viz/palette */ 173).currentPalette;
        viz.getPalette = __webpack_require__( /*! ../../../viz/palette */ 173).getPalette;
        viz.generateColors = __webpack_require__( /*! ../../../viz/palette */ 173).generateColors;
        viz.registerPalette = __webpack_require__( /*! ../../../viz/palette */ 173).registerPalette;
        viz.refreshTheme = __webpack_require__( /*! ../../../viz/themes */ 50).refreshTheme;
        viz.dxChart = __webpack_require__( /*! ../../../viz/chart */ 803);
        viz.dxPieChart = __webpack_require__( /*! ../../../viz/pie_chart */ 840);
        viz.dxPolarChart = __webpack_require__( /*! ../../../viz/polar_chart */ 841);
        viz.dxLinearGauge = __webpack_require__( /*! ../../../viz/linear_gauge */ 842);
        viz.dxCircularGauge = __webpack_require__( /*! ../../../viz/circular_gauge */ 848);
        viz.dxBarGauge = __webpack_require__( /*! ../../../viz/bar_gauge */ 851);
        viz.dxRangeSelector = __webpack_require__( /*! ../../../viz/range_selector */ 853);
        viz.dxVectorMap = __webpack_require__( /*! ../../../viz/vector_map */ 861);
        viz.map = {};
        viz.map.sources = {};
        viz.map.projection = __webpack_require__( /*! ../../../viz/vector_map/projection */ 435).projection;
        viz.dxSparkline = __webpack_require__( /*! ../../../viz/sparkline */ 871);
        viz.dxBullet = __webpack_require__( /*! ../../../viz/bullet */ 873);
        viz.dxTreeMap = __webpack_require__( /*! ../../../viz/tree_map */ 875);
        viz.dxFunnel = __webpack_require__( /*! ../../../viz/funnel */ 886);
        viz.dxSankey = __webpack_require__( /*! ../../../viz/sankey */ 894);
        viz.BaseWidget = __webpack_require__( /*! ../../../viz/core/base_widget */ 102);
        viz.getTheme = __webpack_require__( /*! ../../../viz/themes */ 50).getTheme;
        viz.findTheme = __webpack_require__( /*! ../../../viz/themes */ 50).getTheme;
        viz.refreshAll = __webpack_require__( /*! ../../../viz/themes */ 50).refreshTheme;
        viz.refreshPaths = __webpack_require__( /*! ../../../viz/utils */ 907).refreshPaths;
        viz.gauges = {
            __internals: {}
        };
        viz._dashboard = {};
        viz._dashboard.Renderer = __webpack_require__( /*! ../../../viz/core/renderers/renderer */ 163).Renderer;
        viz._dashboard.SvgElement = __webpack_require__( /*! ../../../viz/core/renderers/renderer */ 163).SvgElement;
        viz._dashboard.patchFontOptions = __webpack_require__( /*! ../../../viz/core/utils */ 13).patchFontOptions;
        module.exports = viz
    },
    /*!*******************************************!*\
      !*** ./artifacts/transpiled/viz/utils.js ***!
      \*******************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        exports.refreshPaths = __webpack_require__( /*! ./core/renderers/renderer */ 163).refreshPaths
    }, , , , , , , ,
    /*!******************************************************!*\
      !*** multi ./artifacts/transpiled/bundles/dx.viz.js ***!
      \******************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! c:\Projects\DevExtreme\20.1\BuildLabel\Temp\DevExtreme.v20.1\repo\GitHub\artifacts\transpiled\bundles\dx.viz.js */ 916)
    },
    /*!************************************************!*\
      !*** ./artifacts/transpiled/bundles/dx.viz.js ***!
      \************************************************/
    /*! dynamic exports provided */
    /*! all exports used */
    function(module, exports, __webpack_require__) {
        __webpack_require__( /*! ./modules/parts/viz */ 906)
    }
]);
